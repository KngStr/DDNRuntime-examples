//----------------------------------------------------------------------------
//  System.Data.dll: System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
//----------------------------------------------------------------------------
//  The code is automatically generated by the GenCodeNET tool.
//----------------------------------------------------------------------------
//  .NET Framework: 4.0
//----------------------------------------------------------------------------
//  UnitName: DDN.System.Data
//  Author: ying32
//----------------------------------------------------------------------------

unit DDN.System.Data;

{$IFDEF FPC}
  {$mode delphi}//{$H+}
  {$modeswitch advancedrecords}
  {$modeswitch prefixedattributes} // Custom attributes feature，fpc3.2.2+
{$ENDIF}

interface

uses
  DDN.Runtime,
  DDN.mscorlib,
  DDN.System,
  DDN.System.Xml,
  DDN.System.Core,
  DDN.System.Transactions,
  DDN.System.EnterpriseServices,
  DDN.System.Configuration;

type

{ enums }

  //-------------namespace: Microsoft.SqlServer.Server----------------
  ///<summary>Describes the type of access to user data for a user-defined method or function.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.DataAccessKind')]
  DNDataAccessKind = type Integer;
  DNDataAccessKindHelper = record helper for DNDataAccessKind
  public const
    ///<summary>The method or function does not access user data.</summary>
    None = 0;
    ///<summary>The method or function reads user data.</summary>
    Read = 1;
  end;


  //-------------namespace: Microsoft.SqlServer.Server----------------
  ///<summary>Used by <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute" />
  ///  and <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute" />
  ///  to indicate the serialization format of a user-defined type (UDT) or aggregate.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.Format')]
  DNFormat = type Integer;
  DNFormatHelper = record helper for DNFormat
  public const
    ///<summary>The serialization format is unknown.</summary>
    Unknown = 0;
    ///<summary>The <see langword="Native" />
    ///  serialization format uses a very simple algorithm that enables SQL Server to store an efficient representation of the UDT on disk. Types marked for <see langword="Native" />
    ///  serialization can only have value types (structs in Microsoft Visual C# and structures in Microsoft Visual Basic .NET) as members. Members of reference types (such as classes in Visual C# and Visual Basic), either user-defined or those existing in the framework (such as <see cref="T:System.String" />
    ///  ), are not supported.</summary>
    Native = 1;
    ///<summary>The <see langword="UserDefined" />
    ///  serialization format gives the developer full control over the binary format through the <see cref="T:Microsoft.SqlServer.Server.IBinarySerialize" />
    ///<see langword=".Write" />
    ///  and <see cref="T:Microsoft.SqlServer.Server.IBinarySerialize" />
    ///<see langword=".Read" />
    ///  methods.</summary>
    UserDefined = 2;
  end;


  //-------------namespace: Microsoft.SqlServer.Server----------------
  ///<summary>Describes the type of access to system data for a user-defined method or function.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SystemDataAccessKind')]
  DNSystemDataAccessKind = type Integer;
  DNSystemDataAccessKindHelper = record helper for DNSystemDataAccessKind
  public const
    ///<summary>The method or function does not access system data. </summary>
    None = 0;
    ///<summary>The method or function reads system data.</summary>
    Read = 1;
  end;


  //-------------namespace: Microsoft.SqlServer.Server----------------
  ///<summary>The <see cref="T:Microsoft.SqlServer.Server.TriggerAction" />
  ///  enumeration is used by the <see cref="T:Microsoft.SqlServer.Server.SqlTriggerContext" />
  ///  class to indicate what action fired the trigger. </summary>
  [DNTypeName('Microsoft.SqlServer.Server.TriggerAction')]
  DNTriggerAction = type Integer;
  DNTriggerActionHelper = record helper for DNTriggerAction
  public const
    ///<summary>An invalid trigger action, one that is not exposed to the user, occurred.</summary>
    Invalid = 0;
    ///<summary>An INSERT Transact-SQL statement was executed.</summary>
    Insert = 1;
    ///<summary>An UPDATE Transact-SQL statement was executed.</summary>
    Update = 2;
    ///<summary>A DELETE Transact-SQL statement was executed.</summary>
    Delete = 3;
    ///<summary>A CREATE TABLE Transact-SQL statement was executed.</summary>
    CreateTable = 21;
    ///<summary>An ALTER TABLE Transact-SQL statement was executed.</summary>
    AlterTable = 22;
    ///<summary>A DROP TABLE Transact-SQL statement was executed.</summary>
    DropTable = 23;
    ///<summary>A CREATE INDEX Transact-SQL statement was executed.</summary>
    CreateIndex = 24;
    ///<summary>An ALTER INDEX Transact-SQL statement was executed.</summary>
    AlterIndex = 25;
    ///<summary>A DROP INDEX Transact-SQL statement was executed.</summary>
    DropIndex = 26;
    ///<summary>Not available.</summary>
    CreateSecurityExpression = 31;
    ///<summary>Not available.</summary>
    DropSecurityExpression = 33;
    ///<summary>A CREATE SYNONYM Transact-SQL statement was executed.</summary>
    CreateSynonym = 34;
    ///<summary>A DROP SYNONYM Transact-SQL statement was executed.</summary>
    DropSynonym = 36;
    ///<summary>A CREATE VIEW Transact-SQL statement was executed.</summary>
    CreateView = 41;
    ///<summary>An ALTER VIEW Transact-SQL statement was executed.</summary>
    AlterView = 42;
    ///<summary>A DROP VIEW Transact-SQL statement was executed.</summary>
    DropView = 43;
    ///<summary>A CREATE PROCEDURE Transact-SQL statement was executed.</summary>
    CreateProcedure = 51;
    ///<summary>An ALTER PROCEDURE Transact-SQL statement was executed.</summary>
    AlterProcedure = 52;
    ///<summary>A DROP PROCEDURE Transact-SQL statement was executed.</summary>
    DropProcedure = 53;
    ///<summary>A CREATE FUNCTION Transact-SQL statement was executed.</summary>
    CreateFunction = 61;
    ///<summary>An ALTER FUNCTION Transact-SQL statement was executed.</summary>
    AlterFunction = 62;
    ///<summary>A DROP FUNCTION Transact-SQL statement was executed.</summary>
    DropFunction = 63;
    ///<summary>A CREATE TRIGGER Transact-SQL statement was executed.</summary>
    CreateTrigger = 71;
    ///<summary>An ALTER TRIGGER Transact-SQL statement was executed.</summary>
    AlterTrigger = 72;
    ///<summary>A DROP TRIGGER Transact-SQL statement was executed.</summary>
    DropTrigger = 73;
    ///<summary>A CREATE EVENT NOTIFICATION Transact-SQL statement was executed.</summary>
    CreateEventNotification = 74;
    ///<summary>A DROP EVENT NOTIFICATION Transact-SQL statement was executed.</summary>
    DropEventNotification = 76;
    ///<summary>A CREATE TYPE Transact-SQL statement was executed.</summary>
    CreateType = 91;
    ///<summary>A DROP TYPE Transact-SQL statement was executed.</summary>
    DropType = 93;
    ///<summary>A CREATE ASSEMBLY Transact-SQL statement was executed.</summary>
    CreateAssembly = 101;
    ///<summary>An ALTER ASSEMBLY Transact-SQL statement was executed.</summary>
    AlterAssembly = 102;
    ///<summary>A DROP ASSEMBLY Transact-SQL statement was executed.</summary>
    DropAssembly = 103;
    ///<summary>A CREATE USER Transact-SQL statement was executed.</summary>
    CreateUser = 131;
    ///<summary>An ALTER USER Transact-SQL statement was executed.</summary>
    AlterUser = 132;
    ///<summary>A DROP USER Transact-SQL statement was executed.</summary>
    DropUser = 133;
    ///<summary>A CREATE ROLE Transact-SQL statement was executed.</summary>
    CreateRole = 134;
    ///<summary>An ALTER ROLE Transact-SQL statement was executed.</summary>
    AlterRole = 135;
    ///<summary>A DROP ROLE Transact-SQL statement was executed.</summary>
    DropRole = 136;
    ///<summary>A CREATE APPLICATION ROLE Transact-SQL statement was executed.</summary>
    CreateAppRole = 137;
    ///<summary>An ALTER APPLICATION ROLE Transact-SQL statement was executed.</summary>
    AlterAppRole = 138;
    ///<summary>A DROP APPLICATION ROLE Transact-SQL statement was executed.</summary>
    DropAppRole = 139;
    ///<summary>A CREATE SCHEMA Transact-SQL statement was executed.</summary>
    CreateSchema = 141;
    ///<summary>An ALTER SCHEMA Transact-SQL statement was executed.</summary>
    AlterSchema = 142;
    ///<summary>A DROP SCHEMA Transact-SQL statement was executed.</summary>
    DropSchema = 143;
    ///<summary>A CREATE LOGIN Transact-SQL statement was executed.</summary>
    CreateLogin = 144;
    ///<summary>An ALTER LOGIN Transact-SQL statement was executed.</summary>
    AlterLogin = 145;
    ///<summary>A DROP LOGIN Transact-SQL statement was executed.</summary>
    DropLogin = 146;
    ///<summary>A CREATE MESSAGE TYPE Transact-SQL statement was executed.</summary>
    CreateMsgType = 151;
    ///<summary>A DROP MESSAGE TYPE Transact-SQL statement was executed.</summary>
    DropMsgType = 153;
    ///<summary>A CREATE CONTRACT Transact-SQL statement was executed.</summary>
    CreateContract = 154;
    ///<summary>A DROP CONTRACT Transact-SQL statement was executed.</summary>
    DropContract = 156;
    ///<summary>A CREATE QUEUE Transact-SQL statement was executed.</summary>
    CreateQueue = 157;
    ///<summary>An ALTER QUEUE Transact-SQL statement was executed.</summary>
    AlterQueue = 158;
    ///<summary>A DROP QUEUE Transact-SQL statement was executed.</summary>
    DropQueue = 159;
    ///<summary>A CREATE SERVICE Transact-SQL statement was executed.</summary>
    CreateService = 161;
    ///<summary>An ALTER SERVICE Transact-SQL statement was executed.</summary>
    AlterService = 162;
    ///<summary>A DROP SERVICE Transact-SQL statement was executed.</summary>
    DropService = 163;
    ///<summary>A CREATE ROUTE Transact-SQL statement was executed.</summary>
    CreateRoute = 164;
    ///<summary>An ALTER ROUTE Transact-SQL statement was executed.</summary>
    AlterRoute = 165;
    ///<summary>A DROP ROUTE Transact-SQL statement was executed.</summary>
    DropRoute = 166;
    ///<summary>A GRANT Transact-SQL statement was executed.</summary>
    GrantStatement = 167;
    ///<summary>A DENY Transact-SQL statement was executed.</summary>
    DenyStatement = 168;
    ///<summary>A REVOKE Transact-SQL statement was executed.</summary>
    RevokeStatement = 169;
    ///<summary>A GRANT OBJECT Transact-SQL statement was executed.</summary>
    GrantObject = 170;
    ///<summary>A DENY Object Permissions Transact-SQL statement was executed.</summary>
    DenyObject = 171;
    ///<summary>A REVOKE OBJECT Transact-SQL statement was executed.</summary>
    RevokeObject = 172;
    ///<summary>A CREATE_REMOTE_SERVICE_BINDING event type was specified when an event notification was created on the database or server instance.</summary>
    CreateBinding = 174;
    ///<summary>An ALTER_REMOTE_SERVICE_BINDING event type was specified when an event notification was created on the database or server instance.</summary>
    AlterBinding = 175;
    ///<summary>A DROP_REMOTE_SERVICE_BINDING event type was specified when an event notification was created on the database or server instance.</summary>
    DropBinding = 176;
    ///<summary>A CREATE PARTITION FUNCTION Transact-SQL statement was executed.</summary>
    CreatePartitionFunction = 191;
    ///<summary>An ALTER PARTITION FUNCTION Transact-SQL statement was executed.</summary>
    AlterPartitionFunction = 192;
    ///<summary>A DROP PARTITION FUNCTION Transact-SQL statement was executed.</summary>
    DropPartitionFunction = 193;
    ///<summary>A CREATE PARTITION SCHEME Transact-SQL statement was executed.</summary>
    CreatePartitionScheme = 194;
    ///<summary>An ALTER PARTITION SCHEME Transact-SQL statement was executed.</summary>
    AlterPartitionScheme = 195;
    ///<summary>A DROP PARTITION SCHEME Transact-SQL statement was executed.</summary>
    DropPartitionScheme = 196;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Determines the action that occurs when the <see cref="M:System.Data.DataSet.AcceptChanges" />
  ///  or <see cref="M:System.Data.DataTable.RejectChanges" />
  ///  method is invoked on a <see cref="T:System.Data.DataTable" />
  ///  with a <see cref="T:System.Data.ForeignKeyConstraint" />
  ///  .</summary>
  [DNTypeName('System.Data.AcceptRejectRule')]
  DNAcceptRejectRule = type Integer;
  DNAcceptRejectRuleHelper = record helper for DNAcceptRejectRule
  public const
    ///<summary>No action occurs (default).</summary>
    None = 0;
    ///<summary>Changes are cascaded across the relationship.</summary>
    Cascade = 1;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Provides a description of the results of the query and its effect on the database.</summary>
  [DNTypeName('System.Data.CommandBehavior')]
  DNCommandBehavior = type Integer;
  DNCommandBehaviorHelper = record helper for DNCommandBehavior
  public const
    ///<summary>The query may return multiple result sets. Execution of the query may affect the database state. <see langword="Default" />
    ///  sets no <see cref="T:System.Data.CommandBehavior" />
    ///  flags, so calling <see langword="ExecuteReader(CommandBehavior.Default)" />
    ///  is functionally equivalent to calling <see langword="ExecuteReader()" />
    ///  .</summary>
    Default_ = 0;
    ///<summary>The query returns a single result set.</summary>
    SingleResult = 1;
    ///<summary>The query returns column information only. When using <see cref="F:System.Data.CommandBehavior.SchemaOnly" />
    ///  , the .NET Framework Data Provider for SQL Server precedes the statement being executed with SET FMTONLY ON.</summary>
    SchemaOnly = 2;
    ///<summary>The query returns column and primary key information. </summary>
    KeyInfo = 4;
    ///<summary>The query is expected to return a single row of the first result set. Execution of the query may affect the database state. Some .NET Framework data providers may, but are not required to, use this information to optimize the performance of the command. When you specify <see cref="F:System.Data.CommandBehavior.SingleRow" />
    ///  with the <see cref="M:System.Data.OleDb.OleDbCommand.ExecuteReader" />
    ///  method of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object, the .NET Framework Data Provider for OLE DB performs binding using the OLE DB <see langword="IRow" />
    ///  interface if it is available. Otherwise, it uses the <see langword="IRowset" />
    ///  interface. If your SQL statement is expected to return only a single row, specifying <see cref="F:System.Data.CommandBehavior.SingleRow" />
    ///  can also improve application performance. It is possible to specify <see langword="SingleRow" />
    ///  when executing queries that are expected to return multiple result sets.  In that case, where both a multi-result set SQL query and single row are specified, the result returned will contain only the first row of the first result set. The other result sets of the query will not be returned.</summary>
    SingleRow = 8;
    ///<summary>Provides a way for the <see langword="DataReader" />
    ///  to handle rows that contain columns with large binary values. Rather than loading the entire row, <see langword="SequentialAccess" />
    ///  enables the <see langword="DataReader" />
    ///  to load data as a stream. You can then use the <see langword="GetBytes" />
    ///  or <see langword="GetChars" />
    ///  method to specify a byte location to start the read operation, and a limited buffer size for the data being returned.</summary>
    SequentialAccess = 16;
    ///<summary>When the command is executed, the associated <see langword="Connection" />
    ///  object is closed when the associated <see langword="DataReader" />
    ///  object is closed.</summary>
    CloseConnection = 32;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how a command string is interpreted.</summary>
  [DNTypeName('System.Data.CommandType')]
  DNCommandType = type Integer;
  DNCommandTypeHelper = record helper for DNCommandType
  public const
    ///<summary>An SQL text command. (Default.) </summary>
    Text = 1;
    ///<summary>The name of a stored procedure.</summary>
    StoredProcedure = 4;
    ///<summary>The name of a table.</summary>
    TableDirect = 512;
  end;


  //-------------namespace: System.Data.Common----------------
  ///<summary>Indicates the position of the catalog name in a qualified table name in a text command. </summary>
  [DNTypeName('System.Data.Common.CatalogLocation')]
  DNCatalogLocation = type Integer;
  DNCatalogLocationHelper = record helper for DNCatalogLocation
  public const
    ///<summary>Indicates that the position of the catalog name occurs before the schema portion of a fully qualified table name in a text command.</summary>
    Start = 1;
    ///<summary>Indicates that the position of the catalog name occurs after the schema portion of a fully qualified table name in a text command.</summary>
    End_ = 2;
  end;


  //-------------namespace: System.Data.Common----------------
  ///<summary>Specifies the relationship between the columns in a GROUP BY clause and the non-aggregated columns in the select-list of a SELECT statement.</summary>
  [DNTypeName('System.Data.Common.GroupByBehavior')]
  DNGroupByBehavior = type Integer;
  DNGroupByBehaviorHelper = record helper for DNGroupByBehavior
  public const
    ///<summary>The support for the GROUP BY clause is unknown.</summary>
    Unknown = 0;
    ///<summary>The GROUP BY clause is not supported.</summary>
    NotSupported = 1;
    ///<summary>There is no relationship between the columns in the GROUP BY clause and the nonaggregated columns in the SELECT list. You may group by any column.</summary>
    Unrelated = 2;
    ///<summary>The GROUP BY clause must contain all nonaggregated columns in the select list, and can contain other columns not in the select list.</summary>
    MustContainAll = 3;
    ///<summary>The GROUP BY clause must contain all nonaggregated columns in the select list, and must not contain other columns not in the select list.</summary>
    ExactMatch = 4;
  end;


  //-------------namespace: System.Data.Common----------------
  ///<summary>Specifies how identifiers are treated by the data source when searching the system catalog.</summary>
  [DNTypeName('System.Data.Common.IdentifierCase')]
  DNIdentifierCase = type Integer;
  DNIdentifierCaseHelper = record helper for DNIdentifierCase
  public const
    ///<summary>The data source has ambiguous rules regarding identifier case and cannot discern this information.</summary>
    Unknown = 0;
    ///<summary>The data source ignores identifier case when searching the system catalog. The identifiers "ab" and "AB" will match.</summary>
    Insensitive = 1;
    ///<summary>The data source distinguishes identifier case when searching the system catalog. The identifiers "ab" and "AB" will not match.</summary>
    Sensitive = 2;
  end;


  //-------------namespace: System.Data.Common----------------
  ///<summary>Specifies what types of Transact-SQL join statements are supported by the data source.</summary>
  [DNTypeName('System.Data.Common.SupportedJoinOperators')]
  DNSupportedJoinOperators = type Integer;
  DNSupportedJoinOperatorsHelper = record helper for DNSupportedJoinOperators
  public const
    ///<summary>The data source does not support join queries.</summary>
    None = 0;
    ///<summary>The data source supports inner joins.</summary>
    Inner = 1;
    ///<summary>The data source supports left outer joins.</summary>
    LeftOuter = 2;
    ///<summary>The data source supports right outer joins.</summary>
    RightOuter = 4;
    ///<summary>The data source supports full outer joins.</summary>
    FullOuter = 8;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how conflicting changes to the data source will be detected and resolved.</summary>
  [DNTypeName('System.Data.ConflictOption')]
  DNConflictOption = type Integer;
  DNConflictOptionHelper = record helper for DNConflictOption
  public const
    ///<summary>Update and delete statements will include all searchable columns from the table in the WHERE clause. This is equivalent to specifying <see langword="CompareAllValuesUpdate" />
    ///  | <see langword="CompareAllValuesDelete" />
    ///  .</summary>
    CompareAllSearchableValues = 1;
    ///<summary>If any Timestamp columns exist in the table, they are used in the WHERE clause for all generated update statements. This is equivalent to specifying <see langword="CompareRowVersionUpdate" />
    ///  | <see langword="CompareRowVersionDelete" />
    ///  .</summary>
    CompareRowVersion = 2;
    ///<summary>All update and delete statements include only <see cref="P:System.Data.DataTable.PrimaryKey" />
    ///  columns in the WHERE clause. If no <see cref="P:System.Data.DataTable.PrimaryKey" />
    ///  is defined, all searchable columns are included in the WHERE clause. This is equivalent to <see langword="OverwriteChangesUpdate" />
    ///  | <see langword="OverwriteChangesDelete" />
    ///  .</summary>
    OverwriteChanges = 3;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Describes the current state of the connection to a data source.</summary>
  [DNTypeName('System.Data.ConnectionState')]
  DNConnectionState = type Integer;
  DNConnectionStateHelper = record helper for DNConnectionState
  public const
    ///<summary>The connection is closed.</summary>
    Closed = 0;
    ///<summary>The connection is open.</summary>
    Open = 1;
    ///<summary>The connection object is connecting to the data source.</summary>
    Connecting = 2;
    ///<summary>The connection object is executing a command. (This value is reserved for future versions of the product.) </summary>
    Executing = 4;
    ///<summary>The connection object is retrieving data. (This value is reserved for future versions of the product.) </summary>
    Fetching = 8;
    ///<summary>The connection to the data source is broken. This can occur only after the connection has been opened. A connection in this state may be closed and then re-opened. (This value is reserved for future versions of the product.) </summary>
    Broken = 16;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Describes an action performed on a <see cref="T:System.Data.DataRow" />
  ///  .</summary>
  [DNTypeName('System.Data.DataRowAction')]
  DNDataRowAction = type Integer;
  DNDataRowActionHelper = record helper for DNDataRowAction
  public const
    ///<summary>The row has not changed.</summary>
    Nothing = 0;
    ///<summary>The row was deleted from the table.</summary>
    Delete = 1;
    ///<summary>The row has changed.</summary>
    Change = 2;
    ///<summary>The most recent change to the row has been rolled back.</summary>
    Rollback = 4;
    ///<summary>The changes to the row have been committed.</summary>
    Commit = 8;
    ///<summary>The row has been added to the table.</summary>
    Add = 16;
    ///<summary>The original version of the row has been changed.</summary>
    ChangeOriginal = 32;
    ///<summary>The original and the current versions of the row have been changed.</summary>
    ChangeCurrentAndOriginal = 64;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Gets the state of a <see cref="T:System.Data.DataRow" />
  ///  object.</summary>
  [DNTypeName('System.Data.DataRowState')]
  DNDataRowState = type Integer;
  DNDataRowStateHelper = record helper for DNDataRowState
  public const
    ///<summary>The row has been created but is not part of any <see cref="T:System.Data.DataRowCollection" />
    ///  . A <see cref="T:System.Data.DataRow" />
    ///  is in this state immediately after it has been created and before it is added to a collection, or if it has been removed from a collection.</summary>
    Detached = 1;
    ///<summary>The row has not changed since <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  was last called.</summary>
    Unchanged = 2;
    ///<summary>The row has been added to a <see cref="T:System.Data.DataRowCollection" />
    ///  , and <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  has not been called.</summary>
    Added = 4;
    ///<summary>The row was deleted using the <see cref="M:System.Data.DataRow.Delete" />
    ///  method of the <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    Deleted = 8;
    ///<summary>The row has been modified and <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  has not been called.</summary>
    Modified = 16;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Describes the version of a <see cref="T:System.Data.DataRow" />
  ///  .</summary>
  [DNTypeName('System.Data.DataRowVersion')]
  DNDataRowVersion = type Integer;
  DNDataRowVersionHelper = record helper for DNDataRowVersion
  public const
    ///<summary>The row contains its original values.</summary>
    Original = 256;
    ///<summary>The row contains current values.</summary>
    Current = 512;
    ///<summary>The row contains a proposed value.</summary>
    Proposed = 1024;
    ///<summary>The default version of <see cref="T:System.Data.DataRowState" />
    ///  . For a <see langword="DataRowState" />
    ///  value of <see langword="Added" />
    ///  , <see langword="Modified" />
    ///  or <see langword="Deleted" />
    ///  , the default version is <see langword="Current" />
    ///  . For a <see cref="T:System.Data.DataRowState" />
    ///  value of <see langword="Detached" />
    ///  , the version is <see langword="Proposed" />
    ///  .</summary>
    Default_ = 1536;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Describes the serialization format for <see cref="T:System.DateTime" />
  ///  columns in a <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.DataSetDateTime')]
  DNDataSetDateTime = type Integer;
  DNDataSetDateTimeHelper = record helper for DNDataSetDateTime
  public const
    ///<summary><see langword="DateTime" />
    ///  is always stored in Local. If <see cref="F:System.Data.DataSetDateTime.Utc" />
    ///  or <see cref="F:System.Data.DataSetDateTime.Unspecified" />
    ///  is assigned to a column in this mode, it is first converted into Local. Serialization in this mode is always performed in Local. There is an offset during serialization.</summary>
    Local = 1;
    ///<summary><see langword="DateTime" />
    ///  is always stored in Unspecified. If <see cref="F:System.Data.DataSetDateTime.Local" />
    ///  or <see cref="F:System.Data.DataSetDateTime.Utc" />
    ///  is assigned to a column in this mode, it is first converted into <see cref="F:System.Data.DataSetDateTime.Unspecified" />
    ///  . Serialization in this mode does not cause an offset.</summary>
    Unspecified = 2;
    ///<summary><see langword="DateTime" />
    ///  is stored in Unspecified. If <see cref="F:System.Data.DataSetDateTime.Local" />
    ///  or <see cref="F:System.Data.DataSetDateTime.Utc" />
    ///  is assigned to a column in this mode, it is first converted into <see cref="F:System.Data.DataSetDateTime.Unspecified" />
    ///  . Serialization in this mode causes offset. This is the default behavior and is backward compatible. This option should be thought of as being Unspecified in storage but applying an offset that is similar to <see cref="F:System.Data.DataSetDateTime.Local" />
    ///  during serialization.</summary>
    UnspecifiedLocal = 3;
    ///<summary><see langword="DateTime" />
    ///  is stored in Universal Coordinated Time (UTC). If <see cref="F:System.Data.DataSetDateTime.Local" />
    ///  or <see cref="F:System.Data.DataSetDateTime.Unspecified" />
    ///  is assigned to a column in this mode, it is first converted into <see langword="Utc" />
    ///  format. Serialization in this mode is always performed in <see langword="Utc" />
    ///  . There is no offset during serialization.</summary>
    Utc = 4;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Describes the version of data in a <see cref="T:System.Data.DataRow" />
  ///  .</summary>
  [DNTypeName('System.Data.DataViewRowState')]
  DNDataViewRowState = type Integer;
  DNDataViewRowStateHelper = record helper for DNDataViewRowState
  public const
    ///<summary>None.</summary>
    None = 0;
    ///<summary>An unchanged row.</summary>
    Unchanged = 2;
    ///<summary>A new row.</summary>
    Added = 4;
    ///<summary>A deleted row.</summary>
    Deleted = 8;
    ///<summary>A current version of original data that has been modified (see <see langword="ModifiedOriginal" />
    ///  ).</summary>
    ModifiedCurrent = 16;
    ///<summary>Current rows including unchanged, new, and modified rows. By default, <see cref="T:System.Data.DataViewRowState" />
    ///  is set to CurrentRows.</summary>
    CurrentRows = 22;
    ///<summary>The original version of the data that was modified. (Although the data has since been modified, it is available as <see langword="ModifiedCurrent" />
    ///  ).</summary>
    ModifiedOriginal = 32;
    ///<summary>Original rows including unchanged and deleted rows.</summary>
    OriginalRows = 42;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the data type of a field, a property, or a <see langword="Parameter" />
  ///  object of a .NET Framework data provider.</summary>
  [DNTypeName('System.Data.DbType')]
  DNDbType = type Integer;
  DNDbTypeHelper = record helper for DNDbType
  public const
    ///<summary>A variable-length stream of non-Unicode characters ranging between 1 and 8,000 characters.</summary>
    AnsiString = 0;
    ///<summary>A variable-length stream of binary data ranging between 1 and 8,000 bytes.</summary>
    Binary = 1;
    ///<summary>An 8-bit unsigned integer ranging in value from 0 to 255.</summary>
    Byte = 2;
    ///<summary>A simple type representing Boolean values of <see langword="true" />
    ///  or <see langword="false" />
    ///  .</summary>
    Boolean = 3;
    ///<summary>A currency value ranging from -2 63 (or -922,337,203,685,477.5808) to 2 63 -1 (or +922,337,203,685,477.5807) with an accuracy to a ten-thousandth of a currency unit.</summary>
    Currency = 4;
    ///<summary>A type representing a date value.</summary>
    Date = 5;
    ///<summary>A type representing a date and time value.</summary>
    DateTime = 6;
    ///<summary>A simple type representing values ranging from 1.0 x 10 -28 to approximately 7.9 x 10 28 with 28-29 significant digits.</summary>
    Decimal = 7;
    ///<summary>A floating point type representing values ranging from approximately 5.0 x 10 -324 to 1.7 x 10 308 with a precision of 15-16 digits.</summary>
    Double = 8;
    ///<summary>A globally unique identifier (or GUID).</summary>
    Guid = 9;
    ///<summary>An integral type representing signed 16-bit integers with values between -32768 and 32767.</summary>
    Int16 = 10;
    ///<summary>An integral type representing signed 32-bit integers with values between -2147483648 and 2147483647.</summary>
    Int32 = 11;
    ///<summary>An integral type representing signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</summary>
    Int64 = 12;
    ///<summary>A general type representing any reference or value type not explicitly represented by another <see langword="DbType" />
    ///  value.</summary>
    Object_ = 13;
    ///<summary>An integral type representing signed 8-bit integers with values between -128 and 127.</summary>
    SByte = 14;
    ///<summary>A floating point type representing values ranging from approximately 1.5 x 10 -45 to 3.4 x 10 38 with a precision of 7 digits.</summary>
    Single = 15;
    ///<summary>A type representing Unicode character strings.</summary>
    String_ = 16;
    ///<summary>A type representing a SQL Server <see langword="DateTime" />
    ///  value. If you want to use a SQL Server <see langword="time" />
    ///  value, use <see cref="F:System.Data.SqlDbType.Time" />
    ///  .</summary>
    Time = 17;
    ///<summary>An integral type representing unsigned 16-bit integers with values between 0 and 65535.</summary>
    UInt16 = 18;
    ///<summary>An integral type representing unsigned 32-bit integers with values between 0 and 4294967295.</summary>
    UInt32 = 19;
    ///<summary>An integral type representing unsigned 64-bit integers with values between 0 and 18446744073709551615.</summary>
    UInt64 = 20;
    ///<summary>A variable-length numeric value.</summary>
    VarNumeric = 21;
    ///<summary>A fixed-length stream of non-Unicode characters.</summary>
    AnsiStringFixedLength = 22;
    ///<summary>A fixed-length string of Unicode characters.</summary>
    StringFixedLength = 23;
    ///<summary>A parsed representation of an XML document or fragment.</summary>
    Xml = 25;
    ///<summary>Date and time data. Date value range is from January 1,1 AD through December 31, 9999 AD. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds.</summary>
    DateTime2 = 26;
    ///<summary>Date and time data with time zone awareness. Date value range is from January 1,1 AD through December 31, 9999 AD. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds. Time zone value range is -14:00 through +14:00. </summary>
    DateTimeOffset = 27;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the transaction locking behavior for the connection.</summary>
  [DNTypeName('System.Data.IsolationLevel')]
  DNIsolationLevel = type Integer;
  DNIsolationLevelHelper = record helper for DNIsolationLevel
  public const
    ///<summary>The pending changes from more highly isolated transactions cannot be overwritten.</summary>
    Chaos = 16;
    ///<summary>A dirty read is possible, meaning that no shared locks are issued and no exclusive locks are honored.</summary>
    ReadUncommitted = 256;
    ///<summary>Shared locks are held while the data is being read to avoid dirty reads, but the data can be changed before the end of the transaction, resulting in non-repeatable reads or phantom data.</summary>
    ReadCommitted = 4096;
    ///<summary>Locks are placed on all data that is used in a query, preventing other users from updating the data. Prevents non-repeatable reads but phantom rows are still possible.</summary>
    RepeatableRead = 65536;
    ///<summary>A range lock is placed on the <see cref="T:System.Data.DataSet" />
    ///  , preventing other users from updating or inserting rows into the dataset until the transaction is complete.</summary>
    Serializable = 1048576;
    ///<summary>Reduces blocking by storing a version of data that one application can read while another is modifying the same data. Indicates that from one transaction you cannot see changes made in other transactions, even if you requery.</summary>
    Snapshot = 16777216;
    ///<summary>A different isolation level than the one specified is being used, but the level cannot be determined.</summary>
    Unspecified = -1;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Identifies a list of connection string parameters identified by the <see langword="KeyRestrictions" />
  ///  property that are either allowed or not allowed.</summary>
  [DNTypeName('System.Data.KeyRestrictionBehavior')]
  DNKeyRestrictionBehavior = type Integer;
  DNKeyRestrictionBehaviorHelper = record helper for DNKeyRestrictionBehavior
  public const
    ///<summary>Default. Identifies the only additional connection string parameters that are allowed.</summary>
    AllowOnly = 0;
    ///<summary>Identifies additional connection string parameters that are not allowed.</summary>
    PreventUsage = 1;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Controls how the values from the data source will be applied to existing rows when using the <see cref="Overload:System.Data.DataTable.Load" />
  ///  or <see cref="Overload:System.Data.DataSet.Load" />
  ///  method.</summary>
  [DNTypeName('System.Data.LoadOption')]
  DNLoadOption = type Integer;
  DNLoadOptionHelper = record helper for DNLoadOption
  public const
    ///<summary>The incoming values for this row will be written to both the current value and the original value versions of the data for each column.</summary>
    OverwriteChanges = 1;
    ///<summary>The incoming values for this row will be written to the original value version of each column. The current version of the data in each column will not be changed.  This is the default.</summary>
    PreserveChanges = 2;
    ///<summary>The incoming values for this row will be written to the current version of each column. The original version of each column's data will not be changed.</summary>
    Upsert = 3;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how a <see cref="T:System.Data.DataColumn" />
  ///  is mapped.</summary>
  [DNTypeName('System.Data.MappingType')]
  DNMappingType = type Integer;
  DNMappingTypeHelper = record helper for DNMappingType
  public const
    ///<summary>The column is mapped to an XML element.</summary>
    Element = 1;
    ///<summary>The column is mapped to an XML attribute.</summary>
    Attribute = 2;
    ///<summary>The column is mapped to an <see cref="T:System.Xml.XmlText" />
    ///  node.</summary>
    SimpleContent = 3;
    ///<summary>The column is mapped to an internal structure.</summary>
    Hidden = 4;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Determines the action that occurs when a mapping is missing from a source table or a source column.</summary>
  [DNTypeName('System.Data.MissingMappingAction')]
  DNMissingMappingAction = type Integer;
  DNMissingMappingActionHelper = record helper for DNMissingMappingAction
  public const
    ///<summary>The source column or source table is created and added to the <see cref="T:System.Data.DataSet" />
    ///  using its original name.</summary>
    Passthrough = 1;
    ///<summary>The column or table not having a mapping is ignored. Returns <see langword="null" />
    ///  .</summary>
    Ignore = 2;
    ///<summary>An <see cref="T:System.InvalidOperationException" />
    ///  is generated if the specified column mapping is missing.</summary>
    Error = 3;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the action to take when adding data to the <see cref="T:System.Data.DataSet" />
  ///  and the required <see cref="T:System.Data.DataTable" />
  ///  or <see cref="T:System.Data.DataColumn" />
  ///  is missing.</summary>
  [DNTypeName('System.Data.MissingSchemaAction')]
  DNMissingSchemaAction = type Integer;
  DNMissingSchemaActionHelper = record helper for DNMissingSchemaAction
  public const
    ///<summary>Adds the necessary columns to complete the schema.</summary>
    Add = 1;
    ///<summary>Ignores the extra columns.</summary>
    Ignore = 2;
    ///<summary>An <see cref="T:System.InvalidOperationException" />
    ///  is generated if the specified column mapping is missing.</summary>
    Error = 3;
    ///<summary>Adds the necessary columns and primary key information to complete the schema. For more information about how primary key information is added to a <see cref="T:System.Data.DataTable" />
    ///  , see <see cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
    ///  .To function properly with the .NET Framework Data Provider for OLE DB, <see langword="AddWithKey" />
    ///  requires that the native OLE DB provider obtains necessary primary key information by setting the DBPROP_UNIQUEROWS property, and then determines which columns are primary key columns by examining DBCOLUMN_KEYCOLUMN in the IColumnsRowset. As an alternative, the user may explicitly set the primary key constraints on each <see cref="T:System.Data.DataTable" />
    ///  . This ensures that incoming records that match existing records are updated instead of appended. When using <see langword="AddWithKey" />
    ///  , the .NET Framework Data Provider for SQL Server appends a FOR BROWSE clause to the statement being executed. The user should be aware of potential side effects, such as interference with the use of SET FMTONLY ON statements. See SQL Server Books Online for more information.</summary>
    AddWithKey = 4;
  end;


  //-------------namespace: System.Data.Odbc----------------
  ///<summary>Specifies the data type of a field, property, for use in an <see cref="T:System.Data.Odbc.OdbcParameter" />
  ///  .</summary>
  [DNTypeName('System.Data.Odbc.OdbcType')]
  DNOdbcType = type Integer;
  DNOdbcTypeHelper = record helper for DNOdbcType
  public const
    ///<summary>Exact numeric value with precision 19 (if signed) or 20 (if unsigned) and scale 0 (signed: –2[63] &lt;= n &lt;= 2[63] – 1, unsigned:0 &lt;= n &lt;= 2[64] – 1) (SQL_BIGINT). This maps to <see cref="T:System.Int64" />
    ///  .</summary>
    BigInt = 1;
    ///<summary>A stream of binary data (SQL_BINARY). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    Binary = 2;
    ///<summary>Single bit binary data (SQL_BIT). This maps to <see cref="T:System.Boolean" />
    ///  .</summary>
    Bit = 3;
    ///<summary>A fixed-length character string (SQL_CHAR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    Char = 4;
    ///<summary>Date data in the format yyyymmddhhmmss (SQL_TYPE_TIMESTAMP). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    DateTime = 5;
    ///<summary>Signed, exact, numeric value with a precision of at least p and scale s, where 1 &lt;= p &lt;= 15 and s &lt;= p. The maximum precision is driver-specific (SQL_DECIMAL). This maps to <see cref="T:System.Decimal" />
    ///  .</summary>
    Decimal = 6;
    ///<summary>Signed, exact, numeric value with a precision p and scale s, where 1 &lt;= p &lt;= 15, and s &lt;= p (SQL_NUMERIC). This maps to <see cref="T:System.Decimal" />
    ///  .</summary>
    Numeric = 7;
    ///<summary>Signed, approximate, numeric value with a binary precision 53 (zero or absolute value 10[–308] to 10[308]) (SQL_DOUBLE). This maps to <see cref="T:System.Double" />
    ///  .</summary>
    Double = 8;
    ///<summary>Variable length binary data. Maximum length is data source–dependent (SQL_LONGVARBINARY). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    Image = 9;
    ///<summary>Exact numeric value with precision 10 and scale 0 (signed: –2[31] &lt;= n &lt;= 2[31] – 1, unsigned:0 &lt;= n &lt;= 2[32] – 1) (SQL_INTEGER). This maps to <see cref="T:System.Int32" />
    ///  .</summary>
    Int = 10;
    ///<summary>Unicode character string of fixed string length (SQL_WCHAR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    NChar = 11;
    ///<summary>Unicode variable-length character data. Maximum length is data source–dependent. (SQL_WLONGVARCHAR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    NText = 12;
    ///<summary>A variable-length stream of Unicode characters (SQL_WVARCHAR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    NVarChar = 13;
    ///<summary>Signed, approximate, numeric value with a binary precision 24 (zero or absolute value 10[–38] to 10[38]).(SQL_REAL). This maps to <see cref="T:System.Single" />
    ///  .</summary>
    Real = 14;
    ///<summary>A fixed-length GUID (SQL_GUID). This maps to <see cref="T:System.Guid" />
    ///  .</summary>
    UniqueIdentifier = 15;
    ///<summary>Data and time data in the format yyyymmddhhmmss (SQL_TYPE_TIMESTAMP). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    SmallDateTime = 16;
    ///<summary>Exact numeric value with precision 5 and scale 0 (signed: –32,768 &lt;= n &lt;= 32,767, unsigned: 0 &lt;= n &lt;= 65,535) (SQL_SMALLINT). This maps to <see cref="T:System.Int16" />
    ///  .</summary>
    SmallInt = 17;
    ///<summary>Variable length character data. Maximum length is data source–dependent (SQL_LONGVARCHAR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    Text = 18;
    ///<summary>A stream of binary data (SQL_BINARY). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    Timestamp = 19;
    ///<summary>Exact numeric value with precision 3 and scale 0 (signed: –128 &lt;= n &lt;= 127, unsigned:0 &lt;= n &lt;= 255)(SQL_TINYINT). This maps to <see cref="T:System.Byte" />
    ///  .</summary>
    TinyInt = 20;
    ///<summary>Variable length binary. The maximum is set by the user (SQL_VARBINARY). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    VarBinary = 21;
    ///<summary>A variable-length stream character string (SQL_CHAR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    VarChar = 22;
    ///<summary>Date data in the format yyyymmdd (SQL_TYPE_DATE). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    Date = 23;
    ///<summary>Date data in the format hhmmss (SQL_TYPE_TIMES). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    Time = 24;
  end;


  //-------------namespace: System.Data.OleDb----------------
  ///<summary>Returns information about literals used in text commands, data values, and database objects.</summary>
  [DNTypeName('System.Data.OleDb.OleDbLiteral')]
  DNOleDbLiteral = type Integer;
  DNOleDbLiteralHelper = record helper for DNOleDbLiteral
  public const
    ///<summary>An invalid value. Maps to DBLITERAL_INVALID.</summary>
    Invalid = 0;
    ///<summary>A binary literal in a text command. Maps to DBLITERAL_BINARY_LITERAL.</summary>
    Binary_Literal = 1;
    ///<summary>A catalog name in a text command. Maps to DBLITERAL_CATALOG_NAME.</summary>
    Catalog_Name = 2;
    ///<summary>The character that separates the catalog name from the rest of the identifier in a text command. Maps to DBLITERAL_CATALOG_SEPARATOR.</summary>
    Catalog_Separator = 3;
    ///<summary>A character literal in a text command. Maps to DBLITERAL_CHAR_LITERAL.</summary>
    Char_Literal = 4;
    ///<summary>A column alias in a text command. Maps to DBLITERAL_COLUMN_ALIAS.</summary>
    Column_Alias = 5;
    ///<summary>A column name used in a text command or in a data-definition interface. Maps to DBLITERAL_COLUMN_NAME.</summary>
    Column_Name = 6;
    ///<summary>A correlation name (table alias) in a text command. Maps to DBLITERAL_CORRELATION_NAME.</summary>
    Correlation_Name = 7;
    ///<summary>A cursor name in a text command. Maps to DBLITERAL_CURSOR_NAME.</summary>
    Cursor_Name = 8;
    ///<summary>The character used in a LIKE clause to escape the character returned for the DBLITERAL_LIKE_PERCENT literal. For example, if a percent sign (%) is used to match zero or more characters and this is a backslash (\), the characters "abc\%%" match all character values that start with "abc%". Some SQL dialects support a clause (the ESCAPE clause) that can be used to override this value. Maps to DBLITERAL_ESCAPE_PERCENT_PREFIX.</summary>
    Escape_Percent_Prefix = 9;
    ///<summary>The character used in a LIKE clause to escape the character returned for the DBLITERAL_LIKE_UNDERSCORE literal. For example, if an underscore (_) is used to match exactly one character and this is a backslash (\), the characters "abc\_ _" match all character values that are five characters long and start with "abc_". Some SQL dialects support a clause (the ESCAPE clause) that can be used to override this value. Maps to DBLITERAL_ESCAPE_UNDERSCORE_PREFIX.</summary>
    Escape_Underscore_Prefix = 10;
    ///<summary>An index name used in a text command or in a data-definition interface. Maps to DBLITERAL_INDEX_NAME.</summary>
    Index_Name = 11;
    ///<summary>The character used in a LIKE clause to match zero or more characters. For example, if this is a percent sign (%), the characters "abc%" match all character values that start with "abc". Maps to DBLITERAL_LIKE_PERCENT.</summary>
    Like_Percent = 12;
    ///<summary>The character used in a LIKE clause to match exactly one character. For example, if this is an underscore (_), the characters "abc_" match all character values that are four characters long and start with "abc". Maps to DBLITERAL_LIKE_UNDERSCORE.</summary>
    Like_Underscore = 13;
    ///<summary>A procedure name in a text command. Maps to DBLITERAL_PROCEDURE_NAME.</summary>
    Procedure_Name = 14;
    ///<summary>The character used in a text command as the opening quote for quoting identifiers that contain special characters. Maps to DBLITERAL_QUOTE_PREFIX.</summary>
    Quote_Prefix = 15;
    ///<summary>A schema name in a text command. Maps to DBLITERAL_SCHEMA_NAME.</summary>
    Schema_Name = 16;
    ///<summary>A table name used in a text command or in a data-definition interface. Maps to DBLITERAL_TABLE_NAME.</summary>
    Table_Name = 17;
    ///<summary>A text command, such as an SQL statement. Maps to DBLITERAL_TEXT_COMMAND.</summary>
    Text_Command = 18;
    ///<summary>A user name in a text command. Maps to DBLITERAL_USER_NAME.</summary>
    User_Name = 19;
    ///<summary>A view name in a text command. Maps to DBLITERAL_VIEW_NAME.</summary>
    View_Name = 20;
    ///<summary>The name of a cube in a schema (or the catalog if the provider does not support schemas).</summary>
    Cube_Name = 21;
    ///<summary>The name of the dimension. If a dimension is part of more than one cube, there is one row for each cube/dimension combination.</summary>
    Dimension_Name = 22;
    ///<summary>The name of the hierarchy. If the dimension does not contain a hierarchy or has only one hierarchy, the current column contains a null value.</summary>
    Hierarchy_Name = 23;
    ///<summary>Name of the cube to which the current level belongs.</summary>
    Level_Name = 24;
    ///<summary>The name of the member.</summary>
    Member_Name = 25;
    ///<summary>The name of the property.</summary>
    Property_Name = 26;
    ///<summary>The character that separates the schema name from the rest of the identifier in a text command. Maps to DBLITERAL_SCHEMA_SEPARATOR.</summary>
    Schema_Separator = 27;
    ///<summary>The character used in a text command as the closing quote for quoting identifiers that contain special characters. 1.x providers that use the same character as the prefix and suffix may not return this literal value and can set the member of the DBLITERAL structure to DBLITERAL_INVALID if requested. Maps to DBLITERAL_QUOTE_SUFFIX.</summary>
    Quote_Suffix = 28;
    ///<summary>The escape character, if any, used to suffix the character returned for the DBLITERAL_LIKE_PERCENT literal. For example, if a percent sign (%) is used to match zero or more characters and percent signs are escaped by enclosing in open and close square brackets, DBLITERAL_ESCAPE_PERCENT_PREFIX is "[", DBLITERAL_ESCAPE_PERCENT_SUFFIX is "]", and the characters "abc[%]%" match all character values that start with "abc%". Providers that do not use a suffix character to escape the DBLITERAL_ESCAPE_PERCENT character do not return this literal value and can set the lt member of the DBLITERAL structure to DBLITERAL_INVALID if requested. Maps to DBLITERAL_ESCAPE_PERCENT_SUFFIX.</summary>
    Escape_Percent_Suffix = 29;
    ///<summary>The character used in a LIKE clause to escape the character returned for the DBLITERAL_LIKE_UNDERSCORE literal. For example, if an underscore (_) is used to match exactly one character and this is a backslash (\), the characters "abc\_ _" match all character values that are five characters long and start with "abc_". Some SQL dialects support a clause (the ESCAPE clause) that can be used to override this value. Maps to DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX.</summary>
    Escape_Underscore_Suffix = 30;
  end;


  //-------------namespace: System.Data.OleDb----------------
  ///<summary>Specifies the data type of a field, a property, for use in an <see cref="T:System.Data.OleDb.OleDbParameter" />
  ///  .</summary>
  [DNTypeName('System.Data.OleDb.OleDbType')]
  DNOleDbType = type Integer;
  DNOleDbTypeHelper = record helper for DNOleDbType
  public const
    ///<summary>No value (DBTYPE_EMPTY).</summary>
    Empty = 0;
    ///<summary>A 16-bit signed integer (DBTYPE_I2). This maps to <see cref="T:System.Int16" />
    ///  .</summary>
    SmallInt = 2;
    ///<summary>A 32-bit signed integer (DBTYPE_I4). This maps to <see cref="T:System.Int32" />
    ///  .</summary>
    Integer = 3;
    ///<summary>A floating-point number within the range of -3.40E +38 through 3.40E +38 (DBTYPE_R4). This maps to <see cref="T:System.Single" />
    ///  .</summary>
    Single = 4;
    ///<summary>A floating-point number within the range of -1.79E +308 through 1.79E +308 (DBTYPE_R8). This maps to <see cref="T:System.Double" />
    ///  .</summary>
    Double = 5;
    ///<summary>A currency value ranging from -2 63 (or -922,337,203,685,477.5808) to 2 63 -1 (or +922,337,203,685,477.5807) with an accuracy to a ten-thousandth of a currency unit (DBTYPE_CY). This maps to <see cref="T:System.Decimal" />
    ///  .</summary>
    Currency = 6;
    ///<summary>Date data, stored as a double (DBTYPE_DATE). The whole portion is the number of days since December 30, 1899, and the fractional portion is a fraction of a day. This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    Date = 7;
    ///<summary>A null-terminated character string of Unicode characters (DBTYPE_BSTR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    BSTR = 8;
    ///<summary>A pointer to an <see langword="IDispatch" />
    ///  interface (DBTYPE_IDISPATCH). This maps to <see cref="T:System.Object" />
    ///  .</summary>
    IDispatch = 9;
    ///<summary>A 32-bit error code (DBTYPE_ERROR). This maps to <see cref="T:System.Exception" />
    ///  .</summary>
    Error = 10;
    ///<summary>A Boolean value (DBTYPE_BOOL). This maps to <see cref="T:System.Boolean" />
    ///  .</summary>
    Boolean = 11;
    ///<summary>A special data type that can contain numeric, string, binary, or date data, and also the special values Empty and Null (DBTYPE_VARIANT). This type is assumed if no other is specified. This maps to <see cref="T:System.Object" />
    ///  .</summary>
    Variant = 12;
    ///<summary>A pointer to an <see langword="IUnknown" />
    ///  interface (DBTYPE_UNKNOWN). This maps to <see cref="T:System.Object" />
    ///  .</summary>
    IUnknown = 13;
    ///<summary>A fixed precision and scale numeric value between -10 38 -1 and 10 38 -1 (DBTYPE_DECIMAL). This maps to <see cref="T:System.Decimal" />
    ///  .</summary>
    Decimal = 14;
    ///<summary>A 8-bit signed integer (DBTYPE_I1). This maps to <see cref="T:System.SByte" />
    ///  .</summary>
    TinyInt = 16;
    ///<summary>A 8-bit unsigned integer (DBTYPE_UI1). This maps to <see cref="T:System.Byte" />
    ///  .</summary>
    UnsignedTinyInt = 17;
    ///<summary>A 16-bit unsigned integer (DBTYPE_UI2). This maps to <see cref="T:System.UInt16" />
    ///  .</summary>
    UnsignedSmallInt = 18;
    ///<summary>A 32-bit unsigned integer (DBTYPE_UI4). This maps to <see cref="T:System.UInt32" />
    ///  .</summary>
    UnsignedInt = 19;
    ///<summary>A 64-bit signed integer (DBTYPE_I8). This maps to <see cref="T:System.Int64" />
    ///  .</summary>
    BigInt = 20;
    ///<summary>A 64-bit unsigned integer (DBTYPE_UI8). This maps to <see cref="T:System.UInt64" />
    ///  .</summary>
    UnsignedBigInt = 21;
    ///<summary>A 64-bit unsigned integer representing the number of 100-nanosecond intervals since January 1, 1601 (DBTYPE_FILETIME). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    Filetime = 64;
    ///<summary>A globally unique identifier (or GUID) (DBTYPE_GUID). This maps to <see cref="T:System.Guid" />
    ///  .</summary>
    Guid = 72;
    ///<summary>A stream of binary data (DBTYPE_BYTES). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    Binary = 128;
    ///<summary>A character string (DBTYPE_STR). This maps to <see cref="T:System.String" />
    ///  .</summary>
    Char = 129;
    ///<summary>A null-terminated stream of Unicode characters (DBTYPE_WSTR). This maps to <see cref="T:System.String" />
    ///  . </summary>
    WChar = 130;
    ///<summary>An exact numeric value with a fixed precision and scale (DBTYPE_NUMERIC). This maps to <see cref="T:System.Decimal" />
    ///  .</summary>
    Numeric = 131;
    ///<summary>Date data in the format yyyymmdd (DBTYPE_DBDATE). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    DBDate = 133;
    ///<summary>Time data in the format hhmmss (DBTYPE_DBTIME). This maps to <see cref="T:System.TimeSpan" />
    ///  .</summary>
    DBTime = 134;
    ///<summary>Data and time data in the format yyyymmddhhmmss (DBTYPE_DBTIMESTAMP). This maps to <see cref="T:System.DateTime" />
    ///  .</summary>
    DBTimeStamp = 135;
    ///<summary>An automation PROPVARIANT (DBTYPE_PROP_VARIANT). This maps to <see cref="T:System.Object" />
    ///  .</summary>
    PropVariant = 138;
    ///<summary>A variable-length numeric value (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to <see cref="T:System.Decimal" />
    ///  .</summary>
    VarNumeric = 139;
    ///<summary>A variable-length stream of non-Unicode characters (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to <see cref="T:System.String" />
    ///  .</summary>
    VarChar = 200;
    ///<summary>A long string value (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to <see cref="T:System.String" />
    ///  .</summary>
    LongVarChar = 201;
    ///<summary>A variable-length, null-terminated stream of Unicode characters (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to <see cref="T:System.String" />
    ///  .</summary>
    VarWChar = 202;
    ///<summary>A long null-terminated Unicode string value (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to <see cref="T:System.String" />
    ///  .</summary>
    LongVarWChar = 203;
    ///<summary>A variable-length stream of binary data (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    VarBinary = 204;
    ///<summary>A long binary value (<see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  only). This maps to an <see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  .</summary>
    LongVarBinary = 205;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the type of a parameter within a query relative to the <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.ParameterDirection')]
  DNParameterDirection = type Integer;
  DNParameterDirectionHelper = record helper for DNParameterDirection
  public const
    ///<summary>The parameter is an input parameter.</summary>
    Input = 1;
    ///<summary>The parameter is an output parameter.</summary>
    Output = 2;
    ///<summary>The parameter is capable of both input and output.</summary>
    InputOutput = 3;
    ///<summary>The parameter represents a return value from an operation such as a stored procedure, built-in function, or user-defined function.</summary>
    ReturnValue = 6;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the attributes of a property.</summary>
  [DNTypeName('System.Data.PropertyAttributes')]
  DNPropertyAttributes = type Integer;
  DNPropertyAttributesHelper = record helper for DNPropertyAttributes
  public const
    ///<summary>The property is not supported by the provider.</summary>
    NotSupported = 0;
    ///<summary>The user must specify a value for this property before the data source is initialized.</summary>
    Required = 1;
    ///<summary>The user does not need to specify a value for this property before the data source is initialized.</summary>
    Optional = 2;
    ///<summary>The user can read the property.</summary>
    Read = 512;
    ///<summary>The user can write to the property.</summary>
    Write = 1024;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Indicates the action that occurs when a <see cref="T:System.Data.ForeignKeyConstraint" />
  ///  is enforced.</summary>
  [DNTypeName('System.Data.Rule')]
  DNRule = type Integer;
  DNRuleHelper = record helper for DNRule
  public const
    ///<summary>No action taken on related rows.</summary>
    None = 0;
    ///<summary>Delete or update related rows. This is the default.</summary>
    Cascade = 1;
    ///<summary>Set values in related rows to <see langword="DBNull" />
    ///  .</summary>
    SetNull = 2;
    ///<summary>Set values in related rows to the value contained in the <see cref="P:System.Data.DataColumn.DefaultValue" />
    ///  property.</summary>
    SetDefault = 3;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Indicates the schema serialization mode for a typed <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.SchemaSerializationMode')]
  DNSchemaSerializationMode = type Integer;
  DNSchemaSerializationModeHelper = record helper for DNSchemaSerializationMode
  public const
    ///<summary>Includes schema serialization for a typed <see cref="T:System.Data.DataSet" />
    ///  . The default.</summary>
    IncludeSchema = 1;
    ///<summary>Skips schema serialization for a typed <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ExcludeSchema = 2;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how to handle existing schema mappings when performing a <see cref="M:System.Data.Common.DataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
  ///  operation.</summary>
  [DNTypeName('System.Data.SchemaType')]
  DNSchemaType = type Integer;
  DNSchemaTypeHelper = record helper for DNSchemaType
  public const
    ///<summary>Ignore any table mappings on the DataAdapter. Configure the <see cref="T:System.Data.DataSet" />
    ///  using the incoming schema without applying any transformations.</summary>
    Source = 1;
    ///<summary>Apply any existing table mappings to the incoming schema. Configure the <see cref="T:System.Data.DataSet" />
    ///  with the transformed schema.</summary>
    Mapped = 2;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Determines the serialization format for a <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.SerializationFormat')]
  DNSerializationFormat = type Integer;
  DNSerializationFormatHelper = record helper for DNSerializationFormat
  public const
    ///<summary>Serialize as XML content. The default.</summary>
    Xml = 0;
    ///<summary>Serialize as binary content. Available in ADO.NET 2.0 only.</summary>
    Binary = 1;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Specifies a value for <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.ApplicationIntent" />
  ///  . Possible values are <see langword="ReadWrite" />
  ///  and <see langword="ReadOnly" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlClient.ApplicationIntent')]
  DNApplicationIntent = type Integer;
  DNApplicationIntentHelper = record helper for DNApplicationIntent
  public const
    ///<summary>The application workload type when connecting to a server is read write.</summary>
    ReadWrite = 0;
    ///<summary>The application workload type when connecting to a server is read only.</summary>
    ReadOnly = 1;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Specifies a value for PoolBlockingPeriod Property. </summary>
  [DNTypeName('System.Data.SqlClient.PoolBlockingPeriod')]
  DNPoolBlockingPeriod = type Integer;
  DNPoolBlockingPeriodHelper = record helper for DNPoolBlockingPeriod
  public const
    ///<summary>Blocking period OFF for Azure SQL servers, but ON for all other SQL servers.</summary>
    Auto = 0;
    ///<summary>Blocking period ON for all SQL servers including Azure SQL servers.</summary>
    AlwaysBlock = 1;
    ///<summary>Blocking period OFF for all SQL servers including Azure SQL servers.</summary>
    NeverBlock = 2;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Specifies how rows of data are sorted.</summary>
  [DNTypeName('System.Data.SqlClient.SortOrder')]
  DNSortOrder = type Integer;
  DNSortOrderHelper = record helper for DNSortOrder
  public const
    ///<summary>Rows are sorted in ascending order.</summary>
    Ascending = 0;
    ///<summary>Rows are sorted in descending order.</summary>
    Descending = 1;
    ///<summary>The default. No sort order is specified.</summary>
    Unspecified = -1;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Describes the different SQL authentication methods that can be used by a client connecting to Azure SQL Database. For details, see Connecting to SQL Database By Using Azure Active Directory Authentication.</summary>
  [DNTypeName('System.Data.SqlClient.SqlAuthenticationMethod')]
  DNSqlAuthenticationMethod = type Integer;
  DNSqlAuthenticationMethodHelper = record helper for DNSqlAuthenticationMethod
  public const
    ///<summary>The authentication method is not specified.</summary>
    NotSpecified = 0;
    ///<summary>The authentication method is Sql Password.</summary>
    SqlPassword = 1;
    ///<summary>The authentication method uses Active Directory Password. Use Active Directory Password to connect to a SQL Database using an Azure AD principal name and password. </summary>
    ActiveDirectoryPassword = 2;
    ///<summary>The authentication method uses Active Directory Integrated. Use Active Directory Integrated to connect to a SQL Database using integrated Windows authentication.</summary>
    ActiveDirectoryIntegrated = 3;
    ActiveDirectoryInteractive = 4;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Bitwise flag that specifies one or more options to use with an instance of <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlClient.SqlBulkCopyOptions')]
  DNSqlBulkCopyOptions = type Integer;
  DNSqlBulkCopyOptionsHelper = record helper for DNSqlBulkCopyOptions
  public const
    ///<summary>Use the default values for all options.</summary>
    Default_ = 0;
    ///<summary>Preserve source identity values. When not specified, identity values are assigned by the destination.</summary>
    KeepIdentity = 1;
    ///<summary>Check constraints while data is being inserted. By default, constraints are not checked.</summary>
    CheckConstraints = 2;
    ///<summary>Obtain a bulk update lock for the duration of the bulk copy operation. When not specified, row locks are used.</summary>
    TableLock = 4;
    ///<summary>Preserve null values in the destination table regardless of the settings for default values. When not specified, null values are replaced by default values where applicable.</summary>
    KeepNulls = 8;
    ///<summary>When specified, cause the server to fire the insert triggers for the rows being inserted into the database.</summary>
    FireTriggers = 16;
    ///<summary>When specified, each batch of the bulk-copy operation will occur within a transaction. If you indicate this option and also provide a <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  object to the constructor, an <see cref="T:System.ArgumentException" />
    ///  occurs.</summary>
    UseInternalTransaction = 32;
    ///<summary>When specified,AllowEncryptedValueModifications enables bulk copying of encrypted data between tables or databases, without decrypting the data. Typically, an application would select data from encrypted columns from one table without decrypting the data (the app would connect to the database with the column encryption setting keyword set to disabled) and then would use this option to bulk insert the data, which is still encrypted. For more information, see Always Encrypted.Use caution when specifying AllowEncryptedValueModifications as this may lead to corrupting the database because the driver does not check if the data is indeed encrypted, or if it is correctly encrypted using the same encryption type, algorithm and key as the target column.</summary>
    AllowEncryptedValueModifications = 64;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Specifies how data will be sent and received when reading and writing encrypted columns. Depending on your specific query, performance impact may be reduced by bypassing the Always Encrypted driver’s processing when non-encrypted columns are being used. Note that these settings cannot be used to bypass encryption and gain access to plaintext data. For details, see Always Encrypted (Database Engine)</summary>
  [DNTypeName('System.Data.SqlClient.SqlCommandColumnEncryptionSetting')]
  DNSqlCommandColumnEncryptionSetting = type Integer;
  DNSqlCommandColumnEncryptionSettingHelper = record helper for DNSqlCommandColumnEncryptionSetting
  public const
    ///<summary>Specifies that the command should default to the Always Encrypted setting in the connection string.</summary>
    UseConnectionSetting = 0;
    ///<summary>Enables Always Encrypted for the query.</summary>
    Enabled = 1;
    ///<summary>Specifies that only the results of the command should be processed by the Always Encrypted routine in the driver. Use this value when the command has no parameters that require encryption.</summary>
    ResultSetOnly = 2;
    ///<summary>Disables Always Encrypted for the query.</summary>
    Disabled = 3;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Specifies that Always Encrypted functionality is enabled in a connection. Note that these settings cannot be used to bypass encryption and gain access to plaintext data. For details, see Always Encrypted (Database Engine).</summary>
  [DNTypeName('System.Data.SqlClient.SqlConnectionColumnEncryptionSetting')]
  DNSqlConnectionColumnEncryptionSetting = type Integer;
  DNSqlConnectionColumnEncryptionSettingHelper = record helper for DNSqlConnectionColumnEncryptionSetting
  public const
    ///<summary>Specifies the connection does not use Always Encrypted. Should be used if no queries sent over the connection access encrypted columns.</summary>
    Disabled = 0;
    ///<summary>Enables Always Encrypted functionality for the connection. Query parameters that correspond to encrypted columns will be transparently encrypted and query results from encrypted columns will be transparently decrypted.</summary>
    Enabled = 1;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>This enumeration provides additional information about the different notifications that can be received by the dependency event handler. </summary>
  [DNTypeName('System.Data.SqlClient.SqlNotificationInfo')]
  DNSqlNotificationInfo = type Integer;
  DNSqlNotificationInfoHelper = record helper for DNSqlNotificationInfo
  public const
    ///<summary>One or more tables were truncated.</summary>
    Truncate = 0;
    ///<summary>Data was changed by an INSERT statement.</summary>
    Insert = 1;
    ///<summary>Data was changed by an UPDATE statement.</summary>
    Update = 2;
    ///<summary>Data was changed by a DELETE statement.</summary>
    Delete = 3;
    ///<summary>An underlying object related to the query was dropped.</summary>
    Drop = 4;
    ///<summary>An underlying server object related to the query was modified.</summary>
    Alter = 5;
    ///<summary>The server was restarted (notifications are sent during restart.).</summary>
    Restart = 6;
    ///<summary>An internal server error occurred.</summary>
    Error = 7;
    ///<summary>A SELECT statement that cannot be notified or was provided.</summary>
    Query = 8;
    ///<summary>A statement was provided that cannot be notified (for example, an UPDATE statement).</summary>
    Invalid = 9;
    ///<summary>The SET options were not set appropriately at subscription time.</summary>
    Options = 10;
    ///<summary>The statement was executed under an isolation mode that was not valid (for example, Snapshot).</summary>
    Isolation = 11;
    ///<summary>The <see langword="SqlDependency" />
    ///  object has expired.</summary>
    Expired = 12;
    ///<summary>Fires as a result of server resource pressure.</summary>
    Resource = 13;
    ///<summary>A previous statement has caused query notifications to fire under the current transaction.</summary>
    PreviousFire = 14;
    ///<summary>The subscribing query causes the number of templates on one of the target tables to exceed the maximum allowable limit.</summary>
    TemplateLimit = 15;
    ///<summary>Used to distinguish the server-side cause for a query notification firing.</summary>
    Merge = 16;
    ///<summary>The <see langword="SqlDependency" />
    ///  object already fired, and new commands cannot be added to it.</summary>
    AlreadyChanged = -2;
    ///<summary>Used when the info option sent by the server was not recognized by the client.</summary>
    Unknown = -1;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Indicates the source of the notification received by the dependency event handler.</summary>
  [DNTypeName('System.Data.SqlClient.SqlNotificationSource')]
  DNSqlNotificationSource = type Integer;
  DNSqlNotificationSourceHelper = record helper for DNSqlNotificationSource
  public const
    ///<summary>Data has changed; for example, an insert, update, delete, or truncate operation occurred.</summary>
    Data = 0;
    ///<summary>The subscription time-out expired.</summary>
    Timeout = 1;
    ///<summary>A database object changed; for example, an underlying object related to the query was dropped or modified.</summary>
    Object_ = 2;
    ///<summary>The database state changed; for example, the database related to the query was dropped or detached.</summary>
    Database = 3;
    ///<summary>A system-related event occurred. For example, there was an internal error, the server was restarted, or resource pressure caused the invalidation.</summary>
    System = 4;
    ///<summary>The Transact-SQL statement is not valid for notifications; for example, a SELECT statement that could not be notified or a non-SELECT statement was executed.</summary>
    Statement = 5;
    ///<summary>The run-time environment was not compatible with notifications; for example, the isolation level was set to snapshot, or one or more SET options are not compatible.</summary>
    Environment = 6;
    ///<summary>A run-time error occurred during execution.</summary>
    Execution = 7;
    ///<summary>Internal only; not intended to be used in your code.</summary>
    Owner = 8;
    ///<summary>A client-initiated notification occurred, such as a client-side time-out or as a result of attempting to add a command to a dependency that has already fired.</summary>
    Client = -2;
    ///<summary>Used when the source option sent by the server was not recognized by the client. </summary>
    Unknown = -1;
  end;


  //-------------namespace: System.Data.SqlClient----------------
  ///<summary>Describes the different notification types that can be received by an <see cref="T:System.Data.SqlClient.OnChangeEventHandler" />
  ///  event handler through the <see cref="T:System.Data.SqlClient.SqlNotificationEventArgs" />
  ///  parameter.</summary>
  [DNTypeName('System.Data.SqlClient.SqlNotificationType')]
  DNSqlNotificationType = type Integer;
  DNSqlNotificationTypeHelper = record helper for DNSqlNotificationType
  public const
    ///<summary>Data on the server being monitored changed. Use the <see cref="T:System.Data.SqlClient.SqlNotificationInfo" />
    ///  item to determine the details of the change.</summary>
    Change = 0;
    ///<summary>There was a failure to create a notification subscription. Use the <see cref="T:System.Data.SqlClient.SqlNotificationEventArgs" />
    ///  object's <see cref="T:System.Data.SqlClient.SqlNotificationInfo" />
    ///  item to determine the cause of the failure.</summary>
    Subscribe = 1;
    ///<summary>Used when the type option sent by the server was not recognized by the client.</summary>
    Unknown = -1;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies SQL Server-specific data type of a field, property, for use in a <see cref="T:System.Data.SqlClient.SqlParameter" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlDbType')]
  DNSqlDbType = type Integer;
  DNSqlDbTypeHelper = record helper for DNSqlDbType
  public const
    ///<summary><see cref="T:System.Int64" />
    ///  . A 64-bit signed integer.</summary>
    BigInt = 0;
    ///<summary><see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  . A fixed-length stream of binary data ranging between 1 and 8,000 bytes.</summary>
    Binary = 1;
    ///<summary><see cref="T:System.Boolean" />
    ///  . An unsigned numeric value that can be 0, 1, or <see langword="null" />
    ///  . </summary>
    Bit = 2;
    ///<summary><see cref="T:System.String" />
    ///  . A fixed-length stream of non-Unicode characters ranging between 1 and 8,000 characters.</summary>
    Char = 3;
    ///<summary><see cref="T:System.DateTime" />
    ///  . Date and time data ranging in value from January 1, 1753 to December 31, 9999 to an accuracy of 3.33 milliseconds.</summary>
    DateTime = 4;
    ///<summary><see cref="T:System.Decimal" />
    ///  . A fixed precision and scale numeric value between -10 38 -1 and 10 38 -1.</summary>
    Decimal = 5;
    ///<summary><see cref="T:System.Double" />
    ///  . A floating point number within the range of -1.79E +308 through 1.79E +308.</summary>
    Float = 6;
    ///<summary><see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  . A variable-length stream of binary data ranging from 0 to 2 31 -1 (or 2,147,483,647) bytes.</summary>
    Image = 7;
    ///<summary><see cref="T:System.Int32" />
    ///  . A 32-bit signed integer.</summary>
    Int = 8;
    ///<summary><see cref="T:System.Decimal" />
    ///  . A currency value ranging from -2 63 (or -9,223,372,036,854,775,808) to 2 63 -1 (or +9,223,372,036,854,775,807) with an accuracy to a ten-thousandth of a currency unit.</summary>
    Money = 9;
    ///<summary><see cref="T:System.String" />
    ///  . A fixed-length stream of Unicode characters ranging between 1 and 4,000 characters.</summary>
    NChar = 10;
    ///<summary><see cref="T:System.String" />
    ///  . A variable-length stream of Unicode data with a maximum length of 2 30 - 1 (or 1,073,741,823) characters.</summary>
    NText = 11;
    ///<summary><see cref="T:System.String" />
    ///  . A variable-length stream of Unicode characters ranging between 1 and 4,000 characters. Implicit conversion fails if the string is greater than 4,000 characters. Explicitly set the object when working with strings longer than 4,000 characters. Use <see cref="F:System.Data.SqlDbType.NVarChar" />
    ///  when the database column is <see langword="nvarchar(max)" />
    ///  .</summary>
    NVarChar = 12;
    ///<summary><see cref="T:System.Single" />
    ///  . A floating point number within the range of -3.40E +38 through 3.40E +38.</summary>
    Real = 13;
    ///<summary><see cref="T:System.Guid" />
    ///  . A globally unique identifier (or GUID).</summary>
    UniqueIdentifier = 14;
    ///<summary><see cref="T:System.DateTime" />
    ///  . Date and time data ranging in value from January 1, 1900 to June 6, 2079 to an accuracy of one minute.</summary>
    SmallDateTime = 15;
    ///<summary><see cref="T:System.Int16" />
    ///  . A 16-bit signed integer.</summary>
    SmallInt = 16;
    ///<summary><see cref="T:System.Decimal" />
    ///  . A currency value ranging from -214,748.3648 to +214,748.3647 with an accuracy to a ten-thousandth of a currency unit.</summary>
    SmallMoney = 17;
    ///<summary><see cref="T:System.String" />
    ///  . A variable-length stream of non-Unicode data with a maximum length of 2 31 -1 (or 2,147,483,647) characters.</summary>
    Text = 18;
    ///<summary><see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  . Automatically generated binary numbers, which are guaranteed to be unique within a database. <see langword="timestamp" />
    ///  is used typically as a mechanism for version-stamping table rows. The storage size is 8 bytes.</summary>
    Timestamp = 19;
    ///<summary><see cref="T:System.Byte" />
    ///  . An 8-bit unsigned integer.</summary>
    TinyInt = 20;
    ///<summary><see cref="T:System.Array" />
    ///  of type <see cref="T:System.Byte" />
    ///  . A variable-length stream of binary data ranging between 1 and 8,000 bytes. Implicit conversion fails if the byte array is greater than 8,000 bytes. Explicitly set the object when working with byte arrays larger than 8,000 bytes.</summary>
    VarBinary = 21;
    ///<summary><see cref="T:System.String" />
    ///  . A variable-length stream of non-Unicode characters ranging between 1 and 8,000 characters. Use <see cref="F:System.Data.SqlDbType.VarChar" />
    ///  when the database column is <see langword="varchar(max)" />
    ///  .</summary>
    VarChar = 22;
    ///<summary><see cref="T:System.Object" />
    ///  . A special data type that can contain numeric, string, binary, or date data as well as the SQL Server values Empty and Null, which is assumed if no other type is declared.</summary>
    Variant = 23;
    ///<summary>An XML value. Obtain the XML as a string using the <see cref="M:System.Data.SqlClient.SqlDataReader.GetValue(System.Int32)" />
    ///  method or <see cref="P:System.Data.SqlTypes.SqlXml.Value" />
    ///  property, or as an <see cref="T:System.Xml.XmlReader" />
    ///  by calling the <see cref="M:System.Data.SqlTypes.SqlXml.CreateReader" />
    ///  method.</summary>
    Xml = 25;
    ///<summary>A SQL Server user-defined type (UDT).</summary>
    Udt = 29;
    ///<summary>A special data type for specifying structured data contained in table-valued parameters.</summary>
    Structured = 30;
    ///<summary>Date data ranging in value from January 1,1 AD through December 31, 9999 AD.</summary>
    Date = 31;
    ///<summary>Time data based on a 24-hour clock. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds. Corresponds to a SQL Server <see langword="time" />
    ///  value.</summary>
    Time = 32;
    ///<summary>Date and time data. Date value range is from January 1,1 AD through December 31, 9999 AD. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds.</summary>
    DateTime2 = 33;
    ///<summary>Date and time data with time zone awareness. Date value range is from January 1,1 AD through December 31, 9999 AD. Time value range is 00:00:00 through 23:59:59.9999999 with an accuracy of 100 nanoseconds. Time zone value range is -14:00 through +14:00. </summary>
    DateTimeOffset = 34;
  end;


  //-------------namespace: System.Data.SqlTypes----------------
  ///<summary>Specifies the compare option values for a <see cref="T:System.Data.SqlTypes.SqlString" />
  ///  structure.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlCompareOptions')]
  DNSqlCompareOptions = type Integer;
  DNSqlCompareOptionsHelper = record helper for DNSqlCompareOptions
  public const
    ///<summary>Specifies the default option settings for <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  comparisons.</summary>
    None = 0;
    ///<summary>Specifies that <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  comparisons must ignore case.</summary>
    IgnoreCase = 1;
    ///<summary>Specifies that <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  comparisons must ignore nonspace combining characters, such as diacritics. The Unicode Standard defines combining characters as characters that are combined with base characters to produce a new character. Non-space combining characters do not use character space by themselves when rendered. For more information about non-space combining characters, see the Unicode Standard at http://www.unicode.org.</summary>
    IgnoreNonSpace = 2;
    ///<summary>Specifies that <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  comparisons must ignore the Kana type. Kana type refers to Japanese hiragana and katakana characters that represent phonetic sounds in the Japanese language. Hiragana is used for native Japanese expressions and words, while katakana is used for words borrowed from other languages, such as "computer" or "Internet". A phonetic sound can be expressed in both hiragana and katakana. If this value is selected, the hiragana character for one sound is considered equal to the katakana character for the same sound.</summary>
    IgnoreKanaType = 8;
    ///<summary>Specifies that <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  comparisons must ignore the character width. For example, Japanese katakana characters can be written as full-width or half-width and, if this value is selected, the katakana characters written as full-width are considered equal to the same characters written in half-width.</summary>
    IgnoreWidth = 16;
    ///<summary>Performs a binary sort.</summary>
    BinarySort2 = 16384;
    ///<summary>Specifies that sorts should be based on a characters numeric value instead of its alphabetical value.</summary>
    BinarySort = 32768;
  end;


  //-------------namespace: System.Data.SqlTypes----------------
  ///<summary>The <see cref="T:System.Data.SqlTypes.StorageState" />
  ///  enumeration is not intended for use as a stand-alone component, but as an enumeration from which other classes derive standard functionality.</summary>
  [DNTypeName('System.Data.SqlTypes.StorageState')]
  DNStorageState = type Integer;
  DNStorageStateHelper = record helper for DNStorageState
  public const
    ///<summary>Buffer size.</summary>
    Buffer = 0;
    ///<summary>Stream.</summary>
    Stream = 1;
    ///<summary>Unmanaged buffer.</summary>
    UnmanagedBuffer = 2;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the type of SQL query to be used by the <see cref="T:System.Data.OleDb.OleDbRowUpdatedEventArgs" />
  ///  , <see cref="T:System.Data.OleDb.OleDbRowUpdatingEventArgs" />
  ///  , <see cref="T:System.Data.SqlClient.SqlRowUpdatedEventArgs" />
  ///  , or <see cref="T:System.Data.SqlClient.SqlRowUpdatingEventArgs" />
  ///  class.</summary>
  [DNTypeName('System.Data.StatementType')]
  DNStatementType = type Integer;
  DNStatementTypeHelper = record helper for DNStatementType
  public const
    ///<summary>An SQL query that is a SELECT statement.</summary>
    Select = 0;
    ///<summary>An SQL query that is an INSERT statement.</summary>
    Insert = 1;
    ///<summary>An SQL query that is an UPDATE statement.</summary>
    Update = 2;
    ///<summary>An SQL query that is a DELETE statement.</summary>
    Delete = 3;
    ///<summary>A SQL query that is a batch statement.</summary>
    Batch = 4;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how query command results are applied to the row being updated.</summary>
  [DNTypeName('System.Data.UpdateRowSource')]
  DNUpdateRowSource = type Integer;
  DNUpdateRowSourceHelper = record helper for DNUpdateRowSource
  public const
    ///<summary>Any returned parameters or rows are ignored.</summary>
    None = 0;
    ///<summary>Output parameters are mapped to the changed row in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    OutputParameters = 1;
    ///<summary>The data in the first returned row is mapped to the changed row in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    FirstReturnedRecord = 2;
    ///<summary>Both the output parameters and the first returned row are mapped to the changed row in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    Both = 3;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies the action to take with regard to the current and remaining rows during an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
  ///  .</summary>
  [DNTypeName('System.Data.UpdateStatus')]
  DNUpdateStatus = type Integer;
  DNUpdateStatusHelper = record helper for DNUpdateStatus
  public const
    ///<summary>The <see cref="T:System.Data.Common.DataAdapter" />
    ///  is to continue proccessing rows.</summary>
    Continue_ = 0;
    ///<summary>The event handler reports that the update should be treated as an error.</summary>
    ErrorsOccurred = 1;
    ///<summary>The current row is not to be updated.</summary>
    SkipCurrentRow = 2;
    ///<summary>The current row and all remaining rows are not to be updated.</summary>
    SkipAllRemainingRows = 3;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how to read XML data and a relational schema into a <see cref="T:System.Data.DataSet" />
  ///  . </summary>
  [DNTypeName('System.Data.XmlReadMode')]
  DNXmlReadMode = type Integer;
  DNXmlReadModeHelper = record helper for DNXmlReadMode
  public const
    ///<summary>Default.  </summary>
    Auto = 0;
    ///<summary>Reads any inline schema and loads the data. If the <see cref="T:System.Data.DataSet" />
    ///  already contains schema, new tables may be added to the schema, but an exception is thrown if any tables in the inline schema already exist in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ReadSchema = 1;
    ///<summary>Ignores any inline schema and reads data into the existing <see cref="T:System.Data.DataSet" />
    ///  schema. If any data does not match the existing schema, it is discarded (including data from differing namespaces defined for the <see cref="T:System.Data.DataSet" />
    ///  ). If the data is a DiffGram, <see langword="IgnoreSchema" />
    ///  has the same functionality as <see langword="DiffGram" />
    ///  .</summary>
    IgnoreSchema = 2;
    ///<summary>Ignores any inline schema, infers schema from the data and loads the data. If the <see cref="T:System.Data.DataSet" />
    ///  already contains a schema, the current schema is extended by adding new tables or adding columns to existing tables. An exception is thrown if the inferred table already exists but with a different namespace, or if any of the inferred columns conflict with existing columns.</summary>
    InferSchema = 3;
    ///<summary>Reads a DiffGram, applying changes from the DiffGram to the <see cref="T:System.Data.DataSet" />
    ///  . The semantics are identical to those of a <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
    ///  operation. As with the <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
    ///  operation, <see cref="P:System.Data.DataRow.RowState" />
    ///  values are preserved. Input to <see cref="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
    ///  with DiffGrams should only be obtained using the output from <see cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
    ///  as a DiffGram.</summary>
    DiffGram = 4;
    ///<summary>Reads XML fragments, such as those generated by executing FOR XML queries, against an instance of SQL Server. When <see cref="T:System.Data.XmlReadMode" />
    ///  is set to <see langword="Fragment" />
    ///  , the default namespace is read as the inline schema.</summary>
    Fragment = 5;
    ///<summary>Ignores any inline schema, infers a strongly typed schema from the data, and loads the data. If the type cannot be inferred from the data, it is interpreted as string data. If the <see cref="T:System.Data.DataSet" />
    ///  already contains a schema, the current schema is extended, either by adding new tables or by adding columns to existing tables. An exception is thrown if the inferred table already exists but with a different namespace, or if any of the inferred columns conflict with existing columns.</summary>
    InferTypedSchema = 6;
  end;


  //-------------namespace: System.Data----------------
  ///<summary>Specifies how to write XML data and a relational schema from a <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.XmlWriteMode')]
  DNXmlWriteMode = type Integer;
  DNXmlWriteModeHelper = record helper for DNXmlWriteMode
  public const
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataSet" />
    ///  as XML data with the relational structure as inline XSD schema. If the <see cref="T:System.Data.DataSet" />
    ///  has only a schema with no data, only the inline schema is written. If the <see cref="T:System.Data.DataSet" />
    ///  does not have a current schema, nothing is written.</summary>
    WriteSchema = 0;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataSet" />
    ///  as XML data, without an XSD schema. If no data is loaded into the <see cref="T:System.Data.DataSet" />
    ///  , nothing is written.</summary>
    IgnoreSchema = 1;
    ///<summary>Writes the entire <see cref="T:System.Data.DataSet" />
    ///  as a DiffGram, including original and current values. To generate a DiffGram containing only changed values, call <see cref="M:System.Data.DataSet.GetChanges" />
    ///  , and then call <see cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
    ///  as a DiffGram on the returned <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    DiffGram = 2;
  end;




type


{ declares }

  DNIBinarySerialize = interface; // type: Microsoft.SqlServer.Server.IBinarySerialize, namespace: Microsoft.SqlServer.Server
  DNIColumnMappingCollection = interface; // type: System.Data.IColumnMappingCollection, namespace: System.Data
  DNIDataParameterCollection = interface; // type: System.Data.IDataParameterCollection, namespace: System.Data
  DNITableMappingCollection = interface; // type: System.Data.ITableMappingCollection, namespace: System.Data
  DNIDbColumnSchemaGenerator = interface; // type: System.Data.Common.IDbColumnSchemaGenerator, namespace: System.Data.Common
  DNIColumnMapping = interface; // type: System.Data.IColumnMapping, namespace: System.Data
  DNIDataAdapter = interface; // type: System.Data.IDataAdapter, namespace: System.Data
  DNIDbDataAdapter = interface; // type: System.Data.IDbDataAdapter, namespace: System.Data
  DNIDataParameter = interface; // type: System.Data.IDataParameter, namespace: System.Data
  DNIDbDataParameter = interface; // type: System.Data.IDbDataParameter, namespace: System.Data
  DNIDataRecord = interface; // type: System.Data.IDataRecord, namespace: System.Data
  DNITableMapping = interface; // type: System.Data.ITableMapping, namespace: System.Data
  DNINullable = interface; // type: System.Data.SqlTypes.INullable, namespace: System.Data.SqlTypes
  DNIDataReader = interface; // type: System.Data.IDataReader, namespace: System.Data
  DNIDbCommand = interface; // type: System.Data.IDbCommand, namespace: System.Data
  DNIDbConnection = interface; // type: System.Data.IDbConnection, namespace: System.Data
  DNIDbTransaction = interface; // type: System.Data.IDbTransaction, namespace: System.Data
  DNSqlContext = interface; // type: Microsoft.SqlServer.Server.SqlContext, namespace: Microsoft.SqlServer.Server
  DNSqlDataRecord = interface; // type: Microsoft.SqlServer.Server.SqlDataRecord, namespace: Microsoft.SqlServer.Server
  DNSqlMetaData = interface; // type: Microsoft.SqlServer.Server.SqlMetaData, namespace: Microsoft.SqlServer.Server
  DNSqlPipe = interface; // type: Microsoft.SqlServer.Server.SqlPipe, namespace: Microsoft.SqlServer.Server
  DNSqlTriggerContext = interface; // type: Microsoft.SqlServer.Server.SqlTriggerContext, namespace: Microsoft.SqlServer.Server
  DNSqlFacetAttribute = interface; // type: Microsoft.SqlServer.Server.SqlFacetAttribute, namespace: Microsoft.SqlServer.Server
  DNSqlFunctionAttribute = interface; // type: Microsoft.SqlServer.Server.SqlFunctionAttribute, namespace: Microsoft.SqlServer.Server
  DNSqlMethodAttribute = interface; // type: Microsoft.SqlServer.Server.SqlMethodAttribute, namespace: Microsoft.SqlServer.Server
  DNSqlProcedureAttribute = interface; // type: Microsoft.SqlServer.Server.SqlProcedureAttribute, namespace: Microsoft.SqlServer.Server
  DNSqlTriggerAttribute = interface; // type: Microsoft.SqlServer.Server.SqlTriggerAttribute, namespace: Microsoft.SqlServer.Server
  DNSqlUserDefinedAggregateAttribute = interface; // type: Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute, namespace: Microsoft.SqlServer.Server
  DNSqlUserDefinedTypeAttribute = interface; // type: Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute, namespace: Microsoft.SqlServer.Server
  DNDataSysDescriptionAttribute = interface; // type: System.Data.DataSysDescriptionAttribute, namespace: System.Data
  DNDbProviderSpecificTypePropertyAttribute = interface; // type: System.Data.Common.DbProviderSpecificTypePropertyAttribute, namespace: System.Data.Common
  DNDBDataPermissionAttribute = interface; // type: System.Data.Common.DBDataPermissionAttribute, namespace: System.Data.Common
  DNOdbcPermissionAttribute = interface; // type: System.Data.Odbc.OdbcPermissionAttribute, namespace: System.Data.Odbc
  DNOleDbPermissionAttribute = interface; // type: System.Data.OleDb.OleDbPermissionAttribute, namespace: System.Data.OleDb
  DNSqlClientPermissionAttribute = interface; // type: System.Data.SqlClient.SqlClientPermissionAttribute, namespace: System.Data.SqlClient
  DNSqlBulkCopyColumnMappingCollection = interface; // type: System.Data.SqlClient.SqlBulkCopyColumnMappingCollection, namespace: System.Data.SqlClient
  DNPropertyCollection = interface; // type: System.Data.PropertyCollection, namespace: System.Data
  DNDataColumn = interface; // type: System.Data.DataColumn, namespace: System.Data
  DNDataSet = interface; // type: System.Data.DataSet, namespace: System.Data
  DNDataTable = interface; // type: System.Data.DataTable, namespace: System.Data
  DNDataView = interface; // type: System.Data.DataView, namespace: System.Data
  DNDataViewManager = interface; // type: System.Data.DataViewManager, namespace: System.Data
  DNDbColumn = interface; // type: System.Data.Common.DbColumn, namespace: System.Data.Common
  DNDbConnectionStringBuilder = interface; // type: System.Data.Common.DbConnectionStringBuilder, namespace: System.Data.Common
  DNOdbcConnectionStringBuilder = interface; // type: System.Data.Odbc.OdbcConnectionStringBuilder, namespace: System.Data.Odbc
  DNOleDbConnectionStringBuilder = interface; // type: System.Data.OleDb.OleDbConnectionStringBuilder, namespace: System.Data.OleDb
  DNSqlConnectionStringBuilder = interface; // type: System.Data.SqlClient.SqlConnectionStringBuilder, namespace: System.Data.SqlClient
  DNDbDataReaderExtensions = interface; // type: System.Data.Common.DbDataReaderExtensions, namespace: System.Data.Common
  DNDbDataRecord = interface; // type: System.Data.Common.DbDataRecord, namespace: System.Data.Common
  DNDbDataSourceEnumerator = interface; // type: System.Data.Common.DbDataSourceEnumerator, namespace: System.Data.Common
  DNSqlDataSourceEnumerator = interface; // type: System.Data.Sql.SqlDataSourceEnumerator, namespace: System.Data.Sql
  DNDbEnumerator = interface; // type: System.Data.Common.DbEnumerator, namespace: System.Data.Common
  DNDbMetaDataCollectionNames = interface; // type: System.Data.Common.DbMetaDataCollectionNames, namespace: System.Data.Common
  DNDbMetaDataColumnNames = interface; // type: System.Data.Common.DbMetaDataColumnNames, namespace: System.Data.Common
  DNDbProviderConfigurationHandler = interface; // type: System.Data.Common.DbProviderConfigurationHandler, namespace: System.Data.Common
  DNDbProviderFactories = interface; // type: System.Data.Common.DbProviderFactories, namespace: System.Data.Common
  DNDbProviderFactoriesConfigurationHandler = interface; // type: System.Data.Common.DbProviderFactoriesConfigurationHandler, namespace: System.Data.Common
  DNDbProviderFactory = interface; // type: System.Data.Common.DbProviderFactory, namespace: System.Data.Common
  DNOdbcFactory = interface; // type: System.Data.Odbc.OdbcFactory, namespace: System.Data.Odbc
  DNOleDbFactory = interface; // type: System.Data.OleDb.OleDbFactory, namespace: System.Data.OleDb
  DNSqlClientFactory = interface; // type: System.Data.SqlClient.SqlClientFactory, namespace: System.Data.SqlClient
  DNSchemaTableColumn = interface; // type: System.Data.Common.SchemaTableColumn, namespace: System.Data.Common
  DNSchemaTableOptionalColumn = interface; // type: System.Data.Common.SchemaTableOptionalColumn, namespace: System.Data.Common
  DNConstraint = interface; // type: System.Data.Constraint, namespace: System.Data
  DNForeignKeyConstraint = interface; // type: System.Data.ForeignKeyConstraint, namespace: System.Data
  DNUniqueConstraint = interface; // type: System.Data.UniqueConstraint, namespace: System.Data
  DNDataRelation = interface; // type: System.Data.DataRelation, namespace: System.Data
  DNDataRow = interface; // type: System.Data.DataRow, namespace: System.Data
  DNDataRowBuilder = interface; // type: System.Data.DataRowBuilder, namespace: System.Data
  DNDataRowView = interface; // type: System.Data.DataRowView, namespace: System.Data
  DNDataViewSetting = interface; // type: System.Data.DataViewSetting, namespace: System.Data
  DNDataViewSettingCollection = interface; // type: System.Data.DataViewSettingCollection, namespace: System.Data
  DNInternalDataCollectionBase = interface; // type: System.Data.InternalDataCollectionBase, namespace: System.Data
  DNConstraintCollection = interface; // type: System.Data.ConstraintCollection, namespace: System.Data
  DNDataColumnCollection = interface; // type: System.Data.DataColumnCollection, namespace: System.Data
  DNDataRelationCollection = interface; // type: System.Data.DataRelationCollection, namespace: System.Data
  DNDataRowCollection = interface; // type: System.Data.DataRowCollection, namespace: System.Data
  DNDataTableCollection = interface; // type: System.Data.DataTableCollection, namespace: System.Data
  DNOdbcError = interface; // type: System.Data.Odbc.OdbcError, namespace: System.Data.Odbc
  DNOdbcErrorCollection = interface; // type: System.Data.Odbc.OdbcErrorCollection, namespace: System.Data.Odbc
  DNOdbcMetaDataCollectionNames = interface; // type: System.Data.Odbc.OdbcMetaDataCollectionNames, namespace: System.Data.Odbc
  DNOdbcMetaDataColumnNames = interface; // type: System.Data.Odbc.OdbcMetaDataColumnNames, namespace: System.Data.Odbc
  DNOleDbEnumerator = interface; // type: System.Data.OleDb.OleDbEnumerator, namespace: System.Data.OleDb
  DNOleDbError = interface; // type: System.Data.OleDb.OleDbError, namespace: System.Data.OleDb
  DNOleDbErrorCollection = interface; // type: System.Data.OleDb.OleDbErrorCollection, namespace: System.Data.OleDb
  DNOleDbMetaDataCollectionNames = interface; // type: System.Data.OleDb.OleDbMetaDataCollectionNames, namespace: System.Data.OleDb
  DNOleDbMetaDataColumnNames = interface; // type: System.Data.OleDb.OleDbMetaDataColumnNames, namespace: System.Data.OleDb
  DNOleDbSchemaGuid = interface; // type: System.Data.OleDb.OleDbSchemaGuid, namespace: System.Data.OleDb
  DNSqlNotificationRequest = interface; // type: System.Data.Sql.SqlNotificationRequest, namespace: System.Data.Sql
  DNSqlAuthenticationInitializer = interface; // type: System.Data.SqlClient.SqlAuthenticationInitializer, namespace: System.Data.SqlClient
  DNSqlAuthenticationParameters = interface; // type: System.Data.SqlClient.SqlAuthenticationParameters, namespace: System.Data.SqlClient
  DNSqlAuthenticationProvider = interface; // type: System.Data.SqlClient.SqlAuthenticationProvider, namespace: System.Data.SqlClient
  DNSqlAuthenticationToken = interface; // type: System.Data.SqlClient.SqlAuthenticationToken, namespace: System.Data.SqlClient
  DNSqlBulkCopy = interface; // type: System.Data.SqlClient.SqlBulkCopy, namespace: System.Data.SqlClient
  DNSqlBulkCopyColumnMapping = interface; // type: System.Data.SqlClient.SqlBulkCopyColumnMapping, namespace: System.Data.SqlClient
  DNSqlClientLogger = interface; // type: System.Data.SqlClient.SqlClientLogger, namespace: System.Data.SqlClient
  DNSqlClientMetaDataCollectionNames = interface; // type: System.Data.SqlClient.SqlClientMetaDataCollectionNames, namespace: System.Data.SqlClient
  DNSqlColumnEncryptionEnclaveProvider = interface; // type: System.Data.SqlClient.SqlColumnEncryptionEnclaveProvider, namespace: System.Data.SqlClient
  DNSqlColumnEncryptionKeyStoreProvider = interface; // type: System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider, namespace: System.Data.SqlClient
  DNSqlColumnEncryptionCertificateStoreProvider = interface; // type: System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider, namespace: System.Data.SqlClient
  DNSqlColumnEncryptionCngProvider = interface; // type: System.Data.SqlClient.SqlColumnEncryptionCngProvider, namespace: System.Data.SqlClient
  DNSqlColumnEncryptionCspProvider = interface; // type: System.Data.SqlClient.SqlColumnEncryptionCspProvider, namespace: System.Data.SqlClient
  DNSqlCredential = interface; // type: System.Data.SqlClient.SqlCredential, namespace: System.Data.SqlClient
  DNSQLDebugging = interface; // type: System.Data.SqlClient.SQLDebugging, namespace: System.Data.SqlClient
  DNSqlDependency = interface; // type: System.Data.SqlClient.SqlDependency, namespace: System.Data.SqlClient
  DNSqlEnclaveAttestationParameters = interface; // type: System.Data.SqlClient.SqlEnclaveAttestationParameters, namespace: System.Data.SqlClient
  DNSqlEnclaveSession = interface; // type: System.Data.SqlClient.SqlEnclaveSession, namespace: System.Data.SqlClient
  DNSqlError = interface; // type: System.Data.SqlClient.SqlError, namespace: System.Data.SqlClient
  DNSqlErrorCollection = interface; // type: System.Data.SqlClient.SqlErrorCollection, namespace: System.Data.SqlClient
  DNSqlBytes = interface; // type: System.Data.SqlTypes.SqlBytes, namespace: System.Data.SqlTypes
  DNSqlChars = interface; // type: System.Data.SqlTypes.SqlChars, namespace: System.Data.SqlTypes
  DNSqlXml = interface; // type: System.Data.SqlTypes.SqlXml, namespace: System.Data.SqlTypes
  DNTypedDataSetGenerator = interface; // type: System.Data.TypedDataSetGenerator, namespace: System.Data
  DNRowUpdatedEventArgs = interface; // type: System.Data.Common.RowUpdatedEventArgs, namespace: System.Data.Common
  DNOdbcRowUpdatedEventArgs = interface; // type: System.Data.Odbc.OdbcRowUpdatedEventArgs, namespace: System.Data.Odbc
  DNOleDbRowUpdatedEventArgs = interface; // type: System.Data.OleDb.OleDbRowUpdatedEventArgs, namespace: System.Data.OleDb
  DNSqlRowUpdatedEventArgs = interface; // type: System.Data.SqlClient.SqlRowUpdatedEventArgs, namespace: System.Data.SqlClient
  DNRowUpdatingEventArgs = interface; // type: System.Data.Common.RowUpdatingEventArgs, namespace: System.Data.Common
  DNOdbcRowUpdatingEventArgs = interface; // type: System.Data.Odbc.OdbcRowUpdatingEventArgs, namespace: System.Data.Odbc
  DNOleDbRowUpdatingEventArgs = interface; // type: System.Data.OleDb.OleDbRowUpdatingEventArgs, namespace: System.Data.OleDb
  DNSqlRowUpdatingEventArgs = interface; // type: System.Data.SqlClient.SqlRowUpdatingEventArgs, namespace: System.Data.SqlClient
  DNDataColumnChangeEventArgs = interface; // type: System.Data.DataColumnChangeEventArgs, namespace: System.Data
  DNDataRowChangeEventArgs = interface; // type: System.Data.DataRowChangeEventArgs, namespace: System.Data
  DNDataTableClearEventArgs = interface; // type: System.Data.DataTableClearEventArgs, namespace: System.Data
  DNDataTableNewRowEventArgs = interface; // type: System.Data.DataTableNewRowEventArgs, namespace: System.Data
  DNFillErrorEventArgs = interface; // type: System.Data.FillErrorEventArgs, namespace: System.Data
  DNMergeFailedEventArgs = interface; // type: System.Data.MergeFailedEventArgs, namespace: System.Data
  DNOdbcInfoMessageEventArgs = interface; // type: System.Data.Odbc.OdbcInfoMessageEventArgs, namespace: System.Data.Odbc
  DNOleDbInfoMessageEventArgs = interface; // type: System.Data.OleDb.OleDbInfoMessageEventArgs, namespace: System.Data.OleDb
  DNSqlInfoMessageEventArgs = interface; // type: System.Data.SqlClient.SqlInfoMessageEventArgs, namespace: System.Data.SqlClient
  DNSqlNotificationEventArgs = interface; // type: System.Data.SqlClient.SqlNotificationEventArgs, namespace: System.Data.SqlClient
  DNSqlRowsCopiedEventArgs = interface; // type: System.Data.SqlClient.SqlRowsCopiedEventArgs, namespace: System.Data.SqlClient
  DNStateChangeEventArgs = interface; // type: System.Data.StateChangeEventArgs, namespace: System.Data
  DNStatementCompletedEventArgs = interface; // type: System.Data.StatementCompletedEventArgs, namespace: System.Data
  DNInvalidUdtException = interface; // type: Microsoft.SqlServer.Server.InvalidUdtException, namespace: Microsoft.SqlServer.Server
  DNDataException = interface; // type: System.Data.DataException, namespace: System.Data
  DNConstraintException = interface; // type: System.Data.ConstraintException, namespace: System.Data
  DNDeletedRowInaccessibleException = interface; // type: System.Data.DeletedRowInaccessibleException, namespace: System.Data
  DNDuplicateNameException = interface; // type: System.Data.DuplicateNameException, namespace: System.Data
  DNInRowChangingEventException = interface; // type: System.Data.InRowChangingEventException, namespace: System.Data
  DNInvalidConstraintException = interface; // type: System.Data.InvalidConstraintException, namespace: System.Data
  DNInvalidExpressionException = interface; // type: System.Data.InvalidExpressionException, namespace: System.Data
  DNEvaluateException = interface; // type: System.Data.EvaluateException, namespace: System.Data
  DNSyntaxErrorException = interface; // type: System.Data.SyntaxErrorException, namespace: System.Data
  DNMissingPrimaryKeyException = interface; // type: System.Data.MissingPrimaryKeyException, namespace: System.Data
  DNNoNullAllowedException = interface; // type: System.Data.NoNullAllowedException, namespace: System.Data
  DNReadOnlyException = interface; // type: System.Data.ReadOnlyException, namespace: System.Data
  DNRowNotInTableException = interface; // type: System.Data.RowNotInTableException, namespace: System.Data
  DNStrongTypingException = interface; // type: System.Data.StrongTypingException, namespace: System.Data
  DNTypedDataSetGeneratorException = interface; // type: System.Data.TypedDataSetGeneratorException, namespace: System.Data
  DNVersionNotFoundException = interface; // type: System.Data.VersionNotFoundException, namespace: System.Data
  DNDBConcurrencyException = interface; // type: System.Data.DBConcurrencyException, namespace: System.Data
  DNOperationAbortedException = interface; // type: System.Data.OperationAbortedException, namespace: System.Data
  DNSqlTypeException = interface; // type: System.Data.SqlTypes.SqlTypeException, namespace: System.Data.SqlTypes
  DNSqlAlreadyFilledException = interface; // type: System.Data.SqlTypes.SqlAlreadyFilledException, namespace: System.Data.SqlTypes
  DNSqlNotFilledException = interface; // type: System.Data.SqlTypes.SqlNotFilledException, namespace: System.Data.SqlTypes
  DNSqlNullValueException = interface; // type: System.Data.SqlTypes.SqlNullValueException, namespace: System.Data.SqlTypes
  DNSqlTruncateException = interface; // type: System.Data.SqlTypes.SqlTruncateException, namespace: System.Data.SqlTypes
  DNDbException = interface; // type: System.Data.Common.DbException, namespace: System.Data.Common
  DNOdbcException = interface; // type: System.Data.Odbc.OdbcException, namespace: System.Data.Odbc
  DNOleDbException = interface; // type: System.Data.OleDb.OleDbException, namespace: System.Data.OleDb
  DNSqlException = interface; // type: System.Data.SqlClient.SqlException, namespace: System.Data.SqlClient
  DNDataAdapter = interface; // type: System.Data.Common.DataAdapter, namespace: System.Data.Common
  DNDbDataAdapter = interface; // type: System.Data.Common.DbDataAdapter, namespace: System.Data.Common
  DNOdbcDataAdapter = interface; // type: System.Data.Odbc.OdbcDataAdapter, namespace: System.Data.Odbc
  DNOleDbDataAdapter = interface; // type: System.Data.OleDb.OleDbDataAdapter, namespace: System.Data.OleDb
  DNSqlDataAdapter = interface; // type: System.Data.SqlClient.SqlDataAdapter, namespace: System.Data.SqlClient
  DNDbCommand = interface; // type: System.Data.Common.DbCommand, namespace: System.Data.Common
  DNOdbcCommand = interface; // type: System.Data.Odbc.OdbcCommand, namespace: System.Data.Odbc
  DNOleDbCommand = interface; // type: System.Data.OleDb.OleDbCommand, namespace: System.Data.OleDb
  DNSqlCommand = interface; // type: System.Data.SqlClient.SqlCommand, namespace: System.Data.SqlClient
  DNDbCommandBuilder = interface; // type: System.Data.Common.DbCommandBuilder, namespace: System.Data.Common
  DNOdbcCommandBuilder = interface; // type: System.Data.Odbc.OdbcCommandBuilder, namespace: System.Data.Odbc
  DNOleDbCommandBuilder = interface; // type: System.Data.OleDb.OleDbCommandBuilder, namespace: System.Data.OleDb
  DNSqlCommandBuilder = interface; // type: System.Data.SqlClient.SqlCommandBuilder, namespace: System.Data.SqlClient
  DNDbConnection = interface; // type: System.Data.Common.DbConnection, namespace: System.Data.Common
  DNOdbcConnection = interface; // type: System.Data.Odbc.OdbcConnection, namespace: System.Data.Odbc
  DNOleDbConnection = interface; // type: System.Data.OleDb.OleDbConnection, namespace: System.Data.OleDb
  DNSqlConnection = interface; // type: System.Data.SqlClient.SqlConnection, namespace: System.Data.SqlClient
  DNDataColumnMapping = interface; // type: System.Data.Common.DataColumnMapping, namespace: System.Data.Common
  DNDataColumnMappingCollection = interface; // type: System.Data.Common.DataColumnMappingCollection, namespace: System.Data.Common
  DNDataTableMapping = interface; // type: System.Data.Common.DataTableMapping, namespace: System.Data.Common
  DNDataTableMappingCollection = interface; // type: System.Data.Common.DataTableMappingCollection, namespace: System.Data.Common
  DNDbDataReader = interface; // type: System.Data.Common.DbDataReader, namespace: System.Data.Common
  DNDataTableReader = interface; // type: System.Data.DataTableReader, namespace: System.Data
  DNOdbcDataReader = interface; // type: System.Data.Odbc.OdbcDataReader, namespace: System.Data.Odbc
  DNOleDbDataReader = interface; // type: System.Data.OleDb.OleDbDataReader, namespace: System.Data.OleDb
  DNSqlDataReader = interface; // type: System.Data.SqlClient.SqlDataReader, namespace: System.Data.SqlClient
  DNDbParameter = interface; // type: System.Data.Common.DbParameter, namespace: System.Data.Common
  DNOdbcParameter = interface; // type: System.Data.Odbc.OdbcParameter, namespace: System.Data.Odbc
  DNOleDbParameter = interface; // type: System.Data.OleDb.OleDbParameter, namespace: System.Data.OleDb
  DNSqlParameter = interface; // type: System.Data.SqlClient.SqlParameter, namespace: System.Data.SqlClient
  DNDbParameterCollection = interface; // type: System.Data.Common.DbParameterCollection, namespace: System.Data.Common
  DNOdbcParameterCollection = interface; // type: System.Data.Odbc.OdbcParameterCollection, namespace: System.Data.Odbc
  DNOleDbParameterCollection = interface; // type: System.Data.OleDb.OleDbParameterCollection, namespace: System.Data.OleDb
  DNSqlParameterCollection = interface; // type: System.Data.SqlClient.SqlParameterCollection, namespace: System.Data.SqlClient
  DNDbTransaction = interface; // type: System.Data.Common.DbTransaction, namespace: System.Data.Common
  DNOdbcTransaction = interface; // type: System.Data.Odbc.OdbcTransaction, namespace: System.Data.Odbc
  DNOleDbTransaction = interface; // type: System.Data.OleDb.OleDbTransaction, namespace: System.Data.OleDb
  DNSqlTransaction = interface; // type: System.Data.SqlClient.SqlTransaction, namespace: System.Data.SqlClient
  DNSqlFileStream = interface; // type: System.Data.SqlTypes.SqlFileStream, namespace: System.Data.SqlTypes
  DNDBDataPermission = interface; // type: System.Data.Common.DBDataPermission, namespace: System.Data.Common
  DNOdbcPermission = interface; // type: System.Data.Odbc.OdbcPermission, namespace: System.Data.Odbc
  DNOleDbPermission = interface; // type: System.Data.OleDb.OleDbPermission, namespace: System.Data.OleDb
  DNSqlClientPermission = interface; // type: System.Data.SqlClient.SqlClientPermission, namespace: System.Data.SqlClient
  DNSqlBinary = interface; // type: System.Data.SqlTypes.SqlBinary, namespace: System.Data.SqlTypes
  DNSqlBoolean = interface; // type: System.Data.SqlTypes.SqlBoolean, namespace: System.Data.SqlTypes
  DNSqlByte = interface; // type: System.Data.SqlTypes.SqlByte, namespace: System.Data.SqlTypes
  DNSqlDateTime = interface; // type: System.Data.SqlTypes.SqlDateTime, namespace: System.Data.SqlTypes
  DNSqlDecimal = interface; // type: System.Data.SqlTypes.SqlDecimal, namespace: System.Data.SqlTypes
  DNSqlDouble = interface; // type: System.Data.SqlTypes.SqlDouble, namespace: System.Data.SqlTypes
  DNSqlGuid = interface; // type: System.Data.SqlTypes.SqlGuid, namespace: System.Data.SqlTypes
  DNSqlInt16 = interface; // type: System.Data.SqlTypes.SqlInt16, namespace: System.Data.SqlTypes
  DNSqlInt32 = interface; // type: System.Data.SqlTypes.SqlInt32, namespace: System.Data.SqlTypes
  DNSqlInt64 = interface; // type: System.Data.SqlTypes.SqlInt64, namespace: System.Data.SqlTypes
  DNSqlMoney = interface; // type: System.Data.SqlTypes.SqlMoney, namespace: System.Data.SqlTypes
  DNSqlSingle = interface; // type: System.Data.SqlTypes.SqlSingle, namespace: System.Data.SqlTypes
  DNSqlString = interface; // type: System.Data.SqlTypes.SqlString, namespace: System.Data.SqlTypes
  DNDataSetSchemaImporterExtension = interface; // type: System.Data.DataSetSchemaImporterExtension, namespace: System.Data
  DNSqlTypesSchemaImporterExtensionHelper = interface; // type: System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper, namespace: System.Data.SqlTypes
  DNTypeBigIntSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeBigIntSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeBinarySchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeBinarySchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeBitSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeBitSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeCharSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeCharSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeDateTimeSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeDateTimeSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeDecimalSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeDecimalSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeFloatSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeFloatSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeIntSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeIntSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeMoneySchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeMoneySchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeNCharSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeNCharSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeNTextSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeNTextSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeNumericSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeNumericSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeNVarCharSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeNVarCharSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeRealSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeRealSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeSmallDateTimeSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeSmallDateTimeSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeSmallIntSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeSmallIntSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeSmallMoneySchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeSmallMoneySchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeTextSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeTextSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeTinyIntSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeTinyIntSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeUniqueIdentifierSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeUniqueIdentifierSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeVarBinarySchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeVarBinarySchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeVarCharSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeVarCharSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNTypeVarImageSchemaImporterExtension = interface; // type: System.Data.SqlTypes.TypeVarImageSchemaImporterExtension, namespace: System.Data.SqlTypes
  DNXmlDataDocument = interface; // type: System.Xml.XmlDataDocument, namespace: System.Xml

{ delegates }

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.DataTable.ColumnChanging" />
  ///  event.</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.DataColumnChangeEventHandler')]
  DNDataColumnChangeEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNDataColumnChangeEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.DataTable.RowChanging" />
  ///  , <see cref="E:System.Data.DataTable.RowChanged" />
  ///  , <see cref="E:System.Data.DataTable.RowDeleting" />
  ///  , and <see cref="E:System.Data.DataTable.RowDeleted" />
  ///  events of a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.DataRowChangeEventHandler')]
  DNDataRowChangeEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNDataRowChangeEventArgs) of object;

  ///<summary>Represents the method that handles the <see cref="M:System.Data.DataTable.Clear" />
  ///  method.</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" />
  ///  that contains the event data.</param>
  [DNTypeName('System.Data.DataTableClearEventHandler')]
  DNDataTableClearEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNDataTableClearEventArgs) of object;

  ///<summary>Represents the method that handles the <see cref="M:System.Data.DataTable.NewRow" />
  ///  method.</summary>
  ///  <param name="sender">The source of the event.</param>
  ///  <param name="e">A <see cref="T:System.Data.DataTableNewRowEventArgs" />
  ///  that contains the event data.</param>
  [DNTypeName('System.Data.DataTableNewRowEventHandler')]
  DNDataTableNewRowEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNDataTableNewRowEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.Common.DataAdapter.FillError" />
  ///  event.</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.FillErrorEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.FillErrorEventHandler')]
  DNFillErrorEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNFillErrorEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.DataSet.MergeFailed" />
  ///  event.</summary>
  ///  <param name="sender">The source of the event.</param>
  ///  <param name="e">The data for the event.</param>
  [DNTypeName('System.Data.MergeFailedEventHandler')]
  DNMergeFailedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNMergeFailedEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.Odbc.OdbcConnection.InfoMessage" />
  ///  event of an <see cref="T:System.Data.Odbc.OdbcConnection" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">An <see cref="T:System.Data.Odbc.OdbcInfoMessageEventArgs" />
  ///  object that contains the event data. </param>
  [DNTypeName('System.Data.Odbc.OdbcInfoMessageEventHandler')]
  DNOdbcInfoMessageEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNOdbcInfoMessageEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.Odbc.OdbcDataAdapter.RowUpdated" />
  ///  event of an <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.Odbc.OdbcRowUpdatedEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.Odbc.OdbcRowUpdatedEventHandler')]
  DNOdbcRowUpdatedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNOdbcRowUpdatedEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.Odbc.OdbcDataAdapter.RowUpdating" />
  ///  event of an <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.Odbc.OdbcRowUpdatingEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.Odbc.OdbcRowUpdatingEventHandler')]
  DNOdbcRowUpdatingEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNOdbcRowUpdatingEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.OleDb.OleDbConnection.InfoMessage" />
  ///  event of an <see cref="T:System.Data.OleDb.OleDbConnection" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">An <see cref="T:System.Data.OleDb.OleDbInfoMessageEventArgs" />
  ///  object that contains the event data. </param>
  [DNTypeName('System.Data.OleDb.OleDbInfoMessageEventHandler')]
  DNOleDbInfoMessageEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNOleDbInfoMessageEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.OleDb.OleDbDataAdapter.RowUpdated" />
  ///  event of an <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.OleDb.OleDbRowUpdatedEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.OleDb.OleDbRowUpdatedEventHandler')]
  DNOleDbRowUpdatedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNOleDbRowUpdatedEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.OleDb.OleDbDataAdapter.RowUpdating" />
  ///  event of an <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.OleDb.OleDbRowUpdatingEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.OleDb.OleDbRowUpdatingEventHandler')]
  DNOleDbRowUpdatingEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNOleDbRowUpdatingEventArgs) of object;

  ///<summary>Handles the <see cref="E:System.Data.SqlClient.SqlDependency.OnChange" />
  ///  event that is fired when a notification is received for any of the commands associated with a <see cref="T:System.Data.SqlClient.SqlDependency" />
  ///  object.</summary>
  ///  <param name="sender">The source of the event.</param>
  ///  <param name="e">A <see cref="T:System.Data.SqlClient.SqlNotificationEventArgs" />
  ///  object that contains the event data.</param>
  [DNTypeName('System.Data.SqlClient.OnChangeEventHandler')]
  DNOnChangeEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNSqlNotificationEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
  ///  event of a <see cref="T:System.Data.SqlClient.SqlConnection" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">A <see cref="T:System.Data.SqlClient.SqlInfoMessageEventArgs" />
  ///  object that contains the event data. </param>
  [DNTypeName('System.Data.SqlClient.SqlInfoMessageEventHandler')]
  DNSqlInfoMessageEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNSqlInfoMessageEventArgs) of object;

  ///<summary>Represents the method that handles the <see cref="E:System.Data.SqlClient.SqlBulkCopy.SqlRowsCopied" />
  ///  event of a <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">A <see cref="T:System.Data.SqlClient.SqlRowsCopiedEventArgs" />
  ///  object that contains the event data. </param>
  [DNTypeName('System.Data.SqlClient.SqlRowsCopiedEventHandler')]
  DNSqlRowsCopiedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNSqlRowsCopiedEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.SqlClient.SqlDataAdapter.RowUpdated" />
  ///  event of a <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.SqlClient.SqlRowUpdatedEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.SqlClient.SqlRowUpdatedEventHandler')]
  DNSqlRowUpdatedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNSqlRowUpdatedEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.SqlClient.SqlDataAdapter.RowUpdating" />
  ///  event of a <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.SqlClient.SqlRowUpdatingEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.SqlClient.SqlRowUpdatingEventHandler')]
  DNSqlRowUpdatingEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNSqlRowUpdatingEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Data.Common.DbConnection.StateChange" />
  ///  event.</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">The <see cref="T:System.Data.StateChangeEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Data.StateChangeEventHandler')]
  DNStateChangeEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNStateChangeEventArgs) of object;

  ///<summary>The delegate type for the event handlers of the <see cref="E:System.Data.SqlClient.SqlCommand.StatementCompleted" />
  ///  event.</summary>
  ///  <param name="sender">The source of the event.</param>
  ///  <param name="e">The data for the event.</param>
  [DNTypeName('System.Data.StatementCompletedEventHandler')]
  DNStatementCompletedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNStatementCompletedEventArgs) of object;




{ objects }

  //-------------namespace: Microsoft.SqlServer.Server----------------
  ///<summary>Provides custom implementation for user-defined type (UDT) and user-defined aggregate serialization and deserialization.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.IBinarySerialize')]
  DNIBinarySerialize = interface(DDN.mscorlib.DNObject)
  ['{EA2D75CA-B756-3302-8412-D2E681C6B978}']
  { methods } 

    ///<summary>Generates a user-defined type (UDT) or user-defined aggregate from its binary form.</summary>
    ///  <param name="r">The <see cref="T:System.IO.BinaryReader" />
    ///  stream from which the object is deserialized.</param>
    procedure Read(r: DDN.mscorlib.DNBinaryReader);
    ///<summary>Converts a user-defined type (UDT) or user-defined aggregate into its binary format so that it may be persisted.</summary>
    ///  <param name="w">The <see cref="T:System.IO.BinaryWriter" />
    ///  stream to which the UDT or user-defined aggregate is serialized.</param>
    procedure Write(w: DDN.mscorlib.DNBinaryWriter);

  end;

  //-------------namespace: System.Data----------------
  ///<summary>Contains a collection of DataColumnMapping objects, and is implemented by the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
  ///  , which is used in common by .NET Framework data providers.</summary>
  [DNTypeName('System.Data.IColumnMappingCollection')]
  DNIColumnMappingCollection = interface(DDN.mscorlib.DNIList)
  ['{FEC17537-6149-34F2-B91F-9FB3AF6B2546}']
  { getters & setters } 

    function get_Item(index: string): DDN.mscorlib.DNObject;
    procedure set_Item(index: string; value: DDN.mscorlib.DNObject);

  { methods } 

    ///<summary>Adds a ColumnMapping object to the ColumnMapping collection using the source column and <see cref="T:System.Data.DataSet" />
    ///  column names.</summary>
    ///  <param name="sourceColumnName">The case-sensitive name of the source column. </param>
    ///  <param name="dataSetColumnName">The name of the <see cref="T:System.Data.DataSet" />
    ///  column. </param>
    ///<returns>The ColumnMapping object that was added to the collection.</returns>
    function Add(sourceColumnName: string; dataSetColumnName: string): DNIColumnMapping;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  contains a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source column name.</summary>
    ///  <param name="sourceColumnName">The case-sensitive name of the source column. </param>
    ///<returns><see langword="true" />
    ///  if a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source column name exists, otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(sourceColumnName: string): Boolean;
    ///<summary>Gets the ColumnMapping object with the specified <see cref="T:System.Data.DataSet" />
    ///  column name.</summary>
    ///  <param name="dataSetColumnName">The name of the <see cref="T:System.Data.DataSet" />
    ///  column within the collection. </param>
    ///<returns>The ColumnMapping object with the specified <see langword="DataSet" />
    ///  column name.</returns>
    function GetByDataSetColumn(dataSetColumnName: string): DNIColumnMapping;
    ///<summary>Gets the location of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source column name. The name is case-sensitive.</summary>
    ///  <param name="sourceColumnName">The case-sensitive name of the source column. </param>
    ///<returns>The zero-based location of the <see langword="DataColumnMapping" />
    ///  object with the specified source column name.</returns>
    function IndexOf(sourceColumnName: string): Int32;
    ///<summary>Removes the <see cref="T:System.Data.IColumnMapping" />
    ///  object with the specified <see cref="P:System.Data.IColumnMapping.SourceColumn" />
    ///  name from the collection.</summary>
    ///  <param name="sourceColumnName">The case-sensitive <see langword="SourceColumn" />
    ///  name. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">A <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object does not exist with the specified <see langword="SourceColumn" />
    ///  name. </exception>
    procedure RemoveAt(sourceColumnName: string);

  { propertys } 

    property Item[index: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Collects all parameters relevant to a Command object and their mappings to <see cref="T:System.Data.DataSet" />
  ///  columns, and is implemented by .NET Framework data providers that access data sources.</summary>
  [DNTypeName('System.Data.IDataParameterCollection')]
  DNIDataParameterCollection = interface(DDN.mscorlib.DNIList)
  ['{B490F13C-7E82-3A54-A31E-DFA010A1AFFE}']
  { getters & setters } 

    function get_Item(parameterName: string): DDN.mscorlib.DNObject;
    procedure set_Item(parameterName: string; value: DDN.mscorlib.DNObject);

  { methods } 

    ///<summary>Gets a value indicating whether a parameter in the collection has the specified name.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///<returns><see langword="true" />
    ///  if the collection contains the parameter; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(parameterName: string): Boolean;
    ///<summary>Gets the location of the <see cref="T:System.Data.IDataParameter" />
    ///  within the collection.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///<returns>The zero-based location of the <see cref="T:System.Data.IDataParameter" />
    ///  within the collection.</returns>
    function IndexOf(parameterName: string): Int32;
    ///<summary>Removes the <see cref="T:System.Data.IDataParameter" />
    ///  from the collection.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    procedure RemoveAt(parameterName: string);

  { propertys } 

    property Item[parameterName: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Contains a collection of TableMapping objects, and is implemented by the <see cref="T:System.Data.Common.DataTableMappingCollection" />
  ///  , which is used in common by .NET Framework data providers.</summary>
  [DNTypeName('System.Data.ITableMappingCollection')]
  DNITableMappingCollection = interface(DDN.mscorlib.DNIList)
  ['{F11B7EBC-377D-3EF7-B126-CC26D43C2ED8}']
  { getters & setters } 

    function get_Item(index: string): DDN.mscorlib.DNObject;
    procedure set_Item(index: string; value: DDN.mscorlib.DNObject);

  { methods } 

    ///<summary>Adds a table mapping to the collection.</summary>
    ///  <param name="sourceTableName">The case-sensitive name of the source table. </param>
    ///  <param name="dataSetTableName">The name of the <see cref="T:System.Data.DataSet" />
    ///  table. </param>
    ///<returns>A reference to the newly-mapped <see cref="T:System.Data.ITableMapping" />
    ///  object.</returns>
    function Add(sourceTableName: string; dataSetTableName: string): DNITableMapping;
    ///<summary>Gets a value indicating whether the collection contains a table mapping with the specified source table name.</summary>
    ///  <param name="sourceTableName">The case-sensitive name of the source table. </param>
    ///<returns><see langword="true" />
    ///  if a table mapping with the specified source table name exists, otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(sourceTableName: string): Boolean;
    ///<summary>Gets the TableMapping object with the specified <see cref="T:System.Data.DataSet" />
    ///  table name.</summary>
    ///  <param name="dataSetTableName">The name of the <see langword="DataSet" />
    ///  table within the collection. </param>
    ///<returns>The TableMapping object with the specified <see langword="DataSet" />
    ///  table name.</returns>
    function GetByDataSetTable(dataSetTableName: string): DNITableMapping;
    ///<summary>Gets the location of the <see cref="T:System.Data.ITableMapping" />
    ///  object within the collection.</summary>
    ///  <param name="sourceTableName">The case-sensitive name of the source table. </param>
    ///<returns>The zero-based location of the <see cref="T:System.Data.ITableMapping" />
    ///  object within the collection.</returns>
    function IndexOf(sourceTableName: string): Int32;
    ///<summary>Removes the <see cref="T:System.Data.ITableMapping" />
    ///  object with the specified <see cref="P:System.Data.ITableMapping.SourceTable" />
    ///  name from the collection.</summary>
    ///  <param name="sourceTableName">The case-sensitive name of the <see langword="SourceTable" />
    ///  . </param>
    procedure RemoveAt(sourceTableName: string);

  { propertys } 

    property Item[index: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
  end;

  //-------------namespace: System.Data.Common----------------
  ///<summary>Generates a column schema.</summary>
  [DNTypeName('System.Data.Common.IDbColumnSchemaGenerator')]
  DNIDbColumnSchemaGenerator = interface(DDN.mscorlib.DNObject)
  ['{59AED2D8-A48C-3E29-AB58-F5400CDAF8F2}']
  { methods } 

    ///<summary>Gets the column schema (<see cref="T:System.Data.Common.DbColumn" />
    ///  collection).</summary>
    ///<returns>The column schema (<see cref="T:System.Data.Common.DbColumn" />
    ///  collection).</returns>
    function GetColumnSchema: DDN.mscorlib.DNReadOnlyCollection<DNDbColumn>;

  end;

  //-------------namespace: System.Data----------------
  ///<summary>Associates a data source column with a <see cref="T:System.Data.DataSet" />
  ///  column, and is implemented by the <see cref="T:System.Data.Common.DataColumnMapping" />
  ///  class, which is used in common by .NET Framework data providers.</summary>
  [DNTypeName('System.Data.IColumnMapping')]
  DNIColumnMapping = interface(DDN.mscorlib.DNObject)
  ['{7701EF45-1147-36B5-B474-23C21843AFC0}']
  { getters & setters } 

    function get_DataSetColumn: string;
    procedure set_DataSetColumn(value: string);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);

  { propertys } 

    ///<summary>Gets or sets the name of the column within the <see cref="T:System.Data.DataSet" />
    ///  to map to.</summary>
    ///<returns>The name of the column within the <see cref="T:System.Data.DataSet" />
    ///  to map to. The name is not case sensitive.</returns>
    property DataSetColumn: string read get_DataSetColumn write set_DataSetColumn;
    ///<summary>Gets or sets the name of the column within the data source to map from. The name is case-sensitive.</summary>
    ///<returns>The case-sensitive name of the column in the data source.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Allows an object to implement a DataAdapter, and represents a set of methods and mapping action-related properties that are used to fill and update a <see cref="T:System.Data.DataSet" />
  ///  and update a data source.
  ///<see cref="T:System.Data.IDbDataAdapter" />
  ///  instances are for data sources that are (or resemble) relational databases with textual commands (like Transact-SQL), while <see cref="T:System.Data.IDataAdapter" />
  ///  instances could can use any type of data source.</summary>
  [DNTypeName('System.Data.IDataAdapter')]
  DNIDataAdapter = interface(DDN.mscorlib.DNObject)
  ['{8883ACAD-6616-3F54-AD75-0BB5F0D85070}']
  { getters & setters } 

    function get_MissingMappingAction: DNMissingMappingAction;
    procedure set_MissingMappingAction(value: DNMissingMappingAction);
    function get_MissingSchemaAction: DNMissingSchemaAction;
    procedure set_MissingSchemaAction(value: DNMissingSchemaAction);
    function get_TableMappings: DNITableMappingCollection;

  { methods } 

    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  named "Table" to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  to be filled with the schema from the data source. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values. </param>
    ///<returns>An array of <see cref="T:System.Data.DataTable" />
    ///  objects that contain schema information returned from the data source.</returns>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType): TArray<DNDataTable>;
    ///<summary>Adds or updates rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  name, and creates a <see cref="T:System.Data.DataTable" />
    ///  named "Table".</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataSet: DNDataSet): Int32;
    ///<summary>Gets the parameters set by the user when executing an SQL SELECT statement.</summary>
    ///<returns>An array of <see cref="T:System.Data.IDataParameter" />
    ///  objects that contains the parameters set by the user.</returns>
    function GetFillParameters: TArray<DNIDataParameter>;
    ///<summary>Calls the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />
    ///  from a <see cref="T:System.Data.DataTable" />
    ///  named "Table".</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet): Int32;

  { propertys } 

    ///<summary>Indicates or specifies whether unmapped source tables or columns are passed with their source names in order to be filtered or to raise an error.</summary>
    ///<returns>One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. The default is <see langword="Passthrough" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value set is not one of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </exception>
    property MissingMappingAction: DNMissingMappingAction read get_MissingMappingAction write set_MissingMappingAction;
    ///<summary>Indicates or specifies whether missing source tables, columns, and their relationships are added to the dataset schema, ignored, or cause an error to be raised.</summary>
    ///<returns>One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. The default is <see langword="Add" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value set is not one of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </exception>
    property MissingSchemaAction: DNMissingSchemaAction read get_MissingSchemaAction write set_MissingSchemaAction;
    ///<summary>Indicates how a source table is mapped to a dataset table.</summary>
    ///<returns>A collection that provides the master mapping between the returned records and the <see cref="T:System.Data.DataSet" />
    ///  . The default value is an empty collection.</returns>
    property TableMappings: DNITableMappingCollection read get_TableMappings;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Represents a set of command-related properties that are used to fill the <see cref="T:System.Data.DataSet" />
  ///  and update a data source, and is implemented by .NET Framework data providers that access relational databases.</summary>
  [DNTypeName('System.Data.IDbDataAdapter')]
  DNIDbDataAdapter = interface(DNIDataAdapter)
  ['{FA46C6A3-7D70-3321-AAA3-148BDF7AB779}']
  { getters & setters } 

    function get_SelectCommand: DNIDbCommand;
    procedure set_SelectCommand(value: DNIDbCommand);
    function get_InsertCommand: DNIDbCommand;
    procedure set_InsertCommand(value: DNIDbCommand);
    function get_UpdateCommand: DNIDbCommand;
    procedure set_UpdateCommand(value: DNIDbCommand);
    function get_DeleteCommand: DNIDbCommand;
    procedure set_DeleteCommand(value: DNIDbCommand);

  { propertys } 

    ///<summary>Gets or sets an SQL statement used to select records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.IDbCommand" />
    ///  that is used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to select records from data source for placement in the data set.</returns>
    property SelectCommand: DNIDbCommand read get_SelectCommand write set_SelectCommand;
    ///<summary>Gets or sets an SQL statement used to insert new records into the data source.</summary>
    ///<returns>An <see cref="T:System.Data.IDbCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to insert records in the data source for new rows in the data set.</returns>
    property InsertCommand: DNIDbCommand read get_InsertCommand write set_InsertCommand;
    ///<summary>Gets or sets an SQL statement used to update records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.IDbCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to update records in the data source for modified rows in the data set.</returns>
    property UpdateCommand: DNIDbCommand read get_UpdateCommand write set_UpdateCommand;
    ///<summary>Gets or sets an SQL statement for deleting records from the data set.</summary>
    ///<returns>An <see cref="T:System.Data.IDbCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to delete records in the data source for deleted rows in the data set.</returns>
    property DeleteCommand: DNIDbCommand read get_DeleteCommand write set_DeleteCommand;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Represents a parameter to a Command object, and optionally, its mapping to <see cref="T:System.Data.DataSet" />
  ///  columns; and is implemented by .NET Framework data providers that access data sources.</summary>
  [DNTypeName('System.Data.IDataParameter')]
  DNIDataParameter = interface(DDN.mscorlib.DNObject)
  ['{DBAE8A91-BB4E-3E18-B45F-233C65FBDA2B}']
  { getters & setters } 

    function get_DbType: DNDbType;
    procedure set_DbType(value: DNDbType);
    function get_Direction: DNParameterDirection;
    procedure set_Direction(value: DNParameterDirection);
    function get_IsNullable: Boolean;
    function get_ParameterName: string;
    procedure set_ParameterName(value: string);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);
    function get_SourceVersion: DNDataRowVersion;
    procedure set_SourceVersion(value: DNDataRowVersion);
    function get_Value: DDN.mscorlib.DNObject;
    procedure set_Value(value: DDN.mscorlib.DNObject);

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.DbType" />
    ///  of the parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.DbType" />
    ///  values. The default is <see cref="F:System.Data.DbType.String" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The property was not set to a valid <see cref="T:System.Data.DbType" />
    ///  . </exception>
    property DbType: DNDbType read get_DbType write set_DbType;
    ///<summary>Gets or sets a value indicating whether the parameter is input-only, output-only, bidirectional, or a stored procedure return value parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. The default is <see langword="Input" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property was not set to one of the valid <see cref="T:System.Data.ParameterDirection" />
    ///  values. </exception>
    property Direction: DNParameterDirection read get_Direction write set_Direction;
    ///<summary>Gets a value indicating whether the parameter accepts null values.</summary>
    ///<returns><see langword="true" />
    ///  if null values are accepted; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable;
    ///<summary>Gets or sets the name of the <see cref="T:System.Data.IDataParameter" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.IDataParameter" />
    ///  . The default is an empty string.</returns>
    property ParameterName: string read get_ParameterName write set_ParameterName;
    ///<summary>Gets or sets the name of the source column that is mapped to the <see cref="T:System.Data.DataSet" />
    ///  and used for loading or returning the <see cref="P:System.Data.IDataParameter.Value" />
    ///  .</summary>
    ///<returns>The name of the source column that is mapped to the <see cref="T:System.Data.DataSet" />
    ///  . The default is an empty string.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
    ///<summary>Gets or sets the <see cref="T:System.Data.DataRowVersion" />
    ///  to use when loading <see cref="P:System.Data.IDataParameter.Value" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. The default is <see langword="Current" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property was not set one of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. </exception>
    property SourceVersion: DNDataRowVersion read get_SourceVersion write set_SourceVersion;
    ///<summary>Gets or sets the value of the parameter.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is the value of the parameter. The default value is null.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value write set_Value;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Used by the Visual Basic .NET Data Designers to represent a parameter to a Command object, and optionally, its mapping to <see cref="T:System.Data.DataSet" />
  ///  columns.</summary>
  [DNTypeName('System.Data.IDbDataParameter')]
  DNIDbDataParameter = interface(DNIDataParameter)
  ['{391E486C-97BE-3FD1-A26F-BC953AF9EF2D}']
  { getters & setters } 

    function get_Precision: Byte;
    procedure set_Precision(value: Byte);
    function get_Scale: Byte;
    procedure set_Scale(value: Byte);
    function get_Size: Int32;
    procedure set_Size(value: Int32);

  { propertys } 

    ///<summary>Indicates the precision of numeric parameters.</summary>
    ///<returns>The maximum number of digits used to represent the Value property of a data provider Parameter object. The default value is 0, which indicates that a data provider sets the precision for Value.</returns>
    property Precision: Byte read get_Precision write set_Precision;
    ///<summary>Indicates the scale of numeric parameters.</summary>
    ///<returns>The number of decimal places to which <see cref="T:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved. The default is 0.</returns>
    property Scale: Byte read get_Scale write set_Scale;
    ///<summary>The size of the parameter.</summary>
    ///<returns>The maximum size, in bytes, of the data within the column. The default value is inferred from the the parameter value.</returns>
    property Size: Int32 read get_Size write set_Size;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Provides access to the column values within each row for a <see langword="DataReader" />
  ///  , and is implemented by .NET Framework data providers that access relational databases.</summary>
  [DNTypeName('System.Data.IDataRecord')]
  DNIDataRecord = interface(DDN.mscorlib.DNObject)
  ['{6DAA5A9D-4EAC-3C24-B85C-794B4E65604D}']
  { getters & setters } 

    function get_FieldCount: Int32;
    function get_Item(i: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;

  { methods } 

    ///<summary>Gets the string value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The string value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetString(i: Int32): string;
    ///<summary>Return whether the specified field is set to null.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns><see langword="true" />
    ///  if the specified field is set to null; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function IsDBNull(i: Int32): Boolean;
    ///<summary>Gets the name for the field to find.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The name of the field or the empty string (""), if there is no value to return.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetName(i: Int32): string;
    ///<summary>Gets the data type information for the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The data type information for the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetDataTypeName(i: Int32): string;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  information corresponding to the type of <see cref="T:System.Object" />
    ///  that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />
    ///  .</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The <see cref="T:System.Type" />
    ///  information corresponding to the type of <see cref="T:System.Object" />
    ///  that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetFieldType(i: Int32): DDN.mscorlib.DNType;
    ///<summary>Return the value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The <see cref="T:System.Object" />
    ///  which will contain the field value upon return.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetValue(i: Int32): DDN.mscorlib.DNObject;
    ///<summary>Populates an array of objects with the column values of the current record.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  to copy the attribute fields into. </param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Return the index of the named field.</summary>
    ///  <param name="name">The name of the field to find. </param>
    ///<returns>The index of the named field.</returns>
    function GetOrdinal(name: string): Int32;
    ///<summary>Gets the value of the specified column as a Boolean.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetBoolean(i: Int32): Boolean;
    ///<summary>Gets the 8-bit unsigned integer value of the specified column.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The 8-bit unsigned integer value of the specified column.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetByte(i: Int32): Byte;
    ///<summary>Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///  <param name="fieldOffset">The index within the field from which to start the read operation. </param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferoffset">The index for <paramref name="buffer" />
    ///  to start the read operation. </param>
    ///  <param name="length">The number of bytes to read. </param>
    ///<returns>The actual number of bytes read.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetBytes(i: Int32; fieldOffset: Int64; buffer: TArray<Byte>; bufferoffset: Int32; length: Int32): Int64;
    ///<summary>Gets the character value of the specified column.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The character value of the specified column.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetChar(i: Int32): Char;
    ///<summary>Reads a stream of characters from the specified column offset into the buffer as an array, starting at the given buffer offset.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///  <param name="fieldoffset">The index within the row from which to start the read operation. </param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferoffset">The index for <paramref name="buffer" />
    ///  to start the read operation. </param>
    ///  <param name="length">The number of bytes to read. </param>
    ///<returns>The actual number of characters read.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetChars(i: Int32; fieldoffset: Int64; buffer: TArray<Char>; bufferoffset: Int32; length: Int32): Int64;
    ///<summary>Returns the GUID value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The GUID value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetGuid(i: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the 16-bit signed integer value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The 16-bit signed integer value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetInt16(i: Int32): Int16;
    ///<summary>Gets the 32-bit signed integer value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The 32-bit signed integer value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetInt32(i: Int32): Int32;
    ///<summary>Gets the 64-bit signed integer value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The 64-bit signed integer value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetInt64(i: Int32): Int64;
    ///<summary>Gets the single-precision floating point number of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The single-precision floating point number of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetFloat(i: Int32): Single;
    ///<summary>Gets the double-precision floating point number of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The double-precision floating point number of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetDouble(i: Int32): Double;
    ///<summary>Gets the fixed-position numeric value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The fixed-position numeric value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetDecimal(i: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the date and time data value of the specified field.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The date and time data value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetDateTime(i: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Returns an <see cref="T:System.Data.IDataReader" />
    ///  for the specified column ordinal.</summary>
    ///  <param name="i">The index of the field to find. </param>
    ///<returns>The <see cref="T:System.Data.IDataReader" />
    ///  for the specified column ordinal.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetData(i: Int32): DNIDataReader;

  { propertys } 

    ///<summary>Gets the number of columns in the current row.</summary>
    ///<returns>When not positioned in a valid recordset, 0; otherwise, the number of columns in the current record. The default is -1.</returns>
    property FieldCount: Int32 read get_FieldCount;
    property Item[i: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Associates a source table with a table in a <see cref="T:System.Data.DataSet" />
  ///  , and is implemented by the <see cref="T:System.Data.Common.DataTableMapping" />
  ///  class, which is used in common by .NET Framework data providers.</summary>
  [DNTypeName('System.Data.ITableMapping')]
  DNITableMapping = interface(DDN.mscorlib.DNObject)
  ['{7D6C1151-07C6-3BAE-A4CA-2505E8B9F92F}']
  { getters & setters } 

    function get_ColumnMappings: DNIColumnMappingCollection;
    function get_DataSetTable: string;
    procedure set_DataSetTable(value: string);
    function get_SourceTable: string;
    procedure set_SourceTable(value: string);

  { propertys } 

    ///<summary>Gets the derived <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  for the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A collection of data column mappings.</returns>
    property ColumnMappings: DNIColumnMappingCollection read get_ColumnMappings;
    ///<summary>Gets or sets the case-insensitive name of the table within the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>The case-insensitive name of the table within the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property DataSetTable: string read get_DataSetTable write set_DataSetTable;
    ///<summary>Gets or sets the case-sensitive name of the source table.</summary>
    ///<returns>The case-sensitive name of the source table.</returns>
    property SourceTable: string read get_SourceTable write set_SourceTable;
  end;

  //-------------namespace: System.Data.SqlTypes----------------
  ///<summary>All the <see cref="N:System.Data.SqlTypes" />
  ///  objects and structures implement the <see langword="INullable" />
  ///  interface. </summary>
  [DNTypeName('System.Data.SqlTypes.INullable')]
  DNINullable = interface(DDN.mscorlib.DNObject)
  ['{E7B3191E-CB93-3820-AB88-949781697507}']
  { getters & setters } 

    function get_IsNull: Boolean;

  { propertys } 

    ///<summary>Indicates whether a structure is null. This property is read-only.</summary>
    ///<returns><see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///<see langword="true" />
    ///  if the value of this object is null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Provides a means of reading one or more forward-only streams of result sets obtained by executing a command at a data source, and is implemented by .NET Framework data providers that access relational databases.</summary>
  [DNTypeName('System.Data.IDataReader')]
  DNIDataReader = interface(DDN.mscorlib.DNIDisposable)
  ['{EEF6063A-B303-370C-A350-20E70194F0B0}']
  { getters & setters } 

    function get_Depth: Int32;
    function get_IsClosed: Boolean;
    function get_RecordsAffected: Int32;

  { methods } 

    ///<summary>Closes the <see cref="T:System.Data.IDataReader" />
    ///  Object.</summary>
    procedure Close;
    ///<summary>Advances the <see cref="T:System.Data.IDataReader" />
    ///  to the next record.</summary>
    ///<returns><see langword="true" />
    ///  if there are more rows; otherwise, <see langword="false" />
    ///  .</returns>
    function Read: Boolean;
    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata of the <see cref="T:System.Data.IDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.IDataReader" />
    ///  is closed. </exception>
    function GetSchemaTable: DNDataTable;
    ///<summary>Advances the data reader to the next result, when reading the results of batch SQL statements.</summary>
    ///<returns><see langword="true" />
    ///  if there are more rows; otherwise, <see langword="false" />
    ///  .</returns>
    function NextResult: Boolean;

  { propertys } 

    ///<summary>Gets a value indicating the depth of nesting for the current row.</summary>
    ///<returns>The level of nesting.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets a value indicating whether the data reader is closed.</summary>
    ///<returns><see langword="true" />
    ///  if the data reader is closed; otherwise, <see langword="false" />
    ///  .</returns>
    property IsClosed: Boolean read get_IsClosed;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Represents an SQL statement that is executed while connected to a data source, and is implemented by .NET Framework data providers that access relational databases.</summary>
  [DNTypeName('System.Data.IDbCommand')]
  DNIDbCommand = interface(DDN.mscorlib.DNIDisposable)
  ['{E41AC658-7894-35BD-B768-0D4824CDD220}']
  { getters & setters } 

    function get_Connection: DNIDbConnection;
    procedure set_Connection(value: DNIDbConnection);
    function get_Transaction: DNIDbTransaction;
    procedure set_Transaction(value: DNIDbTransaction);
    function get_CommandText: string;
    procedure set_CommandText(value: string);
    function get_CommandTimeout: Int32;
    procedure set_CommandTimeout(value: Int32);
    function get_CommandType: DNCommandType;
    procedure set_CommandType(value: DNCommandType);
    function get_Parameters: DNIDataParameterCollection;
    function get_UpdatedRowSource: DNUpdateRowSource;
    procedure set_UpdatedRowSource(value: DNUpdateRowSource);

  { methods } 

    ///<summary>Creates a prepared (or compiled) version of the command on the data source.</summary>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  is not set.-or- The <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  is not <see cref="M:System.Data.OleDb.OleDbConnection.Open" />
    ///  . </exception>
    procedure Prepare;
    ///<summary>Attempts to cancels the execution of an <see cref="T:System.Data.IDbCommand" />
    ///  .</summary>
    procedure Cancel;
    ///<summary>Creates a new instance of an <see cref="T:System.Data.IDbDataParameter" />
    ///  object.</summary>
    ///<returns>An <see langword="IDbDataParameter" />
    ///  object.</returns>
    function CreateParameter: DNIDbDataParameter;
    ///<summary>Executes an SQL statement against the <see langword="Connection" />
    ///  object of a .NET Framework data provider, and returns the number of rows affected.</summary>
    ///<returns>The number of rows affected.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection does not exist.-or- The connection is not open. </exception>
    function ExecuteNonQuery: Int32;
    ///<summary>Executes the <see cref="P:System.Data.IDbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.IDbCommand.Connection" />
    ///  and builds an <see cref="T:System.Data.IDataReader" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Data.IDataReader" />
    ///  object.</returns>
    function ExecuteReader: DNIDataReader; overload;
    ///<summary>Executes the <see cref="P:System.Data.IDbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.IDbCommand.Connection" />
    ///  , and builds an <see cref="T:System.Data.IDataReader" />
    ///  using one of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values. </param>
    ///<returns>An <see cref="T:System.Data.IDataReader" />
    ///  object.</returns>
    function ExecuteReader(behavior: DNCommandBehavior): DNIDataReader; overload;
    ///<summary>Executes the query, and returns the first column of the first row in the resultset returned by the query. Extra columns or rows are ignored.</summary>
    ///<returns>The first column of the first row in the resultset.</returns>
    function ExecuteScalar: DDN.mscorlib.DNObject;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.IDbConnection" />
    ///  used by this instance of the <see cref="T:System.Data.IDbCommand" />
    ///  .</summary>
    ///<returns>The connection to the data source.</returns>
    property Connection: DNIDbConnection read get_Connection write set_Connection;
    ///<summary>Gets or sets the transaction within which the <see langword="Command" />
    ///  object of a .NET Framework data provider executes.</summary>
    ///<returns>the <see langword="Command" />
    ///  object of a .NET Framework data provider executes. The default value is <see langword="null" />
    ///  .</returns>
    property Transaction: DNIDbTransaction read get_Transaction write set_Transaction;
    ///<summary>Gets or sets the text command to run against the data source.</summary>
    ///<returns>The text command to execute. The default value is an empty string ("").</returns>
    property CommandText: string read get_CommandText write set_CommandText;
    ///<summary>Gets or sets the wait time before terminating the attempt to execute a command and generating an error.</summary>
    ///<returns>The time (in seconds) to wait for the command to execute. The default value is 30 seconds.</returns>
    ///<exception cref="T:System.ArgumentException">The property value assigned is less than 0. </exception>
    property CommandTimeout: Int32 read get_CommandTimeout write set_CommandTimeout;
    ///<summary>Indicates or specifies how the <see cref="P:System.Data.IDbCommand.CommandText" />
    ///  property is interpreted.</summary>
    ///<returns>One of the <see cref="T:System.Data.CommandType" />
    ///  values. The default is <see langword="Text" />
    ///  .</returns>
    property CommandType: DNCommandType read get_CommandType write set_CommandType;
    ///<summary>Gets the <see cref="T:System.Data.IDataParameterCollection" />
    ///  .</summary>
    ///<returns>The parameters of the SQL statement or stored procedure.</returns>
    property Parameters: DNIDataParameterCollection read get_Parameters;
    ///<summary>Gets or sets how command results are applied to the <see cref="T:System.Data.DataRow" />
    ///  when used by the <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
    ///  method of a <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values. The default is <see langword="Both" />
    ///  unless the command is automatically generated. Then the default is <see langword="None" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value entered was not one of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values. </exception>
    property UpdatedRowSource: DNUpdateRowSource read get_UpdatedRowSource write set_UpdatedRowSource;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Represents an open connection to a data source, and is implemented by .NET Framework data providers that access relational databases.</summary>
  [DNTypeName('System.Data.IDbConnection')]
  DNIDbConnection = interface(DDN.mscorlib.DNIDisposable)
  ['{9BB226F4-2AF3-37E7-B91D-3BB936FC0A7E}']
  { getters & setters } 

    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_ConnectionTimeout: Int32;
    function get_Database: string;
    function get_State: DNConnectionState;

  { methods } 

    ///<summary>Begins a database transaction.</summary>
    ///<returns>An object representing the new transaction.</returns>
    function BeginTransaction: DNIDbTransaction; overload;
    ///<summary>Begins a database transaction with the specified <see cref="T:System.Data.IsolationLevel" />
    ///  value.</summary>
    ///  <param name="il">One of the <see cref="T:System.Data.IsolationLevel" />
    ///  values. </param>
    ///<returns>An object representing the new transaction.</returns>
    function BeginTransaction(il: DNIsolationLevel): DNIDbTransaction; overload;
    ///<summary>Closes the connection to the database.</summary>
    procedure Close;
    ///<summary>Changes the current database for an open <see langword="Connection" />
    ///  object.</summary>
    ///  <param name="databaseName">The name of the database to use in place of the current database. </param>
    procedure ChangeDatabase(databaseName: string);
    ///<summary>Creates and returns a Command object associated with the connection.</summary>
    ///<returns>A Command object associated with the connection.</returns>
    function CreateCommand: DNIDbCommand;
    ///<summary>Opens a database connection with the settings specified by the <see langword="ConnectionString" />
    ///  property of the provider-specific Connection object.</summary>
    procedure Open;

  { propertys } 

    ///<summary>Gets or sets the string used to open a database.</summary>
    ///<returns>A string containing connection settings.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the time to wait while trying to establish a connection before terminating the attempt and generating an error.</summary>
    ///<returns>The time (in seconds) to wait for a connection to open. The default value is 15 seconds.</returns>
    property ConnectionTimeout: Int32 read get_ConnectionTimeout;
    ///<summary>Gets the name of the current database or the database to be used after a connection is opened.</summary>
    ///<returns>The name of the current database or the name of the database to be used once a connection is open. The default value is an empty string.</returns>
    property Database: string read get_Database;
    ///<summary>Gets the current state of the connection.</summary>
    ///<returns>One of the <see cref="T:System.Data.ConnectionState" />
    ///  values.</returns>
    property State: DNConnectionState read get_State;
  end;

  //-------------namespace: System.Data----------------
  ///<summary>Represents a transaction to be performed at a data source, and is implemented by .NET Framework data providers that access relational databases.</summary>
  [DNTypeName('System.Data.IDbTransaction')]
  DNIDbTransaction = interface(DDN.mscorlib.DNIDisposable)
  ['{62572DE3-DD0D-3763-9548-50665D013F6D}']
  { getters & setters } 

    function get_Connection: DNIDbConnection;
    function get_IsolationLevel: DNIsolationLevel;

  { methods } 

    ///<summary>Commits the database transaction.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Commit;
    ///<summary>Rolls back a transaction from a pending state.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Rollback;

  { propertys } 

    ///<summary>Specifies the Connection object to associate with the transaction.</summary>
    ///<returns>The Connection object to associate with the transaction.</returns>
    property Connection: DNIDbConnection read get_Connection;
    ///<summary>Specifies the <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction.</summary>
    ///<returns>The <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction. The default is <see langword="ReadCommitted" />
    ///  .</returns>
    property IsolationLevel: DNIsolationLevel read get_IsolationLevel;
  end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlContextClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F5151D93-8A81-5185-A0E6-94C7835798A6}']
  { static getter & setter } 

    {class} function get_IsAvailable: Boolean;
    {class} function get_Pipe: DNSqlPipe;
    {class} function get_TriggerContext: DNSqlTriggerContext;
    {class} function get_WindowsIdentity: DDN.mscorlib.DNWindowsIdentity;

  { static propertys } 

    ///<summary>Specifies whether the calling code is running within SQL Server, and if the context connection can be accessed.</summary>
    ///<returns><see langword="True" />
    ///  if the context connection is available and the other <see cref="T:Microsoft.SqlServer.Server.SqlContext" />
    ///  members can be accessed.</returns>
    {class} property IsAvailable: Boolean read get_IsAvailable;
    ///<summary>Gets the pipe object that allows the caller to send result sets, messages, and the results of executing commands back to the client.</summary>
    ///<returns>An instance of <see cref="T:Microsoft.SqlServer.Server.SqlPipe" />
    ///  if a pipe is available, or <see langword="null" />
    ///  if called in a context where pipe is not available (for example, in a user-defined function).</returns>
    {class} property Pipe: DNSqlPipe read get_Pipe;
    ///<summary>Gets the trigger context used to provide the caller with information about what caused the trigger to fire, and a map of the columns that were updated.</summary>
    ///<returns>An instance of <see cref="T:Microsoft.SqlServer.Server.SqlTriggerContext" />
    ///  if a trigger context is available, or <see langword="null" />
    ///  if called outside of a trigger invocation.</returns>
    {class} property TriggerContext: DNSqlTriggerContext read get_TriggerContext;
    ///<summary>The Microsoft Windows identity of the caller.</summary>
    ///<returns>A <see cref="T:System.Security.Principal.WindowsIdentity" />
    ///  instance representing the Windows identity of the caller, or <see langword="null" />
    ///  if the client was authenticated using SQL Server Authentication. </returns>
    {class} property WindowsIdentity: DDN.mscorlib.DNWindowsIdentity read get_WindowsIdentity;
  end;

  ///<summary>Represents an abstraction of the caller's context, which provides access to the <see cref="T:Microsoft.SqlServer.Server.SqlPipe" />
  ///  , <see cref="T:Microsoft.SqlServer.Server.SqlTriggerContext" />
  ///  , and <see cref="T:System.Security.Principal.WindowsIdentity" />
  ///  objects. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlContext')]
  DNSqlContext = interface(DDN.mscorlib.DNObject)
  ['{A9B3388F-A387-3F30-8443-3C83BE2525B1}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlContext = class(TDNGenericImport<DNSqlContextClass, DNSqlContext>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlDataRecordClass = interface(DNObjectClass)
  ['{D37A48F4-F7DD-5320-8C97-FD83B0606727}']
  { constructors } 

    ///<summary>Inititializes a new <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  instance with the schema based on the array of <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  objects passed as an argument.</summary>
    ///  <param name="metaData">An array of <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  objects that describe each column in the <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="metaData" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(metaData: TArray<DNSqlMetaData>): DNSqlDataRecord;

  end;

  ///<summary>Represents a single row of data and its metadata. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlDataRecord')]
  DNSqlDataRecord = interface(DNIDataRecord)
  ['{944E81B5-D1D9-34CE-9699-852F41DE654C}']
  { getters & setters } 

    function get_FieldCount: Int32;
    function get_Item(ordinal: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;

  { methods } 

    ///<summary>Returns the name of the column specified by the ordinal argument.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  containing the column name.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ). </exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetName(ordinal: Int32): string;
    ///<summary>Returns the name of the data type for the column specified by the ordinal argument.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the data type of the column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ). </exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetDataTypeName(ordinal: Int32): string;
    ///<summary>Returns a <see cref="T:System.Type" />
    ///  object representing the common language runtime (CLR) type that maps to the SQL Server type of the column specified by the <paramref name="ordinal" />
    ///  argument.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column type as a <see cref="T:System.Type" />
    ///  object.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ). </exception><exception cref="T:System.TypeLoadException">The column is of a user-defined type that is not available to the calling application domain.</exception><exception cref="T:System.IO.FileNotFoundException">The column is of a user-defined type that is not available to the calling application domain.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Returns the common language runtime (CLR) type value for the column specified by the ordinal argument.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The CLR type value of the column specified by the ordinal.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Returns the values for all the columns in the record, expressed as common language runtime (CLR) types, in an array.</summary>
    ///  <param name="values">The array into which to copy the values column values.</param>
    ///<returns>An <see cref="T:System.Int32" />
    ///  that indicates the number of columns copied.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="values" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Returns the column ordinal specified by the column name.</summary>
    ///  <param name="name">The name of the column to look up.</param>
    ///<returns>The zero-based ordinal of the column as an integer.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.IndexOutOfRangeException">The column name could not be found.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetOrdinal(name: string): Int32;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Boolean" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Boolean" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetBoolean(ordinal: Int32): Boolean;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Byte" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Byte" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetByte(ordinal: Int32): Byte;
    ///<summary>Gets the value for the column specified by the ordinal as an array of <see cref="T:System.Byte" />
    ///  objects.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="fieldOffset">The offset into the field value to start retrieving bytes.</param>
    ///  <param name="buffer">The target buffer to which to copy bytes.</param>
    ///  <param name="bufferOffset">The offset into the buffer to which to start copying bytes.</param>
    ///  <param name="length">The number of bytes to copy to the buffer.</param>
    ///<returns>The number of bytes copied.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetBytes(ordinal: Int32; fieldOffset: Int64; buffer: TArray<Byte>; bufferOffset: Int32; length: Int32): Int64;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Char" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Char" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetChar(ordinal: Int32): Char;
    ///<summary>Gets the value for the column specified by the ordinal as an array of <see cref="T:System.Char" />
    ///  objects.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="fieldOffset">The offset into the field value to start retrieving characters.</param>
    ///  <param name="buffer">The target buffer to copy chars to.</param>
    ///  <param name="bufferOffset">The offset into the buffer to start copying chars to.</param>
    ///  <param name="length">The number of chars to copy to the buffer.</param>
    ///<returns>The number of characters copied.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetChars(ordinal: Int32; fieldOffset: Int64; buffer: TArray<Char>; bufferOffset: Int32; length: Int32): Int64;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Guid" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Guid" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetGuid(ordinal: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Int16" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Int16" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetInt16(ordinal: Int32): Int16;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Int32" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Int32" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetInt32(ordinal: Int32): Int32;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Int64" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Int64" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetInt64(ordinal: Int32): Int64;
    ///<summary>Gets the value for the column specified by the ordinal as a <see langword="float" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see langword="float" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetFloat(ordinal: Int32): Single;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Double" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Double" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetDouble(ordinal: Int32): Double;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.String" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetString(ordinal: Int32): string;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Decimal" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Decimal" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetDecimal(ordinal: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.DateTime" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.DateTime" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.Data.SqlTypes.SqlNullValueException">The column specified by <paramref name="ordinal" />
    ///  is null.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetDateTime(ordinal: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Returns the specified column’s data as a <see cref="T:System.DateTimeOffset" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column as a <see cref="T:System.DateTimeOffset" />
    ///  .</returns>
    function GetDateTimeOffset(ordinal: Int32): DDN.mscorlib.DNDateTimeOffset;
    ///<summary>Returns the specified column’s data as a <see cref="T:System.TimeSpan" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column as a <see cref="T:System.TimeSpan" />
    ///  .</returns>
    function GetTimeSpan(ordinal: Int32): DDN.mscorlib.DNTimeSpan;
    ///<summary>Returns true if the column specified by the column ordinal parameter is null.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns><see langword="true" />
    ///  if the column is null; <see langword="false" />
    ///  otherwise.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    function IsDBNull(ordinal: Int32): Boolean;
    ///<summary>Returns a <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  object, describing the metadata of the column specified by the column ordinal.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column metadata as a <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  object.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlMetaData(ordinal: Int32): DNSqlMetaData;
    ///<summary>Returns a <see cref="T:System.Type" />
    ///  object that represents the type (as a SQL Server type, defined in <see cref="N:System.Data.SqlTypes" />
    ///  ) that maps to the SQL Server type of the column.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column type as a <see cref="T:System.Type" />
    ///  object.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ). </exception><exception cref="T:System.TypeLoadException">The column is of a user-defined type that is not available to the calling application domain.</exception><exception cref="T:System.IO.FileNotFoundException">The column is of a user-defined type that is not available to the calling application domain.</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Returns the data value stored in the column, expressed as a SQL Server type, specified by the column ordinal.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The value of the column, expressed as a SQL Server type, as a <see cref="T:System.Object" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Returns the values for all the columns in the record, expressed as SQL Server types, in an array.</summary>
    ///  <param name="values">The array into which to copy the values column values. </param>
    ///<returns>An <see cref="T:System.Int32" />
    ///  that indicates the number of columns copied.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="values" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlBinary(ordinal: Int32): DNSqlBinary;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlBytes(ordinal: Int32): DNSqlBytes;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlXml(ordinal: Int32): DNSqlXml;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlBoolean(ordinal: Int32): DNSqlBoolean;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlByte(ordinal: Int32): DNSqlByte;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlChars(ordinal: Int32): DNSqlChars;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlInt16(ordinal: Int32): DNSqlInt16;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlInt32(ordinal: Int32): DNSqlInt32;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlInt64(ordinal: Int32): DNSqlInt64;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlSingle(ordinal: Int32): DNSqlSingle;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlDouble(ordinal: Int32): DNSqlDouble;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlMoney(ordinal: Int32): DNSqlMoney;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlDateTime(ordinal: Int32): DNSqlDateTime;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlDecimal(ordinal: Int32): DNSqlDecimal;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlString(ordinal: Int32): DNSqlString;
    ///<summary>Gets the value for the column specified by the ordinal as a <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///<returns>The column value as a <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception><exception cref="T:System.InvalidCastException">There is a type mismatch.</exception>
    function GetSqlGuid(ordinal: Int32): DNSqlGuid;
    ///<summary>Sets new values for all of the columns in the <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  . These values are expressed as common language runtime (CLR) types.</summary>
    ///  <param name="values">The array of new values, expressed as CLR types boxed as <see cref="T:System.Object" />
    ///  references, for the <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  instance.</param>
    ///<returns>The number of column values set as an integer.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="values" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The size of values does not match the number of columns in the <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  instance.</exception>
    function SetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Sets a new value, expressed as a common language runtime (CLR) type, for the column specified by the column ordinal.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value for the specified column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetValue(ordinal: Int32; value: DDN.mscorlib.DNObject);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Boolean" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    procedure SetBoolean(ordinal: Int32; value: Boolean);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Byte" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetByte(ordinal: Int32; value: Byte);
    ///<summary>Sets the data stored in the column to the specified array of <see cref="T:System.Byte" />
    ///  values.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="fieldOffset">The offset into the field value to start copying bytes.</param>
    ///  <param name="buffer">The target buffer from which to copy bytes.</param>
    ///  <param name="bufferOffset">The offset into the buffer from which to start copying bytes.</param>
    ///  <param name="length">The number of bytes to copy from the buffer.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetBytes(ordinal: Int32; fieldOffset: Int64; buffer: TArray<Byte>; bufferOffset: Int32; length: Int32);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Char" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetChar(ordinal: Int32; value: Char);
    ///<summary>Sets the data stored in the column to the specified array of <see cref="T:System.Char" />
    ///  values.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="fieldOffset">The offset into the field value to start copying characters.</param>
    ///  <param name="buffer">The target buffer from which to copy chars.</param>
    ///  <param name="bufferOffset">The offset into the buffer from which to start copying chars.</param>
    ///  <param name="length">The number of chars to copy from the buffer.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetChars(ordinal: Int32; fieldOffset: Int64; buffer: TArray<Char>; bufferOffset: Int32; length: Int32);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Int16" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetInt16(ordinal: Int32; value: Int16);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Int32" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetInt32(ordinal: Int32; value: Int32);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Int64" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetInt64(ordinal: Int32; value: Int64);
    ///<summary>Sets the data stored in the column to the specified <see langword="float" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetFloat(ordinal: Int32; value: Single);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Double" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetDouble(ordinal: Int32; value: Double);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.String" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetString(ordinal: Int32; value: string);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Decimal" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetDecimal(ordinal: Int32; value: DDN.mscorlib.DNDecimal);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.DateTime" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetDateTime(ordinal: Int32; value: DDN.mscorlib.DNDateTime);
    ///<summary>Sets the value of the column specified to the <see cref="T:System.TimeSpan" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  passed in is a negative number.</exception><exception cref="T:System.ArgumentException">The <see cref="T:System.TimeSpan" />
    ///  value passed in is greater than 24 hours in length.</exception>
    procedure SetTimeSpan(ordinal: Int32; value: DDN.mscorlib.DNTimeSpan);
    ///<summary>Sets the value of the column specified to the <see cref="T:System.DateTimeOffset" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    procedure SetDateTimeOffset(ordinal: Int32; value: DDN.mscorlib.DNDateTimeOffset);
    ///<summary>Sets the value in the specified column to <see cref="T:System.DBNull" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    procedure SetDBNull(ordinal: Int32);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Guid" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetGuid(ordinal: Int32; value: DDN.mscorlib.DNGuid);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlBoolean(ordinal: Int32; value: DNSqlBoolean);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlByte(ordinal: Int32; value: DNSqlByte);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlInt16(ordinal: Int32; value: DNSqlInt16);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlInt32(ordinal: Int32; value: DNSqlInt32);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlInt64(ordinal: Int32; value: DNSqlInt64);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlSingle(ordinal: Int32; value: DNSqlSingle);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlDouble(ordinal: Int32; value: DNSqlDouble);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlMoney(ordinal: Int32; value: DNSqlMoney);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlDateTime(ordinal: Int32; value: DNSqlDateTime);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlXml(ordinal: Int32; value: DNSqlXml);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlDecimal(ordinal: Int32; value: DNSqlDecimal);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlString(ordinal: Int32; value: DNSqlString);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlBinary(ordinal: Int32; value: DNSqlBinary);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlGuid(ordinal: Int32; value: DNSqlGuid);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlChars(ordinal: Int32; value: DNSqlChars);
    ///<summary>Sets the data stored in the column to the specified <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  value.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column.</param>
    ///  <param name="value">The new value of the column.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="ordinal" />
    ///  is less than 0 or greater than the number of columns (that is, <see cref="P:Microsoft.SqlServer.Server.SqlDataRecord.FieldCount" />
    ///  ).</exception>
    procedure SetSqlBytes(ordinal: Int32; value: DNSqlBytes);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of columns in the data row. This property is read-only.</summary>
    ///<returns>The number of columns in the data row as an integer.</returns>
    property FieldCount: Int32 read get_FieldCount;
    property Item[ordinal: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
  end;

  TDNSqlDataRecord = class(TDNGenericImport<DNSqlDataRecordClass, DNSqlDataRecord>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlMetaDataClass = interface(DDN.mscorlib.DNObjectClass)
  ['{B737A9D2-6FFD-5BD8-94E0-A2D1A69D4541}']
  { static getter & setter } 

    {class} function get_Max: Int64;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name and type.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">A <see langword="SqlDbType" />
    ///  that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  .</exception>
    {class} function init(name: string; dbType: DNSqlDbType): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, and default server. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, and maximum length.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="maxLength">The maximum length of the specified type.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">A SqlDbType that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  .</exception>
    {class} function init(name: string; dbType: DNSqlDbType; maxLength: Int64): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, maximum length, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="maxLength">The maximum length of the specified type.</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; maxLength: Int64; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, and user-defined type (UDT).</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="userDefinedType">A <see cref="T:System.Type" />
    ///  instance that points to the UDT.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">A SqlDbType that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  , or <paramref name="userDefinedType" />
    ///  points to a type that does not have <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute" />
    ///  declared. </exception>
    {class} function init(name: string; dbType: DNSqlDbType; userDefinedType: DDN.mscorlib.DNType): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, user-defined type (UDT), and SQLServer type.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="userDefinedType">A <see cref="T:System.Type" />
    ///  instance that points to the UDT.</param>
    ///  <param name="serverTypeName">The SQL Server type name for <paramref name="userDefinedType" />
    ///  .</param>
    {class} function init(name: string; dbType: DNSqlDbType; userDefinedType: DDN.mscorlib.DNType; serverTypeName: string): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, user-defined type, SQL Server type, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="userDefinedType">A <see cref="T:System.Type" />
    ///  instance that points to the UDT.</param>
    ///  <param name="serverTypeName">The SQL Server type name for <paramref name="userDefinedType" />
    ///  .</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; userDefinedType: DDN.mscorlib.DNType; serverTypeName: string; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, precision, and scale.</summary>
    ///  <param name="name">The name of the parameter or column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="precision">The precision of the parameter or column.</param>
    ///  <param name="scale">The scale of the parameter or column.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">A <see langword="SqlDbType" />
    ///  that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  , or <paramref name="scale" />
    ///  was greater than <paramref name="precision" />
    ///  . </exception>
    {class} function init(name: string; dbType: DNSqlDbType; precision: Byte; scale: Byte): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, precision, scale, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="precision">The precision of the parameter or column.</param>
    ///  <param name="scale">The scale of the parameter or column.</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; precision: Byte; scale: Byte; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, maximum length, locale, and compare options.</summary>
    ///  <param name="name">The name of the parameter or column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="maxLength">The maximum length of the specified type. </param>
    ///  <param name="locale">The locale ID of the parameter or column.</param>
    ///  <param name="compareOptions">The comparison rules of the parameter or column.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">A SqlDbType that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  .</exception>
    {class} function init(name: string; dbType: DNSqlDbType; maxLength: Int64; locale: Int64; compareOptions: DNSqlCompareOptions): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, maximum length, locale, compare options, and server default. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="maxLength">The maximum length of the specified type.</param>
    ///  <param name="locale">The locale ID of the parameter or column.</param>
    ///  <param name="compareOptions">The comparison rules of the parameter or column.</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; maxLength: Int64; locale: Int64; compareOptions: DNSqlCompareOptions; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, database name, owning schema, object name, and default server. This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="database">The database name of the XML schema collection of a typed XML instance.</param>
    ///  <param name="owningSchema">The relational schema name of the XML schema collection of a typed XML instance.</param>
    ///  <param name="objectName">The name of the XML schema collection of a typed XML instance.</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; database: string; owningSchema: string; objectName: string; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, maximum length, precision, scale, locale ID, compare options, and user-defined type (UDT).</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="maxLength">The maximum length of the specified type.</param>
    ///  <param name="precision">The precision of the parameter or column.</param>
    ///  <param name="scale">The scale of the parameter or column.</param>
    ///  <param name="locale">The locale ID of the parameter or column.</param>
    ///  <param name="compareOptions">The comparison rules of the parameter or column.</param>
    ///  <param name="userDefinedType">A <see cref="T:System.Type" />
    ///  instance that points to the UDT.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">A <see langword="SqlDbType" />
    ///  that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  , or <paramref name="userDefinedType" />
    ///  points to a type that does not have <see cref="T:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute" />
    ///  declared.</exception>
    {class} function init(name: string; dbType: DNSqlDbType; maxLength: Int64; precision: Byte; scale: Byte; locale: Int64; compareOptions: DNSqlCompareOptions; userDefinedType: DDN.mscorlib.DNType): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, maximum length, precision, scale, locale ID, compare options, and user-defined type (UDT). This form of the constructor supports table-valued parameters by allowing you to specify if the column is unique in the table-valued parameter, the sort order for the column, and the ordinal of the sort column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="maxLength">The maximum length of the specified type.</param>
    ///  <param name="precision">The precision of the parameter or column.</param>
    ///  <param name="scale">The scale of the parameter or column.</param>
    ///  <param name="localeId">The locale ID of the parameter or column.</param>
    ///  <param name="compareOptions">The comparison rules of the parameter or column.</param>
    ///  <param name="userDefinedType">A <see cref="T:System.Type" />
    ///  instance that points to the UDT.</param>
    ///  <param name="useServerDefault">Specifes whether this column should use the default server value.</param>
    ///  <param name="isUniqueKey">Specifies if the column in the table-valued parameter is unique.</param>
    ///  <param name="columnSortOrder">Specifies the sort order for a column.</param>
    ///  <param name="sortOrdinal">Specifies the ordinal of the sort column.</param>
    {class} function init(name: string; dbType: DNSqlDbType; maxLength: Int64; precision: Byte; scale: Byte; localeId: Int64; compareOptions: DNSqlCompareOptions; userDefinedType: DDN.mscorlib.DNType; useServerDefault: Boolean; isUniqueKey: Boolean; columnSortOrder: DNSortOrder; sortOrdinal: Int32): DNSqlMetaData; overload;
    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  class with the specified column name, type, database name, owning schema, and object name.</summary>
    ///  <param name="name">The name of the column.</param>
    ///  <param name="dbType">The SQL Server type of the parameter or column.</param>
    ///  <param name="database">The database name of the XML schema collection of a typed XML instance.</param>
    ///  <param name="owningSchema">The relational schema name of the XML schema collection of a typed XML instance.</param>
    ///  <param name="objectName">The name of the XML schema collection of a typed XML instance.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="Name" />
    ///  is <see langword="null" />
    ///  , or <paramref name="objectName" />
    ///  is <see langword="null" />
    ///  when <paramref name="database" />
    ///  and <paramref name="owningSchema" />
    ///  are non-<see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">A SqlDbType that is not allowed was passed to the constructor as <paramref name="dbType" />
    ///  .</exception>
    {class} function init(name: string; dbType: DNSqlDbType; database: string; owningSchema: string; objectName: string): DNSqlMetaData; overload;

  { static methods } 

    ///<summary>Infers the metadata from the specified object and returns it as a <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</summary>
    ///  <param name="value">The object used from which the metadata is inferred.</param>
    ///  <param name="name">The name assigned to the returned <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The inferred metadata as a <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</returns>
    ///<exception cref="T:System.ArgumentNullException">The v<paramref name="alue" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function InferFromValue(value: DDN.mscorlib.DNObject; name: string): DNSqlMetaData;

  { static propertys } 

    ///<summary>Gets the length of <see langword="text" />
    ///  , <see langword="ntext" />
    ///  , and <see langword="image" />
    ///  data types. </summary>
    ///<returns>The length of <see langword="text" />
    ///  , <see langword="ntext" />
    ///  , and <see langword="image" />
    ///  data types.</returns>
    {class} property Max: Int64 read get_Max;
  end;

  ///<summary>Specifies and retrieves metadata information from parameters and columns of <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
  ///  objects. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlMetaData')]
  DNSqlMetaData = interface(DDN.mscorlib.DNObject)
  ['{93BB05EB-6510-36A9-B10B-801D513F1524}']
  { getters & setters } 

    function get_CompareOptions: DNSqlCompareOptions;
    function get_DbType: DNDbType;
    function get_IsUniqueKey: Boolean;
    function get_LocaleId: Int64;
    function get_MaxLength: Int64;
    function get_Name: string;
    function get_Precision: Byte;
    function get_Scale: Byte;
    function get_SortOrder: DNSortOrder;
    function get_SortOrdinal: Int32;
    function get_SqlDbType: DNSqlDbType;
    function get_Type: DDN.mscorlib.DNType;
    function get_TypeName: string;
    function get_UseServerDefault: Boolean;
    function get_XmlSchemaCollectionDatabase: string;
    function get_XmlSchemaCollectionName: string;
    function get_XmlSchemaCollectionOwningSchema: string;

  { methods } 

    ///<summary>Validates the specified <see cref="T:System.Int16" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Int16" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Int16): Int16; overload;
    ///<summary>Validates the specified <see cref="T:System.Int32" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Int32" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Int32): Int32; overload;
    ///<summary>Validates the specified <see cref="T:System.Int64" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Int64" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Int64): Int64; overload;
    ///<summary>Validates the specified <see cref="T:System.Single" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Single" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Single): Single; overload;
    ///<summary>Validates the specified <see cref="T:System.Double" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Double" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Double): Double; overload;
    ///<summary>Validates the specified <see cref="T:System.String" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.String" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: string): string; overload;
    ///<summary>Validates the specified <see cref="T:System.DateTime" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.DateTime" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DDN.mscorlib.DNDateTime): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Validates the specified <see cref="T:System.Guid" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Guid" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DDN.mscorlib.DNGuid): DDN.mscorlib.DNGuid; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlBoolean): DNSqlBoolean; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlByte): DNSqlByte; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlInt16): DNSqlInt16; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlInt32): DNSqlInt32; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlInt64): DNSqlInt64; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlSingle): DNSqlSingle; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlDouble): DNSqlDouble; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlDateTime): DNSqlDateTime; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlString): DNSqlString; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlGuid): DNSqlGuid; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlXml): DNSqlXml; overload;
    ///<summary>Validates the specified <see cref="T:System.TimeSpan" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as an array of <see cref="T:System.TimeSpan" />
    ///  values.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DDN.mscorlib.DNTimeSpan): DDN.mscorlib.DNTimeSpan; overload;
    ///<summary>Validates the specified <see cref="T:System.DateTimeOffset" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as an array of <see cref="T:System.DateTimeOffset" />
    ///  values.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DDN.mscorlib.DNDateTimeOffset): DDN.mscorlib.DNDateTimeOffset; overload;
    ///<summary>Validates the specified <see cref="T:System.Boolean" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Boolean" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Boolean): Boolean; overload;
    ///<summary>Validates the specified <see cref="T:System.Byte" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Byte" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Byte): Byte; overload;
    ///<summary>Validates the specified <see cref="T:System.Char" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Char" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: Char): Char; overload;
    ///<summary>Validates the specified <see cref="T:System.Decimal" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Decimal" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DDN.mscorlib.DNDecimal): DDN.mscorlib.DNDecimal; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlMoney): DNSqlMoney; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlDecimal): DNSqlDecimal; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlBinary): DNSqlBinary; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlChars): DNSqlChars; overload;
    ///<summary>Validates the specified <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DNSqlBytes): DNSqlBytes; overload;
    ///<summary>Validates the specified <see cref="T:System.Object" />
    ///  value against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as a <see cref="T:System.Object" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: DDN.mscorlib.DNObject): DDN.mscorlib.DNObject; overload;
    ///<summary>Validates the specified array of <see cref="T:System.Byte" />
    ///  values against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as an array of <see cref="T:System.Byte" />
    ///  values.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>Validates the specified array of <see cref="T:System.Char" />
    ///  values against the metadata, and adjusts the value if necessary.</summary>
    ///  <param name="value">The value to validate against the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  instance.</param>
    ///<returns>The adjusted value as an array <see cref="T:System.Char" />
    ///  values.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="Value" />
    ///  does not match the <see cref="T:Microsoft.SqlServer.Server.SqlMetaData" />
    ///  type, or <paramref name="value" />
    ///  could not be adjusted. </exception>
    function Adjust(value: TArray<Char>): TArray<Char>; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the comparison rules used for the column or parameter.</summary>
    ///<returns>The comparison rules used for the column or parameter as a <see cref="T:System.Data.SqlTypes.SqlCompareOptions" />
    ///  .</returns>
    property CompareOptions: DNSqlCompareOptions read get_CompareOptions;
    ///<summary>Gets the data type of the column or parameter.</summary>
    ///<returns>The data type of the column or parameter as a <see cref="T:System.Data.DbType" />
    ///  .</returns>
    property DbType: DNDbType read get_DbType;
    ///<summary>Indicates if the column in the table-valued parameter is unique.</summary>
    ///<returns>A <see langword="Boolean" />
    ///  value.</returns>
    property IsUniqueKey: Boolean read get_IsUniqueKey;
    ///<summary>Gets the locale ID of the column or parameter.</summary>
    ///<returns>The locale ID of the column or parameter as a <see cref="T:System.Int64" />
    ///  .</returns>
    property LocaleId: Int64 read get_LocaleId;
    ///<summary>Gets the maximum length of the column or parameter.</summary>
    ///<returns>The maximum length of the column or parameter as a <see cref="T:System.Int64" />
    ///  .</returns>
    property MaxLength: Int64 read get_MaxLength;
    ///<summary>Gets the name of the column or parameter.</summary>
    ///<returns>The name of the column or parameter as a <see cref="T:System.String" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The <paramref name="Name" />
    ///  specified in the constructor is longer than 128 characters. </exception>
    property Name: string read get_Name;
    ///<summary>Gets the precision of the column or parameter.</summary>
    ///<returns>The precision of the column or parameter as a <see cref="T:System.Byte" />
    ///  .</returns>
    property Precision: Byte read get_Precision;
    ///<summary>Gets the scale of the column or parameter.</summary>
    ///<returns>The scale of the column or parameter.</returns>
    property Scale: Byte read get_Scale;
    ///<summary>Returns the sort order for a column.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SortOrder" />
    ///  object.</returns>
    property SortOrder: DNSortOrder read get_SortOrder;
    ///<summary>Returns the ordinal of the sort column.</summary>
    ///<returns>The ordinal of the sort column.</returns>
    property SortOrdinal: Int32 read get_SortOrdinal;
    ///<summary>Gets the data type of the column or parameter.</summary>
    ///<returns>The data type of the column or parameter as a <see cref="T:System.Data.DbType" />
    ///  .</returns>
    property SqlDbType: DNSqlDbType read get_SqlDbType;
    ///<summary>Gets the common language runtime (CLR) type of a user-defined type (UDT).</summary>
    ///<returns>The CLR type name of a user-defined type as a <see cref="T:System.Type" />
    ///  .</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets the three-part name of the user-defined type (UDT) or the SQL Server type represented by the instance.</summary>
    ///<returns>The name of the UDT or SQL Server type as a <see cref="T:System.String" />
    ///  .</returns>
    property TypeName: string read get_TypeName;
    ///<summary>Reports whether this column should use the default server value.</summary>
    ///<returns>A <see langword="Boolean" />
    ///  value.</returns>
    property UseServerDefault: Boolean read get_UseServerDefault;
    ///<summary>Gets the name of the database where the schema collection for this XML instance is located.</summary>
    ///<returns>The name of the database where the schema collection for this XML instance is located as a <see cref="T:System.String" />
    ///  .</returns>
    property XmlSchemaCollectionDatabase: string read get_XmlSchemaCollectionDatabase;
    ///<summary>Gets the name of the schema collection for this XML instance.</summary>
    ///<returns>The name of the schema collection for this XML instance as a <see cref="T:System.String" />
    ///  .</returns>
    property XmlSchemaCollectionName: string read get_XmlSchemaCollectionName;
    ///<summary>Gets the owning relational schema where the schema collection for this XML instance is located.</summary>
    ///<returns>The owning relational schema where the schema collection for this XML instance is located as a <see cref="T:System.String" />
    ///  .</returns>
    property XmlSchemaCollectionOwningSchema: string read get_XmlSchemaCollectionOwningSchema;
  end;

  TDNSqlMetaData = class(TDNGenericImport<DNSqlMetaDataClass, DNSqlMetaData>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlPipeClass = interface(DDN.mscorlib.DNObjectClass)
  ['{AF188E4D-18E8-50E7-AE95-68B49677CF01}']
  end;

  ///<summary>Allows managed stored procedures running in-process on a SQL Server database to return results back to the caller. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlPipe')]
  DNSqlPipe = interface(DDN.mscorlib.DNObject)
  ['{6F724A5D-98E1-3E92-B08A-4E37785768CD}']
  { getters & setters } 

    function get_IsSendingResults: Boolean;

  { methods } 

    ///<summary>Marks the end of a result set, and returns the <see cref="T:Microsoft.SqlServer.Server.SqlPipe" />
    ///  instance back to the initial state.</summary>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
    ///  method was not previously called.</exception>
    procedure SendResultsEnd;
    ///<summary>Executes the command passed as a parameter and sends the results to the client.</summary>
    ///  <param name="command">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object to be executed.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="command" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.InvalidOperationException">This method is not supported on commands bound to out-of-process connections.</exception>
    procedure ExecuteAndSend(command: DNSqlCommand);
    ///<summary>Sends a string message directly to the client or current output consumer.</summary>
    ///  <param name="message">The message string to be sent to the client.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="message" />
    ///  is greater than 4,000 characters.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="message" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure Send(message: string); overload;
    ///<summary>Sends a multirow result set directly to the client or current output consumer.</summary>
    ///  <param name="reader">The multirow result set to be sent to the client: a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  object.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="reader" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure Send(reader: DNSqlDataReader); overload;
    ///<summary>Sends a single-row result set directly to the client or current output consumer.</summary>
    ///  <param name="record">The single-row result set sent to the client: a <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  object.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="record" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure Send(&record: DNSqlDataRecord); overload;
    ///<summary>Marks the beginning of a result set to be sent back to the client, and uses the record parameter to construct the metadata that describes the result set.</summary>
    ///  <param name="record">A <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  object from which metadata is extracted and used to describe the result set.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="record" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The <paramref name="record" />
    ///  has no columns or has not been initialized.</exception><exception cref="T:System.InvalidOperationException">A method other than <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsRow(Microsoft.SqlServer.Server.SqlDataRecord)" />
    ///  or <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsEnd" />
    ///  was called after the <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
    ///  method.</exception>
    procedure SendResultsStart(&record: DNSqlDataRecord);
    ///<summary>Sends a single row of data back to the client.</summary>
    ///  <param name="record">A <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  object with the column values for the row to be sent to the client. The schema for the record must match the schema described by the metadata of the <see cref="T:Microsoft.SqlServer.Server.SqlDataRecord" />
    ///  passed to the <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
    ///  method.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="record" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.InvalidOperationException">The <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
    ///  method was not previously called.</exception>
    procedure SendResultsRow(&record: DNSqlDataRecord);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates whether the <see cref="T:Microsoft.SqlServer.Server.SqlPipe" />
    ///  is in the mode of sending single result sets back to the client. This property is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="M:Microsoft.SqlServer.Server.SqlPipe.SendResultsStart(Microsoft.SqlServer.Server.SqlDataRecord)" />
    ///  method has been called and the <see cref="T:Microsoft.SqlServer.Server.SqlPipe" />
    ///  is in the mode of sending single result sets back to the client; otherwise <see langword="false" />
    ///  .</returns>
    property IsSendingResults: Boolean read get_IsSendingResults;
  end;

  TDNSqlPipe = class(TDNGenericImport<DNSqlPipeClass, DNSqlPipe>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlTriggerContextClass = interface(DDN.mscorlib.DNObjectClass)
  ['{3083F524-CEBE-5A76-B4C9-AD7F7D41EEDB}']
  end;

  ///<summary>Provides contextual information about the trigger that was fired. </summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlTriggerContext')]
  DNSqlTriggerContext = interface(DDN.mscorlib.DNObject)
  ['{02C97B74-F42B-3EA2-956A-1D01A773F21A}']
  { getters & setters } 

    function get_ColumnCount: Int32;
    function get_EventData: DNSqlXml;
    function get_TriggerAction: DNTriggerAction;

  { methods } 

    ///<summary>Returns <see langword="true" />
    ///  if a column was affected by an INSERT or UPDATE statement.</summary>
    ///  <param name="columnOrdinal">The zero-based ordinal of the column.</param>
    ///<returns><see langword="true" />
    ///  if the column was affected by an INSERT or UPDATE operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Called in the context of a trigger where the value of the <see cref="P:Microsoft.SqlServer.Server.SqlTriggerContext.TriggerAction" />
    ///  property is not <see langword="Insert" />
    ///  or <see langword="Update" />
    ///  .</exception>
    function IsUpdatedColumn(columnOrdinal: Int32): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of columns contained by the data table bound to the trigger. This property is read-only.</summary>
    ///<returns>The number of columns contained by the data table bound to the trigger, as an integer. </returns>
    property ColumnCount: Int32 read get_ColumnCount;
    ///<summary>Gets the event data specific to the action that fired the trigger.</summary>
    ///<returns>The event data specific to the action that fired the trigger as a <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  if more information is available; <see langword="null" />
    ///  otherwise.</returns>
    property EventData: DNSqlXml read get_EventData;
    ///<summary>Indicates what action fired the trigger.</summary>
    ///<returns>The action that fired the trigger as a <see cref="T:Microsoft.SqlServer.Server.TriggerAction" />
    ///  .</returns>
    property TriggerAction: DNTriggerAction read get_TriggerAction;
  end;

  TDNSqlTriggerContext = class(TDNGenericImport<DNSqlTriggerContextClass, DNSqlTriggerContext>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlFacetAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{E465348B-C8B9-5F0A-95BF-45B83AE919E7}']
  { constructors } 

    ///<summary>An optional attribute on a user-defined type (UDT) return type, used to annotate the returned result with additional information that can be used in Transact-SQL.</summary>
    {class} function init: DNSqlFacetAttribute;

  end;

  ///<summary>Annotates the returned result of a user-defined type (UDT) with additional information that can be used in Transact-SQL.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlFacetAttribute')]
  DNSqlFacetAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{CCF90767-1E51-33CD-9616-9C98FA0C1692}']
  { getters & setters } 

    function get_IsFixedLength: Boolean;
    procedure set_IsFixedLength(value: Boolean);
    function get_MaxSize: Int32;
    procedure set_MaxSize(value: Int32);
    function get_Precision: Int32;
    procedure set_Precision(value: Int32);
    function get_Scale: Int32;
    procedure set_Scale(value: Int32);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates whether the return type of the user-defined type is of a fixed length.</summary>
    ///<returns><see langword="true" />
    ///  if the return type is of a fixed length; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedLength: Boolean read get_IsFixedLength write set_IsFixedLength;
    ///<summary>The maximum size, in logical units, of the underlying field type of the user-defined type.</summary>
    ///<returns>An <see cref="T:System.Int32" />
    ///  representing the maximum size, in logical units, of the underlying field type.</returns>
    property MaxSize: Int32 read get_MaxSize write set_MaxSize;
    ///<summary>The precision of the return type of the user-defined type.</summary>
    ///<returns>An <see cref="T:System.Int32" />
    ///  representing the precision of the return type.</returns>
    property Precision: Int32 read get_Precision write set_Precision;
    ///<summary>The scale of the return type of the user-defined type.</summary>
    ///<returns>An <see cref="T:System.Int32" />
    ///  representing the scale of the return type.</returns>
    property Scale: Int32 read get_Scale write set_Scale;
    ///<summary>Indicates whether the return type of the user-defined type can be <see langword="null" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the return type of the user-defined type can be <see langword="null" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlFacetAttribute = class(TDNGenericImport<DNSqlFacetAttributeClass, DNSqlFacetAttribute>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlFunctionAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{464EB31E-B1AD-59E4-BB87-C319E722AAE5}']
  { constructors } 

    ///<summary>An optional attribute on a user-defined aggregate, used to indicate that the method should be registered in SQL Server as a function. Also used to set the <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.DataAccess" />
    ///  , <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.FillRowMethodName" />
    ///  , <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.IsDeterministic" />
    ///  , <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.IsPrecise" />
    ///  , <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.Name" />
    ///  , <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.SystemDataAccess" />
    ///  , and <see cref="P:Microsoft.SqlServer.Server.SqlFunctionAttribute.TableDefinition" />
    ///  properties of the function attribute.</summary>
    {class} function init: DNSqlFunctionAttribute;

  end;

  ///<summary>Used to mark a method definition of a user-defined aggregate as a function in SQL Server. The properties on the attribute reflect the physical characteristics used when the type is registered with SQL Server.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlFunctionAttribute')]
  DNSqlFunctionAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{D1590D04-441A-37E9-983D-71C132ED9F6B}']
  { getters & setters } 

    function get_IsDeterministic: Boolean;
    procedure set_IsDeterministic(value: Boolean);
    function get_DataAccess: DNDataAccessKind;
    procedure set_DataAccess(value: DNDataAccessKind);
    function get_SystemDataAccess: DNSystemDataAccessKind;
    procedure set_SystemDataAccess(value: DNSystemDataAccessKind);
    function get_IsPrecise: Boolean;
    procedure set_IsPrecise(value: Boolean);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TableDefinition: string;
    procedure set_TableDefinition(value: string);
    function get_FillRowMethodName: string;
    procedure set_FillRowMethodName(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates whether the user-defined function is deterministic.</summary>
    ///<returns><see langword="true" />
    ///  if the function is deterministic; otherwise <see langword="false" />
    ///  .</returns>
    property IsDeterministic: Boolean read get_IsDeterministic write set_IsDeterministic;
    ///<summary>Indicates whether the function involves access to user data stored in the local instance of SQL Server.</summary>
    ///<returns><see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="None" />
    ///  : Does not access data. <see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="Read" />
    ///  : Only reads user data.</returns>
    property DataAccess: DNDataAccessKind read get_DataAccess write set_DataAccess;
    ///<summary>Indicates whether the function requires access to data stored in the system catalogs or virtual system tables of SQL Server.</summary>
    ///<returns><see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="None" />
    ///  : Does not access system data. <see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="Read" />
    ///  : Only reads system data.</returns>
    property SystemDataAccess: DNSystemDataAccessKind read get_SystemDataAccess write set_SystemDataAccess;
    ///<summary>Indicates whether the function involves imprecise computations, such as floating point operations.</summary>
    ///<returns><see langword="true" />
    ///  if the function involves precise computations; otherwise <see langword="false" />
    ///  .</returns>
    property IsPrecise: Boolean read get_IsPrecise write set_IsPrecise;
    ///<summary>The name under which the function should be registered in SQL Server.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the name under which the function should be registered.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>A string that represents the table definition of the results, if the method is used as a table-valued function (TVF).</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the table definition of the results.</returns>
    property TableDefinition: string read get_TableDefinition write set_TableDefinition;
    ///<summary>The name of a method in the same class as the table-valued function (TVF) that is used by the TVF contract.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the name of a method used by the TVF contract.</returns>
    property FillRowMethodName: string read get_FillRowMethodName write set_FillRowMethodName;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlFunctionAttribute = class(TDNGenericImport<DNSqlFunctionAttributeClass, DNSqlFunctionAttribute>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlMethodAttributeClass = interface(DNSqlFunctionAttributeClass)
  ['{7DFDB86E-0B8B-5D09-9157-7FB0EDF3F8FB}']
  { constructors } 

    ///<summary>An attribute on a user-defined type (UDT), used to indicate the determinism and data access properties of a method or a property on a UDT.</summary>
    {class} function init: DNSqlMethodAttribute;

  end;

  ///<summary>Indicates the determinism and data access properties of a method or property on a user-defined type (UDT). The properties on the attribute reflect the physical characteristics that are used when the type is registered with SQL Server.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlMethodAttribute')]
  DNSqlMethodAttribute = interface(DNSqlFunctionAttribute)
  ['{A2B70C4B-E9BE-3A29-BA7E-5C74FFF1D43A}']
  { getters & setters } 

    function get_OnNullCall: Boolean;
    procedure set_OnNullCall(value: Boolean);
    function get_IsMutator: Boolean;
    procedure set_IsMutator(value: Boolean);
    function get_InvokeIfReceiverIsNull: Boolean;
    procedure set_InvokeIfReceiverIsNull(value: Boolean);
    function get_IsDeterministic: Boolean;
    procedure set_IsDeterministic(value: Boolean);
    function get_DataAccess: DNDataAccessKind;
    procedure set_DataAccess(value: DNDataAccessKind);
    function get_SystemDataAccess: DNSystemDataAccessKind;
    procedure set_SystemDataAccess(value: DNSystemDataAccessKind);
    function get_IsPrecise: Boolean;
    procedure set_IsPrecise(value: Boolean);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TableDefinition: string;
    procedure set_TableDefinition(value: string);
    function get_FillRowMethodName: string;
    procedure set_FillRowMethodName(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates whether the method on a user-defined type (UDT) is called when <see langword="null" />
    ///  input arguments are specified in the method invocation.</summary>
    ///<returns><see langword="true" />
    ///  if the method is called when <see langword="null" />
    ///  input arguments are specified in the method invocation; <see langword="false" />
    ///  if the method returns a <see langword="null" />
    ///  value when any of its input parameters are <see langword="null" />
    ///  . If the method cannot be invoked (because of an attribute on the method), the SQL Server <see langword="DbNull" />
    ///  is returned.</returns>
    property OnNullCall: Boolean read get_OnNullCall write set_OnNullCall;
    ///<summary>Indicates whether a method on a user-defined type (UDT) is a mutator.</summary>
    ///<returns><see langword="true" />
    ///  if the method is a mutator; otherwise <see langword="false" />
    ///  .</returns>
    property IsMutator: Boolean read get_IsMutator write set_IsMutator;
    ///<summary>Indicates whether SQL Server should invoke the method on null instances.</summary>
    ///<returns><see langword="true" />
    ///  if SQL Server should invoke the method on null instances; otherwise, <see langword="false" />
    ///  . If the method cannot be invoked (because of an attribute on the method), the SQL Server <see langword="DbNull" />
    ///  is returned.</returns>
    property InvokeIfReceiverIsNull: Boolean read get_InvokeIfReceiverIsNull write set_InvokeIfReceiverIsNull;
    ///<summary>Indicates whether the user-defined function is deterministic.</summary>
    ///<returns><see langword="true" />
    ///  if the function is deterministic; otherwise <see langword="false" />
    ///  .</returns>
    property IsDeterministic: Boolean read get_IsDeterministic write set_IsDeterministic;
    ///<summary>Indicates whether the function involves access to user data stored in the local instance of SQL Server.</summary>
    ///<returns><see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="None" />
    ///  : Does not access data. <see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="Read" />
    ///  : Only reads user data.</returns>
    property DataAccess: DNDataAccessKind read get_DataAccess write set_DataAccess;
    ///<summary>Indicates whether the function requires access to data stored in the system catalogs or virtual system tables of SQL Server.</summary>
    ///<returns><see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="None" />
    ///  : Does not access system data. <see cref="T:Microsoft.SqlServer.Server.DataAccessKind" />
    ///  .<see langword="Read" />
    ///  : Only reads system data.</returns>
    property SystemDataAccess: DNSystemDataAccessKind read get_SystemDataAccess write set_SystemDataAccess;
    ///<summary>Indicates whether the function involves imprecise computations, such as floating point operations.</summary>
    ///<returns><see langword="true" />
    ///  if the function involves precise computations; otherwise <see langword="false" />
    ///  .</returns>
    property IsPrecise: Boolean read get_IsPrecise write set_IsPrecise;
    ///<summary>The name under which the function should be registered in SQL Server.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the name under which the function should be registered.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>A string that represents the table definition of the results, if the method is used as a table-valued function (TVF).</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the table definition of the results.</returns>
    property TableDefinition: string read get_TableDefinition write set_TableDefinition;
    ///<summary>The name of a method in the same class as the table-valued function (TVF) that is used by the TVF contract.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the name of a method used by the TVF contract.</returns>
    property FillRowMethodName: string read get_FillRowMethodName write set_FillRowMethodName;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlMethodAttribute = class(TDNGenericImport<DNSqlMethodAttributeClass, DNSqlMethodAttribute>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlProcedureAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{E8844317-AF72-5839-81BE-C75FB24EDB4A}']
  { constructors } 

    ///<summary>An attribute on a method definition in an assembly, used to indicate that the given method should be registered as a stored procedure in SQL Server.</summary>
    {class} function init: DNSqlProcedureAttribute;

  end;

  ///<summary>Used to mark a method definition in an assembly as a stored procedure. The properties on the attribute reflect the physical characteristics used when the type is registered with SQL Server. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlProcedureAttribute')]
  DNSqlProcedureAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{7A97767D-AB39-36B5-BA4F-4127F0830702}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The name of the stored procedure.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  representing the name of the stored procedure.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlProcedureAttribute = class(TDNGenericImport<DNSqlProcedureAttributeClass, DNSqlProcedureAttribute>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlTriggerAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{47FF2954-99E8-5FC1-B3E0-D2BCE1E23DB0}']
  { constructors } 

    ///<summary>An attribute on a method definition in an assembly, used to mark the method as a trigger in SQL Server.</summary>
    {class} function init: DNSqlTriggerAttribute;

  end;

  ///<summary>Used to mark a method definition in an assembly as a trigger in SQL Server. The properties on the attribute reflect the physical attributes used when the type is registered with SQL Server. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlTriggerAttribute')]
  DNSqlTriggerAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{5AE35DDC-D0F8-3AF2-8DFB-AA8AC7C77951}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Target: string;
    procedure set_Target(value: string);
    function get_Event: string;
    procedure set_Event(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The name of the trigger.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the name of the trigger.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>The table to which the trigger applies.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the table name.</returns>
    property Target: string read get_Target write set_Target;
    ///<summary>The type of trigger and what data manipulation language (DML) action activates the trigger.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the type of trigger and what data manipulation language (DML) action activates the trigger.</returns>
    property Event: string read get_Event write set_Event;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlTriggerAttribute = class(TDNGenericImport<DNSqlTriggerAttributeClass, DNSqlTriggerAttribute>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlUserDefinedAggregateAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{AECAE990-BFE4-58F9-8B11-573CE4ADED60}']
  { constructors } 

    ///<summary>A required attribute on a user-defined aggregate, used to indicate that the given type is a user-defined aggregate and the storage format of the user-defined aggregate.</summary>
    ///  <param name="format">One of the <see cref="T:Microsoft.SqlServer.Server.Format" />
    ///  values representing the serialization format of the aggregate.</param>
    {class} function init(format: DNFormat): DNSqlUserDefinedAggregateAttribute;

  { static fields getter & setter } 

   function __fakeFieldGet_MaxByteSizeValue: Int32;

  { static fields } 

    ///<summary>The maximum size, in bytes, required to store the state of this aggregate instance during computation.</summary>
    {class} property MaxByteSizeValue: Int32 read __fakeFieldGet_MaxByteSizeValue;

  end;

  ///<summary>Indicates that the type should be registered as a user-defined aggregate. The properties on the attribute reflect the physical attributes used when the type is registered with SQL Server. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute')]
  DNSqlUserDefinedAggregateAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{1434262E-8B0D-3AE6-81A0-B5BBC35D40B8}']
  { getters & setters } 

    function get_MaxByteSize: Int32;
    procedure set_MaxByteSize(value: Int32);
    function get_IsInvariantToDuplicates: Boolean;
    procedure set_IsInvariantToDuplicates(value: Boolean);
    function get_IsInvariantToNulls: Boolean;
    procedure set_IsInvariantToNulls(value: Boolean);
    function get_IsInvariantToOrder: Boolean;
    procedure set_IsInvariantToOrder(value: Boolean);
    function get_IsNullIfEmpty: Boolean;
    procedure set_IsNullIfEmpty(value: Boolean);
    function get_Format: DNFormat;
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The maximum size, in bytes, of the aggregate instance.</summary>
    ///<returns>An <see cref="T:System.Int32" />
    ///  value representing the maximum size of the aggregate instance.</returns>
    property MaxByteSize: Int32 read get_MaxByteSize write set_MaxByteSize;
    ///<summary>Indicates whether the aggregate is invariant to duplicates.</summary>
    ///<returns><see langword="true" />
    ///  if the aggregate is invariant to duplicates; otherwise <see langword="false" />
    ///  .</returns>
    property IsInvariantToDuplicates: Boolean read get_IsInvariantToDuplicates write set_IsInvariantToDuplicates;
    ///<summary>Indicates whether the aggregate is invariant to nulls.</summary>
    ///<returns><see langword="true" />
    ///  if the aggregate is invariant to nulls; otherwise <see langword="false" />
    ///  .</returns>
    property IsInvariantToNulls: Boolean read get_IsInvariantToNulls write set_IsInvariantToNulls;
    ///<summary>Indicates whether the aggregate is invariant to order.</summary>
    ///<returns><see langword="true" />
    ///  if the aggregate is invariant to order; otherwise <see langword="false" />
    ///  .</returns>
    property IsInvariantToOrder: Boolean read get_IsInvariantToOrder write set_IsInvariantToOrder;
    ///<summary>Indicates whether the aggregate returns <see langword="null" />
    ///  if no values have been accumulated.</summary>
    ///<returns><see langword="true" />
    ///  if the aggregate returns <see langword="null" />
    ///  if no values have been accumulated; otherwise <see langword="false" />
    ///  .</returns>
    property IsNullIfEmpty: Boolean read get_IsNullIfEmpty write set_IsNullIfEmpty;
    ///<summary>The serialization format as a <see cref="T:Microsoft.SqlServer.Server.Format" />
    ///  .</summary>
    ///<returns>A <see cref="T:Microsoft.SqlServer.Server.Format" />
    ///  representing the serialization format.</returns>
    property Format: DNFormat read get_Format;
    ///<summary>The name of the aggregate.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the name of the aggregate.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlUserDefinedAggregateAttribute = class(TDNGenericImport<DNSqlUserDefinedAggregateAttributeClass, DNSqlUserDefinedAggregateAttribute>)
  public const
    ///<summary>The maximum size, in bytes, required to store the state of this aggregate instance during computation.</summary>
   MaxByteSizeValue = 8000;
  end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNSqlUserDefinedTypeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{976C3546-1D24-53FE-9538-B7B834AD3105}']
  { constructors } 

    ///<summary>A required attribute on a user-defined type (UDT), used to confirm that the given type is a UDT and to indicate the storage format of the UDT.</summary>
    ///  <param name="format">One of the <see cref="T:Microsoft.SqlServer.Server.Format" />
    ///  values representing the serialization format of the type.</param>
    {class} function init(format: DNFormat): DNSqlUserDefinedTypeAttribute;

  end;

  ///<summary>Used to mark a type definition in an assembly as a user-defined type (UDT) in SQL Server. The properties on the attribute reflect the physical characteristics used when the type is registered with SQL Server. This class cannot be inherited.</summary>
  [DNTypeName('Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute')]
  DNSqlUserDefinedTypeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{5EDF6FF3-80BA-3BE8-B646-991927AFA757}']
  { getters & setters } 

    function get_MaxByteSize: Int32;
    procedure set_MaxByteSize(value: Int32);
    function get_IsFixedLength: Boolean;
    procedure set_IsFixedLength(value: Boolean);
    function get_IsByteOrdered: Boolean;
    procedure set_IsByteOrdered(value: Boolean);
    function get_Format: DNFormat;
    function get_ValidationMethodName: string;
    procedure set_ValidationMethodName(value: string);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The maximum size of the instance, in bytes.</summary>
    ///<returns>An <see cref="T:System.Int32" />
    ///  value representing the maximum size of the instance.</returns>
    property MaxByteSize: Int32 read get_MaxByteSize write set_MaxByteSize;
    ///<summary>Indicates whether all instances of this user-defined type are the same length.</summary>
    ///<returns><see langword="true" />
    ///  if all instances of this type are the same length; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedLength: Boolean read get_IsFixedLength write set_IsFixedLength;
    ///<summary>Indicates whether the user-defined type is byte ordered.</summary>
    ///<returns><see langword="true" />
    ///  if the user-defined type is byte ordered; otherwise <see langword="false" />
    ///  .</returns>
    property IsByteOrdered: Boolean read get_IsByteOrdered write set_IsByteOrdered;
    ///<summary>The serialization format as a <see cref="T:Microsoft.SqlServer.Server.Format" />
    ///  .</summary>
    ///<returns>A <see cref="T:Microsoft.SqlServer.Server.Format" />
    ///  value representing the serialization format.</returns>
    property Format: DNFormat read get_Format;
    ///<summary>The name of the method used to validate instances of the user-defined type.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  representing the name of the method used to validate instances of the user-defined type.</returns>
    property ValidationMethodName: string read get_ValidationMethodName write set_ValidationMethodName;
    ///<summary>The SQL Server name of the user-defined type.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value representing the SQL Server name of the user-defined type.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlUserDefinedTypeAttribute = class(TDNGenericImport<DNSqlUserDefinedTypeAttributeClass, DNSqlUserDefinedTypeAttribute>) end;

  //-------------namespace: System.Data----------------
  DNDataSysDescriptionAttributeClass = interface(DNObjectClass)
  ['{5C08CCA1-4E56-596B-AF91-12164ABCA118}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataSysDescriptionAttribute" />
    ///  class using the specified description string.</summary>
    ///  <param name="description">The description string. </param>
    {class} function init(description: string): DNDataSysDescriptionAttribute;

  end;

  ///<summary>Marks a property, event, or extender with a description. Visual designers can display this description when referencing the member.</summary>
  [DNTypeName('System.Data.DataSysDescriptionAttribute')]
  DNDataSysDescriptionAttribute = interface(DNObject)
  ['{A30B6C19-6EBB-3A35-9EA3-C1DEF99F2E86}']
  { getters & setters } 

    function get_Description: string;
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function IsDefaultAttribute: Boolean;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the text for the description. </summary>
    ///<returns>The description string.</returns>
    property Description: string read get_Description;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNDataSysDescriptionAttribute = class(TDNGenericImport<DNDataSysDescriptionAttributeClass, DNDataSysDescriptionAttribute>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbProviderSpecificTypePropertyAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{C588291B-3EFF-57CF-BFD0-0FCAAD4E120A}']
  { constructors } 

    ///<summary>Initializes a new instance of a <see cref="T:System.Data.Common.DbProviderSpecificTypePropertyAttribute" />
    ///  class.</summary>
    ///  <param name="isProviderSpecificTypeProperty">Specifies whether this property is a provider-specific property.</param>
    {class} function init(isProviderSpecificTypeProperty: Boolean): DNDbProviderSpecificTypePropertyAttribute;

  end;

  ///<summary>Identifies which provider-specific property in the strongly typed parameter classes is to be used when setting a provider-specific type.</summary>
  [DNTypeName('System.Data.Common.DbProviderSpecificTypePropertyAttribute')]
  DNDbProviderSpecificTypePropertyAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{B024F5CD-4554-31D0-8FBF-4876AD26D74E}']
  { getters & setters } 

    function get_IsProviderSpecificTypeProperty: Boolean;
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates whether the attributed property is a provider-specific type.</summary>
    ///<returns><see langword="true" />
    ///  if the property that this attribute is applied to is a provider-specific type property; otherwise <see langword="false" />
    ///  .</returns>
    property IsProviderSpecificTypeProperty: Boolean read get_IsProviderSpecificTypeProperty;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNDbProviderSpecificTypePropertyAttribute = class(TDNGenericImport<DNDbProviderSpecificTypePropertyAttributeClass, DNDbProviderSpecificTypePropertyAttribute>) end;

  //-------------namespace: System.Data.Common----------------
  DNDBDataPermissionAttributeClass = interface(DDN.mscorlib.DNCodeAccessSecurityAttributeClass)
  ['{9BF00A48-F299-50BA-9498-5186E5C17C70}']
  end;

  ///<summary>Associates a security action with a custom security attribute. </summary>
  [DNTypeName('System.Data.Common.DBDataPermissionAttribute')]
  DNDBDataPermissionAttribute = interface(DDN.mscorlib.DNCodeAccessSecurityAttribute)
  ['{A351BE8E-CE50-3768-B8CF-F8A32D69840C}']
  { getters & setters } 

    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_KeyRestrictionBehavior: DNKeyRestrictionBehavior;
    procedure set_KeyRestrictionBehavior(value: DNKeyRestrictionBehavior);
    function get_KeyRestrictions: string;
    procedure set_KeyRestrictions(value: string);
    function get_Action: DDN.mscorlib.DNSecurityAction;
    procedure set_Action(value: DDN.mscorlib.DNSecurityAction);
    function get_Unrestricted: Boolean;
    procedure set_Unrestricted(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Identifies whether the attribute should serialize the connection string.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the connection string; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeConnectionString: Boolean;
    ///<summary>Identifies whether the attribute should serialize the set of key restrictions.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the set of key restrictions; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeKeyRestrictions: Boolean;
    function CreatePermission: DDN.mscorlib.DNIPermission;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed; otherwise <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
    ///<summary>Gets or sets a permitted connection string.</summary>
    ///<returns>A permitted connection string.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Identifies whether the list of connection string parameters identified by the <see cref="P:System.Data.Common.DBDataPermissionAttribute.KeyRestrictions" />
    ///  property are the only connection string parameters allowed.</summary>
    ///<returns>One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  values.</returns>
    property KeyRestrictionBehavior: DNKeyRestrictionBehavior read get_KeyRestrictionBehavior write set_KeyRestrictionBehavior;
    ///<summary>Gets or sets connection string parameters that are allowed or disallowed.</summary>
    ///<returns>One or more connection string parameters that are allowed or disallowed.</returns>
    property KeyRestrictions: string read get_KeyRestrictions write set_KeyRestrictions;
    property Action: DDN.mscorlib.DNSecurityAction read get_Action write set_Action;
    property Unrestricted: Boolean read get_Unrestricted write set_Unrestricted;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNDBDataPermissionAttribute = class(TDNGenericImport<DNDBDataPermissionAttributeClass, DNDBDataPermissionAttribute>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcPermissionAttributeClass = interface(DNDBDataPermissionAttributeClass)
  ['{C2475C12-F70B-5AA6-B5DE-E9F61E0AB0FE}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcPermissionAttribute" />
    ///  class with one of the <see cref="T:System.Security.Permissions.SecurityAction" />
    ///  values.</summary>
    ///  <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction" />
    ///  values representing an action that can be performed by using declarative security. </param>
    {class} function init(action: DDN.mscorlib.DNSecurityAction): DNOdbcPermissionAttribute;

  end;

  ///<summary>Associates a security action with a custom security attribute.</summary>
  [DNTypeName('System.Data.Odbc.OdbcPermissionAttribute')]
  DNOdbcPermissionAttribute = interface(DNDBDataPermissionAttribute)
  ['{2034B089-68FA-3C53-8361-F3E51773C4F0}']
  { getters & setters } 

    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_KeyRestrictionBehavior: DNKeyRestrictionBehavior;
    procedure set_KeyRestrictionBehavior(value: DNKeyRestrictionBehavior);
    function get_KeyRestrictions: string;
    procedure set_KeyRestrictions(value: string);
    function get_Action: DDN.mscorlib.DNSecurityAction;
    procedure set_Action(value: DDN.mscorlib.DNSecurityAction);
    function get_Unrestricted: Boolean;
    procedure set_Unrestricted(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Returns an <see cref="T:System.Data.Odbc.OdbcPermission" />
    ///  object that is configured according to the attribute properties.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcPermission" />
    ///  object.</returns>
    function CreatePermission: DDN.mscorlib.DNIPermission;
    ///<summary>Identifies whether the attribute should serialize the connection string.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the connection string; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeConnectionString: Boolean;
    ///<summary>Identifies whether the attribute should serialize the set of key restrictions.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the set of key restrictions; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeKeyRestrictions: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed; otherwise <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
    ///<summary>Gets or sets a permitted connection string.</summary>
    ///<returns>A permitted connection string.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Identifies whether the list of connection string parameters identified by the <see cref="P:System.Data.Common.DBDataPermissionAttribute.KeyRestrictions" />
    ///  property are the only connection string parameters allowed.</summary>
    ///<returns>One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  values.</returns>
    property KeyRestrictionBehavior: DNKeyRestrictionBehavior read get_KeyRestrictionBehavior write set_KeyRestrictionBehavior;
    ///<summary>Gets or sets connection string parameters that are allowed or disallowed.</summary>
    ///<returns>One or more connection string parameters that are allowed or disallowed.</returns>
    property KeyRestrictions: string read get_KeyRestrictions write set_KeyRestrictions;
    property Action: DDN.mscorlib.DNSecurityAction read get_Action write set_Action;
    property Unrestricted: Boolean read get_Unrestricted write set_Unrestricted;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNOdbcPermissionAttribute = class(TDNGenericImport<DNOdbcPermissionAttributeClass, DNOdbcPermissionAttribute>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbPermissionAttributeClass = interface(DNDBDataPermissionAttributeClass)
  ['{78D7DFE9-B896-5239-BE82-7959B99DE1E2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbPermissionAttribute" />
    ///  class.</summary>
    ///  <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction" />
    ///  values representing an action that can be performed by using declarative security. </param>
    {class} function init(action: DDN.mscorlib.DNSecurityAction): DNOleDbPermissionAttribute;

  end;

  ///<summary>Associates a security action with a custom security attribute.</summary>
  [DNTypeName('System.Data.OleDb.OleDbPermissionAttribute')]
  DNOleDbPermissionAttribute = interface(DNDBDataPermissionAttribute)
  ['{F0645373-794E-3DE7-9A90-4EE727727087}']
  { getters & setters } 

    function get_Provider: string;
    procedure set_Provider(value: string);
    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_KeyRestrictionBehavior: DNKeyRestrictionBehavior;
    procedure set_KeyRestrictionBehavior(value: DNKeyRestrictionBehavior);
    function get_KeyRestrictions: string;
    procedure set_KeyRestrictions(value: string);
    function get_Action: DDN.mscorlib.DNSecurityAction;
    procedure set_Action(value: DDN.mscorlib.DNSecurityAction);
    function get_Unrestricted: Boolean;
    procedure set_Unrestricted(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Returns an <see cref="T:System.Data.OleDb.OleDbPermission" />
    ///  object that is configured according to the attribute properties.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbPermission" />
    ///  object.</returns>
    function CreatePermission: DDN.mscorlib.DNIPermission;
    ///<summary>Identifies whether the attribute should serialize the connection string.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the connection string; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeConnectionString: Boolean;
    ///<summary>Identifies whether the attribute should serialize the set of key restrictions.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the set of key restrictions; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeKeyRestrictions: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a comma-delimited string that contains a list of supported providers.</summary>
    ///<returns>A comma-delimited list of providers allowed by the security policy.</returns>
    property Provider: string read get_Provider write set_Provider;
    ///<summary>Gets or sets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed; otherwise <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
    ///<summary>Gets or sets a permitted connection string.</summary>
    ///<returns>A permitted connection string.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Identifies whether the list of connection string parameters identified by the <see cref="P:System.Data.Common.DBDataPermissionAttribute.KeyRestrictions" />
    ///  property are the only connection string parameters allowed.</summary>
    ///<returns>One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  values.</returns>
    property KeyRestrictionBehavior: DNKeyRestrictionBehavior read get_KeyRestrictionBehavior write set_KeyRestrictionBehavior;
    ///<summary>Gets or sets connection string parameters that are allowed or disallowed.</summary>
    ///<returns>One or more connection string parameters that are allowed or disallowed.</returns>
    property KeyRestrictions: string read get_KeyRestrictions write set_KeyRestrictions;
    property Action: DDN.mscorlib.DNSecurityAction read get_Action write set_Action;
    property Unrestricted: Boolean read get_Unrestricted write set_Unrestricted;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNOleDbPermissionAttribute = class(TDNGenericImport<DNOleDbPermissionAttributeClass, DNOleDbPermissionAttribute>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlClientPermissionAttributeClass = interface(DNDBDataPermissionAttributeClass)
  ['{143373F6-EEE6-5A92-9153-388BEEB3034C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlClientPermissionAttribute" />
    ///  class. </summary>
    ///  <param name="action">One of the <see cref="T:System.Security.Permissions.SecurityAction" />
    ///  values representing an action that can be performed by using declarative security. </param>
    {class} function init(action: DDN.mscorlib.DNSecurityAction): DNSqlClientPermissionAttribute;

  end;

  ///<summary>Associates a security action with a custom security attribute.</summary>
  [DNTypeName('System.Data.SqlClient.SqlClientPermissionAttribute')]
  DNSqlClientPermissionAttribute = interface(DNDBDataPermissionAttribute)
  ['{EA46FFE4-6AC7-312C-BC36-92B31D31AC4C}']
  { getters & setters } 

    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_KeyRestrictionBehavior: DNKeyRestrictionBehavior;
    procedure set_KeyRestrictionBehavior(value: DNKeyRestrictionBehavior);
    function get_KeyRestrictions: string;
    procedure set_KeyRestrictions(value: string);
    function get_Action: DDN.mscorlib.DNSecurityAction;
    procedure set_Action(value: DDN.mscorlib.DNSecurityAction);
    function get_Unrestricted: Boolean;
    procedure set_Unrestricted(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Returns a <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  object that is configured according to the attribute properties.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  object.</returns>
    function CreatePermission: DDN.mscorlib.DNIPermission;
    ///<summary>Identifies whether the attribute should serialize the connection string.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the connection string; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeConnectionString: Boolean;
    ///<summary>Identifies whether the attribute should serialize the set of key restrictions.</summary>
    ///<returns><see langword="true" />
    ///  if the attribute should serialize the set of key restrictions; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeKeyRestrictions: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed; otherwise <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
    ///<summary>Gets or sets a permitted connection string.</summary>
    ///<returns>A permitted connection string.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Identifies whether the list of connection string parameters identified by the <see cref="P:System.Data.Common.DBDataPermissionAttribute.KeyRestrictions" />
    ///  property are the only connection string parameters allowed.</summary>
    ///<returns>One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  values.</returns>
    property KeyRestrictionBehavior: DNKeyRestrictionBehavior read get_KeyRestrictionBehavior write set_KeyRestrictionBehavior;
    ///<summary>Gets or sets connection string parameters that are allowed or disallowed.</summary>
    ///<returns>One or more connection string parameters that are allowed or disallowed.</returns>
    property KeyRestrictions: string read get_KeyRestrictions write set_KeyRestrictions;
    property Action: DDN.mscorlib.DNSecurityAction read get_Action write set_Action;
    property Unrestricted: Boolean read get_Unrestricted write set_Unrestricted;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSqlClientPermissionAttribute = class(TDNGenericImport<DNSqlClientPermissionAttributeClass, DNSqlClientPermissionAttribute>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlBulkCopyColumnMappingCollectionClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{4D06D991-7B4A-51D1-BE5B-A8F9E71C7FB8}']
  end;

  ///<summary>Collection of <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
  ///  objects that inherits from <see cref="T:System.Collections.CollectionBase" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlClient.SqlBulkCopyColumnMappingCollection')]
  DNSqlBulkCopyColumnMappingCollection = interface(DDN.mscorlib.DNCollectionBase)
  ['{E2CBD700-9031-344B-8934-6C37381F90FF}']
  { getters & setters } 

    function get_Item(index: Int32): DNSqlBulkCopyColumnMapping;
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Gets a value indicating whether a specified <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object exists in the collection.</summary>
    ///  <param name="value">A valid <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object. </param>
    ///<returns><see langword="true" />
    ///  if the specified mapping exists in the collection; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DNSqlBulkCopyColumnMapping): Boolean;
    ///<summary>Copies the elements of the <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />
    ///  to an array of <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  items, starting at a particular index.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  array that is the destination of the elements copied from <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />
    ///  . The array must have zero-based indexing. </param>
    ///  <param name="index">The zero-based index in <paramref name="array" />
    ///  at which copying begins. </param>
    procedure CopyTo(&array: TArray<DNSqlBulkCopyColumnMapping>; index: Int32);
    ///<summary>Gets the index of the specified <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object for which to search.</param>
    ///<returns>The zero-based index of the column mapping, or -1 if the column mapping is not found in the collection.</returns>
    function IndexOf(value: DNSqlBulkCopyColumnMapping): Int32;
    ///<summary>Adds the specified mapping to the <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />
    ///  .</summary>
    ///  <param name="bulkCopyColumnMapping">The <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object that describes the mapping to be added to the collection.</param>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object.</returns>
    function Add(bulkCopyColumnMapping: DNSqlBulkCopyColumnMapping): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  and adds it to the collection, using column names to specify both source and destination columns.</summary>
    ///  <param name="sourceColumn">The name of the source column within the data source.</param>
    ///  <param name="destinationColumn">The name of the destination column within the destination table.</param>
    ///<returns>A column mapping.</returns>
    function Add(sourceColumn: string; destinationColumn: string): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  and adds it to the collection, using an ordinal for the source column and a string for the destination column.</summary>
    ///  <param name="sourceColumnIndex">The ordinal position of the source column within the data source.</param>
    ///  <param name="destinationColumn">The name of the destination column within the destination table.</param>
    ///<returns>A column mapping.</returns>
    function Add(sourceColumnIndex: Int32; destinationColumn: string): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  and adds it to the collection, using a column name to describe the source column and an ordinal to specify the destination column.</summary>
    ///  <param name="sourceColumn">The name of the source column within the data source.</param>
    ///  <param name="destinationColumnIndex">The ordinal position of the destination column within the destination table.</param>
    ///<returns>A column mapping.</returns>
    function Add(sourceColumn: string; destinationColumnIndex: Int32): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  and adds it to the collection, using ordinals to specify both source and destination columns.</summary>
    ///  <param name="sourceColumnIndex">The ordinal position of the source column within the data source.</param>
    ///  <param name="destinationColumnIndex">The ordinal position of the destination column within the destination table.</param>
    ///<returns>A column mapping.</returns>
    function Add(sourceColumnIndex: Int32; destinationColumnIndex: Int32): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Clears the contents of the collection.</summary>
    procedure Clear;
    ///<summary>Insert a new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  at the index specified.</summary>
    ///  <param name="index">Integer value of the location within the <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />
    ///  at which to insert the new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  .</param>
    ///  <param name="value"><see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object to be inserted in the collection.</param>
    procedure Insert(index: Int32; value: DNSqlBulkCopyColumnMapping);
    ///<summary>Removes the specified <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  element from the <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMappingCollection" />
    ///  .</summary>
    ///  <param name="value"><see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object to be removed from the collection.</param>
    procedure Remove(value: DNSqlBulkCopyColumnMapping);
    ///<summary>Removes the mapping at the specified index from the collection.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object to be removed from the collection.</param>
    procedure RemoveAt(index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNSqlBulkCopyColumnMapping read get_Item; default;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNSqlBulkCopyColumnMappingCollection = class(TDNGenericImport<DNSqlBulkCopyColumnMappingCollectionClass, DNSqlBulkCopyColumnMappingCollection>) end;

  //-------------namespace: System.Data----------------
  DNPropertyCollectionClass = interface(DDN.mscorlib.DNHashtableClass)
  ['{C85F27D1-0548-568C-B2DE-C2FA42369C7F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.PropertyCollection" />
    ///  class.</summary>
    {class} function init: DNPropertyCollection;

  end;

  ///<summary>Represents a collection of properties that can be added to <see cref="T:System.Data.DataColumn" />
  ///  , <see cref="T:System.Data.DataSet" />
  ///  , or <see cref="T:System.Data.DataTable" />
  ///  . </summary>
  [DNTypeName('System.Data.PropertyCollection')]
  DNPropertyCollection = interface(DDN.mscorlib.DNHashtable)
  ['{AFC091BB-C65A-3D7B-B411-9FE3C18EFA6A}']
  { getters & setters } 

    function get_Item(key: DDN.mscorlib.DNObject): DDN.mscorlib.DNObject;
    procedure set_Item(key: DDN.mscorlib.DNObject; value: DDN.mscorlib.DNObject);
    function get_IsReadOnly: Boolean;
    function get_IsFixedSize: Boolean;
    function get_IsSynchronized: Boolean;
    function get_Keys: DDN.mscorlib.DNICollection;
    function get_Values: DDN.mscorlib.DNICollection;
    function get_SyncRoot: DDN.mscorlib.DNObject;
    function get_Count: Int32;

  { methods } 

    ///<summary>Creates a shallow copy of the <see cref="T:System.Data.PropertyCollection" />
    ///  object.</summary>
    ///<returns>Returns <see cref="T:System.Object" />
    ///  , a shallow copy of the <see cref="T:System.Data.PropertyCollection" />
    ///  object.</returns>
    function Clone: DDN.mscorlib.DNObject;
    procedure Add(key: DDN.mscorlib.DNObject; value: DDN.mscorlib.DNObject);
    procedure Clear;
    function &Contains(key: DDN.mscorlib.DNObject): Boolean;
    function ContainsKey(key: DDN.mscorlib.DNObject): Boolean;
    function ContainsValue(value: DDN.mscorlib.DNObject): Boolean;
    procedure CopyTo(&array: DDN.mscorlib.DNArray; arrayIndex: Int32);
    function GetEnumerator: DDN.mscorlib.DNIDictionaryEnumerator;
    procedure Remove(key: DDN.mscorlib.DNObject);
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    procedure OnDeserialization(sender: DDN.mscorlib.DNObject);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[key: DDN.mscorlib.DNObject]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property IsFixedSize: Boolean read get_IsFixedSize;
    property IsSynchronized: Boolean read get_IsSynchronized;
    property Keys: DDN.mscorlib.DNICollection read get_Keys;
    property Values: DDN.mscorlib.DNICollection read get_Values;
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
    property Count: Int32 read get_Count;
  end;

  TDNPropertyCollection = class(TDNGenericImport<DNPropertyCollectionClass, DNPropertyCollection>) end;

  //-------------namespace: System.Data----------------
  DNDataColumnClass = interface(DNObjectClass)
  ['{AA653357-C952-55EF-A2AB-F65D2563C1D9}']
  { constructors } 

    ///<summary>Initializes a new instance of a <see cref="T:System.Data.DataColumn" />
    ///  class as type string.</summary>
    {class} function init: DNDataColumn; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataColumn" />
    ///  class, as type string, using the specified column name.</summary>
    ///  <param name="columnName">A string that represents the name of the column to be created. If set to <see langword="null" />
    ///  or an empty string (""), a default name will be specified when added to the columns collection. </param>
    {class} function init(columnName: string): DNDataColumn; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataColumn" />
    ///  class using the specified column name and data type.</summary>
    ///  <param name="columnName">A string that represents the name of the column to be created. If set to <see langword="null" />
    ///  or an empty string (""), a default name will be specified when added to the columns collection. </param>
    ///  <param name="dataType">A supported <see cref="P:System.Data.DataColumn.DataType" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentNullException">No <paramref name="dataType" />
    ///  was specified. </exception>
    {class} function init(columnName: string; dataType: DDN.mscorlib.DNType): DNDataColumn; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataColumn" />
    ///  class using the specified name, data type, and expression.</summary>
    ///  <param name="columnName">A string that represents the name of the column to be created. If set to <see langword="null" />
    ///  or an empty string (""), a default name will be specified when added to the columns collection. </param>
    ///  <param name="dataType">A supported <see cref="P:System.Data.DataColumn.DataType" />
    ///  . </param>
    ///  <param name="expr">The expression used to create this column. For more information, see the <see cref="P:System.Data.DataColumn.Expression" />
    ///  property. </param>
    ///<exception cref="T:System.ArgumentNullException">No <paramref name="dataType" />
    ///  was specified. </exception>
    {class} function init(columnName: string; dataType: DDN.mscorlib.DNType; expr: string): DNDataColumn; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataColumn" />
    ///  class using the specified name, data type, expression, and value that determines whether the column is an attribute.</summary>
    ///  <param name="columnName">A string that represents the name of the column to be created. If set to <see langword="null" />
    ///  or an empty string (""), a default name will be specified when added to the columns collection. </param>
    ///  <param name="dataType">A supported <see cref="P:System.Data.DataColumn.DataType" />
    ///  . </param>
    ///  <param name="expr">The expression used to create this column. For more information, see the <see cref="P:System.Data.DataColumn.Expression" />
    ///  property. </param>
    ///  <param name="type">One of the <see cref="T:System.Data.MappingType" />
    ///  values. </param>
    ///<exception cref="T:System.ArgumentNullException">No <paramref name="dataType" />
    ///  was specified. </exception>
    {class} function init(columnName: string; dataType: DDN.mscorlib.DNType; expr: string; &type: DNMappingType): DNDataColumn; overload;

  end;

  ///<summary>Represents the schema of a column in a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  [DNTypeName('System.Data.DataColumn')]
  DNDataColumn = interface(DNObject)
  ['{7AE16284-BC54-3D58-B276-B5B4D6D65157}']
  { getters & setters } 

    function get_AllowDBNull: Boolean;
    procedure set_AllowDBNull(value: Boolean);
    function get_AutoIncrement: Boolean;
    procedure set_AutoIncrement(value: Boolean);
    function get_AutoIncrementSeed: Int64;
    procedure set_AutoIncrementSeed(value: Int64);
    function get_AutoIncrementStep: Int64;
    procedure set_AutoIncrementStep(value: Int64);
    function get_Caption: string;
    procedure set_Caption(value: string);
    function get_ColumnName: string;
    procedure set_ColumnName(value: string);
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_DataType: DDN.mscorlib.DNType;
    procedure set_DataType(value: DDN.mscorlib.DNType);
    function get_DateTimeMode: DNDataSetDateTime;
    procedure set_DateTimeMode(value: DNDataSetDateTime);
    function get_DefaultValue: DDN.mscorlib.DNObject;
    procedure set_DefaultValue(value: DDN.mscorlib.DNObject);
    function get_Expression: string;
    procedure set_Expression(value: string);
    function get_ExtendedProperties: DNPropertyCollection;
    function get_MaxLength: Int32;
    procedure set_MaxLength(value: Int32);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_Ordinal: Int32;
    function get_ReadOnly: Boolean;
    procedure set_ReadOnly(value: Boolean);
    function get_Table: DNDataTable;
    function get_Unique: Boolean;
    procedure set_Unique(value: Boolean);
    function get_ColumnMapping: DNMappingType;
    procedure set_ColumnMapping(value: DNMappingType);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;
    function get_DesignMode: Boolean;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Changes the ordinal or position of the <see cref="T:System.Data.DataColumn" />
    ///  to the specified ordinal or position.</summary>
    ///  <param name="ordinal">The specified ordinal.</param>
    procedure SetOrdinal(ordinal: Int32);
    ///<summary>Gets the <see cref="P:System.Data.DataColumn.Expression" />
    ///  of the column, if one exists.</summary>
    ///<returns>The <see cref="P:System.Data.DataColumn.Expression" />
    ///  value, if the property is set; otherwise, the <see cref="P:System.Data.DataColumn.ColumnName" />
    ///  property.</returns>
    function ToString: string;
    procedure Dispose;
    function GetService(service: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets a value that indicates whether null values are allowed in this column for rows that belong to the table.</summary>
    ///<returns><see langword="true" />
    ///  if null values values are allowed; otherwise, <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property AllowDBNull: Boolean read get_AllowDBNull write set_AllowDBNull;
    ///<summary>Gets or sets a value that indicates whether the column automatically increments the value of the column for new rows added to the table.</summary>
    ///<returns><see langword="true" />
    ///  if the value of the column increments automatically; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The column is a computed column. </exception>
    property AutoIncrement: Boolean read get_AutoIncrement write set_AutoIncrement;
    ///<summary>Gets or sets the starting value for a column that has its <see cref="P:System.Data.DataColumn.AutoIncrement" />
    ///  property set to <see langword="true" />
    ///  . The default is 0.</summary>
    ///<returns>The starting value for the <see cref="P:System.Data.DataColumn.AutoIncrement" />
    ///  feature.</returns>
    property AutoIncrementSeed: Int64 read get_AutoIncrementSeed write set_AutoIncrementSeed;
    ///<summary>Gets or sets the increment used by a column with its <see cref="P:System.Data.DataColumn.AutoIncrement" />
    ///  property set to <see langword="true" />
    ///  .</summary>
    ///<returns>The number by which the value of the column is automatically incremented. The default is 1.</returns>
    ///<exception cref="T:System.ArgumentException">The value set is zero. </exception>
    property AutoIncrementStep: Int64 read get_AutoIncrementStep write set_AutoIncrementStep;
    ///<summary>Gets or sets the caption for the column.</summary>
    ///<returns>The caption of the column. If not set, returns the <see cref="P:System.Data.DataColumn.ColumnName" />
    ///  value.</returns>
    property Caption: string read get_Caption write set_Caption;
    ///<summary>Gets or sets the name of the column in the <see cref="T:System.Data.DataColumnCollection" />
    ///  .</summary>
    ///<returns>The name of the column.</returns>
    ///<exception cref="T:System.ArgumentException">The property is set to <see langword="null" />
    ///  or an empty string and the column belongs to a collection. </exception><exception cref="T:System.Data.DuplicateNameException">A column with the same name already exists in the collection. The name comparison is not case sensitive. </exception>
    property ColumnName: string read get_ColumnName write set_ColumnName;
    ///<summary>Gets or sets an XML prefix that aliases the namespace of the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>The XML prefix for the <see cref="T:System.Data.DataTable" />
    ///  namespace.</returns>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets or sets the type of data stored in the column.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  object that represents the column data type.</returns>
    ///<exception cref="T:System.ArgumentException">The column already has data stored. </exception>
    property DataType: DDN.mscorlib.DNType read get_DataType write set_DataType;
    ///<summary>Gets or sets the <see langword="DateTimeMode" />
    ///  for the column.</summary>
    ///<returns>The <see cref="T:System.Data.DataSetDateTime" />
    ///  for the specified column.</returns>
    property DateTimeMode: DNDataSetDateTime read get_DateTimeMode write set_DateTimeMode;
    ///<summary>Gets or sets the default value for the column when you are creating new rows.</summary>
    ///<returns>A value appropriate to the column's <see cref="P:System.Data.DataColumn.DataType" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidCastException">When you are adding a row, the default value is not an instance of the column's data type. </exception>
    property DefaultValue: DDN.mscorlib.DNObject read get_DefaultValue write set_DefaultValue;
    ///<summary>Gets or sets the expression used to filter rows, calculate the values in a column, or create an aggregate column.</summary>
    ///<returns>An expression to calculate the value of a column, or create an aggregate column. The return type of an expression is determined by the <see cref="P:System.Data.DataColumn.DataType" />
    ///  of the column.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="P:System.Data.DataColumn.AutoIncrement" />
    ///  or <see cref="P:System.Data.DataColumn.Unique" />
    ///  property is set to <see langword="true" />
    ///  . </exception><exception cref="T:System.FormatException">When you are using the CONVERT function, the expression evaluates to a string, but the string does not contain a representation that can be converted to the type parameter. </exception><exception cref="T:System.InvalidCastException">When you are using the CONVERT function, the requested cast is not possible. See the Conversion function in the following section for detailed information about possible casts. </exception><exception cref="T:System.ArgumentOutOfRangeException">When you use the SUBSTRING function, the start argument is out of range.-Or- When you use the SUBSTRING function, the length argument is out of range. </exception><exception cref="T:System.Exception">When you use the LEN function or the TRIM function, the expression does not evaluate to a string. This includes expressions that evaluate to <see cref="T:System.Char" />
    ///  . </exception>
    property Expression: string read get_Expression write set_Expression;
    ///<summary>Gets the collection of custom user information associated with a <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  of custom information.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
    ///<summary>Gets or sets the maximum length of a text column.</summary>
    ///<returns>The maximum length of the column in characters. If the column has no maximum length, the value is –1 (default).</returns>
    property MaxLength: Int32 read get_MaxLength write set_MaxLength;
    ///<summary>Gets or sets the namespace of the <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///<returns>The namespace of the <see cref="T:System.Data.DataColumn" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The namespace already has data. </exception>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets the (zero-based) position of the column in the <see cref="T:System.Data.DataColumnCollection" />
    ///  collection.</summary>
    ///<returns>The position of the column. Gets -1 if the column is not a member of a collection.</returns>
    property Ordinal: Int32 read get_Ordinal;
    ///<summary>Gets or sets a value that indicates whether the column allows for changes as soon as a row has been added to the table.</summary>
    ///<returns><see langword="true" />
    ///  if the column is read only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property is set to <see langword="false" />
    ///  on a computed column. </exception>
    property ReadOnly: Boolean read get_ReadOnly write set_ReadOnly;
    ///<summary>Gets the <see cref="T:System.Data.DataTable" />
    ///  to which the column belongs to.</summary>
    ///<returns>The <see cref="T:System.Data.DataTable" />
    ///  that the <see cref="T:System.Data.DataColumn" />
    ///  belongs to.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>Gets or sets a value that indicates whether the values in each row of the column must be unique.</summary>
    ///<returns><see langword="true" />
    ///  if the value must be unique; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The column is a calculated column. </exception>
    property Unique: Boolean read get_Unique write set_Unique;
    ///<summary>Gets or sets the <see cref="T:System.Data.MappingType" />
    ///  of the column.</summary>
    ///<returns>One of the <see cref="T:System.Data.MappingType" />
    ///  values.</returns>
    property ColumnMapping: DNMappingType read get_ColumnMapping write set_ColumnMapping;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
    property DesignMode: Boolean read get_DesignMode;
  end;

  TDNDataColumn = class(TDNGenericImport<DNDataColumnClass, DNDataColumn>) end;

  //-------------namespace: System.Data----------------
  DNDataSetClass = interface(DNObjectClass)
  ['{5BB739BB-F730-568F-B238-22587AD46860}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataSet" />
    ///  class.</summary>
    {class} function init: DNDataSet; overload;
    ///<summary>Initializes a new instance of a <see cref="T:System.Data.DataSet" />
    ///  class with the given name.</summary>
    ///  <param name="dataSetName">The name of the <see cref="T:System.Data.DataSet" />
    ///  .</param>
    {class} function init(dataSetName: string): DNDataSet; overload;

  { static methods } 

    ///<summary>Gets a copy of <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  for the DataSet.</summary>
    ///  <param name="schemaSet">The specified schema set. </param>
    ///<returns>A copy of <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetDataSetSchema(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlSchemaComplexType;

  end;

  ///<summary>Represents an in-memory cache of data.</summary>
  [DNTypeName('System.Data.DataSet')]
  DNDataSet = interface(DNObject)
  ['{6E3DF7A0-377F-3A21-BB7C-C4C37F17758D}']
  { getters & setters } 

    function get_RemotingFormat: DNSerializationFormat;
    procedure set_RemotingFormat(value: DNSerializationFormat);
    function get_SchemaSerializationMode: DNSchemaSerializationMode;
    procedure set_SchemaSerializationMode(value: DNSchemaSerializationMode);
    function get_CaseSensitive: Boolean;
    procedure set_CaseSensitive(value: Boolean);
    function get_DefaultViewManager: DNDataViewManager;
    function get_EnforceConstraints: Boolean;
    procedure set_EnforceConstraints(value: Boolean);
    function get_DataSetName: string;
    procedure set_DataSetName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_ExtendedProperties: DNPropertyCollection;
    function get_HasErrors: Boolean;
    function get_IsInitialized: Boolean;
    function get_Locale: DDN.mscorlib.DNCultureInfo;
    procedure set_Locale(value: DDN.mscorlib.DNCultureInfo);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Relations: DNDataRelationCollection;
    function get_Tables: DNDataTableCollection;
    function get_Container: DDN.System.DNIContainer;
    function get_DesignMode: Boolean;

  { events } 

    procedure add_MergeFailed(value: DNMergeFailedEventHandler);
    procedure remove_MergeFailed(value: DNMergeFailedEventHandler);
    procedure add_Initialized(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Initialized(value: DDN.mscorlib.DNEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Populates a serialization information object with the data needed to serialize the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  that holds the serialized data associated with the <see cref="T:System.Data.DataSet" />
    ///  .</param>
    ///  <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DataSet" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="info" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    ///<summary>Commits all the changes made to this <see cref="T:System.Data.DataSet" />
    ///  since it was loaded or since the last time <see cref="M:System.Data.DataSet.AcceptChanges" />
    ///  was called.</summary>
    procedure AcceptChanges;
    ///<summary>Begins the initialization of a <see cref="T:System.Data.DataSet" />
    ///  that is used on a form or used by another component. The initialization occurs at run time.</summary>
    procedure BeginInit;
    ///<summary>Ends the initialization of a <see cref="T:System.Data.DataSet" />
    ///  that is used on a form or used by another component. The initialization occurs at run time.</summary>
    procedure EndInit;
    ///<summary>Clears the <see cref="T:System.Data.DataSet" />
    ///  of any data by removing all rows in all tables.</summary>
    procedure Clear;
    ///<summary>Copies the structure of the <see cref="T:System.Data.DataSet" />
    ///  , including all <see cref="T:System.Data.DataTable" />
    ///  schemas, relations, and constraints. Does not copy any data.</summary>
    ///<returns>A new <see cref="T:System.Data.DataSet" />
    ///  with the same schema as the current <see cref="T:System.Data.DataSet" />
    ///  , but none of the data.</returns>
    function Clone: DNDataSet;
    ///<summary>Copies both the structure and data for this <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.DataSet" />
    ///  with the same structure (table schemas, relations, and constraints) and data as this <see cref="T:System.Data.DataSet" />
    ///  .If these classes have been subclassed, the copy will also be of the same subclasses.</returns>
    function Copy: DNDataSet;
    ///<summary>Gets a copy of the <see cref="T:System.Data.DataSet" />
    ///  that contains all changes made to it since it was loaded or since <see cref="M:System.Data.DataSet.AcceptChanges" />
    ///  was last called.</summary>
    ///<returns>A copy of the changes from this <see cref="T:System.Data.DataSet" />
    ///  that can have actions performed on it and later be merged back in using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
    ///  . If no changed rows are found, the method returns <see langword="null" />
    ///  .</returns>
    function GetChanges: DNDataSet; overload;
    ///<summary>Gets a copy of the <see cref="T:System.Data.DataSet" />
    ///  containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataSet.AcceptChanges" />
    ///  was called, filtered by <see cref="T:System.Data.DataRowState" />
    ///  .</summary>
    ///  <param name="rowStates">One of the <see cref="T:System.Data.DataRowState" />
    ///  values. </param>
    ///<returns>A filtered copy of the <see cref="T:System.Data.DataSet" />
    ///  that can have actions performed on it, and subsequently be merged back in using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
    ///  . If no rows of the desired <see cref="T:System.Data.DataRowState" />
    ///  are found, the method returns <see langword="null" />
    ///  .</returns>
    function GetChanges(rowStates: DNDataRowState): DNDataSet; overload;
    ///<summary>Returns the XML representation of the data stored in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>A string that is a representation of the data stored in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function GetXml: string;
    ///<summary>Returns the XML Schema for the XML representation of the data stored in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>String that is the XML Schema for the XML representation of the data stored in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function GetXmlSchema: string;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Data.DataSet" />
    ///  has changes, including new, deleted, or modified rows.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.DataSet" />
    ///  has changes; otherwise <see langword="false" />
    ///  .</returns>
    function HasChanges: Boolean; overload;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Data.DataSet" />
    ///  has changes, including new, deleted, or modified rows, filtered by <see cref="T:System.Data.DataRowState" />
    ///  .</summary>
    ///  <param name="rowStates">One of the <see cref="T:System.Data.DataRowState" />
    ///  values. </param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.DataSet" />
    ///  has changes; otherwise <see langword="false" />
    ///  .</returns>
    function HasChanges(rowStates: DNDataRowState): Boolean; overload;
    ///<summary>Applies the XML schema from the specified <see cref="T:System.Xml.XmlReader" />
    ///  to the <see cref="T:System.Data.DataSet" />
    ///  . </summary>
    ///  <param name="reader">The <see langword="XMLReader" />
    ///  from which to read the schema. </param>
    ///  <param name="nsArray">An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference. </param>
    procedure InferXmlSchema(reader: DDN.System.Xml.DNXmlReader; nsArray: TArray<string>); overload;
    ///<summary>Applies the XML schema from the specified <see cref="T:System.IO.Stream" />
    ///  to the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="stream">The <see langword="Stream" />
    ///  from which to read the schema. </param>
    ///  <param name="nsArray">An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference. </param>
    procedure InferXmlSchema(stream: DDN.mscorlib.DNStream; nsArray: TArray<string>); overload;
    ///<summary>Applies the XML schema from the specified <see cref="T:System.IO.TextReader" />
    ///  to the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="TextReader" />
    ///  from which to read the schema. </param>
    ///  <param name="nsArray">An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference. </param>
    procedure InferXmlSchema(reader: DDN.mscorlib.DNTextReader; nsArray: TArray<string>); overload;
    ///<summary>Applies the XML schema from the specified file to the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="fileName">The name of the file (including the path) from which to read the schema. </param>
    ///  <param name="nsArray">An array of namespace Uniform Resource Identifier (URI) strings to be excluded from schema inference. </param>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />
    ///  .</exception>
    procedure InferXmlSchema(fileName: string; nsArray: TArray<string>); overload;
    ///<summary>Reads the XML schema from the specified <see cref="T:System.Xml.XmlReader" />
    ///  into the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  from which to read. </param>
    procedure ReadXmlSchema(reader: DDN.System.Xml.DNXmlReader); overload;
    ///<summary>Reads the XML schema from the specified <see cref="T:System.IO.Stream" />
    ///  into the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="stream">The <see cref="T:System.IO.Stream" />
    ///  from which to read. </param>
    procedure ReadXmlSchema(stream: DDN.mscorlib.DNStream); overload;
    ///<summary>Reads the XML schema from the specified <see cref="T:System.IO.TextReader" />
    ///  into the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.IO.TextReader" />
    ///  from which to read. </param>
    procedure ReadXmlSchema(reader: DDN.mscorlib.DNTextReader); overload;
    ///<summary>Reads the XML schema from the specified file into the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="fileName">The file name (including the path) from which to read. </param>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />
    ///  .</exception>
    procedure ReadXmlSchema(fileName: string); overload;
    ///<summary>Writes the <see cref="T:System.Data.DataSet" />
    ///  structure as an XML schema to the specified <see cref="T:System.IO.Stream" />
    ///  object.</summary>
    ///  <param name="stream">A <see cref="T:System.IO.Stream" />
    ///  object used to write to a file. </param>
    procedure WriteXmlSchema(stream: DDN.mscorlib.DNStream); overload;
    procedure WriteXmlSchema(stream: DDN.mscorlib.DNStream; multipleTargetConverter: DDN.mscorlib.DNConverter<DDN.mscorlib.DNType, string>); overload;
    ///<summary>Writes the <see cref="T:System.Data.DataSet" />
    ///  structure as an XML schema to a file.</summary>
    ///  <param name="fileName">The file name (including the path) to which to write. </param>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />
    ///  . </exception>
    procedure WriteXmlSchema(fileName: string); overload;
    procedure WriteXmlSchema(fileName: string; multipleTargetConverter: DDN.mscorlib.DNConverter<DDN.mscorlib.DNType, string>); overload;
    ///<summary>Writes the <see cref="T:System.Data.DataSet" />
    ///  structure as an XML schema to the specified <see cref="T:System.IO.TextWriter" />
    ///  object.</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  object with which to write. </param>
    procedure WriteXmlSchema(writer: DDN.mscorlib.DNTextWriter); overload;
    procedure WriteXmlSchema(writer: DDN.mscorlib.DNTextWriter; multipleTargetConverter: DDN.mscorlib.DNConverter<DDN.mscorlib.DNType, string>); overload;
    ///<summary>Writes the <see cref="T:System.Data.DataSet" />
    ///  structure as an XML schema to an <see cref="T:System.Xml.XmlWriter" />
    ///  object.</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  to write to. </param>
    procedure WriteXmlSchema(writer: DDN.System.Xml.DNXmlWriter); overload;
    procedure WriteXmlSchema(writer: DDN.System.Xml.DNXmlWriter; multipleTargetConverter: DDN.mscorlib.DNConverter<DDN.mscorlib.DNType, string>); overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  from which to read. </param>
    ///<returns>The <see langword="XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(reader: DDN.System.Xml.DNXmlReader): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="stream">An object that derives from <see cref="T:System.IO.Stream" />
    ///  . </param>
    ///<returns>The <see cref="T:System.Data.XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(stream: DDN.mscorlib.DNStream): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="TextReader" />
    ///  from which to read the schema and data. </param>
    ///<returns>The <see cref="T:System.Data.XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(reader: DDN.mscorlib.DNTextReader): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified file.</summary>
    ///  <param name="fileName">The filename (including the path) from which to read. </param>
    ///<returns>The <see langword="XmlReadMode" />
    ///  used to read the data.</returns>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />
    ///  . </exception>
    function ReadXml(fileName: string): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.Xml.XmlReader" />
    ///  and <see cref="T:System.Data.XmlReadMode" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  from which to read. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlReadMode" />
    ///  values. </param>
    ///<returns>The <see langword="XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(reader: DDN.System.Xml.DNXmlReader; mode: DNXmlReadMode): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.Stream" />
    ///  and <see cref="T:System.Data.XmlReadMode" />
    ///  .</summary>
    ///  <param name="stream">The <see cref="T:System.IO.Stream" />
    ///  from which to read. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlReadMode" />
    ///  values. </param>
    ///<returns>The <see langword="XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(stream: DDN.mscorlib.DNStream; mode: DNXmlReadMode): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.TextReader" />
    ///  and <see cref="T:System.Data.XmlReadMode" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.IO.TextReader" />
    ///  from which to read. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlReadMode" />
    ///  values. </param>
    ///<returns>The <see langword="XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(reader: DDN.mscorlib.DNTextReader; mode: DNXmlReadMode): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataSet" />
    ///  using the specified file and <see cref="T:System.Data.XmlReadMode" />
    ///  .</summary>
    ///  <param name="fileName">The filename (including the path) from which to read. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlReadMode" />
    ///  values. </param>
    ///<returns>The <see langword="XmlReadMode" />
    ///  used to read the data.</returns>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />
    ///  . </exception>
    function ReadXml(fileName: string; mode: DNXmlReadMode): DNXmlReadMode; overload;
    ///<summary>Writes the current data for the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="stream">A <see cref="T:System.IO.Stream" />
    ///  object used to write to a file. </param>
    procedure WriteXml(stream: DDN.mscorlib.DNStream); overload;
    ///<summary>Writes the current data for the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  object with which to write. </param>
    procedure WriteXml(writer: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Writes the current data for the <see cref="T:System.Data.DataSet" />
    ///  to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  with which to write. </param>
    procedure WriteXml(writer: DDN.System.Xml.DNXmlWriter); overload;
    ///<summary>Writes the current data for the <see cref="T:System.Data.DataSet" />
    ///  to the specified file.</summary>
    ///  <param name="fileName">The file name (including the path) to which to write. </param>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />
    ///  . </exception>
    procedure WriteXml(fileName: string); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.Stream" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="stream">A <see cref="T:System.IO.Stream" />
    ///  object used to write to a file. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    procedure WriteXml(stream: DDN.mscorlib.DNStream; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.IO.TextWriter" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="writer">A <see cref="T:System.IO.TextWriter" />
    ///  object used to write the document. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    procedure WriteXml(writer: DDN.mscorlib.DNTextWriter; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  with which to write. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    procedure WriteXml(writer: DDN.System.Xml.DNXmlWriter; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataSet" />
    ///  to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="fileName">The file name (including the path) to which to write. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    ///<exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />
    ///  is not set to <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />
    ///  . </exception>
    procedure WriteXml(fileName: string; mode: DNXmlWriteMode); overload;
    ///<summary>Merges a specified <see cref="T:System.Data.DataSet" />
    ///  and its schema into the current <see langword="DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The <see langword="DataSet" />
    ///  whose data and schema will be merged. </param>
    ///<exception cref="T:System.Data.ConstraintException">One or more constraints cannot be enabled. </exception><exception cref="T:System.ArgumentNullException">The <paramref name="dataSet" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure Merge(dataSet: DNDataSet); overload;
    ///<summary>Merges a specified <see cref="T:System.Data.DataSet" />
    ///  and its schema into the current <see langword="DataSet" />
    ///  , preserving or discarding any changes in this <see langword="DataSet" />
    ///  according to the given argument.</summary>
    ///  <param name="dataSet">The <see langword="DataSet" />
    ///  whose data and schema will be merged. </param>
    ///  <param name="preserveChanges"><see langword="true" />
    ///  to preserve changes in the current <see langword="DataSet" />
    ///  ; otherwise <see langword="false" />
    ///  . </param>
    procedure Merge(dataSet: DNDataSet; preserveChanges: Boolean); overload;
    ///<summary>Merges a specified <see cref="T:System.Data.DataSet" />
    ///  and its schema with the current <see langword="DataSet" />
    ///  , preserving or discarding changes in the current <see langword="DataSet" />
    ///  and handling an incompatible schema according to the given arguments.</summary>
    ///  <param name="dataSet">The <see langword="DataSet" />
    ///  whose data and schema will be merged. </param>
    ///  <param name="preserveChanges"><see langword="true" />
    ///  to preserve changes in the current <see langword="DataSet" />
    ///  ; otherwise <see langword="false" />
    ///  . </param>
    ///  <param name="missingSchemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="dataSet" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure Merge(dataSet: DNDataSet; preserveChanges: Boolean; missingSchemaAction: DNMissingSchemaAction); overload;
    ///<summary>Merges a specified <see cref="T:System.Data.DataTable" />
    ///  and its schema into the current <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="table">The <see cref="T:System.Data.DataTable" />
    ///  whose data and schema will be merged. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="table" />
    ///  is <see langword="null" />
    ///  .</exception>
    procedure Merge(table: DNDataTable); overload;
    ///<summary>Merges a specified <see cref="T:System.Data.DataTable" />
    ///  and its schema into the current <see langword="DataSet" />
    ///  , preserving or discarding changes in the <see langword="DataSet" />
    ///  and handling an incompatible schema according to the given arguments.</summary>
    ///  <param name="table">The <see langword="DataTable" />
    ///  whose data and schema will be merged. </param>
    ///  <param name="preserveChanges">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </param>
    ///  <param name="missingSchemaAction"><see langword="true" />
    ///  to preserve changes in the <see langword="DataSet" />
    ///  ; otherwise <see langword="false" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="dataSet" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure Merge(table: DNDataTable; preserveChanges: Boolean; missingSchemaAction: DNMissingSchemaAction); overload;
    ///<summary>Merges an array of <see cref="T:System.Data.DataRow" />
    ///  objects into the current <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="rows">The array of <see langword="DataRow" />
    ///  objects to be merged into the <see langword="DataSet" />
    ///  . </param>
    procedure Merge(rows: TArray<DNDataRow>); overload;
    ///<summary>Merges an array of <see cref="T:System.Data.DataRow" />
    ///  objects into the current <see cref="T:System.Data.DataSet" />
    ///  , preserving or discarding changes in the <see langword="DataSet" />
    ///  and handling an incompatible schema according to the given arguments.</summary>
    ///  <param name="rows">The array of <see cref="T:System.Data.DataRow" />
    ///  objects to be merged into the <see langword="DataSet" />
    ///  . </param>
    ///  <param name="preserveChanges"><see langword="true" />
    ///  to preserve changes in the <see langword="DataSet" />
    ///  ; otherwise <see langword="false" />
    ///  . </param>
    ///  <param name="missingSchemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </param>
    procedure Merge(rows: TArray<DNDataRow>; preserveChanges: Boolean; missingSchemaAction: DNMissingSchemaAction); overload;
    ///<summary>Rolls back all the changes made to the <see cref="T:System.Data.DataSet" />
    ///  since it was created, or since the last time <see cref="M:System.Data.DataSet.AcceptChanges" />
    ///  was called.</summary>
    procedure RejectChanges;
    ///<summary>Clears all tables and removes all relations, foreign constraints, and tables from the <see cref="T:System.Data.DataSet" />
    ///  . Subclasses should override <see cref="M:System.Data.DataSet.Reset" />
    ///  to restore a <see cref="T:System.Data.DataSet" />
    ///  to its original state.</summary>
    procedure Reset;
    ///<summary>Fills a <see cref="T:System.Data.DataSet" />
    ///  with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />
    ///  , using an array of <see cref="T:System.Data.DataTable" />
    ///  instances to supply the schema and namespace information.</summary>
    ///  <param name="reader">An <see cref="T:System.Data.IDataReader" />
    ///  that provides one or more result sets.</param>
    ///  <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" />
    ///  enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" />
    ///  instances within the <see cref="T:System.Data.DataSet" />
    ///  will be combined with incoming rows that share the same primary key. </param>
    ///  <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" />
    ///  delegate to call when an error occurs while loading data.</param>
    ///  <param name="tables">An array of <see cref="T:System.Data.DataTable" />
    ///  instances, from which the <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
    ///  method retrieves name and namespace information.</param>
    procedure Load(reader: DNIDataReader; loadOption: DNLoadOption; errorHandler: DNFillErrorEventHandler; tables: TArray<DNDataTable>); overload;
    ///<summary>Fills a <see cref="T:System.Data.DataSet" />
    ///  with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />
    ///  , using an array of <see cref="T:System.Data.DataTable" />
    ///  instances to supply the schema and namespace information.</summary>
    ///  <param name="reader">An <see cref="T:System.Data.IDataReader" />
    ///  that provides one or more result sets. </param>
    ///  <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" />
    ///  enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" />
    ///  instances within the <see cref="T:System.Data.DataSet" />
    ///  will be combined with incoming rows that share the same primary key. </param>
    ///  <param name="tables">An array of <see cref="T:System.Data.DataTable" />
    ///  instances, from which the <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
    ///  method retrieves name and namespace information. Each of these tables must be a member of the <see cref="T:System.Data.DataTableCollection" />
    ///  contained by this <see cref="T:System.Data.DataSet" />
    ///  .</param>
    procedure Load(reader: DNIDataReader; loadOption: DNLoadOption; tables: TArray<DNDataTable>); overload;
    ///<summary>Fills a <see cref="T:System.Data.DataSet" />
    ///  with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />
    ///  , using an array of strings to supply the names for the tables within the <see langword="DataSet" />
    ///  .</summary>
    ///  <param name="reader">An <see cref="T:System.Data.IDataReader" />
    ///  that provides one or more result sets.</param>
    ///  <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" />
    ///  enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" />
    ///  instances within the <see langword="DataSet" />
    ///  will be combined with incoming rows that share the same primary key. </param>
    ///  <param name="tables">An array of strings, from which the <see langword="Load" />
    ///  method retrieves table name information.</param>
    procedure Load(reader: DNIDataReader; loadOption: DNLoadOption; tables: TArray<string>); overload;
    ///<summary>Returns a <see cref="T:System.Data.DataTableReader" />
    ///  with one result set per <see cref="T:System.Data.DataTable" />
    ///  , in the same sequence as the tables appear in the <see cref="P:System.Data.DataSet.Tables" />
    ///  collection.</summary>
    ///<returns>A <see cref="T:System.Data.DataTableReader" />
    ///  containing one or more result sets, corresponding to the <see cref="T:System.Data.DataTable" />
    ///  instances contained within the source <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function CreateDataReader: DNDataTableReader; overload;
    ///<summary>Returns a <see cref="T:System.Data.DataTableReader" />
    ///  with one result set per <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataTables">An array of DataTables providing the order of the result sets to be returned in the <see cref="T:System.Data.DataTableReader" />
    ///  .</param>
    ///<returns>A <see cref="T:System.Data.DataTableReader" />
    ///  containing one or more result sets, corresponding to the <see cref="T:System.Data.DataTable" />
    ///  instances contained within the source <see cref="T:System.Data.DataSet" />
    ///  . The returned result sets are in the order specified by the <paramref name="dataTables" />
    ///  parameter.</returns>
    function CreateDataReader(dataTables: TArray<DNDataTable>): DNDataTableReader; overload;
    procedure Dispose;
    function GetService(service: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets a <see cref="T:System.Data.SerializationFormat" />
    ///  for the <see cref="T:System.Data.DataSet" />
    ///  used during remoting.</summary>
    ///<returns>A <see cref="T:System.Data.SerializationFormat" />
    ///  object.</returns>
    property RemotingFormat: DNSerializationFormat read get_RemotingFormat write set_RemotingFormat;
    ///<summary>Gets or sets a <see cref="T:System.Data.SchemaSerializationMode" />
    ///  for a <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>Gets or sets a <see cref="T:System.Data.SchemaSerializationMode" />
    ///  for a <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property SchemaSerializationMode: DNSchemaSerializationMode read get_SchemaSerializationMode write set_SchemaSerializationMode;
    ///<summary>Gets or sets a value indicating whether string comparisons within <see cref="T:System.Data.DataTable" />
    ///  objects are case-sensitive.</summary>
    ///<returns><see langword="true" />
    ///  if string comparisons are case-sensitive; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property CaseSensitive: Boolean read get_CaseSensitive write set_CaseSensitive;
    ///<summary>Gets a custom view of the data contained in the <see cref="T:System.Data.DataSet" />
    ///  to allow filtering, searching, and navigating using a custom <see cref="T:System.Data.DataViewManager" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataViewManager" />
    ///  object.</returns>
    property DefaultViewManager: DNDataViewManager read get_DefaultViewManager;
    ///<summary>Gets or sets a value indicating whether constraint rules are followed when attempting any update operation.</summary>
    ///<returns><see langword="true" />
    ///  if rules are enforced; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    ///<exception cref="T:System.Data.ConstraintException">One or more constraints cannot be enforced. </exception>
    property EnforceConstraints: Boolean read get_EnforceConstraints write set_EnforceConstraints;
    ///<summary>Gets or sets the name of the current <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property DataSetName: string read get_DataSetName write set_DataSetName;
    ///<summary>Gets or sets the namespace of the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>The namespace of the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The namespace already has data. </exception>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets an XML prefix that aliases the namespace of the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>The XML prefix for the <see cref="T:System.Data.DataSet" />
    ///  namespace.</returns>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the collection of customized user information associated with the <see langword="DataSet" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  with all custom user information.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
    ///<summary>Gets a value indicating whether there are errors in any of the <see cref="T:System.Data.DataTable" />
    ///  objects within this <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if any table contains an error;otherwise <see langword="false" />
    ///  .</returns>
    property HasErrors: Boolean read get_HasErrors;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.DataSet" />
    ///  is initialized.</summary>
    ///<returns><see langword="true" />
    ///  to indicate the component has completed initialization; otherwise <see langword="false" />
    ///  .</returns>
    property IsInitialized: Boolean read get_IsInitialized;
    ///<summary>Gets or sets the locale information used to compare strings within the table.</summary>
    ///<returns>A <see cref="T:System.Globalization.CultureInfo" />
    ///  that contains data about the user's machine locale. The default is <see langword="null" />
    ///  .</returns>
    property Locale: DDN.mscorlib.DNCultureInfo read get_Locale write set_Locale;
    ///<summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" />
    ///  for the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.ComponentModel.ISite" />
    ///  for the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property Site: DDN.System.DNISite read get_Site write set_Site;
    ///<summary>Get the collection of relations that link tables and allow navigation from parent tables to child tables.</summary>
    ///<returns>A <see cref="T:System.Data.DataRelationCollection" />
    ///  that contains a collection of <see cref="T:System.Data.DataRelation" />
    ///  objects. An empty collection is returned if no <see cref="T:System.Data.DataRelation" />
    ///  objects exist.</returns>
    property Relations: DNDataRelationCollection read get_Relations;
    ///<summary>Gets the collection of tables contained in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.DataTableCollection" />
    ///  contained by this <see cref="T:System.Data.DataSet" />
    ///  . An empty collection is returned if no <see cref="T:System.Data.DataTable" />
    ///  objects exist.</returns>
    property Tables: DNDataTableCollection read get_Tables;
    property Container: DDN.System.DNIContainer read get_Container;
    property DesignMode: Boolean read get_DesignMode;
  end;

  TDNDataSet = class(TDNGenericImport<DNDataSetClass, DNDataSet>) end;

  //-------------namespace: System.Data----------------
  DNDataTableClass = interface(DNObjectClass)
  ['{00EA467F-E9AF-5824-8F4E-345226A80AD5}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" />
    ///  class with no arguments.</summary>
    {class} function init: DNDataTable; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" />
    ///  class with the specified table name.</summary>
    ///  <param name="tableName">The name to give the table. If <paramref name="tableName" />
    ///  is <see langword="null" />
    ///  or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />
    ///  . </param>
    {class} function init(tableName: string): DNDataTable; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" />
    ///  class using the specified table name and namespace.</summary>
    ///  <param name="tableName">The name to give the table. If <paramref name="tableName" />
    ///  is <see langword="null" />
    ///  or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />
    ///  . </param>
    ///  <param name="tableNamespace">The namespace for the XML representation of the data stored in the <see langword="DataTable" />
    ///  . </param>
    {class} function init(tableName: string; tableNamespace: string): DNDataTable; overload;

  { static methods } 

    ///<summary>This method returns an <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  instance containing the Web Services Description Language (WSDL) that describes the <see cref="T:System.Data.DataTable" />
    ///  for Web Services.</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  instance.</param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  instance.</returns>
    {class} function GetDataTableSchema(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlSchemaComplexType;

  end;

  ///<summary>Represents one table of in-memory data.</summary>
  [DNTypeName('System.Data.DataTable')]
  DNDataTable = interface(DNObject)
  ['{56839C77-582D-3A29-AEB5-7011A8335593}']
  { getters & setters } 

    function get_CaseSensitive: Boolean;
    procedure set_CaseSensitive(value: Boolean);
    function get_IsInitialized: Boolean;
    function get_RemotingFormat: DNSerializationFormat;
    procedure set_RemotingFormat(value: DNSerializationFormat);
    function get_ChildRelations: DNDataRelationCollection;
    function get_Columns: DNDataColumnCollection;
    function get_Constraints: DNConstraintCollection;
    function get_DataSet: DNDataSet;
    function get_DefaultView: DNDataView;
    function get_DisplayExpression: string;
    procedure set_DisplayExpression(value: string);
    function get_ExtendedProperties: DNPropertyCollection;
    function get_HasErrors: Boolean;
    function get_Locale: DDN.mscorlib.DNCultureInfo;
    procedure set_Locale(value: DDN.mscorlib.DNCultureInfo);
    function get_MinimumCapacity: Int32;
    procedure set_MinimumCapacity(value: Int32);
    function get_ParentRelations: DNDataRelationCollection;
    function get_PrimaryKey: TArray<DNDataColumn>;
    procedure set_PrimaryKey(value: TArray<DNDataColumn>);
    function get_Rows: DNDataRowCollection;
    function get_TableName: string;
    procedure set_TableName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;
    function get_DesignMode: Boolean;

  { events } 

    procedure add_ColumnChanging(value: DNDataColumnChangeEventHandler);
    procedure remove_ColumnChanging(value: DNDataColumnChangeEventHandler);
    procedure add_ColumnChanged(value: DNDataColumnChangeEventHandler);
    procedure remove_ColumnChanged(value: DNDataColumnChangeEventHandler);
    procedure add_Initialized(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Initialized(value: DDN.mscorlib.DNEventHandler);
    procedure add_RowChanged(value: DNDataRowChangeEventHandler);
    procedure remove_RowChanged(value: DNDataRowChangeEventHandler);
    procedure add_RowChanging(value: DNDataRowChangeEventHandler);
    procedure remove_RowChanging(value: DNDataRowChangeEventHandler);
    procedure add_RowDeleting(value: DNDataRowChangeEventHandler);
    procedure remove_RowDeleting(value: DNDataRowChangeEventHandler);
    procedure add_RowDeleted(value: DNDataRowChangeEventHandler);
    procedure remove_RowDeleted(value: DNDataRowChangeEventHandler);
    procedure add_TableClearing(value: DNDataTableClearEventHandler);
    procedure remove_TableClearing(value: DNDataTableClearEventHandler);
    procedure add_TableCleared(value: DNDataTableClearEventHandler);
    procedure remove_TableCleared(value: DNDataTableClearEventHandler);
    procedure add_TableNewRow(value: DNDataTableNewRowEventHandler);
    procedure remove_TableNewRow(value: DNDataTableNewRowEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Populates a serialization information object with the data needed to serialize the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that holds the serialized data associated with the <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///  <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="info" />
    ///  parameter is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    ///<summary>Begins the initialization of a <see cref="T:System.Data.DataTable" />
    ///  that is used on a form or used by another component. The initialization occurs at run time. </summary>
    procedure BeginInit;
    ///<summary>Ends the initialization of a <see cref="T:System.Data.DataTable" />
    ///  that is used on a form or used by another component. The initialization occurs at run time.</summary>
    procedure EndInit;
    ///<summary>Commits all the changes made to this table since the last time <see cref="M:System.Data.DataTable.AcceptChanges" />
    ///  was called.</summary>
    procedure AcceptChanges;
    ///<summary>Clones the structure of the <see cref="T:System.Data.DataTable" />
    ///  , including all <see cref="T:System.Data.DataTable" />
    ///  schemas and constraints.</summary>
    ///<returns>A new <see cref="T:System.Data.DataTable" />
    ///  with the same schema as the current <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function Clone: DNDataTable;
    ///<summary>Copies both the structure and data for this <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.DataTable" />
    ///  with the same structure (table schemas and constraints) and data as this <see cref="T:System.Data.DataTable" />
    ///  .If these classes have been derived, the copy will also be of the same derived classes.
    ///<see cref="M:System.Data.DataTable.Copy" />
    ///  creates a new <see cref="T:System.Data.DataTable" />
    ///  with the same structure and data as the original <see cref="T:System.Data.DataTable" />
    ///  . To copy the structure to a new <see cref="T:System.Data.DataTable" />
    ///  , but not the data, use <see cref="M:System.Data.DataTable.Clone" />
    ///  .</returns>
    function Copy: DNDataTable;
    ///<summary>Clears the <see cref="T:System.Data.DataTable" />
    ///  of all data.</summary>
    procedure Clear;
    ///<summary>Computes the given expression on the current rows that pass the filter criteria.</summary>
    ///  <param name="expression">The expression to compute. </param>
    ///  <param name="filter">The filter to limit the rows that evaluate in the expression. </param>
    ///<returns>An <see cref="T:System.Object" />
    ///  , set to the result of the computation. If the expression evaluates to null, the return value will be <see cref="F:System.DBNull.Value" />
    ///  .</returns>
    function Compute(expression: string; filter: string): DDN.mscorlib.DNObject;
    ///<summary>Gets a copy of the <see cref="T:System.Data.DataTable" />
    ///  that contains all changes made to it since it was loaded or <see cref="M:System.Data.DataTable.AcceptChanges" />
    ///  was last called.</summary>
    ///<returns>A copy of the changes from this <see cref="T:System.Data.DataTable" />
    ///  , or <see langword="null" />
    ///  if no changes are found.</returns>
    function GetChanges: DNDataTable; overload;
    ///<summary>Gets a copy of the <see cref="T:System.Data.DataTable" />
    ///  containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" />
    ///  was called, filtered by <see cref="T:System.Data.DataRowState" />
    ///  .</summary>
    ///  <param name="rowStates">One of the <see cref="T:System.Data.DataRowState" />
    ///  values. </param>
    ///<returns>A filtered copy of the <see cref="T:System.Data.DataTable" />
    ///  that can have actions performed on it, and later be merged back in the <see cref="T:System.Data.DataTable" />
    ///  using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
    ///  . If no rows of the desired <see cref="T:System.Data.DataRowState" />
    ///  are found, the method returns <see langword="null" />
    ///  .</returns>
    function GetChanges(rowStates: DNDataRowState): DNDataTable; overload;
    ///<summary>Gets an array of <see cref="T:System.Data.DataRow" />
    ///  objects that contain errors.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects that have errors.</returns>
    function GetErrors: TArray<DNDataRow>;
    ///<summary>Copies a <see cref="T:System.Data.DataRow" />
    ///  into a <see cref="T:System.Data.DataTable" />
    ///  , preserving any property settings, as well as original and current values.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  to be imported. </param>
    procedure ImportRow(row: DNDataRow);
    ///<summary>Creates a new <see cref="T:System.Data.DataRow" />
    ///  with the same schema as the table.</summary>
    ///<returns>A <see cref="T:System.Data.DataRow" />
    ///  with the same schema as the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function NewRow: DNDataRow;
    ///<summary>Rolls back all changes that have been made to the table since it was loaded, or the last time <see cref="M:System.Data.DataTable.AcceptChanges" />
    ///  was called.</summary>
    procedure RejectChanges;
    ///<summary>Resets the <see cref="T:System.Data.DataTable" />
    ///  to its original state. Reset removes all data, indexes, relations, and columns of the table. If a DataSet includes a DataTable, the table will still be part of the DataSet after the table is reset.</summary>
    procedure Reset;
    ///<summary>Gets an array of all <see cref="T:System.Data.DataRow" />
    ///  objects.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects.</returns>
    function Select: TArray<DNDataRow>; overload;
    ///<summary>Gets an array of all <see cref="T:System.Data.DataRow" />
    ///  objects that match the filter criteria.</summary>
    ///  <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see DataView RowFilter Syntax [C#].</param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects.</returns>
    function Select(filterExpression: string): TArray<DNDataRow>; overload;
    ///<summary>Gets an array of all <see cref="T:System.Data.DataRow" />
    ///  objects that match the filter criteria, in the specified sort order.</summary>
    ///  <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see DataView RowFilter Syntax [C#].</param>
    ///  <param name="sort">A string specifying the column and sort direction. </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects matching the filter expression.</returns>
    function Select(filterExpression: string; sort: string): TArray<DNDataRow>; overload;
    ///<summary>Gets an array of all <see cref="T:System.Data.DataRow" />
    ///  objects that match the filter in the order of the sort that match the specified state.</summary>
    ///  <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see DataView RowFilter Syntax [C#].</param>
    ///  <param name="sort">A string specifying the column and sort direction. </param>
    ///  <param name="recordStates">One of the <see cref="T:System.Data.DataViewRowState" />
    ///  values.</param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects.</returns>
    function Select(filterExpression: string; sort: string; recordStates: DNDataViewRowState): TArray<DNDataRow>; overload;
    ///<summary>Gets the <see cref="P:System.Data.DataTable.TableName" />
    ///  and <see cref="P:System.Data.DataTable.DisplayExpression" />
    ///  , if there is one as a concatenated string.</summary>
    ///<returns>A string consisting of the <see cref="P:System.Data.DataTable.TableName" />
    ///  and the <see cref="P:System.Data.DataTable.DisplayExpression" />
    ///  values.</returns>
    function ToString: string;
    ///<summary>Turns off notifications, index maintenance, and constraints while loading data.</summary>
    procedure BeginLoadData;
    ///<summary>Turns on notifications, index maintenance, and constraints after loading data.</summary>
    procedure EndLoadData;
    ///<summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
    ///  <param name="values">An array of values used to create the new row. </param>
    ///  <param name="fAcceptChanges"><see langword="true" />
    ///  to accept changes; otherwise <see langword="false" />
    ///  . </param>
    ///<returns>The new <see cref="T:System.Data.DataRow" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The array is larger than the number of columns in the table. </exception><exception cref="T:System.InvalidCastException">A value doesn't match its respective column type. </exception><exception cref="T:System.Data.ConstraintException">Adding the row invalidates a constraint. </exception><exception cref="T:System.Data.NoNullAllowedException">Attempting to put a null in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" />
    ///  is false. </exception>
    function LoadDataRow(values: TArray<DDN.mscorlib.DNObject>; fAcceptChanges: Boolean): DNDataRow; overload;
    ///<summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
    ///  <param name="values">An array of values used to create the new row. </param>
    ///  <param name="loadOption">Used to determine how the array values are applied to the corresponding values in an existing row. </param>
    ///<returns>The new <see cref="T:System.Data.DataRow" />
    ///  .</returns>
    function LoadDataRow(values: TArray<DDN.mscorlib.DNObject>; loadOption: DNLoadOption): DNDataRow; overload;
    ///<summary>Merge the specified <see cref="T:System.Data.DataTable" />
    ///  with the current <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="table">The <see cref="T:System.Data.DataTable" />
    ///  to be merged with the current <see cref="T:System.Data.DataTable" />
    ///  .</param>
    procedure Merge(table: DNDataTable); overload;
    ///<summary>Merge the specified <see cref="T:System.Data.DataTable" />
    ///  with the current <see langword="DataTable" />
    ///  , indicating whether to preserve changes in the current <see langword="DataTable" />
    ///  .</summary>
    ///  <param name="table">The <see langword="DataTable" />
    ///  to be merged with the current <see langword="DataTable" />
    ///  .</param>
    ///  <param name="preserveChanges"><see langword="true" />
    ///  , to preserve changes in the current <see langword="DataTable" />
    ///  ; otherwise <see langword="false" />
    ///  .<see langword="" />
    ///</param>
    procedure Merge(table: DNDataTable; preserveChanges: Boolean); overload;
    ///<summary>Merge the specified <see cref="T:System.Data.DataTable" />
    ///  with the current <see langword="DataTable" />
    ///  , indicating whether to preserve changes and how to handle missing schema in the current <see langword="DataTable" />
    ///  .</summary>
    ///  <param name="table">The <see cref="T:System.Data.DataTable" />
    ///  to be merged with the current <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///  <param name="preserveChanges"><see langword="true" />
    ///  , to preserve changes in the current <see cref="T:System.Data.DataTable" />
    ///  ; otherwise <see langword="false" />
    ///  .</param>
    ///  <param name="missingSchemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </param>
    procedure Merge(table: DNDataTable; preserveChanges: Boolean; missingSchemaAction: DNMissingSchemaAction); overload;
    ///<summary>Fills a <see cref="T:System.Data.DataTable" />
    ///  with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />
    ///  . If the <see cref="T:System.Data.DataTable" />
    ///  already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
    ///  <param name="reader">An <see cref="T:System.Data.IDataReader" />
    ///  that provides a result set.</param>
    procedure Load(reader: DNIDataReader); overload;
    ///<summary>Fills a <see cref="T:System.Data.DataTable" />
    ///  with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />
    ///  . If the <see langword="DataTable" />
    ///  already contains rows, the incoming data from the data source is merged with the existing rows according to the value of the <paramref name="loadOption" />
    ///  parameter.</summary>
    ///  <param name="reader">An <see cref="T:System.Data.IDataReader" />
    ///  that provides one or more result sets.</param>
    ///  <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" />
    ///  enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" />
    ///  are combined with incoming rows that share the same primary key. </param>
    procedure Load(reader: DNIDataReader; loadOption: DNLoadOption); overload;
    ///<summary>Fills a <see cref="T:System.Data.DataTable" />
    ///  with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />
    ///  using an error-handling delegate.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.IDataReader" />
    ///  that provides a result set.</param>
    ///  <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" />
    ///  enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" />
    ///  are combined with incoming rows that share the same primary key. </param>
    ///  <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" />
    ///  delegate to call when an error occurs while loading data.</param>
    procedure Load(reader: DNIDataReader; loadOption: DNLoadOption; errorHandler: DNFillErrorEventHandler); overload;
    ///<summary>Returns a <see cref="T:System.Data.DataTableReader" />
    ///  corresponding to the data within this <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTableReader" />
    ///  containing one result set, corresponding to the source <see cref="T:System.Data.DataTable" />
    ///  instance.</returns>
    function CreateDataReader: DNDataTableReader;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="stream">The stream to which the data will be written. </param>
    procedure WriteXml(stream: DDN.mscorlib.DNStream); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified <see cref="T:System.IO.Stream" />
    ///  . To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="stream">The stream to which the data will be written. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(stream: DDN.mscorlib.DNStream; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  with which to write the content. </param>
    procedure WriteXml(writer: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified <see cref="T:System.IO.TextWriter" />
    ///  . To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  with which to write the content. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(writer: DDN.mscorlib.DNTextWriter; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  with which to write the contents. </param>
    procedure WriteXml(writer: DDN.System.Xml.DNXmlWriter); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . </summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  with which to write the contents. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(writer: DDN.System.Xml.DNXmlWriter; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified file.</summary>
    ///  <param name="fileName">The file to which to write the XML data.</param>
    procedure WriteXml(fileName: string); overload;
    ///<summary>Writes the current contents of the <see cref="T:System.Data.DataTable" />
    ///  as XML using the specified file. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="fileName">The file to which to write the XML data.</param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(fileName: string; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="stream">The stream to which the data will be written. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values.</param>
    procedure WriteXml(stream: DDN.mscorlib.DNStream; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  . To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="stream">The stream to which the data will be written. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(stream: DDN.mscorlib.DNStream; mode: DNXmlWriteMode; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.IO.TextWriter" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  used to write the document. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    procedure WriteXml(writer: DDN.mscorlib.DNTextWriter; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.IO.TextWriter" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  . To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  used to write the document. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(writer: DDN.mscorlib.DNTextWriter; mode: DNXmlWriteMode; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the document. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    procedure WriteXml(writer: DDN.System.Xml.DNXmlWriter; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  . To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the document. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(writer: DDN.System.Xml.DNXmlWriter; mode: DNXmlWriteMode; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  using the specified file and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  .</summary>
    ///  <param name="fileName">The name of the file to which the data will be written. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    procedure WriteXml(fileName: string; mode: DNXmlWriteMode); overload;
    ///<summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" />
    ///  using the specified file and <see cref="T:System.Data.XmlWriteMode" />
    ///  . To write the schema, set the value for the <paramref name="mode" />
    ///  parameter to <see langword="WriteSchema" />
    ///  . To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="fileName">The name of the file to which the data will be written. </param>
    ///  <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" />
    ///  values. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the contents of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the data for the current table only.</param>
    procedure WriteXml(fileName: string; mode: DNXmlWriteMode; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema to the specified stream.</summary>
    ///  <param name="stream">The stream to which the XML schema will be written. </param>
    procedure WriteXmlSchema(stream: DDN.mscorlib.DNStream); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema to the specified stream. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="stream">The stream to which the XML schema will be written. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the schema of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the schema for the current table only.</param>
    procedure WriteXmlSchema(stream: DDN.mscorlib.DNStream; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema using the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  with which to write. </param>
    procedure WriteXmlSchema(writer: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema using the specified <see cref="T:System.IO.TextWriter" />
    ///  . To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  with which to write. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the schema of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the schema for the current table only.</param>
    procedure WriteXmlSchema(writer: DDN.mscorlib.DNTextWriter; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  to use. </param>
    procedure WriteXmlSchema(writer: DDN.System.Xml.DNXmlWriter); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the document. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the schema of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the schema for the current table only.</param>
    procedure WriteXmlSchema(writer: DDN.System.Xml.DNXmlWriter; writeHierarchy: Boolean); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema to the specified file.</summary>
    ///  <param name="fileName">The name of the file to use. </param>
    procedure WriteXmlSchema(fileName: string); overload;
    ///<summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" />
    ///  as an XML schema to the specified file. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" />
    ///  parameter to <see langword="true" />
    ///  .</summary>
    ///  <param name="fileName">The name of the file to use. </param>
    ///  <param name="writeHierarchy">If <see langword="true" />
    ///  , write the schema of the current table and all its descendants. If <see langword="false" />
    ///  (the default value), write the schema for the current table only.</param>
    procedure WriteXmlSchema(fileName: string; writeHierarchy: Boolean); overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="stream">An object that derives from <see cref="T:System.IO.Stream" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(stream: DDN.mscorlib.DNStream): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.IO.TextReader" />
    ///  that will be used to read the data.</param>
    ///<returns>The <see cref="T:System.Data.XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(reader: DDN.mscorlib.DNTextReader): DNXmlReadMode; overload;
    ///<summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" />
    ///  from the specified file.</summary>
    ///  <param name="fileName">The name of the file from which to read the data. </param>
    ///<returns>The <see cref="T:System.Data.XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(fileName: string): DNXmlReadMode; overload;
    ///<summary>Reads XML Schema and Data into the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.Xml.XmlReader" />
    ///  . </summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  that will be used to read the data. </param>
    ///<returns>The <see cref="T:System.Data.XmlReadMode" />
    ///  used to read the data.</returns>
    function ReadXml(reader: DDN.System.Xml.DNXmlReader): DNXmlReadMode; overload;
    ///<summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />
    ///  using the specified stream.</summary>
    ///  <param name="stream">The stream used to read the schema. </param>
    procedure ReadXmlSchema(stream: DDN.mscorlib.DNStream); overload;
    ///<summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.IO.TextReader" />
    ///  used to read the schema information. </param>
    procedure ReadXmlSchema(reader: DDN.mscorlib.DNTextReader); overload;
    ///<summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />
    ///  from the specified file.</summary>
    ///  <param name="fileName">The name of the file from which to read the schema information. </param>
    procedure ReadXmlSchema(fileName: string); overload;
    ///<summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  used to read the schema information. </param>
    procedure ReadXmlSchema(reader: DDN.System.Xml.DNXmlReader); overload;
    procedure Dispose;
    function GetService(service: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether string comparisons within the table are case-sensitive.</summary>
    ///<returns><see langword="true" />
    ///  if the comparison is case-sensitive; otherwise <see langword="false" />
    ///  . The default is set to the parent <see cref="T:System.Data.DataSet" />
    ///  object's <see cref="P:System.Data.DataSet.CaseSensitive" />
    ///  property, or <see langword="false" />
    ///  if the <see cref="T:System.Data.DataTable" />
    ///  was created independently of a <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property CaseSensitive: Boolean read get_CaseSensitive write set_CaseSensitive;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.DataTable" />
    ///  is initialized.</summary>
    ///<returns><see langword="true" />
    ///  to indicate the component has completed initialization; otherwise <see langword="false" />
    ///  . </returns>
    property IsInitialized: Boolean read get_IsInitialized;
    ///<summary>Gets or sets the serialization format.</summary>
    ///<returns>A <see cref="T:System.Data.SerializationFormat" />
    ///  enumeration specifying either <see langword="Binary" />
    ///  or <see langword="Xml" />
    ///  serialization.</returns>
    property RemotingFormat: DNSerializationFormat read get_RemotingFormat write set_RemotingFormat;
    ///<summary>Gets the collection of child relations for this <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataRelationCollection" />
    ///  that contains the child relations for the table. An empty collection is returned if no <see cref="T:System.Data.DataRelation" />
    ///  objects exist.</returns>
    property ChildRelations: DNDataRelationCollection read get_ChildRelations;
    ///<summary>Gets the collection of columns that belong to this table.</summary>
    ///<returns>A <see cref="T:System.Data.DataColumnCollection" />
    ///  that contains the collection of <see cref="T:System.Data.DataColumn" />
    ///  objects for the table. An empty collection is returned if no <see cref="T:System.Data.DataColumn" />
    ///  objects exist.</returns>
    property Columns: DNDataColumnCollection read get_Columns;
    ///<summary>Gets the collection of constraints maintained by this table.</summary>
    ///<returns>A <see cref="T:System.Data.ConstraintCollection" />
    ///  that contains the collection of <see cref="T:System.Data.Constraint" />
    ///  objects for the table. An empty collection is returned if no <see cref="T:System.Data.Constraint" />
    ///  objects exist.</returns>
    property Constraints: DNConstraintCollection read get_Constraints;
    ///<summary>Gets the <see cref="T:System.Data.DataSet" />
    ///  to which this table belongs.</summary>
    ///<returns>The <see cref="T:System.Data.DataSet" />
    ///  to which this table belongs.</returns>
    property DataSet: DNDataSet read get_DataSet;
    ///<summary>Gets a customized view of the table that may include a filtered view, or a cursor position.</summary>
    ///<returns>The <see cref="T:System.Data.DataView" />
    ///  associated with the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    property DefaultView: DNDataView read get_DefaultView;
    ///<summary>Gets or sets the expression that returns a value used to represent this table in the user interface. The <see langword="DisplayExpression" />
    ///  property lets you display the name of this table in a user interface.</summary>
    ///<returns>A display string.</returns>
    property DisplayExpression: string read get_DisplayExpression write set_DisplayExpression;
    ///<summary>Gets the collection of customized user information.</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  that contains custom user information.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
    ///<summary>Gets a value indicating whether there are errors in any of the rows in any of the tables of the <see cref="T:System.Data.DataSet" />
    ///  to which the table belongs.</summary>
    ///<returns><see langword="true" />
    ///  if errors exist; otherwise <see langword="false" />
    ///  .</returns>
    property HasErrors: Boolean read get_HasErrors;
    ///<summary>Gets or sets the locale information used to compare strings within the table.</summary>
    ///<returns>A <see cref="T:System.Globalization.CultureInfo" />
    ///  that contains data about the user's machine locale. The default is the <see cref="T:System.Data.DataSet" />
    ///  object's <see cref="T:System.Globalization.CultureInfo" />
    ///  (returned by the <see cref="P:System.Data.DataSet.Locale" />
    ///  property) to which the <see cref="T:System.Data.DataTable" />
    ///  belongs; if the table doesn't belong to a <see cref="T:System.Data.DataSet" />
    ///  , the default is the current system <see cref="T:System.Globalization.CultureInfo" />
    ///  .</returns>
    property Locale: DDN.mscorlib.DNCultureInfo read get_Locale write set_Locale;
    ///<summary>Gets or sets the initial starting size for this table.</summary>
    ///<returns>The initial starting size in rows of this table. The default is 50.</returns>
    property MinimumCapacity: Int32 read get_MinimumCapacity write set_MinimumCapacity;
    ///<summary>Gets the collection of parent relations for this <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataRelationCollection" />
    ///  that contains the parent relations for the table. An empty collection is returned if no <see cref="T:System.Data.DataRelation" />
    ///  objects exist.</returns>
    property ParentRelations: DNDataRelationCollection read get_ParentRelations;
    ///<summary>Gets or sets an array of columns that function as primary keys for the data table.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects.</returns>
    ///<exception cref="T:System.Data.DataException">The key is a foreign key. </exception>
    property PrimaryKey: TArray<DNDataColumn> read get_PrimaryKey write set_PrimaryKey;
    ///<summary>Gets the collection of rows that belong to this table.</summary>
    ///<returns>A <see cref="T:System.Data.DataRowCollection" />
    ///  that contains <see cref="T:System.Data.DataRow" />
    ///  objects; otherwise a null value if no <see cref="T:System.Data.DataRow" />
    ///  objects exist.</returns>
    property Rows: DNDataRowCollection read get_Rows;
    ///<summary>Gets or sets the name of the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><see langword="null" />
    ///  or empty string ("") is passed in and this table belongs to a collection. </exception><exception cref="T:System.Data.DuplicateNameException">The table belongs to a collection that already has a table with the same name. (Comparison is case-sensitive).</exception>
    property TableName: string read get_TableName write set_TableName;
    ///<summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>The namespace of the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>The prefix of the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" />
    ///  for the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.ComponentModel.ISite" />
    ///  for the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
    property DesignMode: Boolean read get_DesignMode;
  end;

  TDNDataTable = class(TDNGenericImport<DNDataTableClass, DNDataTable>) end;

  //-------------namespace: System.Data----------------
  DNDataViewClass = interface(DNObjectClass)
  ['{6293E4A1-BAC8-5136-ACE2-021771D79AE2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataView" />
    ///  class.</summary>
    {class} function init: DNDataView; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataView" />
    ///  class with the specified <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  to add to the <see cref="T:System.Data.DataView" />
    ///  . </param>
    {class} function init(table: DNDataTable): DNDataView; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataView" />
    ///  class with the specified <see cref="T:System.Data.DataTable" />
    ///  , <see cref="P:System.Data.DataView.RowFilter" />
    ///  , <see cref="P:System.Data.DataView.Sort" />
    ///  , and <see cref="T:System.Data.DataViewRowState" />
    ///  .</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  to add to the <see cref="T:System.Data.DataView" />
    ///  . </param>
    ///  <param name="RowFilter">A <see cref="P:System.Data.DataView.RowFilter" />
    ///  to apply to the <see cref="T:System.Data.DataView" />
    ///  . </param>
    ///  <param name="Sort">A <see cref="P:System.Data.DataView.Sort" />
    ///  to apply to the <see cref="T:System.Data.DataView" />
    ///  . </param>
    ///  <param name="RowState">A <see cref="T:System.Data.DataViewRowState" />
    ///  to apply to the <see cref="T:System.Data.DataView" />
    ///  . </param>
    {class} function init(table: DNDataTable; RowFilter: string; Sort: string; RowState: DNDataViewRowState): DNDataView; overload;

  end;

  ///<summary>Represents a databindable, customized view of a <see cref="T:System.Data.DataTable" />
  ///  for sorting, filtering, searching, editing, and navigation. The <see cref="T:System.Data.DataView" />
  ///  does not store data, but instead represents a connected view of its corresponding <see cref="T:System.Data.DataTable" />
  ///  . Changes to the <see cref="T:System.Data.DataView" />
  ///  ’s data will affect the <see cref="T:System.Data.DataTable" />
  ///  . Changes to the <see cref="T:System.Data.DataTable" />
  ///  ’s data will affect all <see cref="T:System.Data.DataView" />
  ///  s associated with it.</summary>
  [DNTypeName('System.Data.DataView')]
  DNDataView = interface(DNObject)
  ['{954DCFBB-B6BF-3BAA-B683-D6ECDB9E8FD8}']
  { getters & setters } 

    function get_AllowDelete: Boolean;
    procedure set_AllowDelete(value: Boolean);
    function get_ApplyDefaultSort: Boolean;
    procedure set_ApplyDefaultSort(value: Boolean);
    function get_AllowEdit: Boolean;
    procedure set_AllowEdit(value: Boolean);
    function get_AllowNew: Boolean;
    procedure set_AllowNew(value: Boolean);
    function get_Count: Int32;
    function get_DataViewManager: DNDataViewManager;
    function get_IsInitialized: Boolean;
    function get_RowFilter: string;
    procedure set_RowFilter(value: string);
    function get_RowStateFilter: DNDataViewRowState;
    procedure set_RowStateFilter(value: DNDataViewRowState);
    function get_Sort: string;
    procedure set_Sort(value: string);
    function get_Table: DNDataTable;
    procedure set_Table(value: DNDataTable);
    function get_Item(recordIndex: Int32): DNDataRowView;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;
    function get_DesignMode: Boolean;

  { events } 

    procedure add_ListChanged(value: DDN.System.DNListChangedEventHandler);
    procedure remove_ListChanged(value: DDN.System.DNListChangedEventHandler);
    procedure add_Initialized(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Initialized(value: DDN.mscorlib.DNEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Starts the initialization of a <see cref="T:System.Data.DataView" />
    ///  that is used on a form or used by another component. The initialization occurs at runtime.</summary>
    procedure BeginInit;
    ///<summary>Ends the initialization of a <see cref="T:System.Data.DataView" />
    ///  that is used on a form or used by another component. The initialization occurs at runtime.</summary>
    procedure EndInit;
    ///<summary>Deletes a row at the specified index.</summary>
    ///  <param name="index">The index of the row to delete. </param>
    procedure Delete(index: Int32);
    ///<summary>Finds a row in the <see cref="T:System.Data.DataView" />
    ///  by the specified sort key value.</summary>
    ///  <param name="key">The object to search for. </param>
    ///<returns>The index of the row in the <see cref="T:System.Data.DataView" />
    ///  that contains the sort key value specified; otherwise -1 if the sort key value does not exist.</returns>
    function Find(key: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Finds a row in the <see cref="T:System.Data.DataView" />
    ///  by the specified sort key values.</summary>
    ///  <param name="key">An array of values, typed as <see cref="T:System.Object" />
    ///  . </param>
    ///<returns>The index of the position of the first row in the <see cref="T:System.Data.DataView" />
    ///  that matches the sort key values specified; otherwise -1 if there are no matching sort key values. </returns>
    function Find(key: TArray<DDN.mscorlib.DNObject>): Int32; overload;
    ///<summary>Returns an array of <see cref="T:System.Data.DataRowView" />
    ///  objects whose columns match the specified sort key value.</summary>
    ///  <param name="key">An array of column values, typed as <see cref="T:System.Object" />
    ///  , to search for. </param>
    ///<returns>An array of <see langword="DataRowView" />
    ///  objects whose columns match the specified sort key value; or, if no rows contain the specified sort key values, an empty <see langword="DataRowView" />
    ///  array.</returns>
    function FindRows(key: TArray<DDN.mscorlib.DNObject>): TArray<DNDataRowView>; overload;
    ///<summary>Creates and returns a new <see cref="T:System.Data.DataTable" />
    ///  based on rows in an existing <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///  <param name="distinct">If <see langword="true" />
    ///  , the returned <see cref="T:System.Data.DataTable" />
    ///  contains rows that have distinct values for all its columns. The default value is <see langword="false" />
    ///  .</param>
    ///  <param name="columnNames">A string array that contains a list of the column names to be included in the returned <see cref="T:System.Data.DataTable" />
    ///  . The <see cref="T:System.Data.DataTable" />
    ///  contains the specified columns in the order they appear within this array.</param>
    ///<returns>A new <see cref="T:System.Data.DataTable" />
    ///  instance that contains the requested rows and columns.</returns>
    function ToTable(distinct: Boolean; columnNames: TArray<string>): DNDataTable; overload;
    ///<summary>Determines whether the specified <see cref="T:System.Data.DataView" />
    ///  instances are considered equal. </summary>
    ///  <param name="view">The <see cref="T:System.Data.DataView" />
    ///  to be compared.</param>
    ///<returns><see langword="true" />
    ///  if the two <see cref="T:System.Data.DataView" />
    ///  instances are equal; otherwise, <see langword="false" />
    ///  . </returns>
    function Equals(view: DNDataView): Boolean; overload;
    ///<summary>Adds a new row to the <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.DataRowView" />
    ///  object.</returns>
    function AddNew: DNDataRowView;
    ///<summary>Copies items into an array. Only for Web Forms Interfaces.</summary>
    ///  <param name="array">array to copy into. </param>
    ///  <param name="index">index to start at. </param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32);
    ///<summary>Returns an array of <see cref="T:System.Data.DataRowView" />
    ///  objects whose columns match the specified sort key value.</summary>
    ///  <param name="key">The column value, typed as <see cref="T:System.Object" />
    ///  , to search for. </param>
    ///<returns>An array of <see langword="DataRowView" />
    ///  objects whose columns match the specified sort key value; or, if no rows contain the specified sort key values, an empty <see langword="DataRowView" />
    ///  array.</returns>
    function FindRows(key: DDN.mscorlib.DNObject): TArray<DNDataRowView>; overload;
    ///<summary>Gets an enumerator for this <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for navigating through the list.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Creates and returns a new <see cref="T:System.Data.DataTable" />
    ///  based on rows in an existing <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.DataTable" />
    ///  instance that contains the requested rows and columns.</returns>
    function ToTable: DNDataTable; overload;
    ///<summary>Creates and returns a new <see cref="T:System.Data.DataTable" />
    ///  based on rows in an existing <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///  <param name="tableName">The name of the returned <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///<returns>A new <see cref="T:System.Data.DataTable" />
    ///  instance that contains the requested rows and columns.</returns>
    function ToTable(tableName: string): DNDataTable; overload;
    ///<summary>Creates and returns a new <see cref="T:System.Data.DataTable" />
    ///  based on rows in an existing <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///  <param name="tableName">The name of the returned <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///  <param name="distinct">If <see langword="true" />
    ///  , the returned <see cref="T:System.Data.DataTable" />
    ///  contains rows that have distinct values for all its columns. The default value is <see langword="false" />
    ///  .</param>
    ///  <param name="columnNames">A string array that contains a list of the column names to be included in the returned <see cref="T:System.Data.DataTable" />
    ///  . The <see langword="DataTable" />
    ///  contains the specified columns in the order they appear within this array.</param>
    ///<returns>A new <see cref="T:System.Data.DataTable" />
    ///  instance that contains the requested rows and columns.</returns>
    function ToTable(tableName: string; distinct: Boolean; columnNames: TArray<string>): DNDataTable; overload;
    procedure Dispose;
    function GetService(service: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean; overload;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Sets or gets a value that indicates whether deletes are allowed.</summary>
    ///<returns><see langword="true" />
    ///  , if deletes are allowed; otherwise, <see langword="false" />
    ///  .</returns>
    property AllowDelete: Boolean read get_AllowDelete write set_AllowDelete;
    ///<summary>Gets or sets a value that indicates whether to use the default sort. The default sort is (ascending) by all primary keys as specified by <see cref="P:System.Data.DataTable.PrimaryKey" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  , if the default sort is used; otherwise, <see langword="false" />
    ///  .</returns>
    property ApplyDefaultSort: Boolean read get_ApplyDefaultSort write set_ApplyDefaultSort;
    ///<summary>Gets or sets a value that indicates whether edits are allowed.</summary>
    ///<returns><see langword="true" />
    ///  , if edits are allowed; otherwise, <see langword="false" />
    ///  .</returns>
    property AllowEdit: Boolean read get_AllowEdit write set_AllowEdit;
    ///<summary>Gets or sets a value that indicates whether the new rows can be added by using the <see cref="M:System.Data.DataView.AddNew" />
    ///  method.</summary>
    ///<returns><see langword="true" />
    ///  , if new rows can be added; otherwise, <see langword="false" />
    ///  .</returns>
    property AllowNew: Boolean read get_AllowNew write set_AllowNew;
    ///<summary>Gets the number of records in the <see cref="T:System.Data.DataView" />
    ///  after <see cref="P:System.Data.DataView.RowFilter" />
    ///  and <see cref="P:System.Data.DataView.RowStateFilter" />
    ///  have been applied.</summary>
    ///<returns>The number of records in the <see cref="T:System.Data.DataView" />
    ///  .</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets the <see cref="T:System.Data.DataViewManager" />
    ///  associated with this view.</summary>
    ///<returns>The <see langword="DataViewManager" />
    ///  that created this view. If this is the default <see cref="T:System.Data.DataView" />
    ///  for a <see cref="T:System.Data.DataTable" />
    ///  , the <see langword="DataViewManager" />
    ///  property returns the default <see langword="DataViewManager" />
    ///  for the <see langword="DataSet" />
    ///  . Otherwise, if the <see langword="DataView" />
    ///  was created without a <see langword="DataViewManager" />
    ///  , this property is <see langword="null" />
    ///  .</returns>
    property DataViewManager: DNDataViewManager read get_DataViewManager;
    ///<summary>Gets a value that indicates whether the component is initialized.</summary>
    ///<returns><see langword="true" />
    ///  to indicate the component has completed initialization; otherwise, <see langword="false" />
    ///  . </returns>
    property IsInitialized: Boolean read get_IsInitialized;
    ///<summary>Gets or sets the expression used to filter which rows are viewed in the <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>A string that specifies how rows are to be filtered. For more information, see the Remarks section.</returns>
    property RowFilter: string read get_RowFilter write set_RowFilter;
    ///<summary>Gets or sets the row state filter used in the <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataViewRowState" />
    ///  values.</returns>
    property RowStateFilter: DNDataViewRowState read get_RowStateFilter write set_RowStateFilter;
    ///<summary>Gets or sets the sort column or columns, and sort order for the <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>A string that contains the column name followed by "ASC" (ascending) or "DESC" (descending). Columns are sorted ascending by default. Multiple columns can be separated by commas.</returns>
    property Sort: string read get_Sort write set_Sort;
    ///<summary>Gets or sets the source <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that provides the data for this view.</returns>
    property Table: DNDataTable read get_Table write set_Table;
    property Item[recordIndex: Int32]: DNDataRowView read get_Item; default;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
    property DesignMode: Boolean read get_DesignMode;
  end;

  TDNDataView = class(TDNGenericImport<DNDataViewClass, DNDataView>) end;

  //-------------namespace: System.Data----------------
  DNDataViewManagerClass = interface(DNObjectClass)
  ['{FEFEA83B-9600-5D1E-8BF2-8A841409B4EF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataViewManager" />
    ///  class.</summary>
    {class} function init: DNDataViewManager; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataViewManager" />
    ///  class for the specified <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The name of the <see cref="T:System.Data.DataSet" />
    ///  to use. </param>
    {class} function init(dataSet: DNDataSet): DNDataViewManager; overload;

  end;

  ///<summary>Contains a default <see cref="T:System.Data.DataViewSettingCollection" />
  ///  for each <see cref="T:System.Data.DataTable" />
  ///  in a <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.DataViewManager')]
  DNDataViewManager = interface(DNObject)
  ['{720CC903-7243-397C-854C-1F8900F3F337}']
  { getters & setters } 

    function get_DataSet: DNDataSet;
    procedure set_DataSet(value: DNDataSet);
    function get_DataViewSettings: DNDataViewSettingCollection;
    function get_DataViewSettingCollectionString: string;
    procedure set_DataViewSettingCollectionString(value: string);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;
    function get_DesignMode: Boolean;

  { events } 

    procedure add_ListChanged(value: DDN.System.DNListChangedEventHandler);
    procedure remove_ListChanged(value: DDN.System.DNListChangedEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Creates a <see cref="T:System.Data.DataView" />
    ///  for the specified <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="table">The name of the <see cref="T:System.Data.DataTable" />
    ///  to use in the <see cref="T:System.Data.DataView" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.DataView" />
    ///  object.</returns>
    function CreateDataView(table: DNDataTable): DNDataView;
    procedure Dispose;
    function GetService(service: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.DataSet" />
    ///  to use with the <see cref="T:System.Data.DataViewManager" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.DataSet" />
    ///  to use.</returns>
    property DataSet: DNDataSet read get_DataSet write set_DataSet;
    ///<summary>Gets the <see cref="T:System.Data.DataViewSettingCollection" />
    ///  for each <see cref="T:System.Data.DataTable" />
    ///  in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataViewSettingCollection" />
    ///  for each <see langword="DataTable" />
    ///  .</returns>
    property DataViewSettings: DNDataViewSettingCollection read get_DataViewSettings;
    ///<summary>Gets or sets a value that is used for code persistence.</summary>
    ///<returns>A value that is used for code persistence.</returns>
    property DataViewSettingCollectionString: string read get_DataViewSettingCollectionString write set_DataViewSettingCollectionString;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
    property DesignMode: Boolean read get_DesignMode;
  end;

  TDNDataViewManager = class(TDNGenericImport<DNDataViewManagerClass, DNDataViewManager>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbColumnClass = interface(DDN.mscorlib.DNObjectClass)
  ['{FB6C5C4D-46F4-593C-8010-A3BAF6540872}']
  end;

  ///<summary>Represents a column within a data source.</summary>
  [DNTypeName('System.Data.Common.DbColumn')]
  DNDbColumn = interface(DDN.mscorlib.DNObject)
  ['{4742526D-9BC9-3BF6-9346-46EBB65DD1FF}']
  { getters & setters } 

    function get_AllowDBNull: DDN.mscorlib.DNNullable<Boolean>;
    function get_BaseCatalogName: string;
    function get_BaseColumnName: string;
    function get_BaseSchemaName: string;
    function get_BaseServerName: string;
    function get_BaseTableName: string;
    function get_ColumnName: string;
    function get_ColumnOrdinal: DDN.mscorlib.DNNullable<Int32>;
    function get_ColumnSize: DDN.mscorlib.DNNullable<Int32>;
    function get_IsAliased: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsAutoIncrement: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsExpression: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsHidden: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsIdentity: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsKey: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsLong: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsReadOnly: DDN.mscorlib.DNNullable<Boolean>;
    function get_IsUnique: DDN.mscorlib.DNNullable<Boolean>;
    function get_NumericPrecision: DDN.mscorlib.DNNullable<Int32>;
    function get_NumericScale: DDN.mscorlib.DNNullable<Int32>;
    function get_UdtAssemblyQualifiedName: string;
    function get_DataType: DDN.mscorlib.DNType;
    function get_DataTypeName: string;
    function get_Item(&property: string): DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a nullable boolean value that indicates whether <see langword="DBNull" />
    ///  values are allowed in this column, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether <see langword="DBNull" />
    ///  values are allowed in this column, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if <see langword="DBNull" />
    ///  values are allowed in this column; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property AllowDBNull: DDN.mscorlib.DNNullable<Boolean> read get_AllowDBNull;
    ///<summary>Gets the catalog name associated with the data source; otherwise, <see langword="null" />
    ///  if no value is set. Can be set to either the catalog name or <see langword="null" />
    ///  when overridden in a derived class.</summary>
    ///<returns>The catalog name associated with the data source; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.</returns>
    property BaseCatalogName: string read get_BaseCatalogName;
    ///<summary>Gets the base column name; otherwise,
    ///<see langword="null" />
    ///  if no value is set. Can be set to either the column name
    ///  or <see langword="null" />
    ///  when overridden in a derived class.
    ///</summary>
    ///<returns>The base column name; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.
    ///</returns>
    property BaseColumnName: string read get_BaseColumnName;
    ///<summary>Gets the schema name associated with the data source; otherwise, <see langword="null" />
    ///  if no value is set. Can be set to either the schema name or <see langword="null" />
    ///  when overridden in a derived class.</summary>
    ///<returns>The schema name associated with the data source; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.</returns>
    property BaseSchemaName: string read get_BaseSchemaName;
    ///<summary>Gets the server name associated with the column; otherwise, <see langword="null" />
    ///  if no value is set. Can be set to either the server name or <see langword="null" />
    ///  when overridden in a derived class.</summary>
    ///<returns>The server name associated with the column; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.</returns>
    property BaseServerName: string read get_BaseServerName;
    ///<summary>Gets the table name in the schema; otherwise, <see langword="null" />
    ///  if no value is set. Can be set to either the table name or <see langword="null" />
    ///  when overridden in a derived class.</summary>
    ///<returns>The table name in the schema; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.</returns>
    property BaseTableName: string read get_BaseTableName;
    ///<summary>Gets the name of the column. Can be set to the column name when overridden in a derived class.</summary>
    ///<returns>The name of the column.</returns>
    property ColumnName: string read get_ColumnName;
    ///<summary>Gets the column position (ordinal) in the datasource row; otherwise, <see langword="null" />
    ///  if no value is set. Can be set to either an <see langword="int32" />
    ///  value to specify the column position or <see langword="null" />
    ///  when overridden in a derived class.</summary>
    ///<returns>An <see langword="int32" />
    ///  value for column ordinal; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.</returns>
    property ColumnOrdinal: DDN.mscorlib.DNNullable<Int32> read get_ColumnOrdinal;
    ///<summary>Gets the column size; otherwise,
    ///<see langword="null" />
    ///  if no value is set. Can be set to either an
    ///<see langword="int32" />
    ///  value to specify the column size or
    ///<see langword="null" />
    ///  when overridden in a derived class.
    ///</summary>
    ///<returns>An
    ///<see langword="int32" />
    ///  value for column size; otherwise, a null reference (
    ///<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.
    ///</returns>
    property ColumnSize: DDN.mscorlib.DNNullable<Int32> read get_ColumnSize;
    ///<summary>Gets a nullable boolean value that indicates whether this column is aliased, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column is aliased, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column is aliased; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsAliased: DDN.mscorlib.DNNullable<Boolean> read get_IsAliased;
    ///<summary>Gets a nullable boolean value that indicates whether values in this column are automatically incremented, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether values in this column are automatically incremented, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if values in this column are automatically incremented; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsAutoIncrement: DDN.mscorlib.DNNullable<Boolean> read get_IsAutoIncrement;
    ///<summary>Gets a nullable boolean value that indicates whether this column is an expression, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column is an expression, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column is an expression; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsExpression: DDN.mscorlib.DNNullable<Boolean> read get_IsExpression;
    ///<summary>Gets a nullable boolean value that indicates whether this column is hidden, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column is hidden, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column is hidden; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsHidden: DDN.mscorlib.DNNullable<Boolean> read get_IsHidden;
    ///<summary>Gets a nullable boolean value that indicates whether this column is an identity, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column is an identity, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column is an identity; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsIdentity: DDN.mscorlib.DNNullable<Boolean> read get_IsIdentity;
    ///<summary>Gets a nullable boolean value that indicates whether this column is a key, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column is a key, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column is a key; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsKey: DDN.mscorlib.DNNullable<Boolean> read get_IsKey;
    ///<summary>Gets a nullable boolean value that indicates whether this column contains long data, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column contains long data, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column contains long data; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsLong: DDN.mscorlib.DNNullable<Boolean> read get_IsLong;
    ///<summary>Gets a nullable boolean value that indicates whether this column is read-only, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether this column is read-only, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if this column is read-only; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsReadOnly: DDN.mscorlib.DNNullable<Boolean> read get_IsReadOnly;
    ///<summary>Gets a nullable boolean value that indicates whether a unique constraint applies to this column, or returns <see langword="null" />
    ///  if no value is set. Can be set to either <see langword="true" />
    ///  or <see langword="false" />
    ///  indicating whether a unique constraint applies to this column, or <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) when overridden in a derived class.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if a unique constraint applies to this column; otherwise, <see langword="false" />
    ///  . If no value is set, returns a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property IsUnique: DDN.mscorlib.DNNullable<Boolean> read get_IsUnique;
    ///<summary>Gets the numeric precision of the column data; otherwise,
    ///<see langword="null" />
    ///  if no value is set. Can be set to either an
    ///<see langword="int32" />
    ///  value to specify the numeric precision of the column data or
    ///<see langword="null" />
    ///  when overridden in a derived class.
    ///</summary>
    ///<returns>An
    ///<see langword="int32" />
    ///  value that specifies the precision of the column data, if the data is numeric; otherwise, a null reference (
    ///<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.
    ///</returns>
    property NumericPrecision: DDN.mscorlib.DNNullable<Int32> read get_NumericPrecision;
    ///<summary>Gets a nullable <see langword="int32" />
    ///  value that either returns <see langword="null" />
    ///  or the numeric scale of the column data. Can be set to either <see langword="null" />
    ///  or an <see langword="int32" />
    ///  value for the numeric scale of the column data when overridden in a derived class.</summary>
    ///<returns>A null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set; otherwise, a <see langword="int32" />
    ///  value that specifies the scale of the column data, if the data is numeric.</returns>
    property NumericScale: DDN.mscorlib.DNNullable<Int32> read get_NumericScale;
    ///<summary>Gets the assembly-qualified name of the <see cref="T:System.Type" />
    ///  object that represents the type of data in the column; otherwise,
    ///<see langword="null" />
    ///  if no value is set. Can be set to either the assembly-qualified name or
    ///<see langword="null" />
    ///  when overridden in a derived class.
    ///</summary>
    ///<returns>The assembly-qualified name of the <see cref="T:System.Type" />
    ///  object that represents the type of data in the column; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.
    ///</returns>
    property UdtAssemblyQualifiedName: string read get_UdtAssemblyQualifiedName;
    ///<summary>Gets the type of data stored in the column. Can be set to a <see cref="T:System.Type" />
    ///  object that represents the type of data in the column when overridden in a derived class.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  object that represents the type of data the column contains.</returns>
    property DataType: DDN.mscorlib.DNType read get_DataType;
    ///<summary>Gets the name of the data type; otherwise, <see langword="null" />
    ///  if no value is set. Can be set to either the data type name or <see langword="null" />
    ///  when overridden in a derived class.</summary>
    ///<returns>The name of the data type; otherwise, a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no value is set.</returns>
    property DataTypeName: string read get_DataTypeName;
    property Item[&property: string]: DDN.mscorlib.DNObject read get_Item; default;
  end;

  TDNDbColumn = class(TDNGenericImport<DNDbColumnClass, DNDbColumn>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbConnectionStringBuilderClass = interface(DNObjectClass)
  ['{CF7AA95D-C35E-5CD4-93A5-97C16324E230}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  class.</summary>
    {class} function init: DNDbConnectionStringBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  class, optionally using ODBC rules for quoting values.</summary>
    ///  <param name="useOdbcRules"><see langword="true" />
    ///  to use {} to delimit fields; <see langword="false" />
    ///  to use quotation marks.</param>
    {class} function init(useOdbcRules: Boolean): DNDbConnectionStringBuilder; overload;

  { static methods } 

    ///<summary>Provides an efficient and safe way to append a key and value to an existing <see cref="T:System.Text.StringBuilder" />
    ///  object.</summary>
    ///  <param name="builder">The <see cref="T:System.Text.StringBuilder" />
    ///  to which to add the key/value pair.</param>
    ///  <param name="keyword">The key to be added.</param>
    ///  <param name="value">The value for the supplied key.</param>
    {class} procedure AppendKeyValuePair(builder: DDN.mscorlib.DNStringBuilder; keyword: string; value: string); overload;
    ///<summary>Provides an efficient and safe way to append a key and value to an existing <see cref="T:System.Text.StringBuilder" />
    ///  object.</summary>
    ///  <param name="builder">The <see cref="T:System.Text.StringBuilder" />
    ///  to which to add the key/value pair.</param>
    ///  <param name="keyword">The key to be added.</param>
    ///  <param name="value">The value for the supplied key.</param>
    ///  <param name="useOdbcRules"><see langword="true" />
    ///  to use {} to delimit fields, <see langword="false" />
    ///  to use quotation marks.</param>
    {class} procedure AppendKeyValuePair(builder: DDN.mscorlib.DNStringBuilder; keyword: string; value: string; useOdbcRules: Boolean); overload;

  end;

  ///<summary>Provides a base class for strongly typed connection string builders.</summary>
  [DNTypeName('System.Data.Common.DbConnectionStringBuilder')]
  DNDbConnectionStringBuilder = interface(DDN.mscorlib.DNIDictionary)
  ['{4C0C21B0-F263-3AED-A5DF-33B6E6F99D18}']
  { getters & setters } 

    function get_Item(keyword: string): DDN.mscorlib.DNObject;
    procedure set_Item(keyword: string; value: DDN.mscorlib.DNObject);
    function get_BrowsableConnectionString: Boolean;
    procedure set_BrowsableConnectionString(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsFixedSize: Boolean;
    function get_Keys: DDN.mscorlib.DNICollection;
    function get_Values: DDN.mscorlib.DNICollection;

  { methods } 

    ///<summary>Adds an entry with the specified key and value into the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///  <param name="keyword">The key to add to the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///  <param name="value">The value for the specified key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only. -or-The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</exception>
    procedure Add(keyword: string; value: DDN.mscorlib.DNObject);
    ///<summary>Returns the connection string associated with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</returns>
    function ToString: string;
    ///<summary>Clears the contents of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///<exception cref="T:System.NotSupportedException">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only.</exception>
    procedure Clear;
    ///<summary>Determines whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  contains a specific key.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  contains an entry with the specified key; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    function ContainsKey(keyword: string): Boolean;
    ///<summary>Compares the connection information in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object with the connection information in the supplied object.</summary>
    ///  <param name="connectionStringBuilder">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  to be compared with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the connection information in both of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  objects causes an equivalent connection string; otherwise <see langword="false" />
    ///  .</returns>
    function EquivalentTo(connectionStringBuilder: DNDbConnectionStringBuilder): Boolean;
    ///<summary>Removes the entry with the specified key from the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key of the key/value pair to be removed from the connection string in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the key existed within the connection string and was removed; <see langword="false" />
    ///  if the key did not exist.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic)</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only, or the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</exception>
    function Remove(keyword: string): Boolean;
    ///<summary>Indicates whether the specified key exists in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  contains an entry with the specified key; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerialize(keyword: string): Boolean;
    function TryGetValue(keyword: string; out value: DDN.mscorlib.DNObject): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Item[keyword: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    ///<summary>Gets or sets a value that indicates whether the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property is visible in Visual Studio designers.</summary>
    ///<returns><see langword="true" />
    ///  if the connection string is visible within designers; <see langword="false" />
    ///  otherwise. The default is <see langword="true" />
    ///  .</returns>
    property BrowsableConnectionString: Boolean read get_BrowsableConnectionString write set_BrowsableConnectionString;
    ///<summary>Gets or sets the connection string associated with the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current connection string, created from the key/value pairs that are contained within the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  . The default value is an empty string.</returns>
    ///<exception cref="T:System.ArgumentException">An invalid connection string argument has been supplied.</exception>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the current number of keys that are contained within the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</summary>
    ///<returns>The number of keys that are contained within the connection string maintained by the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    property Keys: DDN.mscorlib.DNICollection read get_Keys;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    property Values: DDN.mscorlib.DNICollection read get_Values;
  end;

  TDNDbConnectionStringBuilder = class(TDNGenericImport<DNDbConnectionStringBuilderClass, DNDbConnectionStringBuilder>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcConnectionStringBuilderClass = interface(DNDbConnectionStringBuilderClass)
  ['{0D832B2A-C83C-5AB8-9910-C850899F9179}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  class.</summary>
    {class} function init: DNOdbcConnectionStringBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  class. The provided connection string provides the data for the instance's internal connection information.</summary>
    ///  <param name="connectionString">The basis for the object's internal connection information. Parsed into key/value pairs.</param>
    ///<exception cref="T:System.ArgumentException">The connection string is incorrectly formatted (perhaps missing the required "=" within a key/value pair).</exception>
    {class} function init(connectionString: string): DNOdbcConnectionStringBuilder; overload;

  end;

  ///<summary>Provides a simple way to create and manage the contents of connection strings used by the <see cref="T:System.Data.Odbc.OdbcConnection" />
  ///  class.</summary>
  [DNTypeName('System.Data.Odbc.OdbcConnectionStringBuilder')]
  DNOdbcConnectionStringBuilder = interface(DNDbConnectionStringBuilder)
  ['{CB08F5D9-6D9E-352C-B3B2-24A4617FD060}']
  { getters & setters } 

    function get_Item(keyword: string): DDN.mscorlib.DNObject;
    procedure set_Item(keyword: string; value: DDN.mscorlib.DNObject);
    function get_Driver: string;
    procedure set_Driver(value: string);
    function get_Dsn: string;
    procedure set_Dsn(value: string);
    function get_Keys: DDN.mscorlib.DNICollection;
    function get_BrowsableConnectionString: Boolean;
    procedure set_BrowsableConnectionString(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsFixedSize: Boolean;
    function get_Values: DDN.mscorlib.DNICollection;

  { methods } 

    ///<summary>Clears the contents of the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  instance.</summary>
    procedure Clear;
    ///<summary>Determines whether the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  contains a specific key.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  contains an element that has the specified key; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    function ContainsKey(keyword: string): Boolean;
    ///<summary>Removes the entry with the specified key from the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key of the key/value pair to be removed from the connection string in this <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the key existed within the connection string and was removed; <see langword="false" />
    ///  if the key did not exist.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    function Remove(keyword: string): Boolean;
    function TryGetValue(keyword: string; out value: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Adds an entry with the specified key and value into the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///  <param name="keyword">The key to add to the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///  <param name="value">The value for the specified key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only. -or-The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</exception>
    procedure Add(keyword: string; value: DDN.mscorlib.DNObject);
    ///<summary>Returns the connection string associated with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</returns>
    function ToString: string;
    ///<summary>Compares the connection information in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object with the connection information in the supplied object.</summary>
    ///  <param name="connectionStringBuilder">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  to be compared with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the connection information in both of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  objects causes an equivalent connection string; otherwise <see langword="false" />
    ///  .</returns>
    function EquivalentTo(connectionStringBuilder: DNDbConnectionStringBuilder): Boolean;
    ///<summary>Indicates whether the specified key exists in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  contains an entry with the specified key; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerialize(keyword: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Item[keyword: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    ///<summary>Gets or sets the name of the ODBC driver associated with the connection.</summary>
    ///<returns>The value of the <see cref="P:System.Data.Odbc.OdbcConnectionStringBuilder.Driver" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    property Driver: string read get_Driver write set_Driver;
    ///<summary>Gets or sets the name of the data source name (DSN) associated with the connection.</summary>
    ///<returns>The value of the <see cref="P:System.Data.Odbc.OdbcConnectionStringBuilder.Dsn" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    property Dsn: string read get_Dsn write set_Dsn;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.Odbc.OdbcConnectionStringBuilder" />
    ///  .</returns>
    property Keys: DDN.mscorlib.DNICollection read get_Keys;
    ///<summary>Gets or sets a value that indicates whether the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property is visible in Visual Studio designers.</summary>
    ///<returns><see langword="true" />
    ///  if the connection string is visible within designers; <see langword="false" />
    ///  otherwise. The default is <see langword="true" />
    ///  .</returns>
    property BrowsableConnectionString: Boolean read get_BrowsableConnectionString write set_BrowsableConnectionString;
    ///<summary>Gets or sets the connection string associated with the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current connection string, created from the key/value pairs that are contained within the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  . The default value is an empty string.</returns>
    ///<exception cref="T:System.ArgumentException">An invalid connection string argument has been supplied.</exception>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the current number of keys that are contained within the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</summary>
    ///<returns>The number of keys that are contained within the connection string maintained by the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    property Values: DDN.mscorlib.DNICollection read get_Values;
  end;

  TDNOdbcConnectionStringBuilder = class(TDNGenericImport<DNOdbcConnectionStringBuilderClass, DNOdbcConnectionStringBuilder>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbConnectionStringBuilderClass = interface(DNDbConnectionStringBuilderClass)
  ['{B62EF529-B460-5B73-A68A-EA6379F66658}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  class.</summary>
    {class} function init: DNOleDbConnectionStringBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  class. The provided connection string provides the data for the instance's internal connection information.</summary>
    ///  <param name="connectionString">The basis for the object's internal connection information. Parsed into key/value pairs.</param>
    ///<exception cref="T:System.ArgumentException">The connection string is incorrectly formatted (perhaps missing the required "=" within a key/value pair).</exception>
    {class} function init(connectionString: string): DNOleDbConnectionStringBuilder; overload;

  end;

  ///<summary>Provides a simple way to create and manage the contents of connection strings used by the <see cref="T:System.Data.OleDb.OleDbConnection" />
  ///  class.</summary>
  [DNTypeName('System.Data.OleDb.OleDbConnectionStringBuilder')]
  DNOleDbConnectionStringBuilder = interface(DNDbConnectionStringBuilder)
  ['{BD5C2F6C-8E32-36AC-A89B-A5C8C3342E21}']
  { getters & setters } 

    function get_Item(keyword: string): DDN.mscorlib.DNObject;
    procedure set_Item(keyword: string; value: DDN.mscorlib.DNObject);
    function get_DataSource: string;
    procedure set_DataSource(value: string);
    function get_FileName: string;
    procedure set_FileName(value: string);
    function get_OleDbServices: Int32;
    procedure set_OleDbServices(value: Int32);
    function get_PersistSecurityInfo: Boolean;
    procedure set_PersistSecurityInfo(value: Boolean);
    function get_Provider: string;
    procedure set_Provider(value: string);
    function get_Keys: DDN.mscorlib.DNICollection;
    function get_BrowsableConnectionString: Boolean;
    procedure set_BrowsableConnectionString(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsFixedSize: Boolean;
    function get_Values: DDN.mscorlib.DNICollection;

  { methods } 

    ///<summary>Clears the contents of the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  instance.</summary>
    procedure Clear;
    ///<summary>Determines whether the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  contains a specific key.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  .</param>
    ///<returns>true if the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  contains an element that has the specified key; otherwise false.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    function ContainsKey(keyword: string): Boolean;
    ///<summary>Removes the entry with the specified key from the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key of the key/value pair to be removed from the connection string in this <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the key existed within the connection string and was removed, <see langword="false" />
    ///  if the key did not exist.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    function Remove(keyword: string): Boolean;
    function TryGetValue(keyword: string; out value: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Adds an entry with the specified key and value into the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///  <param name="keyword">The key to add to the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///  <param name="value">The value for the specified key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only. -or-The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</exception>
    procedure Add(keyword: string; value: DDN.mscorlib.DNObject);
    ///<summary>Returns the connection string associated with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</returns>
    function ToString: string;
    ///<summary>Compares the connection information in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object with the connection information in the supplied object.</summary>
    ///  <param name="connectionStringBuilder">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  to be compared with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the connection information in both of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  objects causes an equivalent connection string; otherwise <see langword="false" />
    ///  .</returns>
    function EquivalentTo(connectionStringBuilder: DNDbConnectionStringBuilder): Boolean;
    ///<summary>Indicates whether the specified key exists in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  contains an entry with the specified key; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerialize(keyword: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Item[keyword: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    ///<summary>Gets or sets the name of the data source to connect to.</summary>
    ///<returns>The value of the <see cref="P:System.Data.OleDb.OleDbConnectionStringBuilder.DataSource" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    property DataSource: string read get_DataSource write set_DataSource;
    ///<summary>Gets or sets the name of the Universal Data Link (UDL) file for connecting to the data source.</summary>
    ///<returns>The value of the <see cref="P:System.Data.OleDb.OleDbConnectionStringBuilder.FileName" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    property FileName: string read get_FileName write set_FileName;
    ///<summary>Gets or sets the value to be passed for the OLE DB Services key within the connection string.</summary>
    ///<returns>Returns the value corresponding to the OLE DB Services key within the connection string. By default, the value is -13.</returns>
    property OleDbServices: Int32 read get_OleDbServices write set_OleDbServices;
    ///<summary>Gets or sets a Boolean value that indicates whether security-sensitive information, such as the password, is returned as part of the connection if the connection is open or has ever been in an open state.</summary>
    ///<returns>The value of the <see cref="P:System.Data.OleDb.OleDbConnectionStringBuilder.PersistSecurityInfo" />
    ///  property, or <see langword="false" />
    ///  if none has been supplied.</returns>
    property PersistSecurityInfo: Boolean read get_PersistSecurityInfo write set_PersistSecurityInfo;
    ///<summary>Gets or sets a string that contains the name of the data provider associated with the internal connection string.</summary>
    ///<returns>The value of the <see cref="P:System.Data.OleDb.OleDbConnectionStringBuilder.Provider" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    property Provider: string read get_Provider write set_Provider;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.OleDb.OleDbConnectionStringBuilder" />
    ///  .</returns>
    property Keys: DDN.mscorlib.DNICollection read get_Keys;
    ///<summary>Gets or sets a value that indicates whether the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property is visible in Visual Studio designers.</summary>
    ///<returns><see langword="true" />
    ///  if the connection string is visible within designers; <see langword="false" />
    ///  otherwise. The default is <see langword="true" />
    ///  .</returns>
    property BrowsableConnectionString: Boolean read get_BrowsableConnectionString write set_BrowsableConnectionString;
    ///<summary>Gets or sets the connection string associated with the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current connection string, created from the key/value pairs that are contained within the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  . The default value is an empty string.</returns>
    ///<exception cref="T:System.ArgumentException">An invalid connection string argument has been supplied.</exception>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the current number of keys that are contained within the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</summary>
    ///<returns>The number of keys that are contained within the connection string maintained by the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    property Values: DDN.mscorlib.DNICollection read get_Values;
  end;

  TDNOleDbConnectionStringBuilder = class(TDNGenericImport<DNOleDbConnectionStringBuilderClass, DNOleDbConnectionStringBuilder>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlConnectionStringBuilderClass = interface(DNDbConnectionStringBuilderClass)
  ['{3F34A947-4EC9-5337-A384-5E33860966F9}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  class.</summary>
    {class} function init: DNSqlConnectionStringBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  class. The provided connection string provides the data for the instance's internal connection information.</summary>
    ///  <param name="connectionString">The basis for the object's internal connection information. Parsed into name/value pairs. Invalid key names raise <see cref="T:System.Collections.Generic.KeyNotFoundException" />
    ///  .</param>
    ///<exception cref="T:System.Collections.Generic.KeyNotFoundException">Invalid key name within the connection string.</exception><exception cref="T:System.FormatException">Invalid value within the connection string (specifically, when a Boolean or numeric value was expected but not supplied).</exception><exception cref="T:System.ArgumentException">The supplied <paramref name="connectionString" />
    ///  is not valid.</exception>
    {class} function init(connectionString: string): DNSqlConnectionStringBuilder; overload;

  end;

  ///<summary>Provides a simple way to create and manage the contents of connection strings used by the <see cref="T:System.Data.SqlClient.SqlConnection" />
  ///  class. </summary>
  [DNTypeName('System.Data.SqlClient.SqlConnectionStringBuilder')]
  DNSqlConnectionStringBuilder = interface(DNDbConnectionStringBuilder)
  ['{3A386B26-6DF0-3BDF-801E-6580EFABEC73}']
  { getters & setters } 

    function get_Item(keyword: string): DDN.mscorlib.DNObject;
    procedure set_Item(keyword: string; value: DDN.mscorlib.DNObject);
    function get_ApplicationIntent: DNApplicationIntent;
    procedure set_ApplicationIntent(value: DNApplicationIntent);
    function get_ApplicationName: string;
    procedure set_ApplicationName(value: string);
    function get_AsynchronousProcessing: Boolean;
    procedure set_AsynchronousProcessing(value: Boolean);
    function get_AttachDBFilename: string;
    procedure set_AttachDBFilename(value: string);
    function get_PoolBlockingPeriod: DNPoolBlockingPeriod;
    procedure set_PoolBlockingPeriod(value: DNPoolBlockingPeriod);
    function get_ConnectionReset: Boolean;
    procedure set_ConnectionReset(value: Boolean);
    function get_ContextConnection: Boolean;
    procedure set_ContextConnection(value: Boolean);
    function get_ConnectTimeout: Int32;
    procedure set_ConnectTimeout(value: Int32);
    function get_CurrentLanguage: string;
    procedure set_CurrentLanguage(value: string);
    function get_DataSource: string;
    procedure set_DataSource(value: string);
    function get_Encrypt: Boolean;
    procedure set_Encrypt(value: Boolean);
    function get_ColumnEncryptionSetting: DNSqlConnectionColumnEncryptionSetting;
    procedure set_ColumnEncryptionSetting(value: DNSqlConnectionColumnEncryptionSetting);
    function get_EnclaveAttestationUrl: string;
    procedure set_EnclaveAttestationUrl(value: string);
    function get_TrustServerCertificate: Boolean;
    procedure set_TrustServerCertificate(value: Boolean);
    function get_Enlist: Boolean;
    procedure set_Enlist(value: Boolean);
    function get_FailoverPartner: string;
    procedure set_FailoverPartner(value: string);
    function get_InitialCatalog: string;
    procedure set_InitialCatalog(value: string);
    function get_IntegratedSecurity: Boolean;
    procedure set_IntegratedSecurity(value: Boolean);
    function get_Authentication: DNSqlAuthenticationMethod;
    procedure set_Authentication(value: DNSqlAuthenticationMethod);
    function get_LoadBalanceTimeout: Int32;
    procedure set_LoadBalanceTimeout(value: Int32);
    function get_MaxPoolSize: Int32;
    procedure set_MaxPoolSize(value: Int32);
    function get_ConnectRetryCount: Int32;
    procedure set_ConnectRetryCount(value: Int32);
    function get_ConnectRetryInterval: Int32;
    procedure set_ConnectRetryInterval(value: Int32);
    function get_MinPoolSize: Int32;
    procedure set_MinPoolSize(value: Int32);
    function get_MultipleActiveResultSets: Boolean;
    procedure set_MultipleActiveResultSets(value: Boolean);
    function get_MultiSubnetFailover: Boolean;
    procedure set_MultiSubnetFailover(value: Boolean);
    function get_TransparentNetworkIPResolution: Boolean;
    procedure set_TransparentNetworkIPResolution(value: Boolean);
    function get_NetworkLibrary: string;
    procedure set_NetworkLibrary(value: string);
    function get_PacketSize: Int32;
    procedure set_PacketSize(value: Int32);
    function get_Password: string;
    procedure set_Password(value: string);
    function get_PersistSecurityInfo: Boolean;
    procedure set_PersistSecurityInfo(value: Boolean);
    function get_Pooling: Boolean;
    procedure set_Pooling(value: Boolean);
    function get_Replication: Boolean;
    procedure set_Replication(value: Boolean);
    function get_TransactionBinding: string;
    procedure set_TransactionBinding(value: string);
    function get_TypeSystemVersion: string;
    procedure set_TypeSystemVersion(value: string);
    function get_UserID: string;
    procedure set_UserID(value: string);
    function get_UserInstance: Boolean;
    procedure set_UserInstance(value: Boolean);
    function get_WorkstationID: string;
    procedure set_WorkstationID(value: string);
    function get_IsFixedSize: Boolean;
    function get_Keys: DDN.mscorlib.DNICollection;
    function get_Values: DDN.mscorlib.DNICollection;
    function get_BrowsableConnectionString: Boolean;
    procedure set_BrowsableConnectionString(value: Boolean);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;

  { methods } 

    ///<summary>Clears the contents of the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  instance.</summary>
    procedure Clear;
    function TryGetValue(keyword: string; out value: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Determines whether the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  contains a specific key.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</param>
    ///<returns>true if the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  contains an element that has the specified key; otherwise, false.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic)</exception>
    function ContainsKey(keyword: string): Boolean;
    ///<summary>Removes the entry with the specified key from the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key of the key/value pair to be removed from the connection string in this <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the key existed within the connection string and was removed; <see langword="false" />
    ///  if the key did not exist.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is null (<see langword="Nothing" />
    ///  in Visual Basic)</exception>
    function Remove(keyword: string): Boolean;
    ///<summary>Indicates whether the specified key exists in this <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  instance.</summary>
    ///  <param name="keyword">The key to locate in the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  contains an entry with the specified key; otherwise, <see langword="false" />
    ///  .</returns>
    function ShouldSerialize(keyword: string): Boolean;
    ///<summary>Adds an entry with the specified key and value into the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///  <param name="keyword">The key to add to the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</param>
    ///  <param name="value">The value for the specified key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyword" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only. -or-The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  has a fixed size.</exception>
    procedure Add(keyword: string; value: DDN.mscorlib.DNObject);
    ///<summary>Returns the connection string associated with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</returns>
    function ToString: string;
    ///<summary>Compares the connection information in this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object with the connection information in the supplied object.</summary>
    ///  <param name="connectionStringBuilder">The <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  to be compared with this <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the connection information in both of the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  objects causes an equivalent connection string; otherwise <see langword="false" />
    ///  .</returns>
    function EquivalentTo(connectionStringBuilder: DNDbConnectionStringBuilder): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Item[keyword: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    ///<summary>Declares the application workload type when connecting to a database in an SQL Server Availability Group. You can set the value of this property with <see cref="T:System.Data.SqlClient.ApplicationIntent" />
    ///  . For more information about SqlClient support for Always On Availability Groups, see SqlClient Support for High Availability, Disaster Recovery.</summary>
    ///<returns>Returns the current value of the property (a value of type <see cref="T:System.Data.SqlClient.ApplicationIntent" />
    ///  ).</returns>
    property ApplicationIntent: DNApplicationIntent read get_ApplicationIntent write set_ApplicationIntent;
    ///<summary>Gets or sets the name of the application associated with the connection string.</summary>
    ///<returns>The name of the application, or ".NET SqlClient Data Provider" if no name has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property ApplicationName: string read get_ApplicationName write set_ApplicationName;
    ///<summary>Gets or sets a Boolean value that indicates whether asynchronous processing is allowed by the connection created by using this connection string.</summary>
    ///<returns>This property is ignored beginning in .NET Framework 4.5. For more information about SqlClient support for asynchronous programming, see Asynchronous Programming.The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.AsynchronousProcessing" />
    ///  property, or <see langword="false" />
    ///  if no value has been supplied.</returns>
    property AsynchronousProcessing: Boolean read get_AsynchronousProcessing write set_AsynchronousProcessing;
    ///<summary>Gets or sets a string that contains the name of the primary data file. This includes the full path name of an attachable database.</summary>
    ///<returns>The value of the <see langword="AttachDBFilename" />
    ///  property, or <see langword="String.Empty" />
    ///  if no value has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property AttachDBFilename: string read get_AttachDBFilename write set_AttachDBFilename;
    ///<summary>The blocking period behavior for a connection pool.</summary>
    ///<returns>The available blocking period settings.</returns>
    property PoolBlockingPeriod: DNPoolBlockingPeriod read get_PoolBlockingPeriod write set_PoolBlockingPeriod;
    ///<summary>Obsolete. Gets or sets a Boolean value that indicates whether the connection is reset when drawn from the connection pool.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.ConnectionReset" />
    ///  property, or true if no value has been supplied.</returns>
    property ConnectionReset: Boolean read get_ConnectionReset write set_ConnectionReset;
    ///<summary>Gets or sets a value that indicates whether a client/server or in-process connection to SQL Server should be made.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.ContextConnection" />
    ///  property, or <see langword="False" />
    ///  if none has been supplied.</returns>
    property ContextConnection: Boolean read get_ContextConnection write set_ContextConnection;
    ///<summary>Gets or sets the length of time (in seconds) to wait for a connection to the server before terminating the attempt and generating an error.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.ConnectTimeout" />
    ///  property, or 15 seconds if no value has been supplied.</returns>
    property ConnectTimeout: Int32 read get_ConnectTimeout write set_ConnectTimeout;
    ///<summary>Gets or sets the SQL Server Language record name.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.CurrentLanguage" />
    ///  property, or <see langword="String.Empty" />
    ///  if no value has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property CurrentLanguage: string read get_CurrentLanguage write set_CurrentLanguage;
    ///<summary>Gets or sets the name or network address of the instance of SQL Server to connect to.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.DataSource" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property DataSource: string read get_DataSource write set_DataSource;
    ///<summary>Gets or sets a Boolean value that indicates whether SQL Server uses SSL encryption for all data sent between the client and server if the server has a certificate installed.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.Encrypt" />
    ///  property, or <see langword="false" />
    ///  if none has been supplied.</returns>
    property Encrypt: Boolean read get_Encrypt write set_Encrypt;
    ///<summary>Gets and sets the column encryption settings for the connection string builder.</summary>
    ///<returns>The column encryption settings for the connection string builder.</returns>
    property ColumnEncryptionSetting: DNSqlConnectionColumnEncryptionSetting read get_ColumnEncryptionSetting write set_ColumnEncryptionSetting;
    property EnclaveAttestationUrl: string read get_EnclaveAttestationUrl write set_EnclaveAttestationUrl;
    ///<summary>Gets or sets a value that indicates whether the channel will be encrypted while bypassing walking the certificate chain to validate trust.</summary>
    ///<returns>A <see langword="Boolean" />
    ///  . Recognized values are <see langword="true" />
    ///  , <see langword="false" />
    ///  , <see langword="yes" />
    ///  , and <see langword="no" />
    ///  . </returns>
    property TrustServerCertificate: Boolean read get_TrustServerCertificate write set_TrustServerCertificate;
    ///<summary>Gets or sets a Boolean value that indicates whether the SQL Server connection pooler automatically enlists the connection in the creation thread's current transaction context.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.Enlist" />
    ///  property, or <see langword="true " />
    ///  if none has been supplied.</returns>
    property Enlist: Boolean read get_Enlist write set_Enlist;
    ///<summary>Gets or sets the name or address of the partner server to connect to if the primary server is down.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.FailoverPartner" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property FailoverPartner: string read get_FailoverPartner write set_FailoverPartner;
    ///<summary>Gets or sets the name of the database associated with the connection.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.InitialCatalog" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property InitialCatalog: string read get_InitialCatalog write set_InitialCatalog;
    ///<summary>Gets or sets a Boolean value that indicates whether User ID and Password are specified in the connection (when <see langword="false" />
    ///  ) or whether the current Windows account credentials are used for authentication (when <see langword="true" />
    ///  ).</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.IntegratedSecurity" />
    ///  property, or <see langword="false" />
    ///  if none has been supplied.</returns>
    property IntegratedSecurity: Boolean read get_IntegratedSecurity write set_IntegratedSecurity;
    ///<summary>Gets the authentication of the connection string.</summary>
    ///<returns>The authentication of the connection string.</returns>
    property Authentication: DNSqlAuthenticationMethod read get_Authentication write set_Authentication;
    ///<summary>Gets or sets the minimum time, in seconds, for the connection to live in the connection pool before being destroyed.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.LoadBalanceTimeout" />
    ///  property, or 0 if none has been supplied.</returns>
    property LoadBalanceTimeout: Int32 read get_LoadBalanceTimeout write set_LoadBalanceTimeout;
    ///<summary>Gets or sets the maximum number of connections allowed in the connection pool for this specific connection string.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.MaxPoolSize" />
    ///  property, or 100 if none has been supplied.</returns>
    property MaxPoolSize: Int32 read get_MaxPoolSize write set_MaxPoolSize;
    ///<summary>[Supported in the .NET Framework 4.5.1 and later versions] The number of reconnections attempted after identifying that there was an idle connection failure. This must be an integer between 0 and 255. Default is 1. Set to 0 to disable reconnecting on idle connection failures. An <see cref="T:System.ArgumentException" />
    ///  will be thrown if set to a value outside of the allowed range.</summary>
    ///<returns>The number of reconnections attempted after identifying that there was an idle connection failure.</returns>
    property ConnectRetryCount: Int32 read get_ConnectRetryCount write set_ConnectRetryCount;
    ///<summary>[Supported in the .NET Framework 4.5.1 and later versions] Amount of time (in seconds) between each reconnection attempt after identifying that there was an idle connection failure. This must be an integer between 1 and 60. The default is 10 seconds. An <see cref="T:System.ArgumentException" />
    ///  will be thrown if set to a value outside of the allowed range.</summary>
    ///<returns>Amount of time (in seconds) between each reconnection attempt after identifying that there was an idle connection failure.</returns>
    property ConnectRetryInterval: Int32 read get_ConnectRetryInterval write set_ConnectRetryInterval;
    ///<summary>Gets or sets the minimum number of connections allowed in the connection pool for this specific connection string.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.MinPoolSize" />
    ///  property, or 0 if none has been supplied.</returns>
    property MinPoolSize: Int32 read get_MinPoolSize write set_MinPoolSize;
    ///<summary>When true, an application can maintain multiple active result sets (MARS). When false, an application must process or cancel all result sets from one batch before it can execute any other batch on that connection.For more information, see Multiple Active Result Sets (MARS).</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.MultipleActiveResultSets" />
    ///  property, or <see langword="false" />
    ///  if none has been supplied.</returns>
    property MultipleActiveResultSets: Boolean read get_MultipleActiveResultSets write set_MultipleActiveResultSets;
    ///<summary>If your application is connecting to an AlwaysOn availability group (AG) on different subnets, setting MultiSubnetFailover=true provides faster detection of and connection to the (currently) active server. For more information about SqlClient support for Always On Availability Groups, see SqlClient Support for High Availability, Disaster Recovery.</summary>
    ///<returns>Returns <see cref="T:System.Boolean" />
    ///  indicating the current value of the property.</returns>
    property MultiSubnetFailover: Boolean read get_MultiSubnetFailover write set_MultiSubnetFailover;
    ///<summary>When the value of this key is set to <see langword="true" />
    ///  , the application is required to retrieve all IP addresses for a particular DNS entry and attempt to connect with the first one in the list. If the connection is not established within 0.5 seconds, the application will try to connect to all others in parallel. When the first answers, the application will establish the connection with the respondent IP address.</summary>
    ///<returns>A boolean value.</returns>
    property TransparentNetworkIPResolution: Boolean read get_TransparentNetworkIPResolution write set_TransparentNetworkIPResolution;
    ///<summary>Gets or sets a string that contains the name of the network library used to establish a connection to the SQL Server.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.NetworkLibrary" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property NetworkLibrary: string read get_NetworkLibrary write set_NetworkLibrary;
    ///<summary>Gets or sets the size in bytes of the network packets used to communicate with an instance of SQL Server.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.PacketSize" />
    ///  property, or 8000 if none has been supplied.</returns>
    property PacketSize: Int32 read get_PacketSize write set_PacketSize;
    ///<summary>Gets or sets the password for the SQL Server account.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.Password" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">The password was incorrectly set to null.  See code sample below.</exception>
    property Password: string read get_Password write set_Password;
    ///<summary>Gets or sets a Boolean value that indicates if security-sensitive information, such as the password, is not returned as part of the connection if the connection is open or has ever been in an open state.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.PersistSecurityInfo" />
    ///  property, or <see langword="false" />
    ///  if none has been supplied.</returns>
    property PersistSecurityInfo: Boolean read get_PersistSecurityInfo write set_PersistSecurityInfo;
    ///<summary>Gets or sets a Boolean value that indicates whether the connection will be pooled or explicitly opened every time that the connection is requested.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.Pooling" />
    ///  property, or <see langword="true" />
    ///  if none has been supplied.</returns>
    property Pooling: Boolean read get_Pooling write set_Pooling;
    ///<summary>Gets or sets a Boolean value that indicates whether replication is supported using the connection.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.Replication" />
    ///  property, or false if none has been supplied.</returns>
    property Replication: Boolean read get_Replication write set_Replication;
    ///<summary>Gets or sets a string value that indicates how the connection maintains its association with an enlisted <see langword="System.Transactions" />
    ///  transaction.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.TransactionBinding" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    property TransactionBinding: string read get_TransactionBinding write set_TransactionBinding;
    ///<summary>Gets or sets a string value that indicates the type system the application expects.</summary>
    ///<returns>The following table shows the possible values for the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.TypeSystemVersion" />
    ///  property:ValueDescription
    ///  SQL Server 2005Uses the SQL Server 2005 type system. No conversions are made for the current version of ADO.NET.SQL Server 2008Uses the SQL Server 2008 type system.LatestUse the latest version than this client-server pair can handle. This will automatically move forward as the client and server components are upgraded.</returns>
    property TypeSystemVersion: string read get_TypeSystemVersion write set_TypeSystemVersion;
    ///<summary>Gets or sets the user ID to be used when connecting to SQL Server.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.UserID" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property UserID: string read get_UserID write set_UserID;
    ///<summary>Gets or sets a value that indicates whether to redirect the connection from the default SQL Server Express instance to a runtime-initiated instance running under the account of the caller.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.UserInstance" />
    ///  property, or <see langword="False" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property UserInstance: Boolean read get_UserInstance write set_UserInstance;
    ///<summary>Gets or sets the name of the workstation connecting to SQL Server.</summary>
    ///<returns>The value of the <see cref="P:System.Data.SqlClient.SqlConnectionStringBuilder.WorkstationID" />
    ///  property, or <see langword="String.Empty" />
    ///  if none has been supplied.</returns>
    ///<exception cref="T:System.ArgumentNullException">To set the value to null, use <see cref="F:System.DBNull.Value" />
    ///  .</exception>
    property WorkstationID: string read get_WorkstationID write set_WorkstationID;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  has a fixed size.</summary>
    ///<returns><see langword="true" />
    ///  in every case, because the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  supplies a fixed-size collection of key/value pairs.</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the keys in the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</returns>
    property Keys: DDN.mscorlib.DNICollection read get_Keys;
    ///<summary>Gets an <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  that contains the values in the <see cref="T:System.Data.SqlClient.SqlConnectionStringBuilder" />
    ///  .</returns>
    property Values: DDN.mscorlib.DNICollection read get_Values;
    ///<summary>Gets or sets a value that indicates whether the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property is visible in Visual Studio designers.</summary>
    ///<returns><see langword="true" />
    ///  if the connection string is visible within designers; <see langword="false" />
    ///  otherwise. The default is <see langword="true" />
    ///  .</returns>
    property BrowsableConnectionString: Boolean read get_BrowsableConnectionString write set_BrowsableConnectionString;
    ///<summary>Gets or sets the connection string associated with the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</summary>
    ///<returns>The current connection string, created from the key/value pairs that are contained within the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  . The default value is an empty string.</returns>
    ///<exception cref="T:System.ArgumentException">An invalid connection string argument has been supplied.</exception>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the current number of keys that are contained within the <see cref="P:System.Data.Common.DbConnectionStringBuilder.ConnectionString" />
    ///  property.</summary>
    ///<returns>The number of keys that are contained within the connection string maintained by the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  is read-only; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
  end;

  TDNSqlConnectionStringBuilder = class(TDNGenericImport<DNSqlConnectionStringBuilderClass, DNSqlConnectionStringBuilder>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbDataReaderExtensionsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6E06702B-7C2A-5BF2-A0AB-5FEA314EFE7F}']
  { static methods } 

    ///<summary>Gets the column schema (<see cref="T:System.Data.Common.DbColumn" />
    ///  collection) for a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .</summary>
    ///  <param name="reader">The <see cref="T:System.Data.Common.DbDataReader" />
    ///  to return the column schema.</param>
    ///<returns>The column schema (<see cref="T:System.Data.Common.DbColumn" />
    ///  collection) for a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .</returns>
    {class} function GetColumnSchema(reader: DNDbDataReader): DDN.mscorlib.DNReadOnlyCollection<DNDbColumn>;
    ///<summary>Gets a value that indicates whether a <see cref="T:System.Data.Common.DbDataReader" />
    ///  can get a column schema.</summary>
    ///  <param name="reader">The <see cref="T:System.Data.Common.DbDataReader" />
    ///  to be checked for column schema support.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbDataReader" />
    ///  can get a column schema; otherwise, <see langword="false" />
    ///  .</returns>
    {class} function CanGetColumnSchema(reader: DNDbDataReader): Boolean;

  end;

  ///<summary>This class contains column schema extension methods for <see cref="T:System.Data.Common.DbDataReader" />
  ///  .</summary>
  [DNTypeName('System.Data.Common.DbDataReaderExtensions')]
  DNDbDataReaderExtensions = interface(DDN.mscorlib.DNObject)
  ['{B6AEE8F8-1EE1-308F-8092-1AACE315F09B}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbDataReaderExtensions = class(TDNGenericImport<DNDbDataReaderExtensionsClass, DNDbDataReaderExtensions>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbDataRecordClass = interface(DNObjectClass)
  ['{D4C8BE44-8B2C-5326-811C-F203B591EB6D}']
  end;

  ///<summary>Implements <see cref="T:System.Data.IDataRecord" />
  ///  and <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />
  ///  , and provides data binding support for <see cref="T:System.Data.Common.DbEnumerator" />
  ///  .</summary>
  [DNTypeName('System.Data.Common.DbDataRecord')]
  DNDbDataRecord = interface(DDN.System.DNICustomTypeDescriptor)
  ['{7529B2E8-64FA-3F43-9323-335FC77F4E2B}']
  { getters & setters } 

    function get_FieldCount: Int32;
    function get_Item(i: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;

  { methods } 

    ///<summary>Not currently supported.</summary>
    ///  <param name="i">Not currently supported.</param>
    ///<returns>Not currently supported.</returns>
    function GetData(i: Int32): DNIDataReader;
    ///<summary>Returns the value of the specified column as a Boolean.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns><see langword="true" />
    ///  if the Boolean is <see langword="true" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function GetBoolean(i: Int32): Boolean;
    ///<summary>Returns the value of the specified column as a byte.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetByte(i: Int32): Byte;
    ///<summary>Returns the value of the specified column as a byte array.</summary>
    ///  <param name="i">The zero-based column ordinal.</param>
    ///  <param name="dataIndex">The index within the field from which to start the read operation.</param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes.</param>
    ///  <param name="bufferIndex">The index for <paramref name="buffer" />
    ///  to start the read operation.</param>
    ///  <param name="length">The number of bytes to read.</param>
    ///<returns>The value of the specified column.</returns>
    function GetBytes(i: Int32; dataIndex: Int64; buffer: TArray<Byte>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Returns the value of the specified column as a character.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetChar(i: Int32): Char;
    ///<summary>Returns the value of the specified column as a character array.</summary>
    ///  <param name="i">Column ordinal. </param>
    ///  <param name="dataIndex">Buffer to copy data into. </param>
    ///  <param name="buffer">Maximum length to copy into the buffer. </param>
    ///  <param name="bufferIndex">Point to start from within the buffer. </param>
    ///  <param name="length">Point to start from within the source data. </param>
    ///<returns>The value of the specified column.</returns>
    function GetChars(i: Int32; dataIndex: Int64; buffer: TArray<Char>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Returns the name of the back-end data type.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The name of the back-end data type.</returns>
    function GetDataTypeName(i: Int32): string;
    ///<summary>Returns the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetDateTime(i: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Returns the value of the specified column as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetDecimal(i: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Returns the value of the specified column as a double-precision floating-point number.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetDouble(i: Int32): Double;
    ///<summary>Returns the <see cref="T:System.Type" />
    ///  that is the data type of the object.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The <see cref="T:System.Type" />
    ///  that is the data type of the object.</returns>
    function GetFieldType(i: Int32): DDN.mscorlib.DNType;
    ///<summary>Returns the value of the specified column as a single-precision floating-point number.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetFloat(i: Int32): Single;
    ///<summary>Returns the GUID value of the specified field.</summary>
    ///  <param name="i">The index of the field to return. </param>
    ///<returns>The GUID value of the specified field.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />
    ///  . </exception>
    function GetGuid(i: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Returns the value of the specified column as a 16-bit signed integer.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetInt16(i: Int32): Int16;
    ///<summary>Returns the value of the specified column as a 32-bit signed integer.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetInt32(i: Int32): Int32;
    ///<summary>Returns the value of the specified column as a 64-bit signed integer.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetInt64(i: Int32): Int64;
    ///<summary>Returns the name of the specified column.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The name of the specified column.</returns>
    function GetName(i: Int32): string;
    ///<summary>Returns the column ordinal, given the name of the column.</summary>
    ///  <param name="name">The name of the column. </param>
    ///<returns>The column ordinal.</returns>
    function GetOrdinal(name: string): Int32;
    ///<summary>Returns the value of the specified column as a string.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    function GetString(i: Int32): string;
    ///<summary>Returns the value at the specified column in its native format.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns>The value to return.</returns>
    function GetValue(i: Int32): DDN.mscorlib.DNObject;
    ///<summary>Populates an array of objects with the column values of the current record.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  to copy the attribute fields into. </param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Used to indicate nonexistent values.</summary>
    ///  <param name="i">The column ordinal. </param>
    ///<returns><see langword="true" />
    ///  if the specified column is equivalent to <see cref="T:System.DBNull" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function IsDBNull(i: Int32): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates the number of fields within the current record. This property is read-only.</summary>
    ///<returns>The number of fields within the current record.</returns>
    ///<exception cref="T:System.NotSupportedException">Not connected to a data source to read from. </exception>
    property FieldCount: Int32 read get_FieldCount;
    property Item[i: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
  end;

  TDNDbDataRecord = class(TDNGenericImport<DNDbDataRecordClass, DNDbDataRecord>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbDataSourceEnumeratorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{3BDAF0E7-1148-5DC4-A723-D0739D500B10}']
  end;

  ///<summary>Provides a mechanism for enumerating all available instances of database servers within the local network. </summary>
  [DNTypeName('System.Data.Common.DbDataSourceEnumerator')]
  DNDbDataSourceEnumerator = interface(DDN.mscorlib.DNObject)
  ['{9767A78B-E5A6-3DA2-B87B-445904AC0CBF}']
  { methods } 

    ///<summary>Retrieves a <see cref="T:System.Data.DataTable" />
    ///  containing information about all visible instances of the server represented by the strongly typed instance of this class.</summary>
    ///<returns>Returns a <see cref="T:System.Data.DataTable" />
    ///  containing information about the visible instances of the associated data source.</returns>
    function GetDataSources: DNDataTable;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbDataSourceEnumerator = class(TDNGenericImport<DNDbDataSourceEnumeratorClass, DNDbDataSourceEnumerator>) end;

  //-------------namespace: System.Data.Sql----------------
  DNSqlDataSourceEnumeratorClass = interface(DNDbDataSourceEnumeratorClass)
  ['{142DDE02-3AB9-53A3-82B2-573326157A8F}']
  { static getter & setter } 

    {class} function get_Instance: DNSqlDataSourceEnumerator;

  { static propertys } 

    ///<summary>Gets an instance of the <see cref="T:System.Data.Sql.SqlDataSourceEnumerator" />
    ///  , which can be used to retrieve information about available SQL Server instances.</summary>
    ///<returns>An instance of the <see cref="T:System.Data.Sql.SqlDataSourceEnumerator" />
    ///  used to retrieve information about available SQL Server instances.</returns>
    {class} property Instance: DNSqlDataSourceEnumerator read get_Instance;
  end;

  ///<summary>Provides a mechanism for enumerating all available instances of SQL Server within the local network.</summary>
  [DNTypeName('System.Data.Sql.SqlDataSourceEnumerator')]
  DNSqlDataSourceEnumerator = interface(DNDbDataSourceEnumerator)
  ['{0B789350-8957-30C4-B768-17F9F650DC54}']
  { methods } 

    ///<summary>Retrieves a <see cref="T:System.Data.DataTable" />
    ///  containing information about all visible SQL Server 2000 or SQL Server 2005 instances.</summary>
    ///<returns>Returns a <see cref="T:System.Data.DataTable" />
    ///  containing information about the visible SQL Server instances.</returns>
    function GetDataSources: DNDataTable;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlDataSourceEnumerator = class(TDNGenericImport<DNSqlDataSourceEnumeratorClass, DNSqlDataSourceEnumerator>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbEnumeratorClass = interface(DNObjectClass)
  ['{5B316C41-9FB5-58AF-916B-A357E6911750}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DbEnumerator" />
    ///  class using the specified <see langword="DataReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="DataReader" />
    ///  through which to iterate. </param>
    {class} function init(reader: DNIDataReader): DNDbEnumerator; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DbEnumerator" />
    ///  class using the specified <see langword="DataReader" />
    ///  , and indicates whether to automatically close the <see langword="DataReader" />
    ///  after iterating through its data.</summary>
    ///  <param name="reader">The <see langword="DataReader" />
    ///  through which to iterate. </param>
    ///  <param name="closeReader"><see langword="true" />
    ///  to automatically close the <see langword="DataReader" />
    ///  after iterating through its data; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(reader: DNIDataReader; closeReader: Boolean): DNDbEnumerator; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DbEnumerator" />
    ///  class with the give n data reader.</summary>
    ///  <param name="reader">The DataReader through which to iterate.</param>
    {class} function init(reader: DNDbDataReader): DNDbEnumerator; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DbEnumerator" />
    ///  class using the specified reader and indicates whether to automatically close the reader after iterating through its data.</summary>
    ///  <param name="reader">The DataReader through which to iterate.</param>
    ///  <param name="closeReader"><see langword="true" />
    ///  to automatically close the DataReader after iterating through its data; otherwise, <see langword="false" />
    ///  .</param>
    {class} function init(reader: DNDbDataReader; closeReader: Boolean): DNDbEnumerator; overload;

  end;

  ///<summary>Exposes the <see cref="M:System.Collections.IEnumerable.GetEnumerator" />
  ///  method, which supports a simple iteration over a collection by a .NET Framework data provider.</summary>
  [DNTypeName('System.Data.Common.DbEnumerator')]
  DNDbEnumerator = interface(DDN.mscorlib.DNIEnumerator)
  ['{E4F30E4F-D3B2-3FF8-95A4-0207BB25EA7B}']
  { getters & setters } 

    function get_Current: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Advances the enumerator to the next element of the collection.</summary>
    ///<returns><see langword="true" />
    ///  if the enumerator was successfully advanced to the next element; <see langword="false" />
    ///  if the enumerator has passed the end of the collection.</returns>
    ///<exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
    function MoveNext: Boolean;
    ///<summary>Sets the enumerator to its initial position, which is before the first element in the collection.</summary>
    ///<exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
    procedure Reset;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the current element in the collection.</summary>
    ///<returns>The current element in the collection.</returns>
    ///<exception cref="T:System.InvalidOperationException">The enumerator is positioned before the first element of the collection or after the last element. </exception>
    property Current: DDN.mscorlib.DNObject read get_Current;
  end;

  TDNDbEnumerator = class(TDNGenericImport<DNDbEnumeratorClass, DNDbEnumerator>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbMetaDataCollectionNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D6FE4D1F-2EBB-54C8-897F-A87CB0E4B8F3}']
  { static fields getter & setter } 

   function __fakeFieldGet_MetaDataCollections: string;
   function __fakeFieldGet_DataSourceInformation: string;
   function __fakeFieldGet_DataTypes: string;
   function __fakeFieldGet_Restrictions: string;
   function __fakeFieldGet_ReservedWords: string;

  { static fields } 

    ///<summary>A constant for use with the <see cref="M:System.Data.Common.DbConnection.GetSchema" />
    ///  method that represents the MetaDataCollections collection.</summary>
    {class} property MetaDataCollections: string read __fakeFieldGet_MetaDataCollections;
    ///<summary>A constant for use with the <see cref="M:System.Data.Common.DbConnection.GetSchema" />
    ///  method that represents the DataSourceInformation collection.</summary>
    {class} property DataSourceInformation: string read __fakeFieldGet_DataSourceInformation;
    ///<summary>A constant for use with the <see cref="M:System.Data.Common.DbConnection.GetSchema" />
    ///  method that represents the DataTypes collection.</summary>
    {class} property DataTypes: string read __fakeFieldGet_DataTypes;
    ///<summary>A constant for use with the <see cref="M:System.Data.Common.DbConnection.GetSchema" />
    ///  method that represents the Restrictions collection.  </summary>
    {class} property Restrictions: string read __fakeFieldGet_Restrictions;
    ///<summary>A constant for use with the <see cref="M:System.Data.Common.DbConnection.GetSchema" />
    ///  method that represents the ReservedWords collection.</summary>
    {class} property ReservedWords: string read __fakeFieldGet_ReservedWords;

  end;

  ///<summary>Provides a list of constants for the well-known MetaDataCollections: DataSourceInformation, DataTypes, MetaDataCollections, ReservedWords, and Restrictions.</summary>
  [DNTypeName('System.Data.Common.DbMetaDataCollectionNames')]
  DNDbMetaDataCollectionNames = interface(DDN.mscorlib.DNObject)
  ['{CE5E7406-07E8-3A8A-B04E-4043BD4AA10D}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbMetaDataCollectionNames = class(TDNGenericImport<DNDbMetaDataCollectionNamesClass, DNDbMetaDataCollectionNames>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbMetaDataColumnNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{C3ECE213-79F4-5D35-8F22-73F920EC4B0F}']
  { static fields getter & setter } 

   function __fakeFieldGet_CollectionName: string;
   function __fakeFieldGet_ColumnSize: string;
   function __fakeFieldGet_CompositeIdentifierSeparatorPattern: string;
   function __fakeFieldGet_CreateFormat: string;
   function __fakeFieldGet_CreateParameters: string;
   function __fakeFieldGet_DataSourceProductName: string;
   function __fakeFieldGet_DataSourceProductVersion: string;
   function __fakeFieldGet_DataType: string;
   function __fakeFieldGet_DataSourceProductVersionNormalized: string;
   function __fakeFieldGet_GroupByBehavior: string;
   function __fakeFieldGet_IdentifierCase: string;
   function __fakeFieldGet_IdentifierPattern: string;
   function __fakeFieldGet_IsAutoIncrementable: string;
   function __fakeFieldGet_IsBestMatch: string;
   function __fakeFieldGet_IsCaseSensitive: string;
   function __fakeFieldGet_IsConcurrencyType: string;
   function __fakeFieldGet_IsFixedLength: string;
   function __fakeFieldGet_IsFixedPrecisionScale: string;
   function __fakeFieldGet_IsLiteralSupported: string;
   function __fakeFieldGet_IsLong: string;
   function __fakeFieldGet_IsNullable: string;
   function __fakeFieldGet_IsSearchable: string;
   function __fakeFieldGet_IsSearchableWithLike: string;
   function __fakeFieldGet_IsUnsigned: string;
   function __fakeFieldGet_LiteralPrefix: string;
   function __fakeFieldGet_LiteralSuffix: string;
   function __fakeFieldGet_MaximumScale: string;
   function __fakeFieldGet_MinimumScale: string;
   function __fakeFieldGet_NumberOfIdentifierParts: string;
   function __fakeFieldGet_NumberOfRestrictions: string;
   function __fakeFieldGet_OrderByColumnsInSelect: string;
   function __fakeFieldGet_ParameterMarkerFormat: string;
   function __fakeFieldGet_ParameterMarkerPattern: string;
   function __fakeFieldGet_ParameterNameMaxLength: string;
   function __fakeFieldGet_ParameterNamePattern: string;
   function __fakeFieldGet_ProviderDbType: string;
   function __fakeFieldGet_QuotedIdentifierCase: string;
   function __fakeFieldGet_QuotedIdentifierPattern: string;
   function __fakeFieldGet_ReservedWord: string;
   function __fakeFieldGet_StatementSeparatorPattern: string;
   function __fakeFieldGet_StringLiteralPattern: string;
   function __fakeFieldGet_SupportedJoinOperators: string;
   function __fakeFieldGet_TypeName: string;

  { static fields } 

    ///<summary>Used by the GetSchema method to create the CollectionName column in the DataTypes collection.</summary>
    {class} property CollectionName: string read __fakeFieldGet_CollectionName;
    ///<summary>Used by the GetSchema method to create the ColumnSize column in the DataTypes collection.</summary>
    {class} property ColumnSize: string read __fakeFieldGet_ColumnSize;
    ///<summary>Used by the GetSchema method to create the CompositeIdentifierSeparatorPattern column in the DataSourceInformation collection.</summary>
    {class} property CompositeIdentifierSeparatorPattern: string read __fakeFieldGet_CompositeIdentifierSeparatorPattern;
    ///<summary>Used by the GetSchema method to create the CreateFormat column in the DataTypes collection.</summary>
    {class} property CreateFormat: string read __fakeFieldGet_CreateFormat;
    ///<summary>Used by the GetSchema method to create the CreateParameters column in the DataTypes collection.</summary>
    {class} property CreateParameters: string read __fakeFieldGet_CreateParameters;
    ///<summary>Used by the GetSchema method to create the DataSourceProductName column in the DataSourceInformation collection.</summary>
    {class} property DataSourceProductName: string read __fakeFieldGet_DataSourceProductName;
    ///<summary>Used by the GetSchema method to create the DataSourceProductVersion column in the DataSourceInformation collection.</summary>
    {class} property DataSourceProductVersion: string read __fakeFieldGet_DataSourceProductVersion;
    ///<summary>Used by the GetSchema method to create the DataType column in the DataTypes collection.</summary>
    {class} property DataType: string read __fakeFieldGet_DataType;
    ///<summary>Used by the GetSchema method to create the DataSourceProductVersionNormalized column in the DataSourceInformation collection.</summary>
    {class} property DataSourceProductVersionNormalized: string read __fakeFieldGet_DataSourceProductVersionNormalized;
    ///<summary>Used by the GetSchema method to create the GroupByBehavior column in the DataSourceInformation collection.</summary>
    {class} property GroupByBehavior: string read __fakeFieldGet_GroupByBehavior;
    ///<summary>Used by the GetSchema method to create the IdentifierCase column in the DataSourceInformation collection.</summary>
    {class} property IdentifierCase: string read __fakeFieldGet_IdentifierCase;
    ///<summary>Used by the GetSchema method to create the IdentifierPattern column in the DataSourceInformation collection.</summary>
    {class} property IdentifierPattern: string read __fakeFieldGet_IdentifierPattern;
    ///<summary>Used by the GetSchema method to create the IsAutoIncrementable column in the DataTypes collection.</summary>
    {class} property IsAutoIncrementable: string read __fakeFieldGet_IsAutoIncrementable;
    ///<summary>Used by the GetSchema method to create the IsBestMatch column in the DataTypes collection.</summary>
    {class} property IsBestMatch: string read __fakeFieldGet_IsBestMatch;
    ///<summary>Used by the GetSchema method to create the IsCaseSensitive column in the DataTypes collection.</summary>
    {class} property IsCaseSensitive: string read __fakeFieldGet_IsCaseSensitive;
    ///<summary>Used by the GetSchema method to create the IsConcurrencyType column in the DataTypes collection.</summary>
    {class} property IsConcurrencyType: string read __fakeFieldGet_IsConcurrencyType;
    ///<summary>Used by the GetSchema method to create the IsFixedLength column in the DataTypes collection.</summary>
    {class} property IsFixedLength: string read __fakeFieldGet_IsFixedLength;
    ///<summary>Used by the GetSchema method to create the IsFixedPrecisionScale column in the DataTypes collection.</summary>
    {class} property IsFixedPrecisionScale: string read __fakeFieldGet_IsFixedPrecisionScale;
    ///<summary>Used by the GetSchema method to create the IsLiteralSupported column in the DataTypes collection.</summary>
    {class} property IsLiteralSupported: string read __fakeFieldGet_IsLiteralSupported;
    ///<summary>Used by the GetSchema method to create the IsLong column in the DataTypes collection.</summary>
    {class} property IsLong: string read __fakeFieldGet_IsLong;
    ///<summary>Used by the GetSchema method to create the IsNullable column in the DataTypes collection.</summary>
    {class} property IsNullable: string read __fakeFieldGet_IsNullable;
    ///<summary>Used by the GetSchema method to create the IsSearchable column in the DataTypes collection.</summary>
    {class} property IsSearchable: string read __fakeFieldGet_IsSearchable;
    ///<summary>Used by the GetSchema method to create the IsSearchableWithLike column in the DataTypes collection.</summary>
    {class} property IsSearchableWithLike: string read __fakeFieldGet_IsSearchableWithLike;
    ///<summary>Used by the GetSchema method to create the IsUnsigned column in the DataTypes collection.</summary>
    {class} property IsUnsigned: string read __fakeFieldGet_IsUnsigned;
    ///<summary>Used by the GetSchema method to create the LiteralPrefix column in the DataTypes collection.</summary>
    {class} property LiteralPrefix: string read __fakeFieldGet_LiteralPrefix;
    ///<summary>Used by the GetSchema method to create the LiteralSuffix column in the DataTypes collection.</summary>
    {class} property LiteralSuffix: string read __fakeFieldGet_LiteralSuffix;
    ///<summary>Used by the GetSchema method to create the MaximumScale column in the DataTypes collection.</summary>
    {class} property MaximumScale: string read __fakeFieldGet_MaximumScale;
    ///<summary>Used by the GetSchema method to create the MinimumScale column in the DataTypes collection.</summary>
    {class} property MinimumScale: string read __fakeFieldGet_MinimumScale;
    ///<summary>Used by the GetSchema method to create the NumberOfIdentifierParts column in the MetaDataCollections collection.</summary>
    {class} property NumberOfIdentifierParts: string read __fakeFieldGet_NumberOfIdentifierParts;
    ///<summary>Used by the GetSchema method to create the NumberOfRestrictions column in the MetaDataCollections collection.</summary>
    {class} property NumberOfRestrictions: string read __fakeFieldGet_NumberOfRestrictions;
    ///<summary>Used by the GetSchema method to create the OrderByColumnsInSelect column in the DataSourceInformation collection.</summary>
    {class} property OrderByColumnsInSelect: string read __fakeFieldGet_OrderByColumnsInSelect;
    ///<summary>Used by the GetSchema method to create the ParameterMarkerFormat column in the DataSourceInformation collection.</summary>
    {class} property ParameterMarkerFormat: string read __fakeFieldGet_ParameterMarkerFormat;
    ///<summary>Used by the GetSchema method to create the ParameterMarkerPattern column in the DataSourceInformation collection.</summary>
    {class} property ParameterMarkerPattern: string read __fakeFieldGet_ParameterMarkerPattern;
    ///<summary>Used by the GetSchema method to create the ParameterNameMaxLength column in the DataSourceInformation collection.</summary>
    {class} property ParameterNameMaxLength: string read __fakeFieldGet_ParameterNameMaxLength;
    ///<summary>Used by the GetSchema method to create the ParameterNamePattern column in the DataSourceInformation collection.</summary>
    {class} property ParameterNamePattern: string read __fakeFieldGet_ParameterNamePattern;
    ///<summary>Used by the GetSchema method to create the ProviderDbType column in the DataTypes collection.</summary>
    {class} property ProviderDbType: string read __fakeFieldGet_ProviderDbType;
    ///<summary>Used by the GetSchema method to create the QuotedIdentifierCase column in the DataSourceInformation collection.</summary>
    {class} property QuotedIdentifierCase: string read __fakeFieldGet_QuotedIdentifierCase;
    ///<summary>Used by the GetSchema method to create the QuotedIdentifierPattern column in the DataSourceInformation collection.</summary>
    {class} property QuotedIdentifierPattern: string read __fakeFieldGet_QuotedIdentifierPattern;
    ///<summary>Used by the GetSchema method to create the ReservedWord column in the ReservedWords collection.</summary>
    {class} property ReservedWord: string read __fakeFieldGet_ReservedWord;
    ///<summary>Used by the GetSchema method to create the StatementSeparatorPattern column in the DataSourceInformation collection.</summary>
    {class} property StatementSeparatorPattern: string read __fakeFieldGet_StatementSeparatorPattern;
    ///<summary>Used by the GetSchema method to create the StringLiteralPattern column in the DataSourceInformation collection.</summary>
    {class} property StringLiteralPattern: string read __fakeFieldGet_StringLiteralPattern;
    ///<summary>Used by the GetSchema method to create the SupportedJoinOperators column in the DataSourceInformation collection.</summary>
    {class} property SupportedJoinOperators: string read __fakeFieldGet_SupportedJoinOperators;
    ///<summary>Used by the GetSchema method to create the TypeName column in the DataTypes collection.</summary>
    {class} property TypeName: string read __fakeFieldGet_TypeName;

  end;

  ///<summary>Provides static values that are used for the column names in the MetaDataCollection objects contained in the <see cref="T:System.Data.DataTable" />
  ///  . The <see cref="T:System.Data.DataTable" />
  ///  is created by the GetSchema method.</summary>
  [DNTypeName('System.Data.Common.DbMetaDataColumnNames')]
  DNDbMetaDataColumnNames = interface(DDN.mscorlib.DNObject)
  ['{179009F4-9A5A-331D-9FD8-A68057B57177}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbMetaDataColumnNames = class(TDNGenericImport<DNDbMetaDataColumnNamesClass, DNDbMetaDataColumnNames>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbProviderConfigurationHandlerClass = interface(DNObjectClass)
  ['{ADCF575D-AD12-5CFA-BBF4-0B71877A90E9}']
  { constructors } 

    ///<summary>This class can be used by any provider to support a provider-specific configuration section.</summary>
    {class} function init: DNDbProviderConfigurationHandler;

  end;

  ///<summary>This class can be used by any provider to support a provider-specific configuration section.</summary>
  [DNTypeName('System.Data.Common.DbProviderConfigurationHandler')]
  DNDbProviderConfigurationHandler = interface(DDN.System.Configuration.DNIConfigurationSectionHandler)
  ['{25D5927A-38D6-3F85-B3C8-2E8603CB0C55}']
  { methods } 

    ///<summary>Creates a new <see cref="System.Collections.Specialized.NameValueCollection" />
    ///  expression.</summary>
    ///  <param name="parent">This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</param>
    ///  <param name="configContext">This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</param>
    ///  <param name="section">This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</param>
    ///<returns>The new expression.</returns>
    function Create(parent: DDN.mscorlib.DNObject; configContext: DDN.mscorlib.DNObject; section: DDN.System.Xml.DNXmlNode): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbProviderConfigurationHandler = class(TDNGenericImport<DNDbProviderConfigurationHandlerClass, DNDbProviderConfigurationHandler>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbProviderFactoriesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{A3FC1820-7795-59D2-9A22-9059712AD6E6}']
  { static methods } 

    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that contains information about all installed providers that implement <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  .</summary>
    ///<returns>Returns a <see cref="T:System.Data.DataTable" />
    ///  containing <see cref="T:System.Data.DataRow" />
    ///  objects that contain the following data. Column ordinalColumn nameDescription0
    ///  Name
    ///  Human-readable name for the data provider.1
    ///  Description
    ///  Human-readable description of the data provider.2
    ///  InvariantName
    ///  Name that can be used programmatically to refer to the data provider.3
    ///  AssemblyQualifiedName
    ///  Fully qualified name of the factory class, which contains enough information to instantiate the object.</returns>
    {class} function GetFactoryClasses: DNDataTable;
    ///<summary>Returns an instance of a <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  .</summary>
    ///  <param name="providerInvariantName">Invariant name of a provider.</param>
    ///<returns>An instance of a <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  for a specified provider name.</returns>
    {class} function GetFactory(providerInvariantName: string): DNDbProviderFactory; overload;
    ///<summary>Returns an instance of a <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  .</summary>
    ///  <param name="providerRow"><see cref="T:System.Data.DataRow" />
    ///  containing the provider's configuration information.</param>
    ///<returns>An instance of a <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  for a specified <see cref="T:System.Data.DataRow" />
    ///  .</returns>
    {class} function GetFactory(providerRow: DNDataRow): DNDbProviderFactory; overload;
    ///<summary>Returns an instance of a <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  .</summary>
    ///  <param name="connection">The connection used.</param>
    ///<returns>An instance of a <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  for a specified connection.</returns>
    {class} function GetFactory(connection: DNDbConnection): DNDbProviderFactory; overload;

  end;

  ///<summary>Represents a set of static methods for creating one or more instances of <see cref="T:System.Data.Common.DbProviderFactory" />
  ///  classes.</summary>
  [DNTypeName('System.Data.Common.DbProviderFactories')]
  DNDbProviderFactories = interface(DDN.mscorlib.DNObject)
  ['{4F66693F-753B-38BA-8CE7-5993A84851D8}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbProviderFactories = class(TDNGenericImport<DNDbProviderFactoriesClass, DNDbProviderFactories>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbProviderFactoriesConfigurationHandlerClass = interface(DNObjectClass)
  ['{0DD69E91-5FF4-5654-B866-09AFECEF66F1}']
  { constructors } 

    ///<summary>This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    {class} function init: DNDbProviderFactoriesConfigurationHandler;

  end;

  ///<summary>This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
  [DNTypeName('System.Data.Common.DbProviderFactoriesConfigurationHandler')]
  DNDbProviderFactoriesConfigurationHandler = interface(DDN.System.Configuration.DNIConfigurationSectionHandler)
  ['{7C35AC0E-F224-3EB1-BF6D-153E48CA5FF2}']
  { methods } 

    ///<summary>This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    ///  <param name="parent">This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</param>
    ///  <param name="configContext">This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</param>
    ///  <param name="section">This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</param>
    ///<returns>This type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</returns>
    function Create(parent: DDN.mscorlib.DNObject; configContext: DDN.mscorlib.DNObject; section: DDN.System.Xml.DNXmlNode): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDbProviderFactoriesConfigurationHandler = class(TDNGenericImport<DNDbProviderFactoriesConfigurationHandlerClass, DNDbProviderFactoriesConfigurationHandler>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbProviderFactoryClass = interface(DDN.mscorlib.DNObjectClass)
  ['{BCE20412-E2C3-5A60-BC9A-7A98ECCFF473}']
  end;

  ///<summary>Represents a set of methods for creating instances of a provider's implementation of the data source classes.</summary>
  [DNTypeName('System.Data.Common.DbProviderFactory')]
  DNDbProviderFactory = interface(DDN.mscorlib.DNObject)
  ['{D444E2EA-2294-335C-AD61-ECF89730C995}']
  { getters & setters } 

    function get_CanCreateDataSourceEnumerator: Boolean;

  { methods } 

    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbCommand" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbCommand" />
    ///  .</returns>
    function CreateCommand: DNDbCommand;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    function CreateCommandBuilder: DNDbCommandBuilder;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbConnection" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbConnection" />
    ///  .</returns>
    function CreateConnection: DNDbConnection;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    function CreateConnectionStringBuilder: DNDbConnectionStringBuilder;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  .</returns>
    function CreateDataAdapter: DNDbDataAdapter;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbParameter" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbParameter" />
    ///  .</returns>
    function CreateParameter: DNDbParameter;
    ///<summary>Returns a new instance of the provider's class that implements the provider's version of the <see cref="T:System.Security.CodeAccessPermission" />
    ///  class.</summary>
    ///  <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values.</param>
    ///<returns>A <see cref="T:System.Security.CodeAccessPermission" />
    ///  object for the specified <see cref="T:System.Security.Permissions.PermissionState" />
    ///  .</returns>
    function CreatePermission(state: DDN.mscorlib.DNPermissionState): DDN.mscorlib.DNCodeAccessPermission;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  .</returns>
    function CreateDataSourceEnumerator: DNDbDataSourceEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Specifies whether the specific <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  supports the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class.</summary>
    ///<returns><see langword="true" />
    ///  if the instance of the <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  supports the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class; otherwise <see langword="false" />
    ///  .</returns>
    property CanCreateDataSourceEnumerator: Boolean read get_CanCreateDataSourceEnumerator;
  end;

  TDNDbProviderFactory = class(TDNGenericImport<DNDbProviderFactoryClass, DNDbProviderFactory>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcFactoryClass = interface(DNDbProviderFactoryClass)
  ['{A8BB5F11-B5CF-56F5-B43D-EE80FE09FC7E}']
  { static fields getter & setter } 

   function __fakeFieldGet_Instance: DNOdbcFactory;

  { static fields } 

    ///<summary>Gets an instance of the <see cref="T:System.Data.Odbc.OdbcFactory" />
    ///  , which can be used to retrieve strongly-typed data objects.</summary>
    {class} property Instance: DNOdbcFactory read __fakeFieldGet_Instance;

  end;

  ///<summary>Represents a set of methods for creating instances of the ODBC provider's implementation of the data source classes.</summary>
  [DNTypeName('System.Data.Odbc.OdbcFactory')]
  DNOdbcFactory = interface(DNDbProviderFactory)
  ['{27C6B951-E1BC-3BB3-BEB7-6F0D23C21915}']
  { getters & setters } 

    function get_CanCreateDataSourceEnumerator: Boolean;

  { methods } 

    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbCommand" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbCommand" />
    ///  .</returns>
    function CreateCommand: DNDbCommand;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    function CreateCommandBuilder: DNDbCommandBuilder;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbConnection" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbConnection" />
    ///  .</returns>
    function CreateConnection: DNDbConnection;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    function CreateConnectionStringBuilder: DNDbConnectionStringBuilder;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  .</returns>
    function CreateDataAdapter: DNDbDataAdapter;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbParameter" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbParameter" />
    ///  .</returns>
    function CreateParameter: DNDbParameter;
    ///<summary>Returns a strongly-typed <see cref="T:System.Security.CodeAccessPermission" />
    ///  instance.</summary>
    ///  <param name="state">A member of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  enumeration.</param>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Security.CodeAccessPermission" />
    ///  . </returns>
    function CreatePermission(state: DDN.mscorlib.DNPermissionState): DDN.mscorlib.DNCodeAccessPermission;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  .</returns>
    function CreateDataSourceEnumerator: DNDbDataSourceEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Specifies whether the specific <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  supports the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class.</summary>
    ///<returns><see langword="true" />
    ///  if the instance of the <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  supports the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class; otherwise <see langword="false" />
    ///  .</returns>
    property CanCreateDataSourceEnumerator: Boolean read get_CanCreateDataSourceEnumerator;
  end;

  TDNOdbcFactory = class(TDNGenericImport<DNOdbcFactoryClass, DNOdbcFactory>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbFactoryClass = interface(DNDbProviderFactoryClass)
  ['{F526CC0E-C8D3-5B64-B170-4B6621E0E3BA}']
  { static fields getter & setter } 

   function __fakeFieldGet_Instance: DNOleDbFactory;

  { static fields } 

    ///<summary>Gets an instance of the <see cref="T:System.Data.OleDb.OleDbFactory" />
    ///  . This can be used to retrieve strongly-typed data objects.</summary>
    {class} property Instance: DNOleDbFactory read __fakeFieldGet_Instance;

  end;

  ///<summary>Represents a set of methods for creating instances of the OLEDB provider's implementation of the data source classes.</summary>
  [DNTypeName('System.Data.OleDb.OleDbFactory')]
  DNOleDbFactory = interface(DNDbProviderFactory)
  ['{E0D6CA8C-13A3-3E42-881A-EBEA076DE2FE}']
  { getters & setters } 

    function get_CanCreateDataSourceEnumerator: Boolean;

  { methods } 

    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbCommand" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbCommand" />
    ///  .</returns>
    function CreateCommand: DNDbCommand;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    function CreateCommandBuilder: DNDbCommandBuilder;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbConnection" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbConnection" />
    ///  .</returns>
    function CreateConnection: DNDbConnection;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    function CreateConnectionStringBuilder: DNDbConnectionStringBuilder;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  . </returns>
    function CreateDataAdapter: DNDbDataAdapter;
    ///<summary>Returns a strongly-typed <see cref="T:System.Data.Common.DbParameter" />
    ///  instance.</summary>
    ///<returns>A new strongly-typed instance of <see cref="T:System.Data.Common.DbParameter" />
    ///  .</returns>
    function CreateParameter: DNDbParameter;
    ///<summary>Returns a strongly-typed <see cref="T:System.Security.CodeAccessPermission" />
    ///  instance.</summary>
    ///  <param name="state">A member of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  enumeration.</param>
    ///<returns>A strongly-typed instance of <see cref="T:System.Security.CodeAccessPermission" />
    ///  .</returns>
    function CreatePermission(state: DDN.mscorlib.DNPermissionState): DDN.mscorlib.DNCodeAccessPermission;
    ///<summary>Returns a new instance of the provider's class that implements the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class.</summary>
    ///<returns>A new instance of <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  .</returns>
    function CreateDataSourceEnumerator: DNDbDataSourceEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Specifies whether the specific <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  supports the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class.</summary>
    ///<returns><see langword="true" />
    ///  if the instance of the <see cref="T:System.Data.Common.DbProviderFactory" />
    ///  supports the <see cref="T:System.Data.Common.DbDataSourceEnumerator" />
    ///  class; otherwise <see langword="false" />
    ///  .</returns>
    property CanCreateDataSourceEnumerator: Boolean read get_CanCreateDataSourceEnumerator;
  end;

  TDNOleDbFactory = class(TDNGenericImport<DNOleDbFactoryClass, DNOleDbFactory>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlClientFactoryClass = interface(DNDbProviderFactoryClass)
  ['{1A62464C-3560-5279-A3FD-D2CB7A2C0BB2}']
  { static fields getter & setter } 

   function __fakeFieldGet_Instance: DNSqlClientFactory;

  { static fields } 

    ///<summary>Gets an instance of the <see cref="T:System.Data.SqlClient.SqlClientFactory" />
    ///  . This can be used to retrieve strongly typed data objects.</summary>
    {class} property Instance: DNSqlClientFactory read __fakeFieldGet_Instance;

  end;

  ///<summary>Represents a set of methods for creating instances of the <see cref="N:System.Data.SqlClient" />
  ///  provider's implementation of the data source classes.</summary>
  [DNTypeName('System.Data.SqlClient.SqlClientFactory')]
  DNSqlClientFactory = interface(DNDbProviderFactory)
  ['{FCF7570C-31C8-34C5-93D2-6A37D7612323}']
  { getters & setters } 

    function get_CanCreateDataSourceEnumerator: Boolean;

  { methods } 

    ///<summary>Returns a strongly typed <see cref="T:System.Data.Common.DbCommand" />
    ///  instance.</summary>
    ///<returns>A new strongly typed instance of <see cref="T:System.Data.Common.DbCommand" />
    ///  .</returns>
    function CreateCommand: DNDbCommand;
    ///<summary>Returns a strongly typed <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  instance.</summary>
    ///<returns>A new strongly typed instance of <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    function CreateCommandBuilder: DNDbCommandBuilder;
    ///<summary>Returns a strongly typed <see cref="T:System.Data.Common.DbConnection" />
    ///  instance.</summary>
    ///<returns>A new strongly typed instance of <see cref="T:System.Data.Common.DbConnection" />
    ///  .</returns>
    function CreateConnection: DNDbConnection;
    ///<summary>Returns a strongly typed <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  instance.</summary>
    ///<returns>A new strongly typed instance of <see cref="T:System.Data.Common.DbConnectionStringBuilder" />
    ///  .</returns>
    function CreateConnectionStringBuilder: DNDbConnectionStringBuilder;
    ///<summary>Returns a strongly typed <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  instance.</summary>
    ///<returns>A new strongly typed instance of <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  .</returns>
    function CreateDataAdapter: DNDbDataAdapter;
    ///<summary>Returns a strongly typed <see cref="T:System.Data.Common.DbParameter" />
    ///  instance.</summary>
    ///<returns>A new strongly typed instance of <see cref="T:System.Data.Common.DbParameter" />
    ///  .</returns>
    function CreateParameter: DNDbParameter;
    ///<summary>Returns a new <see cref="T:System.Security.CodeAccessPermission" />
    ///  .</summary>
    ///  <param name="state">A member of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  enumeration.</param>
    ///<returns>A strongly typed instance of <see cref="T:System.Security.CodeAccessPermission" />
    ///  .</returns>
    function CreatePermission(state: DDN.mscorlib.DNPermissionState): DDN.mscorlib.DNCodeAccessPermission;
    ///<summary>Returns a new <see cref="T:System.Data.Sql.SqlDataSourceEnumerator" />
    ///  .</summary>
    ///<returns>A new data source enumerator.</returns>
    function CreateDataSourceEnumerator: DNDbDataSourceEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Returns <see langword="true" />
    ///  if a <see cref="T:System.Data.Sql.SqlDataSourceEnumerator" />
    ///  can be created; otherwise <see langword="false" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if a <see cref="T:System.Data.Sql.SqlDataSourceEnumerator" />
    ///  can be created; otherwise <see langword="false" />
    ///  .</returns>
    property CanCreateDataSourceEnumerator: Boolean read get_CanCreateDataSourceEnumerator;
  end;

  TDNSqlClientFactory = class(TDNGenericImport<DNSqlClientFactoryClass, DNSqlClientFactory>) end;

  //-------------namespace: System.Data.Common----------------
  DNSchemaTableColumnClass = interface(DDN.mscorlib.DNObjectClass)
  ['{340E6785-7541-5ED1-9F11-8E382841FC4A}']
  { static fields getter & setter } 

   function __fakeFieldGet_ColumnName: string;
   function __fakeFieldGet_ColumnOrdinal: string;
   function __fakeFieldGet_ColumnSize: string;
   function __fakeFieldGet_NumericPrecision: string;
   function __fakeFieldGet_NumericScale: string;
   function __fakeFieldGet_DataType: string;
   function __fakeFieldGet_ProviderType: string;
   function __fakeFieldGet_NonVersionedProviderType: string;
   function __fakeFieldGet_IsLong: string;
   function __fakeFieldGet_AllowDBNull: string;
   function __fakeFieldGet_IsAliased: string;
   function __fakeFieldGet_IsExpression: string;
   function __fakeFieldGet_IsKey: string;
   function __fakeFieldGet_IsUnique: string;
   function __fakeFieldGet_BaseSchemaName: string;
   function __fakeFieldGet_BaseTableName: string;
   function __fakeFieldGet_BaseColumnName: string;

  { static fields } 

    ///<summary>Specifies the name of the column in the schema table.</summary>
    {class} property ColumnName: string read __fakeFieldGet_ColumnName;
    ///<summary>Specifies the ordinal of the column.</summary>
    {class} property ColumnOrdinal: string read __fakeFieldGet_ColumnOrdinal;
    ///<summary>Specifies the size of the column.</summary>
    {class} property ColumnSize: string read __fakeFieldGet_ColumnSize;
    ///<summary>Specifies the precision of the column data, if the data is numeric.</summary>
    {class} property NumericPrecision: string read __fakeFieldGet_NumericPrecision;
    ///<summary>Specifies the scale of the column data, if the data is numeric.</summary>
    {class} property NumericScale: string read __fakeFieldGet_NumericScale;
    ///<summary>Specifies the type of data in the column.</summary>
    {class} property DataType: string read __fakeFieldGet_DataType;
    ///<summary>Specifies the provider-specific data type of the column.</summary>
    {class} property ProviderType: string read __fakeFieldGet_ProviderType;
    ///<summary>Specifies the non-versioned provider-specific data type of the column.</summary>
    {class} property NonVersionedProviderType: string read __fakeFieldGet_NonVersionedProviderType;
    ///<summary>Specifies whether this column contains long data.</summary>
    {class} property IsLong: string read __fakeFieldGet_IsLong;
    ///<summary>Specifies whether value <see langword="DBNull" />
    ///  is allowed.</summary>
    {class} property AllowDBNull: string read __fakeFieldGet_AllowDBNull;
    ///<summary>Specifies whether this column is aliased.</summary>
    {class} property IsAliased: string read __fakeFieldGet_IsAliased;
    ///<summary>Specifies whether this column is an expression.</summary>
    {class} property IsExpression: string read __fakeFieldGet_IsExpression;
    ///<summary>Specifies whether this column is a key for the table. </summary>
    {class} property IsKey: string read __fakeFieldGet_IsKey;
    ///<summary>Specifies whether a unique constraint applies to this column.</summary>
    {class} property IsUnique: string read __fakeFieldGet_IsUnique;
    ///<summary>Specifies the name of the schema in the schema table.</summary>
    {class} property BaseSchemaName: string read __fakeFieldGet_BaseSchemaName;
    ///<summary>Specifies the name of the table in the schema table.</summary>
    {class} property BaseTableName: string read __fakeFieldGet_BaseTableName;
    ///<summary>Specifies the name of the column in the schema table.</summary>
    {class} property BaseColumnName: string read __fakeFieldGet_BaseColumnName;

  end;

  ///<summary>Describes the column metadata of the schema for a database table.</summary>
  [DNTypeName('System.Data.Common.SchemaTableColumn')]
  DNSchemaTableColumn = interface(DDN.mscorlib.DNObject)
  ['{945894BD-B20F-3623-92A4-CFBC2CF121D8}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSchemaTableColumn = class(TDNGenericImport<DNSchemaTableColumnClass, DNSchemaTableColumn>) end;

  //-------------namespace: System.Data.Common----------------
  DNSchemaTableOptionalColumnClass = interface(DDN.mscorlib.DNObjectClass)
  ['{86063EB6-8BF1-5ADA-8DF4-B9E9FA661882}']
  { static fields getter & setter } 

   function __fakeFieldGet_ProviderSpecificDataType: string;
   function __fakeFieldGet_IsAutoIncrement: string;
   function __fakeFieldGet_IsHidden: string;
   function __fakeFieldGet_IsReadOnly: string;
   function __fakeFieldGet_IsRowVersion: string;
   function __fakeFieldGet_BaseServerName: string;
   function __fakeFieldGet_BaseCatalogName: string;
   function __fakeFieldGet_AutoIncrementSeed: string;
   function __fakeFieldGet_AutoIncrementStep: string;
   function __fakeFieldGet_DefaultValue: string;
   function __fakeFieldGet_Expression: string;
   function __fakeFieldGet_BaseTableNamespace: string;
   function __fakeFieldGet_BaseColumnNamespace: string;
   function __fakeFieldGet_ColumnMapping: string;

  { static fields } 

    ///<summary>Specifies the provider-specific data type of the column.</summary>
    {class} property ProviderSpecificDataType: string read __fakeFieldGet_ProviderSpecificDataType;
    ///<summary>Specifies whether the column values in the column are automatically incremented.</summary>
    {class} property IsAutoIncrement: string read __fakeFieldGet_IsAutoIncrement;
    ///<summary>Specifies whether this column is hidden.</summary>
    {class} property IsHidden: string read __fakeFieldGet_IsHidden;
    ///<summary>Specifies whether this column is read-only.</summary>
    {class} property IsReadOnly: string read __fakeFieldGet_IsReadOnly;
    ///<summary>Specifies whether this column contains row version information.</summary>
    {class} property IsRowVersion: string read __fakeFieldGet_IsRowVersion;
    ///<summary>The server name of the column.</summary>
    {class} property BaseServerName: string read __fakeFieldGet_BaseServerName;
    ///<summary>The name of the catalog associated with the results of the latest query.</summary>
    {class} property BaseCatalogName: string read __fakeFieldGet_BaseCatalogName;
    ///<summary>Specifies the value at which the series for new identity columns is assigned.</summary>
    {class} property AutoIncrementSeed: string read __fakeFieldGet_AutoIncrementSeed;
    ///<summary>Specifies the increment between values in the identity column.</summary>
    {class} property AutoIncrementStep: string read __fakeFieldGet_AutoIncrementStep;
    ///<summary>The default value for the column.</summary>
    {class} property DefaultValue: string read __fakeFieldGet_DefaultValue;
    ///<summary>The expression used to compute the column.</summary>
    {class} property Expression: string read __fakeFieldGet_Expression;
    ///<summary>The namespace for the table that contains the column.</summary>
    {class} property BaseTableNamespace: string read __fakeFieldGet_BaseTableNamespace;
    ///<summary>The namespace of the column.</summary>
    {class} property BaseColumnNamespace: string read __fakeFieldGet_BaseColumnNamespace;
    ///<summary>Specifies the mapping for the column.</summary>
    {class} property ColumnMapping: string read __fakeFieldGet_ColumnMapping;

  end;

  ///<summary>Describes optional column metadata of the schema for a database table.</summary>
  [DNTypeName('System.Data.Common.SchemaTableOptionalColumn')]
  DNSchemaTableOptionalColumn = interface(DDN.mscorlib.DNObject)
  ['{12B8017E-5FCB-31B1-82FC-C00CB63695FC}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSchemaTableOptionalColumn = class(TDNGenericImport<DNSchemaTableOptionalColumnClass, DNSchemaTableOptionalColumn>) end;

  //-------------namespace: System.Data----------------
  DNConstraintClass = interface(DDN.mscorlib.DNObjectClass)
  ['{376E489F-FCFD-5759-9D08-4ECBEE117D5D}']
  end;

  ///<summary>Represents a constraint that can be enforced on one or more <see cref="T:System.Data.DataColumn" />
  ///  objects.</summary>
  [DNTypeName('System.Data.Constraint')]
  DNConstraint = interface(DDN.mscorlib.DNObject)
  ['{EB020EE2-BFFB-30DF-B5FA-7769DC394BD2}']
  { getters & setters } 

    function get_ConstraintName: string;
    procedure set_ConstraintName(value: string);
    function get_Table: DNDataTable;
    function get_ExtendedProperties: DNPropertyCollection;

  { methods } 

    ///<summary>Gets the <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  , if there is one, as a string.</summary>
    ///<returns>The string value of the <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>The name of a constraint in the <see cref="T:System.Data.ConstraintCollection" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.Constraint" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.Constraint" />
    ///  name is a null value or empty string. </exception><exception cref="T:System.Data.DuplicateNameException">The <see cref="T:System.Data.ConstraintCollection" />
    ///  already contains a <see cref="T:System.Data.Constraint" />
    ///  with the same name (The comparison is not case-sensitive.). </exception>
    property ConstraintName: string read get_ConstraintName write set_ConstraintName;
    ///<summary>Gets the <see cref="T:System.Data.DataTable" />
    ///  to which the constraint applies.</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  to which the constraint applies.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>Gets the collection of user-defined constraint properties.</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  of custom information.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
  end;

  TDNConstraint = class(TDNGenericImport<DNConstraintClass, DNConstraint>) end;

  //-------------namespace: System.Data----------------
  DNForeignKeyConstraintClass = interface(DNConstraintClass)
  ['{E2C7B0FB-A5E1-57AF-BD3E-BFC62C242C38}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  class with the specified parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="parentColumn">The parent <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///  <param name="childColumn">The child <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the columns is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types.-Or - The tables don't belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(parentColumn: DNDataColumn; childColumn: DNDataColumn): DNForeignKeyConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  class with the specified name, parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="constraintName">The name of the constraint. </param>
    ///  <param name="parentColumn">The parent <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///  <param name="childColumn">The child <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the columns is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types.-Or - The tables don't belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(constraintName: string; parentColumn: DNDataColumn; childColumn: DNDataColumn): DNForeignKeyConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  class with the specified arrays of parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="parentColumns">An array of parent <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///  <param name="childColumns">An array of child <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the columns is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types.-Or - The tables don't belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>): DNForeignKeyConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  class with the specified name, and arrays of parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="constraintName">The name of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  . If <see langword="null" />
    ///  or empty string, a default name will be given when added to the constraints collection. </param>
    ///  <param name="parentColumns">An array of parent <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///  <param name="childColumns">An array of child <see cref="T:System.Data.DataColumn" />
    ///  in the constraint. </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the columns is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types.-Or - The tables don't belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(constraintName: string; parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>): DNForeignKeyConstraint; overload;
    ///<summary>This constructor is provided for design time support in the Visual Studio  environment. <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  objects created by using this constructor must then be added to the collection via <see cref="M:System.Data.ConstraintCollection.AddRange(System.Data.Constraint[])" />
    ///  . Tables and columns with the specified names must exist at the time the method is called, or if <see cref="M:System.Data.DataTable.BeginInit" />
    ///  has been called prior to calling this constructor, the tables and columns with the specified names must exist at the time that <see cref="M:System.Data.DataTable.EndInit" />
    ///  is called.</summary>
    ///  <param name="constraintName">The name of the constraint. </param>
    ///  <param name="parentTableName">The name of the parent <see cref="T:System.Data.DataTable" />
    ///  that contains parent <see cref="T:System.Data.DataColumn" />
    ///  objects in the constraint. </param>
    ///  <param name="parentColumnNames">An array of the names of parent <see cref="T:System.Data.DataColumn" />
    ///  objects in the constraint. </param>
    ///  <param name="childColumnNames">An array of the names of child <see cref="T:System.Data.DataColumn" />
    ///  objects in the constraint. </param>
    ///  <param name="acceptRejectRule">One of the <see cref="T:System.Data.AcceptRejectRule" />
    ///  values. Possible values include <see langword="None" />
    ///  , <see langword="Cascade" />
    ///  , and <see langword="Default" />
    ///  . </param>
    ///  <param name="deleteRule">One of the <see cref="T:System.Data.Rule" />
    ///  values to use when a row is deleted. The default is <see langword="Cascade" />
    ///  . Possible values include: <see langword="None" />
    ///  , <see langword="Cascade" />
    ///  , <see langword="SetNull" />
    ///  , <see langword="SetDefault" />
    ///  , and <see langword="Default" />
    ///  . </param>
    ///  <param name="updateRule">One of the <see cref="T:System.Data.Rule" />
    ///  values to use when a row is updated. The default is <see langword="Cascade" />
    ///  . Possible values include: <see langword="None" />
    ///  , <see langword="Cascade" />
    ///  , <see langword="SetNull" />
    ///  , <see langword="SetDefault" />
    ///  , and <see langword="Default" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the columns is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types.-Or - The tables don't belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(constraintName: string; parentTableName: string; parentColumnNames: TArray<string>; childColumnNames: TArray<string>; acceptRejectRule: DNAcceptRejectRule; deleteRule: DNRule; updateRule: DNRule): DNForeignKeyConstraint; overload;
    ///<summary>This constructor is provided for design time support in the Visual Studio  environment. <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  objects created by using this constructor must then be added to the collection via <see cref="M:System.Data.ConstraintCollection.AddRange(System.Data.Constraint[])" />
    ///  . Tables and columns with the specified names must exist at the time the method is called, or if <see cref="M:System.Data.DataTable.BeginInit" />
    ///  has been called prior to calling this constructor, the tables and columns with the specified names must exist at the time that <see cref="M:System.Data.DataTable.EndInit" />
    ///  is called.</summary>
    ///  <param name="constraintName">The name of the constraint. </param>
    ///  <param name="parentTableName">The name of the parent <see cref="T:System.Data.DataTable" />
    ///  that contains parent <see cref="T:System.Data.DataColumn" />
    ///  objects in the constraint. </param>
    ///  <param name="parentTableNamespace">The name of the <see cref="P:System.Data.DataTable.Namespace" />
    ///  . </param>
    ///  <param name="parentColumnNames">An array of the names of parent <see cref="T:System.Data.DataColumn" />
    ///  objects in the constraint. </param>
    ///  <param name="childColumnNames">An array of the names of child <see cref="T:System.Data.DataColumn" />
    ///  objects in the constraint. </param>
    ///  <param name="acceptRejectRule">One of the <see cref="T:System.Data.AcceptRejectRule" />
    ///  values. Possible values include <see langword="None" />
    ///  , <see langword="Cascade" />
    ///  , and <see langword="Default" />
    ///  . </param>
    ///  <param name="deleteRule">One of the <see cref="T:System.Data.Rule" />
    ///  values to use when a row is deleted. The default is <see langword="Cascade" />
    ///  . Possible values include: <see langword="None" />
    ///  , <see langword="Cascade" />
    ///  , <see langword="SetNull" />
    ///  , <see langword="SetDefault" />
    ///  , and <see langword="Default" />
    ///  . </param>
    ///  <param name="updateRule">One of the <see cref="T:System.Data.Rule" />
    ///  values to use when a row is updated. The default is <see langword="Cascade" />
    ///  . Possible values include: <see langword="None" />
    ///  , <see langword="Cascade" />
    ///  , <see langword="SetNull" />
    ///  , <see langword="SetDefault" />
    ///  , and <see langword="Default" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the columns is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types.-Or - The tables don't belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(constraintName: string; parentTableName: string; parentTableNamespace: string; parentColumnNames: TArray<string>; childColumnNames: TArray<string>; acceptRejectRule: DNAcceptRejectRule; deleteRule: DNRule; updateRule: DNRule): DNForeignKeyConstraint; overload;

  end;

  ///<summary>Represents an action restriction enforced on a set of columns in a primary key/foreign key relationship when a value or row is either deleted or updated.</summary>
  [DNTypeName('System.Data.ForeignKeyConstraint')]
  DNForeignKeyConstraint = interface(DNConstraint)
  ['{9CEA06B5-47F6-3E63-B5F4-9564F1F86276}']
  { getters & setters } 

    function get_Columns: TArray<DNDataColumn>;
    function get_Table: DNDataTable;
    function get_AcceptRejectRule: DNAcceptRejectRule;
    procedure set_AcceptRejectRule(value: DNAcceptRejectRule);
    function get_DeleteRule: DNRule;
    procedure set_DeleteRule(value: DNRule);
    function get_RelatedColumns: TArray<DNDataColumn>;
    function get_RelatedTable: DNDataTable;
    function get_UpdateRule: DNRule;
    procedure set_UpdateRule(value: DNRule);
    function get_ConstraintName: string;
    procedure set_ConstraintName(value: string);
    function get_ExtendedProperties: DNPropertyCollection;

  { methods } 

    ///<summary>Gets a value indicating whether the current <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  is identical to the specified object.</summary>
    ///  <param name="key">The object to which this <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  is compared. Two <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  are equal if they constrain the same columns. </param>
    ///<returns><see langword="true" />
    ///  , if the objects are identical; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(key: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Gets the hash code of this instance of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  object.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    ///<summary>Gets the <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  , if there is one, as a string.</summary>
    ///<returns>The string value of the <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  .</returns>
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the child columns of this constraint.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects that are the child columns of the constraint.</returns>
    property Columns: TArray<DNDataColumn> read get_Columns;
    ///<summary>Gets the child table of this constraint.</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that is the child table in the constraint.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>Indicates the action that should take place across this constraint when <see cref="M:System.Data.DataTable.AcceptChanges" />
    ///  is invoked.</summary>
    ///<returns>One of the <see cref="T:System.Data.AcceptRejectRule" />
    ///  values. Possible values include <see langword="None" />
    ///  , and <see langword="Cascade" />
    ///  . The default is <see langword="None" />
    ///  .</returns>
    property AcceptRejectRule: DNAcceptRejectRule read get_AcceptRejectRule write set_AcceptRejectRule;
    ///<summary>Gets or sets the action that occurs across this constraint when a row is deleted.</summary>
    ///<returns>One of the <see cref="T:System.Data.Rule" />
    ///  values. The default is <see langword="Cascade" />
    ///  .</returns>
    property DeleteRule: DNRule read get_DeleteRule write set_DeleteRule;
    ///<summary>The parent columns of this constraint.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects that are the parent columns of the constraint.</returns>
    property RelatedColumns: TArray<DNDataColumn> read get_RelatedColumns;
    ///<summary>Gets the parent table of this constraint.</summary>
    ///<returns>The parent <see cref="T:System.Data.DataTable" />
    ///  of this constraint.</returns>
    property RelatedTable: DNDataTable read get_RelatedTable;
    ///<summary>Gets or sets the action that occurs across this constraint on when a row is updated.</summary>
    ///<returns>One of the <see cref="T:System.Data.Rule" />
    ///  values. The default is <see langword="Cascade" />
    ///  .</returns>
    property UpdateRule: DNRule read get_UpdateRule write set_UpdateRule;
    ///<summary>The name of a constraint in the <see cref="T:System.Data.ConstraintCollection" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.Constraint" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.Constraint" />
    ///  name is a null value or empty string. </exception><exception cref="T:System.Data.DuplicateNameException">The <see cref="T:System.Data.ConstraintCollection" />
    ///  already contains a <see cref="T:System.Data.Constraint" />
    ///  with the same name (The comparison is not case-sensitive.). </exception>
    property ConstraintName: string read get_ConstraintName write set_ConstraintName;
    ///<summary>Gets the collection of user-defined constraint properties.</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  of custom information.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
  end;

  TDNForeignKeyConstraint = class(TDNGenericImport<DNForeignKeyConstraintClass, DNForeignKeyConstraint>) end;

  //-------------namespace: System.Data----------------
  DNUniqueConstraintClass = interface(DNConstraintClass)
  ['{5999817A-58A5-5682-8C2C-C667F7EB385E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the specified name and <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///  <param name="name">The name of the constraint. </param>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to constrain. </param>
    {class} function init(name: string; column: DNDataColumn): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the specified <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to constrain. </param>
    {class} function init(column: DNDataColumn): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the specified name and array of <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="name">The name of the constraint. </param>
    ///  <param name="columns">The array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain. </param>
    {class} function init(name: string; columns: TArray<DNDataColumn>): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the given array of <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="columns">The array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain. </param>
    {class} function init(columns: TArray<DNDataColumn>): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the specified name, an array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain, and a value specifying whether the constraint is a primary key.</summary>
    ///  <param name="name">The name of the constraint. </param>
    ///  <param name="columnNames">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain. </param>
    ///  <param name="isPrimaryKey"><see langword="true" />
    ///  to indicate that the constraint is a primary key; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(name: string; columnNames: TArray<string>; isPrimaryKey: Boolean): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the specified name, the <see cref="T:System.Data.DataColumn" />
    ///  to constrain, and a value specifying whether the constraint is a primary key.</summary>
    ///  <param name="name">The name of the constraint. </param>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to constrain. </param>
    ///  <param name="isPrimaryKey"><see langword="true" />
    ///  to indicate that the constraint is a primary key; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(name: string; column: DNDataColumn; isPrimaryKey: Boolean): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the <see cref="T:System.Data.DataColumn" />
    ///  to constrain, and a value specifying whether the constraint is a primary key.</summary>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to constrain. </param>
    ///  <param name="isPrimaryKey"><see langword="true" />
    ///  to indicate that the constraint is a primary key; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(column: DNDataColumn; isPrimaryKey: Boolean): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with the specified name, an array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain, and a value specifying whether the constraint is a primary key.</summary>
    ///  <param name="name">The name of the constraint. </param>
    ///  <param name="columns">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain. </param>
    ///  <param name="isPrimaryKey"><see langword="true" />
    ///  to indicate that the constraint is a primary key; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(name: string; columns: TArray<DNDataColumn>; isPrimaryKey: Boolean): DNUniqueConstraint; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  class with an array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain, and a value specifying whether the constraint is a primary key.</summary>
    ///  <param name="columns">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects to constrain. </param>
    ///  <param name="isPrimaryKey"><see langword="true" />
    ///  to indicate that the constraint is a primary key; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(columns: TArray<DNDataColumn>; isPrimaryKey: Boolean): DNUniqueConstraint; overload;

  end;

  ///<summary>Represents a restriction on a set of columns in which all values must be unique.</summary>
  [DNTypeName('System.Data.UniqueConstraint')]
  DNUniqueConstraint = interface(DNConstraint)
  ['{2E43B09D-4045-385B-9FBA-0D749852FE19}']
  { getters & setters } 

    function get_Columns: TArray<DNDataColumn>;
    function get_IsPrimaryKey: Boolean;
    function get_Table: DNDataTable;
    function get_ConstraintName: string;
    procedure set_ConstraintName(value: string);
    function get_ExtendedProperties: DNPropertyCollection;

  { methods } 

    ///<summary>Compares this constraint to a second to determine if both are identical.</summary>
    ///  <param name="key2">The object to which this <see cref="T:System.Data.UniqueConstraint" />
    ///  is compared. </param>
    ///<returns><see langword="true" />
    ///  , if the contraints are equal; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(key2: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Gets the hash code of this instance of the <see cref="T:System.Data.UniqueConstraint" />
    ///  object.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    ///<summary>Gets the <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  , if there is one, as a string.</summary>
    ///<returns>The string value of the <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  .</returns>
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the array of columns that this constraint affects.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects.</returns>
    property Columns: TArray<DNDataColumn> read get_Columns;
    ///<summary>Gets a value indicating whether or not the constraint is on a primary key.</summary>
    ///<returns><see langword="true" />
    ///  , if the constraint is on a primary key; otherwise, <see langword="false" />
    ///  .</returns>
    property IsPrimaryKey: Boolean read get_IsPrimaryKey;
    ///<summary>Gets the table to which this constraint belongs.</summary>
    ///<returns>The <see cref="T:System.Data.DataTable" />
    ///  to which the constraint belongs.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>The name of a constraint in the <see cref="T:System.Data.ConstraintCollection" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.Constraint" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.Constraint" />
    ///  name is a null value or empty string. </exception><exception cref="T:System.Data.DuplicateNameException">The <see cref="T:System.Data.ConstraintCollection" />
    ///  already contains a <see cref="T:System.Data.Constraint" />
    ///  with the same name (The comparison is not case-sensitive.). </exception>
    property ConstraintName: string read get_ConstraintName write set_ConstraintName;
    ///<summary>Gets the collection of user-defined constraint properties.</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  of custom information.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
  end;

  TDNUniqueConstraint = class(TDNGenericImport<DNUniqueConstraintClass, DNUniqueConstraint>) end;

  //-------------namespace: System.Data----------------
  DNDataRelationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{1C2B58DB-0CF6-54E5-A228-9139B6D1F527}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataRelation" />
    ///  class using the specified <see cref="T:System.Data.DataRelation" />
    ///  name, and parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="relationName">The name of the <see cref="T:System.Data.DataRelation" />
    ///  . If <see langword="null" />
    ///  or an empty string (""), a default name will be given when the created object is added to the <see cref="T:System.Data.DataRelationCollection" />
    ///  . </param>
    ///  <param name="parentColumn">The parent <see cref="T:System.Data.DataColumn" />
    ///  in the relationship. </param>
    ///  <param name="childColumn">The child <see cref="T:System.Data.DataColumn" />
    ///  in the relationship. </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the <see cref="T:System.Data.DataColumn" />
    ///  objects contains <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types -Or- The tables do not belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(relationName: string; parentColumn: DNDataColumn; childColumn: DNDataColumn): DNDataRelation; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataRelation" />
    ///  class using the specified name, parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects, and a value that indicates whether to create constraints.</summary>
    ///  <param name="relationName">The name of the relation. If <see langword="null" />
    ///  or an empty string (""), a default name will be given when the created object is added to the <see cref="T:System.Data.DataRelationCollection" />
    ///  . </param>
    ///  <param name="parentColumn">The parent <see cref="T:System.Data.DataColumn" />
    ///  in the relation. </param>
    ///  <param name="childColumn">The child <see cref="T:System.Data.DataColumn" />
    ///  in the relation. </param>
    ///  <param name="createConstraints">A value that indicates whether constraints are created. <see langword="true" />
    ///  , if constraints are created. Otherwise, <see langword="false" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the <see cref="T:System.Data.DataColumn" />
    ///  objects contains <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types -Or- The tables do not belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(relationName: string; parentColumn: DNDataColumn; childColumn: DNDataColumn; createConstraints: Boolean): DNDataRelation; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataRelation" />
    ///  class using the specified <see cref="T:System.Data.DataRelation" />
    ///  name and matched arrays of parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects.</summary>
    ///  <param name="relationName">The name of the relation. If <see langword="null" />
    ///  or an empty string (""), a default name will be given when the created object is added to the <see cref="T:System.Data.DataRelationCollection" />
    ///  . </param>
    ///  <param name="parentColumns">An array of parent <see cref="T:System.Data.DataColumn" />
    ///  objects. </param>
    ///  <param name="childColumns">An array of child <see cref="T:System.Data.DataColumn" />
    ///  objects. </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the <see cref="T:System.Data.DataColumn" />
    ///  objects contains <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The <see cref="T:System.Data.DataColumn" />
    ///  objects have different data types -Or- One or both of the arrays are not composed of distinct columns from the same table.-Or- The tables do not belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(relationName: string; parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>): DNDataRelation; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataRelation" />
    ///  class using the specified name, matched arrays of parent and child <see cref="T:System.Data.DataColumn" />
    ///  objects, and value that indicates whether to create constraints.</summary>
    ///  <param name="relationName">The name of the relation. If <see langword="null" />
    ///  or an empty string (""), a default name will be given when the created object is added to the <see cref="T:System.Data.DataRelationCollection" />
    ///  . </param>
    ///  <param name="parentColumns">An array of parent <see cref="T:System.Data.DataColumn" />
    ///  objects. </param>
    ///  <param name="childColumns">An array of child <see cref="T:System.Data.DataColumn" />
    ///  objects. </param>
    ///  <param name="createConstraints">A value that indicates whether to create constraints. <see langword="true" />
    ///  , if constraints are created. Otherwise, <see langword="false" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentNullException">One or both of the <see cref="T:System.Data.DataColumn" />
    ///  objects is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The columns have different data types -Or- The tables do not belong to the same <see cref="T:System.Data.DataSet" />
    ///  . </exception>
    {class} function init(relationName: string; parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>; createConstraints: Boolean): DNDataRelation; overload;
    ///<summary>This constructor is provided for design time support in the Visual Studio environment.</summary>
    ///  <param name="relationName">The name of the relation. If <see langword="null" />
    ///  or an empty string (""), a default name will be given when the created object is added to the <see cref="T:System.Data.DataRelationCollection" />
    ///  . </param>
    ///  <param name="parentTableName">The name of the <see cref="T:System.Data.DataTable" />
    ///  that is the parent table of the relation. </param>
    ///  <param name="childTableName">The name of the <see cref="T:System.Data.DataTable" />
    ///  that is the child table of the relation. </param>
    ///  <param name="parentColumnNames">An array of <see cref="T:System.Data.DataColumn" />
    ///  object names in the parent <see cref="T:System.Data.DataTable" />
    ///  of the relation. </param>
    ///  <param name="childColumnNames">An array of <see cref="T:System.Data.DataColumn" />
    ///  object names in the child <see cref="T:System.Data.DataTable" />
    ///  of the relation. </param>
    ///  <param name="nested">A value that indicates whether relationships are nested. </param>
    {class} function init(relationName: string; parentTableName: string; childTableName: string; parentColumnNames: TArray<string>; childColumnNames: TArray<string>; nested: Boolean): DNDataRelation; overload;
    ///<summary>This constructor is provided for design time support in the Visual Studio environment.</summary>
    ///  <param name="relationName">The name of the <see cref="T:System.Data.DataRelation" />
    ///  . If <see langword="null" />
    ///  or an empty string (""), a default name will be given when the created object is added to the <see cref="T:System.Data.DataRelationCollection" />
    ///  . </param>
    ///  <param name="parentTableName">The name of the <see cref="T:System.Data.DataTable" />
    ///  that is the parent table of the relation.</param>
    ///  <param name="parentTableNamespace">The name of the parent table namespace.</param>
    ///  <param name="childTableName">The name of the <see cref="T:System.Data.DataTable" />
    ///  that is the child table of the relation. </param>
    ///  <param name="childTableNamespace">The name of the child table namespace.</param>
    ///  <param name="parentColumnNames">An array of <see cref="T:System.Data.DataColumn" />
    ///  object names in the parent <see cref="T:System.Data.DataTable" />
    ///  of the relation.</param>
    ///  <param name="childColumnNames">An array of <see cref="T:System.Data.DataColumn" />
    ///  object names in the child <see cref="T:System.Data.DataTable" />
    ///  of the relation.</param>
    ///  <param name="nested">A value that indicates whether relationships are nested.</param>
    {class} function init(relationName: string; parentTableName: string; parentTableNamespace: string; childTableName: string; childTableNamespace: string; parentColumnNames: TArray<string>; childColumnNames: TArray<string>; nested: Boolean): DNDataRelation; overload;

  end;

  ///<summary>Represents a parent/child relationship between two <see cref="T:System.Data.DataTable" />
  ///  objects.</summary>
  [DNTypeName('System.Data.DataRelation')]
  DNDataRelation = interface(DDN.mscorlib.DNObject)
  ['{28A715A9-0E4D-3E5F-85A2-D3FB10F07D1D}']
  { getters & setters } 

    function get_ChildColumns: TArray<DNDataColumn>;
    function get_ChildTable: DNDataTable;
    function get_DataSet: DNDataSet;
    function get_ParentColumns: TArray<DNDataColumn>;
    function get_ParentTable: DNDataTable;
    function get_RelationName: string;
    procedure set_RelationName(value: string);
    function get_Nested: Boolean;
    procedure set_Nested(value: Boolean);
    function get_ParentKeyConstraint: DNUniqueConstraint;
    function get_ChildKeyConstraint: DNForeignKeyConstraint;
    function get_ExtendedProperties: DNPropertyCollection;

  { methods } 

    ///<summary>Gets the <see cref="P:System.Data.DataRelation.RelationName" />
    ///  , if one exists.</summary>
    ///<returns>The value of the <see cref="P:System.Data.DataRelation.RelationName" />
    ///  property.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the child <see cref="T:System.Data.DataColumn" />
    ///  objects of this relation.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects.</returns>
    property ChildColumns: TArray<DNDataColumn> read get_ChildColumns;
    ///<summary>Gets the child table of this relation.</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that is the child table of the relation.</returns>
    property ChildTable: DNDataTable read get_ChildTable;
    ///<summary>Gets the <see cref="T:System.Data.DataSet" />
    ///  to which the <see cref="T:System.Data.DataRelation" />
    ///  belongs.</summary>
    ///<returns>A <see cref="T:System.Data.DataSet" />
    ///  to which the <see cref="T:System.Data.DataRelation" />
    ///  belongs.</returns>
    property DataSet: DNDataSet read get_DataSet;
    ///<summary>Gets an array of <see cref="T:System.Data.DataColumn" />
    ///  objects that are the parent columns of this <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects that are the parent columns of this <see cref="T:System.Data.DataRelation" />
    ///  .</returns>
    property ParentColumns: TArray<DNDataColumn> read get_ParentColumns;
    ///<summary>Gets the parent <see cref="T:System.Data.DataTable" />
    ///  of this <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that is the parent table of this relation.</returns>
    property ParentTable: DNDataTable read get_ParentTable;
    ///<summary>Gets or sets the name used to retrieve a <see cref="T:System.Data.DataRelation" />
    ///  from the <see cref="T:System.Data.DataRelationCollection" />
    ///  .</summary>
    ///<returns>The name of the a <see cref="T:System.Data.DataRelation" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><see langword="null" />
    ///  or empty string ("") was passed into a <see cref="T:System.Data.DataColumn" />
    ///  that is a <see cref="T:System.Data.DataRelation" />
    ///  . </exception><exception cref="T:System.Data.DuplicateNameException">The <see cref="T:System.Data.DataRelation" />
    ///  belongs to a collection that already contains a <see cref="T:System.Data.DataRelation" />
    ///  with the same name. </exception>
    property RelationName: string read get_RelationName write set_RelationName;
    ///<summary>Gets or sets a value that indicates whether <see cref="T:System.Data.DataRelation" />
    ///  objects are nested.</summary>
    ///<returns><see langword="true" />
    ///  , if <see cref="T:System.Data.DataRelation" />
    ///  objects are nested; otherwise, <see langword="false" />
    ///  .</returns>
    property Nested: Boolean read get_Nested write set_Nested;
    ///<summary>Gets the <see cref="T:System.Data.UniqueConstraint" />
    ///  that guarantees that values in the parent column of a <see cref="T:System.Data.DataRelation" />
    ///  are unique.</summary>
    ///<returns>A <see cref="T:System.Data.UniqueConstraint" />
    ///  that makes sure that values in a parent column are unique.</returns>
    property ParentKeyConstraint: DNUniqueConstraint read get_ParentKeyConstraint;
    ///<summary>Gets the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  for the relation.</summary>
    ///<returns>A <see langword="ForeignKeyConstraint" />
    ///  .</returns>
    property ChildKeyConstraint: DNForeignKeyConstraint read get_ChildKeyConstraint;
    ///<summary>Gets the collection that stores customized properties.</summary>
    ///<returns>A <see cref="T:System.Data.PropertyCollection" />
    ///  that contains customized properties.</returns>
    property ExtendedProperties: DNPropertyCollection read get_ExtendedProperties;
  end;

  TDNDataRelation = class(TDNGenericImport<DNDataRelationClass, DNDataRelation>) end;

  //-------------namespace: System.Data----------------
  DNDataRowClass = interface(DDN.mscorlib.DNObjectClass)
  ['{EB7D244F-523B-57B6-89A4-E31CABF91FF2}']
  end;

  ///<summary>Represents a row of data in a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  [DNTypeName('System.Data.DataRow')]
  DNDataRow = interface(DDN.mscorlib.DNObject)
  ['{208AC0D0-8D94-3FE0-8090-4813634573A2}']
  { getters & setters } 

    function get_RowError: string;
    procedure set_RowError(value: string);
    function get_RowState: DNDataRowState;
    function get_Table: DNDataTable;
    function get_Item(columnIndex: Int32): DDN.mscorlib.DNObject; overload;
    procedure set_Item(columnIndex: Int32; value: DDN.mscorlib.DNObject); overload;
    function get_Item(columnName: string): DDN.mscorlib.DNObject; overload;
    procedure set_Item(columnName: string; value: DDN.mscorlib.DNObject); overload;
    function get_Item(column: DNDataColumn): DDN.mscorlib.DNObject; overload;
    procedure set_Item(column: DNDataColumn; value: DDN.mscorlib.DNObject); overload;
    function get_Item(columnIndex: Int32; version: DNDataRowVersion): DDN.mscorlib.DNObject; overload;
    function get_Item(columnName: string; version: DNDataRowVersion): DDN.mscorlib.DNObject; overload;
    function get_Item(column: DNDataColumn; version: DNDataRowVersion): DDN.mscorlib.DNObject; overload;
    function get_ItemArray: TArray<DDN.mscorlib.DNObject>;
    procedure set_ItemArray(value: TArray<DDN.mscorlib.DNObject>);
    function get_HasErrors: Boolean;

  { methods } 

    ///<summary>Starts an edit operation on a <see cref="T:System.Data.DataRow" />
    ///  object.</summary>
    ///<exception cref="T:System.Data.InRowChangingEventException">The method was called inside the <see cref="E:System.Data.DataTable.RowChanging" />
    ///  event. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">The method was called upon a deleted row. </exception>
    procedure BeginEdit;
    ///<summary>Cancels the current edit on the row.</summary>
    ///<exception cref="T:System.Data.InRowChangingEventException">The method was called inside the <see cref="E:System.Data.DataTable.RowChanging" />
    ///  event. </exception>
    procedure CancelEdit;
    ///<summary>Deletes the <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    ///<exception cref="T:System.Data.DeletedRowInaccessibleException">The <see cref="T:System.Data.DataRow" />
    ///  has already been deleted.</exception>
    procedure Delete;
    ///<summary>Ends the edit occurring on the row.</summary>
    ///<exception cref="T:System.Data.InRowChangingEventException">The method was called inside the <see cref="E:System.Data.DataTable.RowChanging" />
    ///  event. </exception><exception cref="T:System.Data.ConstraintException">The edit broke a constraint. </exception><exception cref="T:System.Data.ReadOnlyException">The row belongs to the table and the edit tried to change the value of a read-only column. </exception><exception cref="T:System.Data.NoNullAllowedException">The edit tried to put a null value into a column where <see cref="P:System.Data.DataColumn.AllowDBNull" />
    ///  is false. </exception>
    procedure EndEdit;
    ///<summary>Sets the error description for a column specified by index.</summary>
    ///  <param name="columnIndex">The zero-based index of the column. </param>
    ///  <param name="error">The error description. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="columnIndex" />
    ///  argument is out of range </exception>
    procedure SetColumnError(columnIndex: Int32; error: string); overload;
    ///<summary>Sets the error description for a column specified by name.</summary>
    ///  <param name="columnName">The name of the column. </param>
    ///  <param name="error">The error description. </param>
    procedure SetColumnError(columnName: string; error: string); overload;
    ///<summary>Gets the error description for the column specified by index.</summary>
    ///  <param name="columnIndex">The zero-based index of the column. </param>
    ///<returns>The text of the error description.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The <paramref name="columnIndex" />
    ///  argument is out of range. </exception>
    function GetColumnError(columnIndex: Int32): string; overload;
    ///<summary>Gets the error description for a column, specified by name.</summary>
    ///  <param name="columnName">The name of the column. </param>
    ///<returns>The text of the error description.</returns>
    function GetColumnError(columnName: string): string; overload;
    ///<summary>Gets the error description of the specified <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///  <param name="column">A <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///<returns>The text of the error description.</returns>
    function GetColumnError(column: DNDataColumn): string; overload;
    ///<summary>Clears the errors for the row. This includes the <see cref="P:System.Data.DataRow.RowError" />
    ///  and errors set with <see cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
    ///  .</summary>
    procedure ClearErrors;
    ///<summary>Gets the child rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relationName">The <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of the <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception>
    function GetChildRows(relationName: string): TArray<DNDataRow>; overload;
    ///<summary>Gets the child rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  , and <see cref="T:System.Data.DataRowVersion" />
    ///  .</summary>
    ///  <param name="relationName">The <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of the <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values specifying the version of the data to get. Possible values are <see langword="Default" />
    ///  , <see langword="Original" />
    ///  , <see langword="Current" />
    ///  , and <see langword="Proposed" />
    ///  . </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have the requested <see cref="T:System.Data.DataRowVersion" />
    ///  . </exception>
    function GetChildRows(relationName: string; version: DNDataRowVersion): TArray<DNDataRow>; overload;
    ///<summary>Gets the child rows of this <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.ArgumentNullException">The relation is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have this version of data. </exception>
    function GetChildRows(relation: DNDataRelation): TArray<DNDataRow>; overload;
    ///<summary>Gets the child rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="T:System.Data.DataRelation" />
    ///  , and <see cref="T:System.Data.DataRowVersion" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values specifying the version of the data to get. Possible values are <see langword="Default" />
    ///  , <see langword="Original" />
    ///  , <see langword="Current" />
    ///  , and <see langword="Proposed" />
    ///  . </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have the requested <see cref="T:System.Data.DataRowVersion" />
    ///  . </exception>
    function GetChildRows(relation: DNDataRelation; version: DNDataRowVersion): TArray<DNDataRow>; overload;
    ///<summary>Gets the parent row of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relationName">The <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  . </param>
    ///<returns>The parent <see cref="T:System.Data.DataRow" />
    ///  of the current row.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.Data.DataException">A child row has multiple parents.</exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception>
    function GetParentRow(relationName: string): DNDataRow; overload;
    ///<summary>Gets the parent row of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  , and <see cref="T:System.Data.DataRowVersion" />
    ///  .</summary>
    ///  <param name="relationName">The <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  . </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values.</param>
    ///<returns>The parent <see cref="T:System.Data.DataRow" />
    ///  of the current row.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Data.DataException">A child row has multiple parents.</exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have the requested <see cref="T:System.Data.DataRowVersion" />
    ///  . </exception>
    function GetParentRow(relationName: string; version: DNDataRowVersion): DNDataRow; overload;
    ///<summary>Gets the parent row of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///<returns>The parent <see cref="T:System.Data.DataRow" />
    ///  of the current row.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  does not belong to the <see cref="T:System.Data.DataTable" />
    ///  .The row is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.DataException">A child row has multiple parents.</exception><exception cref="T:System.Data.InvalidConstraintException">This row does not belong to the child table of the <see cref="T:System.Data.DataRelation" />
    ///  object. </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to a table. </exception>
    function GetParentRow(relation: DNDataRelation): DNDataRow; overload;
    ///<summary>Gets the parent row of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="T:System.Data.DataRelation" />
    ///  , and <see cref="T:System.Data.DataRowVersion" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values specifying the version of the data to get. </param>
    ///<returns>The parent <see cref="T:System.Data.DataRow" />
    ///  of the current row.</returns>
    ///<exception cref="T:System.ArgumentNullException">The row is <see langword="null" />
    ///  .The <paramref name="relation" />
    ///  does not belong to this table's parent relations. </exception><exception cref="T:System.Data.DataException">A child row has multiple parents.</exception><exception cref="T:System.Data.InvalidConstraintException">The relation's child table is not the table the row belongs to. </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to a table. </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have this version of data. </exception>
    function GetParentRow(relation: DNDataRelation; version: DNDataRowVersion): DNDataRow; overload;
    ///<summary>Gets the parent rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relationName">The <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  . </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception>
    function GetParentRows(relationName: string): TArray<DNDataRow>; overload;
    ///<summary>Gets the parent rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  , and <see cref="T:System.Data.DataRowVersion" />
    ///  .</summary>
    ///  <param name="relationName">The <see cref="P:System.Data.DataRelation.RelationName" />
    ///  of a <see cref="T:System.Data.DataRelation" />
    ///  . </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values specifying the version of the data to get. Possible values are <see langword="Default" />
    ///  , <see langword="Original" />
    ///  , <see langword="Current" />
    ///  , and <see langword="Proposed" />
    ///  . </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The relation and row do not belong to the same table. </exception><exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have the requested <see cref="T:System.Data.DataRowVersion" />
    ///  . </exception>
    function GetParentRows(relationName: string; version: DNDataRowVersion): TArray<DNDataRow>; overload;
    ///<summary>Gets the parent rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.DataRelation" />
    ///  does not belong to this row's <see cref="T:System.Data.DataSet" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The row is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The relation's child table is not the table the row belongs to. </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to a <see cref="T:System.Data.DataTable" />
    ///  . </exception>
    function GetParentRows(relation: DNDataRelation): TArray<DNDataRow>; overload;
    ///<summary>Gets the parent rows of a <see cref="T:System.Data.DataRow" />
    ///  using the specified <see cref="T:System.Data.DataRelation" />
    ///  , and <see cref="T:System.Data.DataRowVersion" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values specifying the version of the data to get. </param>
    ///<returns>An array of <see cref="T:System.Data.DataRow" />
    ///  objects or an array of length zero.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.DataRelation" />
    ///  does not belong to this row's <see cref="T:System.Data.DataSet" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The row is <see langword="null" />
    ///  . </exception><exception cref="T:System.Data.InvalidConstraintException">The relation's child table is not the table the row belongs to. </exception><exception cref="T:System.Data.RowNotInTableException">The row does not belong to a <see cref="T:System.Data.DataTable" />
    ///  . </exception><exception cref="T:System.Data.VersionNotFoundException">The row does not have the requested <see cref="T:System.Data.DataRowVersion" />
    ///  . </exception>
    function GetParentRows(relation: DNDataRelation; version: DNDataRowVersion): TArray<DNDataRow>; overload;
    ///<summary>Gets a value that indicates whether a specified version exists.</summary>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values that specifies the row version. </param>
    ///<returns><see langword="true" />
    ///  if the version exists; otherwise, <see langword="false" />
    ///  .</returns>
    function HasVersion(version: DNDataRowVersion): Boolean;
    ///<summary>Gets a value that indicates whether the column at the specified index contains a null value.</summary>
    ///  <param name="columnIndex">The zero-based index of the column. </param>
    ///<returns><see langword="true" />
    ///  if the column contains a null value; otherwise, <see langword="false" />
    ///  .</returns>
    function IsNull(columnIndex: Int32): Boolean; overload;
    ///<summary>Gets a value that indicates whether the named column contains a null value.</summary>
    ///  <param name="columnName">The name of the column. </param>
    ///<returns><see langword="true" />
    ///  if the column contains a null value; otherwise, <see langword="false" />
    ///  .</returns>
    function IsNull(columnName: string): Boolean; overload;
    ///<summary>Gets a value that indicates whether the specified <see cref="T:System.Data.DataColumn" />
    ///  contains a null value.</summary>
    ///  <param name="column">A <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if the column contains a null value; otherwise, <see langword="false" />
    ///  .</returns>
    function IsNull(column: DNDataColumn): Boolean; overload;
    ///<summary>Gets a value that indicates whether the specified <see cref="T:System.Data.DataColumn" />
    ///  and <see cref="T:System.Data.DataRowVersion" />
    ///  contains a null value.</summary>
    ///  <param name="column">A <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///  <param name="version">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values that specifies the row version. Possible values are <see langword="Default" />
    ///  , <see langword="Original" />
    ///  , <see langword="Current" />
    ///  , and <see langword="Proposed" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if the column contains a null value; otherwise, <see langword="false" />
    ///  .</returns>
    function IsNull(column: DNDataColumn; version: DNDataRowVersion): Boolean; overload;
    ///<summary>Sets the parent row of a <see cref="T:System.Data.DataRow" />
    ///  with specified new parent <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    ///  <param name="parentRow">The new parent <see cref="T:System.Data.DataRow" />
    ///  . </param>
    procedure SetParentRow(parentRow: DNDataRow); overload;
    ///<summary>Sets the parent row of a <see cref="T:System.Data.DataRow" />
    ///  with specified new parent <see cref="T:System.Data.DataRow" />
    ///  and <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="parentRow">The new parent <see cref="T:System.Data.DataRow" />
    ///  . </param>
    ///  <param name="relation">The relation <see cref="T:System.Data.DataRelation" />
    ///  to use. </param>
    ///<exception cref="T:System.Data.RowNotInTableException">One of the rows does not belong to a table </exception><exception cref="T:System.ArgumentNullException">One of the rows is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The relation does not belong to the <see cref="T:System.Data.DataRelationCollection" />
    ///  of the <see cref="T:System.Data.DataSet" />
    ///  object. </exception><exception cref="T:System.Data.InvalidConstraintException">The relation's child <see cref="T:System.Data.DataTable" />
    ///  is not the table this row belongs to. </exception>
    procedure SetParentRow(parentRow: DNDataRow; relation: DNDataRelation); overload;
    ///<summary>Changes the <see cref="P:System.Data.DataRow.Rowstate" />
    ///  of a <see cref="T:System.Data.DataRow" />
    ///  to <see langword="Added" />
    ///  . </summary>
    procedure SetAdded;
    ///<summary>Changes the <see cref="P:System.Data.DataRow.Rowstate" />
    ///  of a <see cref="T:System.Data.DataRow" />
    ///  to <see langword="Modified" />
    ///  . </summary>
    procedure SetModified;
    ///<summary>Commits all the changes made to this row since the last time <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  was called.</summary>
    ///<exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception>
    procedure AcceptChanges;
    ///<summary>Sets the error description for a column specified as a <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to set the error description for. </param>
    ///  <param name="error">The error description. </param>
    procedure SetColumnError(column: DNDataColumn; error: string); overload;
    ///<summary>Gets an array of columns that have errors.</summary>
    ///<returns>An array of <see cref="T:System.Data.DataColumn" />
    ///  objects that contain errors.</returns>
    function GetColumnsInError: TArray<DNDataColumn>;
    ///<summary>Rejects all changes made to the row since <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  was last called.</summary>
    ///<exception cref="T:System.Data.RowNotInTableException">The row does not belong to the table. </exception>
    procedure RejectChanges;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the custom error description for a row.</summary>
    ///<returns>The text describing an error.</returns>
    property RowError: string read get_RowError write set_RowError;
    ///<summary>Gets the current state of the row with regard to its relationship to the <see cref="T:System.Data.DataRowCollection" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowState" />
    ///  values.</returns>
    property RowState: DNDataRowState read get_RowState;
    ///<summary>Gets the <see cref="T:System.Data.DataTable" />
    ///  for which this row has a schema.</summary>
    ///<returns>The <see cref="T:System.Data.DataTable" />
    ///  to which this row belongs.</returns>
    property Table: DNDataTable read get_Table;
    property Item[columnIndex: Int32]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    property Item[columnName: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    property Item[column: DNDataColumn]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    property Item[columnIndex: Int32; version: DNDataRowVersion]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[columnName: string; version: DNDataRowVersion]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[column: DNDataColumn; version: DNDataRowVersion]: DDN.mscorlib.DNObject read get_Item; default;
    ///<summary>Gets or sets all the values for this row through an array.</summary>
    ///<returns>An array of type <see cref="T:System.Object" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The array is larger than the number of columns in the table. </exception><exception cref="T:System.InvalidCastException">A value in the array does not match its <see cref="P:System.Data.DataColumn.DataType" />
    ///  in its respective <see cref="T:System.Data.DataColumn" />
    ///  . </exception><exception cref="T:System.Data.ConstraintException">An edit broke a constraint. </exception><exception cref="T:System.Data.ReadOnlyException">An edit tried to change the value of a read-only column. </exception><exception cref="T:System.Data.NoNullAllowedException">An edit tried to put a null value in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" />
    ///  of the <see cref="T:System.Data.DataColumn" />
    ///  object is <see langword="false" />
    ///  . </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">The row has been deleted. </exception>
    property ItemArray: TArray<DDN.mscorlib.DNObject> read get_ItemArray write set_ItemArray;
    ///<summary>Gets a value that indicates whether there are errors in a row.</summary>
    ///<returns><see langword="true" />
    ///  if the row contains an error; otherwise, <see langword="false" />
    ///  .</returns>
    property HasErrors: Boolean read get_HasErrors;
  end;

  TDNDataRow = class(TDNGenericImport<DNDataRowClass, DNDataRow>) end;

  //-------------namespace: System.Data----------------
  DNDataRowBuilderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{9CCC6370-F073-5902-9B26-AD16F3C32860}']
  end;

  ///<summary>The <see langword="DataRowBuilder" />
  ///  type supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
  [DNTypeName('System.Data.DataRowBuilder')]
  DNDataRowBuilder = interface(DDN.mscorlib.DNObject)
  ['{AFE4600F-6640-31C0-ADC9-C67BA3F200AA}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDataRowBuilder = class(TDNGenericImport<DNDataRowBuilderClass, DNDataRowBuilder>) end;

  //-------------namespace: System.Data----------------
  DNDataRowViewClass = interface(DNObjectClass)
  ['{C17EB2C8-B8C1-526F-939F-9872BCC64767}']
  end;

  ///<summary>Represents a customized view of a <see cref="T:System.Data.DataRow" />
  ///  .</summary>
  [DNTypeName('System.Data.DataRowView')]
  DNDataRowView = interface(DDN.System.DNICustomTypeDescriptor)
  ['{91862A40-DC23-3C7F-B0D8-1BFD26EC98E4}']
  { getters & setters } 

    function get_DataView: DNDataView;
    function get_Item(ndx: Int32): DDN.mscorlib.DNObject; overload;
    procedure set_Item(ndx: Int32; value: DDN.mscorlib.DNObject); overload;
    function get_Item(&property: string): DDN.mscorlib.DNObject; overload;
    procedure set_Item(&property: string; value: DDN.mscorlib.DNObject); overload;
    function get_RowVersion: DNDataRowVersion;
    function get_Row: DNDataRow;
    function get_IsNew: Boolean;
    function get_IsEdit: Boolean;

  { events } 

    procedure add_PropertyChanged(value: DDN.System.DNPropertyChangedEventHandler);
    procedure remove_PropertyChanged(value: DDN.System.DNPropertyChangedEventHandler);

  { methods } 

    ///<summary>Gets a value indicating whether the current <see cref="T:System.Data.DataRowView" />
    ///  is identical to the specified object.</summary>
    ///  <param name="other">An <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns><see langword="true" />
    ///  if <paramref name="object" />
    ///  is a <see cref="T:System.Data.DataRowView" />
    ///  and it returns the same row as the current <see cref="T:System.Data.DataRowView" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(other: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Returns the hash code of the <see cref="T:System.Data.DataRow" />
    ///  object.</summary>
    ///<returns>A 32-bit signed integer hash code 1, which represents Boolean <see langword="true" />
    ///  if the value of this instance is nonzero; otherwise the integer zero, which represents Boolean <see langword="false" />
    ///  .</returns>
    function GetHashCode: Int32;
    ///<summary>Returns a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  with the specified <see cref="T:System.Data.DataRelation" />
    ///  and parent..</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  object.</param>
    ///  <param name="followParent">The parent object.</param>
    ///<returns>A <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function CreateChildView(relation: DNDataRelation; followParent: Boolean): DNDataView; overload;
    ///<summary>Returns a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  with the specified child <see cref="T:System.Data.DataRelation" />
    ///  .</summary>
    ///  <param name="relation">The <see cref="T:System.Data.DataRelation" />
    ///  object. </param>
    ///<returns>a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function CreateChildView(relation: DNDataRelation): DNDataView; overload;
    ///<summary>Returns a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  with the specified <see cref="T:System.Data.DataRelation" />
    ///  name and parent.</summary>
    ///  <param name="relationName">A string containing the <see cref="T:System.Data.DataRelation" />
    ///  name.</param>
    ///  <param name="followParent">The parent</param>
    ///<returns>a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function CreateChildView(relationName: string; followParent: Boolean): DNDataView; overload;
    ///<summary>Returns a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  with the specified child <see cref="T:System.Data.DataRelation" />
    ///  name.</summary>
    ///  <param name="relationName">A string containing the <see cref="T:System.Data.DataRelation" />
    ///  name. </param>
    ///<returns>a <see cref="T:System.Data.DataView" />
    ///  for the child <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function CreateChildView(relationName: string): DNDataView; overload;
    ///<summary>Begins an edit procedure.</summary>
    procedure BeginEdit;
    ///<summary>Cancels an edit procedure.</summary>
    procedure CancelEdit;
    ///<summary>Commits changes to the underlying <see cref="T:System.Data.DataRow" />
    ///  and ends the editing session that was begun with <see cref="M:System.Data.DataRowView.BeginEdit" />
    ///  .  Use <see cref="M:System.Data.DataRowView.CancelEdit" />
    ///  to discard the changes made to the <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    procedure EndEdit;
    ///<summary>Deletes a row.</summary>
    procedure Delete;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.DataView" />
    ///  to which this row belongs.</summary>
    ///<returns>The <see langword="DataView" />
    ///  to which this row belongs.</returns>
    property DataView: DNDataView read get_DataView;
    property Item[ndx: Int32]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    property Item[&property: string]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
    ///<summary>Gets the current version description of the <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. Possible values for the <see cref="P:System.Data.DataRowView.RowVersion" />
    ///  property are <see langword="Default" />
    ///  , <see langword="Original" />
    ///  , <see langword="Current" />
    ///  , and <see langword="Proposed" />
    ///  .</returns>
    property RowVersion: DNDataRowVersion read get_RowVersion;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  being viewed.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  being viewed by the <see cref="T:System.Data.DataRowView" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Indicates whether a <see cref="T:System.Data.DataRowView" />
    ///  is new.</summary>
    ///<returns><see langword="true" />
    ///  if the row is new; otherwise <see langword="false" />
    ///  .</returns>
    property IsNew: Boolean read get_IsNew;
    ///<summary>Indicates whether the row is in edit mode.</summary>
    ///<returns><see langword="true" />
    ///  if the row is in edit mode; otherwise <see langword="false" />
    ///  .</returns>
    property IsEdit: Boolean read get_IsEdit;
  end;

  TDNDataRowView = class(TDNGenericImport<DNDataRowViewClass, DNDataRowView>) end;

  //-------------namespace: System.Data----------------
  DNDataViewSettingClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F7258DA3-4FD2-5DD6-A8B2-89B70951B0AF}']
  end;

  ///<summary>Represents the default settings for <see cref="P:System.Data.DataView.ApplyDefaultSort" />
  ///  , <see cref="P:System.Data.DataView.DataViewManager" />
  ///  , <see cref="P:System.Data.DataView.RowFilter" />
  ///  , <see cref="P:System.Data.DataView.RowStateFilter" />
  ///  , <see cref="P:System.Data.DataView.Sort" />
  ///  , and <see cref="P:System.Data.DataView.Table" />
  ///  for DataViews created from the <see cref="T:System.Data.DataViewManager" />
  ///  .</summary>
  [DNTypeName('System.Data.DataViewSetting')]
  DNDataViewSetting = interface(DDN.mscorlib.DNObject)
  ['{A69B4B3C-E79F-3DA5-9584-17C3D4AF0A9E}']
  { getters & setters } 

    function get_ApplyDefaultSort: Boolean;
    procedure set_ApplyDefaultSort(value: Boolean);
    function get_DataViewManager: DNDataViewManager;
    function get_Table: DNDataTable;
    function get_RowFilter: string;
    procedure set_RowFilter(value: string);
    function get_RowStateFilter: DNDataViewRowState;
    procedure set_RowStateFilter(value: DNDataViewRowState);
    function get_Sort: string;
    procedure set_Sort(value: string);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether to use the default sort.</summary>
    ///<returns><see langword="true" />
    ///  if the default sort is used; otherwise <see langword="false" />
    ///  .</returns>
    property ApplyDefaultSort: Boolean read get_ApplyDefaultSort write set_ApplyDefaultSort;
    ///<summary>Gets the <see cref="T:System.Data.DataViewManager" />
    ///  that contains this <see cref="T:System.Data.DataViewSetting" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataViewManager" />
    ///  object.</returns>
    property DataViewManager: DNDataViewManager read get_DataViewManager;
    ///<summary>Gets the <see cref="T:System.Data.DataTable" />
    ///  to which the <see cref="T:System.Data.DataViewSetting" />
    ///  properties apply.</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  object.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>Gets or sets the filter to apply in the <see cref="T:System.Data.DataView" />
    ///  . See <see cref="P:System.Data.DataView.RowFilter" />
    ///  for a code sample using RowFilter.</summary>
    ///<returns>A string that contains the filter to apply.</returns>
    property RowFilter: string read get_RowFilter write set_RowFilter;
    ///<summary>Gets or sets a value indicating whether to display Current, Deleted, Modified Current, ModifiedOriginal, New, Original, Unchanged, or no rows in the <see cref="T:System.Data.DataView" />
    ///  .</summary>
    ///<returns>A value that indicates which rows to display.</returns>
    property RowStateFilter: DNDataViewRowState read get_RowStateFilter write set_RowStateFilter;
    ///<summary>Gets or sets a value indicating the sort to apply in the <see cref="T:System.Data.DataView" />
    ///  . </summary>
    ///<returns>The sort to apply in the <see cref="T:System.Data.DataView" />
    ///  .</returns>
    property Sort: string read get_Sort write set_Sort;
  end;

  TDNDataViewSetting = class(TDNGenericImport<DNDataViewSettingClass, DNDataViewSetting>) end;

  //-------------namespace: System.Data----------------
  DNDataViewSettingCollectionClass = interface(DNObjectClass)
  ['{B5806A80-E07F-5D92-844B-6850F4506BAD}']
  end;

  ///<summary>Contains a read-only collection of <see cref="T:System.Data.DataViewSetting" />
  ///  objects for each <see cref="T:System.Data.DataTable" />
  ///  in a <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.DataViewSettingCollection')]
  DNDataViewSettingCollection = interface(DDN.mscorlib.DNICollection)
  ['{F9A67967-A864-3864-A823-94EB28C60765}']
  { getters & setters } 

    function get_Item(table: DNDataTable): DNDataViewSetting; overload;
    procedure set_Item(table: DNDataTable; value: DNDataViewSetting); overload;
    function get_Item(tableName: string): DNDataViewSetting; overload;
    function get_Item(index: Int32): DNDataViewSetting; overload;
    procedure set_Item(index: Int32; value: DNDataViewSetting); overload;
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Copies the collection objects to a one-dimensional <see cref="T:System.Array" />
    ///  instance starting at the specified index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the values copied from the collection. </param>
    ///  <param name="index">The index of the array at which to start inserting. </param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Copies the collection objects to a one-dimensional <see cref="T:System.Array" />
    ///  instance starting at the specified index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the values copied from the collection. </param>
    ///  <param name="index">The index of the array at which to start inserting. </param>
    procedure CopyTo(ar: TArray<DNDataViewSetting>; index: Int32); overload;
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[table: DNDataTable]: DNDataViewSetting read get_Item write set_Item; default;
    property Item[tableName: string]: DNDataViewSetting read get_Item; default;
    property Item[index: Int32]: DNDataViewSetting read get_Item write set_Item; default;
    ///<summary>Gets the number of <see cref="T:System.Data.DataViewSetting" />
    ///  objects in the <see cref="T:System.Data.DataViewSettingCollection" />
    ///  .</summary>
    ///<returns>The number of <see cref="T:System.Data.DataViewSetting" />
    ///  objects in the collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.DataViewSettingCollection" />
    ///  is read-only.</summary>
    ///<returns>Returns <see langword="true" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether access to the <see cref="T:System.Data.DataViewSettingCollection" />
    ///  is synchronized (thread-safe).</summary>
    ///<returns>This property is always <see langword="false" />
    ///  , unless overridden by a derived class.</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Data.DataViewSettingCollection" />
    ///  .</summary>
    ///<returns>An object that can be used to synchronize access to the <see cref="T:System.Data.DataViewSettingCollection" />
    ///  .</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNDataViewSettingCollection = class(TDNGenericImport<DNDataViewSettingCollectionClass, DNDataViewSettingCollection>) end;

  //-------------namespace: System.Data----------------
  DNInternalDataCollectionBaseClass = interface(DNObjectClass)
  ['{6F9B9085-B3D4-5711-B22B-D3D771AADA35}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  class.</summary>
    {class} function init: DNInternalDataCollectionBase;

  end;

  ///<summary>Provides the base functionality for creating collections.</summary>
  [DNTypeName('System.Data.InternalDataCollectionBase')]
  DNInternalDataCollectionBase = interface(DDN.mscorlib.DNICollection)
  ['{E55DE979-3346-3493-ADE7-ECC252F2D229}']
  { getters & setters } 

    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Copies all the elements of the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  to a one-dimensional <see cref="T:System.Array" />
    ///  , starting at the specified <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  to copy the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  object's elements into. </param>
    ///  <param name="index">The destination <see cref="T:System.Array" />
    ///  index to start copying into. </param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32);
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the total number of elements in a collection.</summary>
    ///<returns>The total number of elements in a collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is synchonized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize the collection.</summary>
    ///<returns>The <see cref="T:System.object" />
    ///  used to synchronize the collection.</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNInternalDataCollectionBase = class(TDNGenericImport<DNInternalDataCollectionBaseClass, DNInternalDataCollectionBase>) end;

  //-------------namespace: System.Data----------------
  DNConstraintCollectionClass = interface(DNInternalDataCollectionBaseClass)
  ['{62C546D3-8AA5-5A4E-BC36-7AAF56476D74}']
  end;

  ///<summary>Represents a collection of constraints for a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  [DNTypeName('System.Data.ConstraintCollection')]
  DNConstraintCollection = interface(DNInternalDataCollectionBase)
  ['{75461A0D-19F9-3D4E-885C-A066AD8C7DA9}']
  { getters & setters } 

    function get_Item(index: Int32): DNConstraint; overload;
    function get_Item(name: string): DNConstraint; overload;
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { events } 

    procedure add_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);
    procedure remove_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);

  { methods } 

    ///<summary>Adds the specified <see cref="T:System.Data.Constraint" />
    ///  object to the collection.</summary>
    ///  <param name="constraint">The <see langword="Constraint" />
    ///  to add. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="constraint" />
    ///  argument is null. </exception><exception cref="T:System.ArgumentException">The constraint already belongs to this collection, or belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a constraint with the same name. (The comparison is not case-sensitive.) </exception>
    procedure Add(constraint: DNConstraint); overload;
    ///<summary>Constructs a new <see cref="T:System.Data.UniqueConstraint" />
    ///  with the specified name, array of <see cref="T:System.Data.DataColumn" />
    ///  objects, and value that indicates whether the column is a primary key, and adds it to the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.UniqueConstraint" />
    ///  . </param>
    ///  <param name="columns">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects to which the constraint applies. </param>
    ///  <param name="primaryKey">Specifies whether the column should be the primary key. If <see langword="true" />
    ///  , the column will be a primary key column.</param>
    ///<returns>A new <see langword="UniqueConstraint" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The constraint already belongs to this collection.-Or- The constraint belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a constraint with the specified name. (The comparison is not case-sensitive.) </exception>
    function Add(name: string; columns: TArray<DNDataColumn>; primaryKey: Boolean): DNConstraint; overload;
    ///<summary>Constructs a new <see cref="T:System.Data.UniqueConstraint" />
    ///  with the specified name, <see cref="T:System.Data.DataColumn" />
    ///  , and value that indicates whether the column is a primary key, and adds it to the collection.</summary>
    ///  <param name="name">The name of the <see langword="UniqueConstraint" />
    ///  . </param>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to which the constraint applies. </param>
    ///  <param name="primaryKey">Specifies whether the column should be the primary key. If <see langword="true" />
    ///  , the column will be a primary key column. </param>
    ///<returns>A new <see langword="UniqueConstraint" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The constraint already belongs to this collection.-Or- The constraint belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a constraint with the specified name. (The comparison is not case-sensitive.) </exception>
    function Add(name: string; column: DNDataColumn; primaryKey: Boolean): DNConstraint; overload;
    ///<summary>Constructs a new <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  with the specified name, parent column, and child column, and adds the constraint to the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  . </param>
    ///  <param name="primaryKeyColumn">The primary key, or parent, <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///  <param name="foreignKeyColumn">The foreign key, or child, <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///<returns>A new <see langword="ForeignKeyConstraint" />
    ///  .</returns>
    function Add(name: string; primaryKeyColumn: DNDataColumn; foreignKeyColumn: DNDataColumn): DNConstraint; overload;
    ///<summary>Constructs a new <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  , with the specified arrays of parent columns and child columns, and adds the constraint to the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  . </param>
    ///  <param name="primaryKeyColumns">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects that are the primary key, or parent, columns. </param>
    ///  <param name="foreignKeyColumns">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects that are the foreign key, or child, columns. </param>
    ///<returns>A new <see langword="ForeignKeyConstraint" />
    ///  .</returns>
    function Add(name: string; primaryKeyColumns: TArray<DNDataColumn>; foreignKeyColumns: TArray<DNDataColumn>): DNConstraint; overload;
    ///<summary>Copies the elements of the specified <see cref="T:System.Data.ConstraintCollection" />
    ///  array to the end of the collection.</summary>
    ///  <param name="constraints">An array of <see cref="T:System.Data.ConstraintCollection" />
    ///  objects to add to the collection. </param>
    procedure AddRange(constraints: TArray<DNConstraint>);
    ///<summary>Indicates whether a <see cref="T:System.Data.Constraint" />
    ///  can be removed.</summary>
    ///  <param name="constraint">The <see cref="T:System.Data.Constraint" />
    ///  to be tested for removal from the collection. </param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Constraint" />
    ///  can be removed from collection; otherwise, <see langword="false" />
    ///  .</returns>
    function CanRemove(constraint: DNConstraint): Boolean;
    ///<summary>Indicates whether the <see cref="T:System.Data.Constraint" />
    ///  object specified by name exists in the collection.</summary>
    ///  <param name="name">The <see cref="P:System.Data.Constraint.ConstraintName" />
    ///  of the constraint. </param>
    ///<returns><see langword="true" />
    ///  if the collection contains the specified constraint; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(name: string): Boolean;
    ///<summary>Copies the collection objects to a one-dimensional <see cref="T:System.Array" />
    ///  instance starting at the specified index.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the values copied from the collection.</param>
    ///  <param name="index">The index of the array at which to start inserting. </param>
    procedure CopyTo(&array: TArray<DNConstraint>; index: Int32); overload;
    ///<summary>Gets the index of the specified <see cref="T:System.Data.Constraint" />
    ///  .</summary>
    ///  <param name="constraint">The <see cref="T:System.Data.Constraint" />
    ///  to search for. </param>
    ///<returns>The zero-based index of the <see cref="T:System.Data.Constraint" />
    ///  if it is in the collection; otherwise, -1.</returns>
    function IndexOf(constraint: DNConstraint): Int32; overload;
    ///<summary>Gets the index of the <see cref="T:System.Data.Constraint" />
    ///  specified by name.</summary>
    ///  <param name="constraintName">The name of the <see cref="T:System.Data.Constraint" />
    ///  . </param>
    ///<returns>The index of the <see cref="T:System.Data.Constraint" />
    ///  if it is in the collection; otherwise, -1.</returns>
    function IndexOf(constraintName: string): Int32; overload;
    ///<summary>Removes the specified <see cref="T:System.Data.Constraint" />
    ///  from the collection.</summary>
    ///  <param name="constraint">The <see cref="T:System.Data.Constraint" />
    ///  to remove. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="constraint" />
    ///  argument is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The constraint does not belong to the collection. </exception>
    procedure Remove(constraint: DNConstraint); overload;
    ///<summary>Removes the <see cref="T:System.Data.Constraint" />
    ///  object at the specified index from the collection.</summary>
    ///  <param name="index">The index of the <see cref="T:System.Data.Constraint" />
    ///  to remove. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">The collection does not have a constraint at this index. </exception>
    procedure RemoveAt(index: Int32);
    ///<summary>Removes the <see cref="T:System.Data.Constraint" />
    ///  object specified by name from the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.Constraint" />
    ///  to remove. </param>
    procedure Remove(name: string); overload;
    ///<summary>Clears the collection of any <see cref="T:System.Data.Constraint" />
    ///  objects.</summary>
    procedure Clear;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  to a one-dimensional <see cref="T:System.Array" />
    ///  , starting at the specified <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  to copy the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  object's elements into. </param>
    ///  <param name="index">The destination <see cref="T:System.Array" />
    ///  index to start copying into. </param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNConstraint read get_Item; default;
    property Item[name: string]: DNConstraint read get_Item; default;
    ///<summary>Gets the total number of elements in a collection.</summary>
    ///<returns>The total number of elements in a collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is synchonized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize the collection.</summary>
    ///<returns>The <see cref="T:System.object" />
    ///  used to synchronize the collection.</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNConstraintCollection = class(TDNGenericImport<DNConstraintCollectionClass, DNConstraintCollection>) end;

  //-------------namespace: System.Data----------------
  DNDataColumnCollectionClass = interface(DNInternalDataCollectionBaseClass)
  ['{A00A9A17-EE05-5836-99D0-2CE1D70A785F}']
  end;

  ///<summary>Represents a collection of <see cref="T:System.Data.DataColumn" />
  ///  objects for a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  [DNTypeName('System.Data.DataColumnCollection')]
  DNDataColumnCollection = interface(DNInternalDataCollectionBase)
  ['{68727487-487C-383F-A83C-DEE9FDDC59EB}']
  { getters & setters } 

    function get_Item(index: Int32): DNDataColumn; overload;
    function get_Item(name: string): DNDataColumn; overload;
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { events } 

    procedure add_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);
    procedure remove_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);

  { methods } 

    ///<summary>Creates and adds the specified <see cref="T:System.Data.DataColumn" />
    ///  object to the <see cref="T:System.Data.DataColumnCollection" />
    ///  .</summary>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to add. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="column" />
    ///  parameter is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The column already belongs to this collection, or to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a column with the specified name. (The comparison is not case-sensitive.) </exception><exception cref="T:System.Data.InvalidExpressionException">The expression is invalid. See the <see cref="P:System.Data.DataColumn.Expression" />
    ///  property for more information about how to create expressions. </exception>
    procedure Add(column: DNDataColumn); overload;
    ///<summary>Copies the elements of the specified <see cref="T:System.Data.DataColumn" />
    ///  array to the end of the collection.</summary>
    ///  <param name="columns">The array of <see cref="T:System.Data.DataColumn" />
    ///  objects to add to the collection. </param>
    procedure AddRange(columns: TArray<DNDataColumn>);
    ///<summary>Creates and adds a <see cref="T:System.Data.DataColumn" />
    ///  object that has the specified name, type, and expression to the <see cref="T:System.Data.DataColumnCollection" />
    ///  .</summary>
    ///  <param name="columnName">The name to use when you create the column. </param>
    ///  <param name="type">The <see cref="P:System.Data.DataColumn.DataType" />
    ///  of the new column. </param>
    ///  <param name="expression">The expression to assign to the <see cref="P:System.Data.DataColumn.Expression" />
    ///  property. </param>
    ///<returns>The newly created <see cref="T:System.Data.DataColumn" />
    ///  .</returns>
    ///<exception cref="T:System.Data.DuplicateNameException">The collection already has a column with the specified name. (The comparison is not case-sensitive.) </exception><exception cref="T:System.Data.InvalidExpressionException">The expression is invalid. See the <see cref="P:System.Data.DataColumn.Expression" />
    ///  property for more information about how to create expressions. </exception>
    function Add(columnName: string; &type: DDN.mscorlib.DNType; expression: string): DNDataColumn; overload;
    ///<summary>Creates and adds a <see cref="T:System.Data.DataColumn" />
    ///  object that has the specified name and type to the <see cref="T:System.Data.DataColumnCollection" />
    ///  .</summary>
    ///  <param name="columnName">The <see cref="P:System.Data.DataColumn.ColumnName" />
    ///  to use when you create the column. </param>
    ///  <param name="type">The <see cref="P:System.Data.DataColumn.DataType" />
    ///  of the new column. </param>
    ///<returns>The newly created <see cref="T:System.Data.DataColumn" />
    ///  .</returns>
    ///<exception cref="T:System.Data.DuplicateNameException">The collection already has a column with the specified name. (The comparison is not case-sensitive.) </exception><exception cref="T:System.Data.InvalidExpressionException">The expression is invalid. See the <see cref="P:System.Data.DataColumn.Expression" />
    ///  property for more information about how to create expressions. </exception>
    function Add(columnName: string; &type: DDN.mscorlib.DNType): DNDataColumn; overload;
    ///<summary>Creates and adds a <see cref="T:System.Data.DataColumn" />
    ///  object that has the specified name to the <see cref="T:System.Data.DataColumnCollection" />
    ///  .</summary>
    ///  <param name="columnName">The name of the column. </param>
    ///<returns>The newly created <see cref="T:System.Data.DataColumn" />
    ///  .</returns>
    ///<exception cref="T:System.Data.DuplicateNameException">The collection already has a column with the specified name. (The comparison is not case-sensitive.) </exception>
    function Add(columnName: string): DNDataColumn; overload;
    ///<summary>Creates and adds a <see cref="T:System.Data.DataColumn" />
    ///  object to the <see cref="T:System.Data.DataColumnCollection" />
    ///  .</summary>
    ///<returns>The newly created <see cref="T:System.Data.DataColumn" />
    ///  .</returns>
    function Add: DNDataColumn; overload;
    ///<summary>Checks whether a specific column can be removed from the collection.</summary>
    ///  <param name="column">A <see cref="T:System.Data.DataColumn" />
    ///  in the collection.</param>
    ///<returns><see langword="true" />
    ///  if the column can be removed. <see langword="false" />
    ///  if,The <paramref name="column" />
    ///  parameter is <see langword="null" />
    ///  .The column does not belong to this collection.The column is part of a relationship.Another column's expression depends on this column.</returns>
    function CanRemove(column: DNDataColumn): Boolean;
    ///<summary>Checks whether the collection contains a column with the specified name.</summary>
    ///  <param name="name">The <see cref="P:System.Data.DataColumn.ColumnName" />
    ///  of the column to look for. </param>
    ///<returns><see langword="true" />
    ///  if a column exists with this name; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(name: string): Boolean;
    ///<summary>Copies the entire collection into an existing array, starting at a specified index within the array.</summary>
    ///  <param name="array">An array of <see cref="T:System.Data.DataColumn" />
    ///  objects to copy the collection into. </param>
    ///  <param name="index">The index to start from.</param>
    procedure CopyTo(&array: TArray<DNDataColumn>; index: Int32); overload;
    ///<summary>Gets the index of a column specified by name.</summary>
    ///  <param name="column">The name of the column to return. </param>
    ///<returns>The index of the column specified by <paramref name="column" />
    ///  if it is found; otherwise, -1.</returns>
    function IndexOf(column: DNDataColumn): Int32; overload;
    ///<summary>Gets the index of the column with the specific name (the name is not case sensitive).</summary>
    ///  <param name="columnName">The name of the column to find. </param>
    ///<returns>The zero-based index of the column with the specified name, or -1 if the column does not exist in the collection.</returns>
    function IndexOf(columnName: string): Int32; overload;
    ///<summary>Removes the specified <see cref="T:System.Data.DataColumn" />
    ///  object from the collection.</summary>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  to remove. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="column" />
    ///  parameter is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The column does not belong to this collection.-Or- The column is part of a relationship.-Or- Another column's expression depends on this column. </exception>
    procedure Remove(column: DNDataColumn); overload;
    ///<summary>Removes the column at the specified index from the collection.</summary>
    ///  <param name="index">The index of the column to remove. </param>
    ///<exception cref="T:System.ArgumentException">The collection does not have a column at the specified index. </exception>
    procedure RemoveAt(index: Int32);
    ///<summary>Removes the <see cref="T:System.Data.DataColumn" />
    ///  object that has the specified name from the collection.</summary>
    ///  <param name="name">The name of the column to remove. </param>
    ///<exception cref="T:System.ArgumentException">The collection does not have a column with the specified name. </exception>
    procedure Remove(name: string); overload;
    ///<summary>Clears the collection of any columns.</summary>
    procedure Clear;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  to a one-dimensional <see cref="T:System.Array" />
    ///  , starting at the specified <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  to copy the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  object's elements into. </param>
    ///  <param name="index">The destination <see cref="T:System.Array" />
    ///  index to start copying into. </param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNDataColumn read get_Item; default;
    property Item[name: string]: DNDataColumn read get_Item; default;
    ///<summary>Gets the total number of elements in a collection.</summary>
    ///<returns>The total number of elements in a collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is synchonized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize the collection.</summary>
    ///<returns>The <see cref="T:System.object" />
    ///  used to synchronize the collection.</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNDataColumnCollection = class(TDNGenericImport<DNDataColumnCollectionClass, DNDataColumnCollection>) end;

  //-------------namespace: System.Data----------------
  DNDataRelationCollectionClass = interface(DNInternalDataCollectionBaseClass)
  ['{D7BD456A-CD28-5D2F-8BC1-CE6573B5B4F1}']
  end;

  ///<summary>Represents the collection of <see cref="T:System.Data.DataRelation" />
  ///  objects for this <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.DataRelationCollection')]
  DNDataRelationCollection = interface(DNInternalDataCollectionBase)
  ['{6AA9CAE2-68C2-3EFB-8947-06F2A62BE714}']
  { getters & setters } 

    function get_Item(index: Int32): DNDataRelation; overload;
    function get_Item(name: string): DNDataRelation; overload;
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { events } 

    procedure add_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);
    procedure remove_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);

  { methods } 

    ///<summary>Copies the elements of the specified <see cref="T:System.Data.DataRelation" />
    ///  array to the end of the collection.</summary>
    ///  <param name="relations">The array of <see cref="T:System.Data.DataRelation" />
    ///  objects to add to the collection. </param>
    procedure AddRange(relations: TArray<DNDataRelation>);
    ///<summary>Creates a <see cref="T:System.Data.DataRelation" />
    ///  with the specified name and arrays of parent and child columns, and adds it to the collection.</summary>
    ///  <param name="name">The name of the <see langword="DataRelation" />
    ///  to create. </param>
    ///  <param name="parentColumns">An array of parent <see cref="T:System.Data.DataColumn" />
    ///  objects. </param>
    ///  <param name="childColumns">An array of child <see langword="DataColumn" />
    ///  objects. </param>
    ///<returns>The created <see langword="DataRelation" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The relation name is a null value. </exception><exception cref="T:System.ArgumentException">The relation already belongs to this collection, or it belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a relation with the same name. (The comparison is not case sensitive.) </exception><exception cref="T:System.Data.InvalidConstraintException">The relation has entered an invalid state since it was created. </exception>
    function Add(name: string; parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>): DNDataRelation; overload;
    ///<summary>Creates a <see cref="T:System.Data.DataRelation" />
    ///  with the specified name, arrays of parent and child columns, and value specifying whether to create a constraint, and adds it to the collection.</summary>
    ///  <param name="name">The name of the <see langword="DataRelation" />
    ///  to create. </param>
    ///  <param name="parentColumns">An array of parent <see cref="T:System.Data.DataColumn" />
    ///  objects. </param>
    ///  <param name="childColumns">An array of child <see langword="DataColumn" />
    ///  objects. </param>
    ///  <param name="createConstraints"><see langword="true" />
    ///  to create a constraint; otherwise <see langword="false" />
    ///  . </param>
    ///<returns>The created relation.</returns>
    ///<exception cref="T:System.ArgumentNullException">The relation name is a null value. </exception><exception cref="T:System.ArgumentException">The relation already belongs to this collection, or it belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a relation with the same name. (The comparison is not case sensitive.) </exception><exception cref="T:System.Data.InvalidConstraintException">The relation has entered an invalid state since it was created. </exception>
    function Add(name: string; parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>; createConstraints: Boolean): DNDataRelation; overload;
    ///<summary>Creates a <see cref="T:System.Data.DataRelation" />
    ///  with the specified parent and child columns, and adds it to the collection.</summary>
    ///  <param name="parentColumns">The parent columns of the relation. </param>
    ///  <param name="childColumns">The child columns of the relation. </param>
    ///<returns>The created relation.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  argument is a null value. </exception><exception cref="T:System.ArgumentException">The relation already belongs to this collection, or it belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a relation with the same name. (The comparison is not case sensitive.) </exception><exception cref="T:System.Data.InvalidConstraintException">The relation has entered an invalid state since it was created. </exception>
    function Add(parentColumns: TArray<DNDataColumn>; childColumns: TArray<DNDataColumn>): DNDataRelation; overload;
    ///<summary>Creates a <see cref="T:System.Data.DataRelation" />
    ///  with the specified name, and parent and child columns, and adds it to the collection.</summary>
    ///  <param name="name">The name of the relation. </param>
    ///  <param name="parentColumn">The parent column of the relation. </param>
    ///  <param name="childColumn">The child column of the relation. </param>
    ///<returns>The created relation.</returns>
    function Add(name: string; parentColumn: DNDataColumn; childColumn: DNDataColumn): DNDataRelation; overload;
    ///<summary>Creates a <see cref="T:System.Data.DataRelation" />
    ///  with the specified name, parent and child columns, with optional constraints according to the value of the <paramref name="createConstraints" />
    ///  parameter, and adds it to the collection.</summary>
    ///  <param name="name">The name of the relation. </param>
    ///  <param name="parentColumn">The parent column of the relation. </param>
    ///  <param name="childColumn">The child column of the relation. </param>
    ///  <param name="createConstraints"><see langword="true" />
    ///  to create constraints; otherwise <see langword="false" />
    ///  . (The default is <see langword="true" />
    ///  ). </param>
    ///<returns>The created relation.</returns>
    function Add(name: string; parentColumn: DNDataColumn; childColumn: DNDataColumn; createConstraints: Boolean): DNDataRelation; overload;
    ///<summary>Creates a <see cref="T:System.Data.DataRelation" />
    ///  with a specified parent and child column, and adds it to the collection.</summary>
    ///  <param name="parentColumn">The parent column of the relation. </param>
    ///  <param name="childColumn">The child column of the relation. </param>
    ///<returns>The created relation.</returns>
    function Add(parentColumn: DNDataColumn; childColumn: DNDataColumn): DNDataRelation; overload;
    ///<summary>Verifies whether a <see cref="T:System.Data.DataRelation" />
    ///  with the specific name (case insensitive) exists in the collection.</summary>
    ///  <param name="name">The name of the relation to find. </param>
    ///<returns><see langword="true" />
    ///  , if a relation with the specified name exists; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(name: string): Boolean;
    ///<summary>Copies the collection of <see cref="T:System.Data.DataRelation" />
    ///  objects starting at the specified index.</summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRelation" />
    ///  objects to copy the collection to.</param>
    ///  <param name="index">The index to start from.</param>
    procedure CopyTo(&array: TArray<DNDataRelation>; index: Int32); overload;
    ///<summary>Gets the index of the specified <see cref="T:System.Data.DataRelation" />
    ///  object.</summary>
    ///  <param name="relation">The relation to search for. </param>
    ///<returns>The 0-based index of the relation, or -1 if the relation is not found in the collection.</returns>
    function IndexOf(relation: DNDataRelation): Int32; overload;
    ///<summary>Gets the index of the <see cref="T:System.Data.DataRelation" />
    ///  specified by name.</summary>
    ///  <param name="relationName">The name of the relation to find. </param>
    ///<returns>The zero-based index of the relation with the specified name, or -1 if the relation does not exist in the collection.</returns>
    function IndexOf(relationName: string): Int32; overload;
    ///<summary>Verifies whether the specified <see cref="T:System.Data.DataRelation" />
    ///  can be removed from the collection.</summary>
    ///  <param name="relation">The relation to perform the check against. </param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.DataRelation" />
    ///  can be removed; otherwise, <see langword="false" />
    ///  .</returns>
    function CanRemove(relation: DNDataRelation): Boolean;
    ///<summary>Removes the relation at the specified index from the collection.</summary>
    ///  <param name="index">The index of the relation to remove. </param>
    ///<exception cref="T:System.ArgumentException">The collection does not have a relation at the specified index. </exception>
    procedure RemoveAt(index: Int32);
    ///<summary>Removes the relation with the specified name from the collection.</summary>
    ///  <param name="name">The name of the relation to remove. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">The collection does not have a relation with the specified name.</exception>
    procedure Remove(name: string); overload;
    ///<summary>Adds a <see cref="T:System.Data.DataRelation" />
    ///  to the <see cref="T:System.Data.DataRelationCollection" />
    ///  .</summary>
    ///  <param name="relation">The <see langword="DataRelation" />
    ///  to add to the collection. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="relation" />
    ///  parameter is a null value. </exception><exception cref="T:System.ArgumentException">The relation already belongs to this collection, or it belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">The collection already has a relation with the specified name. (The comparison is not case sensitive.) </exception><exception cref="T:System.Data.InvalidConstraintException">The relation has entered an invalid state since it was created. </exception>
    procedure Add(relation: DNDataRelation); overload;
    ///<summary>Clears the collection of any relations.</summary>
    procedure Clear;
    ///<summary>Removes the specified relation from the collection.</summary>
    ///  <param name="relation">The relation to remove. </param>
    ///<exception cref="T:System.ArgumentNullException">The relation is a null value.</exception><exception cref="T:System.ArgumentException">The relation does not belong to the collection.</exception>
    procedure Remove(relation: DNDataRelation); overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  to a one-dimensional <see cref="T:System.Array" />
    ///  , starting at the specified <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  to copy the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  object's elements into. </param>
    ///  <param name="index">The destination <see cref="T:System.Array" />
    ///  index to start copying into. </param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNDataRelation read get_Item; default;
    property Item[name: string]: DNDataRelation read get_Item; default;
    ///<summary>Gets the total number of elements in a collection.</summary>
    ///<returns>The total number of elements in a collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is synchonized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize the collection.</summary>
    ///<returns>The <see cref="T:System.object" />
    ///  used to synchronize the collection.</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNDataRelationCollection = class(TDNGenericImport<DNDataRelationCollectionClass, DNDataRelationCollection>) end;

  //-------------namespace: System.Data----------------
  DNDataRowCollectionClass = interface(DNInternalDataCollectionBaseClass)
  ['{5E6C1162-90E6-59F3-BAA0-3D0B3939C9A9}']
  end;

  ///<summary>Represents a collection of rows for a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  [DNTypeName('System.Data.DataRowCollection')]
  DNDataRowCollection = interface(DNInternalDataCollectionBase)
  ['{E3A1DFAE-10DE-3667-8ADD-B69986EBF849}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(index: Int32): DNDataRow;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Adds the specified <see cref="T:System.Data.DataRow" />
    ///  to the <see cref="T:System.Data.DataRowCollection" />
    ///  object.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  to add.</param>
    ///<exception cref="T:System.ArgumentNullException">The row is null. </exception><exception cref="T:System.ArgumentException">The row either belongs to another table or already belongs to this table.</exception><exception cref="T:System.Data.ConstraintException">The addition invalidates a constraint. </exception><exception cref="T:System.Data.NoNullAllowedException">The addition tries to put a null in a <see cref="T:System.Data.DataColumn" />
    ///  where <see cref="P:System.Data.DataColumn.AllowDBNull" />
    ///  is false.</exception>
    procedure Add(row: DNDataRow); overload;
    ///<summary>Inserts a new row into the collection at the specified location.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  to add. </param>
    ///  <param name="pos">The (zero-based) location in the collection where you want to add the <see langword="DataRow" />
    ///  . </param>
    procedure InsertAt(row: DNDataRow; pos: Int32);
    ///<summary>Gets the index of the specified <see cref="T:System.Data.DataRow" />
    ///  object.</summary>
    ///  <param name="row">The <see langword="DataRow" />
    ///  to search for.</param>
    ///<returns>The zero-based index of the row, or -1 if the row is not found in the collection.</returns>
    function IndexOf(row: DNDataRow): Int32;
    ///<summary>Creates a row using specified values and adds it to the <see cref="T:System.Data.DataRowCollection" />
    ///  .</summary>
    ///  <param name="values">The array of values that are used to create the new row. </param>
    ///<returns>None.</returns>
    ///<exception cref="T:System.ArgumentException">The array is larger than the number of columns in the table.</exception><exception cref="T:System.InvalidCastException">A value does not match its respective column type. </exception><exception cref="T:System.Data.ConstraintException">Adding the row invalidates a constraint. </exception><exception cref="T:System.Data.NoNullAllowedException">Trying to put a null in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" />
    ///  is false. </exception>
    function Add(values: TArray<DDN.mscorlib.DNObject>): DNDataRow; overload;
    ///<summary>Gets the row specified by the primary key value.</summary>
    ///  <param name="key">The primary key value of the <see cref="T:System.Data.DataRow" />
    ///  to find. </param>
    ///<returns>A <see cref="T:System.Data.DataRow" />
    ///  that contains the primary key value specified; otherwise a null value if the primary key value does not exist in the <see cref="T:System.Data.DataRowCollection" />
    ///  .</returns>
    ///<exception cref="T:System.Data.MissingPrimaryKeyException">The table does not have a primary key. </exception>
    function Find(key: DDN.mscorlib.DNObject): DNDataRow; overload;
    ///<summary>Gets the row that contains the specified primary key values.</summary>
    ///  <param name="keys">An array of primary key values to find. The type of the array is <see langword="Object" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.DataRow" />
    ///  object that contains the primary key values specified; otherwise a null value if the primary key value does not exist in the <see cref="T:System.Data.DataRowCollection" />
    ///  .</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">No row corresponds to that index value. </exception><exception cref="T:System.Data.MissingPrimaryKeyException">The table does not have a primary key. </exception>
    function Find(keys: TArray<DDN.mscorlib.DNObject>): DNDataRow; overload;
    ///<summary>Clears the collection of all rows.</summary>
    ///<exception cref="T:System.Data.InvalidConstraintException">A <see cref="T:System.Data.ForeignKeyConstraint" />
    ///  is enforced on the <see cref="T:System.Data.DataRowCollection" />
    ///  . </exception>
    procedure Clear;
    ///<summary>Gets a value that indicates whether the primary key of any row in the collection contains the specified value.</summary>
    ///  <param name="key">The value of the primary key to test for. </param>
    ///<returns><see langword="true" />
    ///  if the collection contains a <see cref="T:System.Data.DataRow" />
    ///  with the specified primary key value; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Data.MissingPrimaryKeyException">The table does not have a primary key. </exception>
    function &Contains(key: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Gets a value that indicates whether the primary key columns of any row in the collection contain the values specified in the object array.</summary>
    ///  <param name="keys">An array of primary key values to test for. </param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.DataRowCollection" />
    ///  contains a <see cref="T:System.Data.DataRow" />
    ///  with the specified key values; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Data.MissingPrimaryKeyException">The table does not have a primary key. </exception>
    function &Contains(keys: TArray<DDN.mscorlib.DNObject>): Boolean; overload;
    ///<summary>Copies all the <see cref="T:System.Data.DataRow" />
    ///  objects from the collection into the given array, starting at the given destination array index.</summary>
    ///  <param name="ar">The one-dimensional array that is the destination of the elements copied from the <see langword="DataRowCollection" />
    ///  . The array must have zero-based indexing.</param>
    ///  <param name="index">The zero-based index in the array at which copying begins.</param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Copies all the <see cref="T:System.Data.DataRow" />
    ///  objects from the collection into the given array, starting at the given destination array index.</summary>
    ///  <param name="array">The one-dimensional array that is the destination of the elements copied from the <see langword="DataRowCollection" />
    ///  . The array must have zero-based indexing.</param>
    ///  <param name="index">The zero-based index in the array at which copying begins.</param>
    procedure CopyTo(&array: TArray<DNDataRow>; index: Int32); overload;
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for this collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for this collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes the specified <see cref="T:System.Data.DataRow" />
    ///  from the collection.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  to remove. </param>
    procedure Remove(row: DNDataRow);
    ///<summary>Removes the row at the specified index from the collection.</summary>
    ///  <param name="index">The index of the row to remove. </param>
    procedure RemoveAt(index: Int32);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the total number of <see cref="T:System.Data.DataRow" />
    ///  objects in this collection.</summary>
    ///<returns>The total number of <see cref="T:System.Data.DataRow" />
    ///  objects in this collection.</returns>
    property Count: Int32 read get_Count;
    property Item[index: Int32]: DNDataRow read get_Item; default;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is synchonized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize the collection.</summary>
    ///<returns>The <see cref="T:System.object" />
    ///  used to synchronize the collection.</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNDataRowCollection = class(TDNGenericImport<DNDataRowCollectionClass, DNDataRowCollection>) end;

  //-------------namespace: System.Data----------------
  DNDataTableCollectionClass = interface(DNInternalDataCollectionBaseClass)
  ['{C362542A-D4FE-581A-9E75-42982C793A0F}']
  end;

  ///<summary>Represents the collection of tables for the <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.DataTableCollection')]
  DNDataTableCollection = interface(DNInternalDataCollectionBase)
  ['{1FB590A0-3C5C-3492-B1BB-B1BBBF38D68A}']
  { getters & setters } 

    function get_Item(index: Int32): DNDataTable; overload;
    function get_Item(name: string): DNDataTable; overload;
    function get_Item(name: string; tableNamespace: string): DNDataTable; overload;
    function get_Count: Int32;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { events } 

    procedure add_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);
    procedure remove_CollectionChanged(value: DDN.System.DNCollectionChangeEventHandler);
    procedure add_CollectionChanging(value: DDN.System.DNCollectionChangeEventHandler);
    procedure remove_CollectionChanging(value: DDN.System.DNCollectionChangeEventHandler);

  { methods } 

    ///<summary>Verifies whether the specified <see cref="T:System.Data.DataTable" />
    ///  object can be removed from the collection.</summary>
    ///  <param name="table">The <see langword="DataTable" />
    ///  in the collection to perform the check against. </param>
    ///<returns><see langword="true" />
    ///  if the table can be removed; otherwise <see langword="false" />
    ///  .</returns>
    function CanRemove(table: DNDataTable): Boolean;
    ///<summary>Gets a value that indicates whether a <see cref="T:System.Data.DataTable" />
    ///  object with the specified name exists in the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.DataTable" />
    ///  to find. </param>
    ///<returns><see langword="true" />
    ///  if the specified table exists; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(name: string): Boolean; overload;
    ///<summary>Gets a value that indicates whether a <see cref="T:System.Data.DataTable" />
    ///  object with the specified name and table namespace exists in the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.DataTable" />
    ///  to find.</param>
    ///  <param name="tableNamespace">The name of the <see cref="T:System.Data.DataTable" />
    ///  namespace to look in.</param>
    ///<returns><see langword="true" />
    ///  if the specified table exists; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(name: string; tableNamespace: string): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.DataTableCollection" />
    ///  to a one-dimensional <see cref="T:System.Array" />
    ///  , starting at the specified destination array index.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Array" />
    ///  to copy the current <see cref="T:System.Data.DataTableCollection" />
    ///  object's elements into.</param>
    ///  <param name="index">The destination <see cref="T:System.Array" />
    ///  index to start copying into.</param>
    procedure CopyTo(&array: TArray<DNDataTable>; index: Int32); overload;
    ///<summary>Gets the index of the specified <see cref="T:System.Data.DataTable" />
    ///  object.</summary>
    ///  <param name="table">The <see langword="DataTable" />
    ///  to search for. </param>
    ///<returns>The zero-based index of the table, or -1 if the table is not found in the collection.</returns>
    function IndexOf(table: DNDataTable): Int32; overload;
    ///<summary>Gets the index in the collection of the <see cref="T:System.Data.DataTable" />
    ///  object with the specified name.</summary>
    ///  <param name="tableName">The name of the <see langword="DataTable" />
    ///  object to look for. </param>
    ///<returns>The zero-based index of the <see langword="DataTable" />
    ///  with the specified name, or -1 if the table does not exist in the collection.Returns -1 when two or more tables have the same name but different namespaces. The call does not succeed if there is any ambiguity when matching a table name to exactly one table.</returns>
    function IndexOf(tableName: string): Int32; overload;
    ///<summary>Gets the index in the collection of the specified <see cref="T:System.Data.DataTable" />
    ///  object.</summary>
    ///  <param name="tableName">The name of the <see cref="T:System.Data.DataTable" />
    ///  object to look for.</param>
    ///  <param name="tableNamespace">The name of the <see cref="T:System.Data.DataTable" />
    ///  namespace to look in.</param>
    ///<returns>The zero-based index of the <see cref="T:System.Data.DataTable" />
    ///  with the specified name, or -1 if the table does not exist in the collection.</returns>
    function IndexOf(tableName: string; tableNamespace: string): Int32; overload;
    ///<summary>Removes the <see cref="T:System.Data.DataTable" />
    ///  object with the specified name from the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.DataTable" />
    ///  object to remove.</param>
    ///  <param name="tableNamespace">The name of the <see cref="T:System.Data.DataTable" />
    ///  namespace to look in.</param>
    ///<exception cref="T:System.ArgumentException">The collection does not have a table with the specified name. </exception>
    procedure Remove(name: string; tableNamespace: string); overload;
    ///<summary>Adds the specified <see langword="DataTable" />
    ///  to the collection.</summary>
    ///  <param name="table">The <see langword="DataTable" />
    ///  object to add. </param>
    ///<exception cref="T:System.ArgumentNullException">The value specified for the table is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The table already belongs to this collection, or belongs to another collection. </exception><exception cref="T:System.Data.DuplicateNameException">A table in the collection has the same name. The comparison is not case sensitive. </exception>
    procedure Add(table: DNDataTable); overload;
    ///<summary>Copies the elements of the specified <see cref="T:System.Data.DataTable" />
    ///  array to the end of the collection.</summary>
    ///  <param name="tables">The array of <see cref="T:System.Data.DataTable" />
    ///  objects to add to the collection. </param>
    procedure AddRange(tables: TArray<DNDataTable>);
    ///<summary>Creates a <see cref="T:System.Data.DataTable" />
    ///  object by using the specified name and adds it to the collection.</summary>
    ///  <param name="name">The name to give the created <see cref="T:System.Data.DataTable" />
    ///  . </param>
    ///<returns>The newly created <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.Data.DuplicateNameException">A table in the collection has the same name. (The comparison is not case sensitive.) </exception>
    function Add(name: string): DNDataTable; overload;
    ///<summary>Creates a <see cref="T:System.Data.DataTable" />
    ///  object by using the specified name and adds it to the collection.</summary>
    ///  <param name="name">The name to give the created <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///  <param name="tableNamespace">The namespace to give the created <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///<returns>The newly created <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.Data.DuplicateNameException">A table in the collection has the same name. (The comparison is not case sensitive.) </exception>
    function Add(name: string; tableNamespace: string): DNDataTable; overload;
    ///<summary>Creates a new <see cref="T:System.Data.DataTable" />
    ///  object by using a default name and adds it to the collection.</summary>
    ///<returns>The newly created <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    function Add: DNDataTable; overload;
    ///<summary>Clears the collection of all <see cref="T:System.Data.DataTable" />
    ///  objects.</summary>
    procedure Clear;
    ///<summary>Removes the specified <see cref="T:System.Data.DataTable" />
    ///  object from the collection.</summary>
    ///  <param name="table">The <see langword="DataTable" />
    ///  to remove. </param>
    ///<exception cref="T:System.ArgumentNullException">The value specified for the table is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The table does not belong to this collection.-or- The table is part of a relationship. </exception>
    procedure Remove(table: DNDataTable); overload;
    ///<summary>Removes the <see cref="T:System.Data.DataTable" />
    ///  object at the specified index from the collection.</summary>
    ///  <param name="index">The index of the <see langword="DataTable" />
    ///  to remove. </param>
    ///<exception cref="T:System.ArgumentException">The collection does not have a table at the specified index. </exception>
    procedure RemoveAt(index: Int32);
    ///<summary>Removes the <see cref="T:System.Data.DataTable" />
    ///  object with the specified name from the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Data.DataTable" />
    ///  object to remove. </param>
    ///<exception cref="T:System.ArgumentException">The collection does not have a table with the specified name. </exception>
    procedure Remove(name: string); overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  to a one-dimensional <see cref="T:System.Array" />
    ///  , starting at the specified <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  index.</summary>
    ///  <param name="ar">The one-dimensional <see cref="T:System.Array" />
    ///  to copy the current <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  object's elements into. </param>
    ///  <param name="index">The destination <see cref="T:System.Array" />
    ///  index to start copying into. </param>
    procedure CopyTo(ar: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Gets an <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNDataTable read get_Item; default;
    property Item[name: string]: DNDataTable read get_Item; default;
    property Item[name: string; tableNamespace: string]: DNDataTable read get_Item; default;
    ///<summary>Gets the total number of elements in a collection.</summary>
    ///<returns>The total number of elements in a collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.InternalDataCollectionBase" />
    ///  is synchonized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize the collection.</summary>
    ///<returns>The <see cref="T:System.object" />
    ///  used to synchronize the collection.</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNDataTableCollection = class(TDNGenericImport<DNDataTableCollectionClass, DNDataTableCollection>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcErrorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{63387667-F2B4-5701-A2E6-495753AB3B94}']
  end;

  ///<summary>Collects information relevant to a warning or error returned by the data source.</summary>
  [DNTypeName('System.Data.Odbc.OdbcError')]
  DNOdbcError = interface(DDN.mscorlib.DNObject)
  ['{B89EC9F4-D800-3B8E-B0A6-B1A1ADBC950A}']
  { getters & setters } 

    function get_Message: string;
    function get_SQLState: string;
    function get_NativeError: Int32;
    function get_Source: string;

  { methods } 

    ///<summary>Gets the complete text of the error message.</summary>
    ///<returns>The complete text of the error.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a short description of the error.</summary>
    ///<returns>A description of the error.</returns>
    property Message: string read get_Message;
    ///<summary>Gets the five-character error code that follows the ANSI SQL standard for the database.</summary>
    ///<returns>The five-character error code, which identifies the source of the error if the error can be issued from more than one place.</returns>
    property SQLState: string read get_SQLState;
    ///<summary>Gets the data source-specific error information.</summary>
    ///<returns>The data source-specific error information.</returns>
    property NativeError: Int32 read get_NativeError;
    ///<summary>Gets the name of the driver that generated the error.</summary>
    ///<returns>The name of the driver that generated the error.</returns>
    property Source: string read get_Source;
  end;

  TDNOdbcError = class(TDNGenericImport<DNOdbcErrorClass, DNOdbcError>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcErrorCollectionClass = interface(DNObjectClass)
  ['{4BC64D8C-EAAC-5C61-B243-A04BC49C9E7E}']
  end;

  ///<summary>Collects all errors generated by the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
  ///  . This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcErrorCollection')]
  DNOdbcErrorCollection = interface(DDN.mscorlib.DNICollection)
  ['{1EB0B38A-577C-3F0C-8341-E97E8CCFE6A3}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(i: Int32): DNOdbcError;

  { methods } 

    ///<summary>Copies the elements of the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  into an array, starting at the specified index within the array.</summary>
    ///  <param name="array">The array into which to copy the elements. </param>
    ///  <param name="i">The starting index of <paramref name="array" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The sum of <paramref name="index" />
    ///  and the number of elements in the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  is greater than the length of the array. </exception><exception cref="T:System.ArgumentNullException">The <paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index" />
    ///  is not valid for <paramref name="array" />
    ///  . </exception>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; i: Int32); overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  to the specified <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  starting at the specified destination index.</summary>
    ///  <param name="array">The <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  .</param>
    ///  <param name="i">A 32-bit integer that represents the index in the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: TArray<DNOdbcError>; i: Int32); overload;
    ///<summary>Returns an object that implements the <see cref="T:System.Collections.IEnumerator" />
    ///  interface and that can iterate through the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  objects in the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  .</summary>
    ///<returns>An object that implements the <see cref="T:System.Collections.IEnumerator" />
    ///  interface and that can iterate through the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  objects in the <see cref="T:System.Data.Odbc.OdbcErrorCollection" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of errors in the collection.</summary>
    ///<returns>The total number of errors in the collection.</returns>
    property Count: Int32 read get_Count;
    property Item[i: Int32]: DNOdbcError read get_Item; default;
  end;

  TDNOdbcErrorCollection = class(TDNGenericImport<DNOdbcErrorCollectionClass, DNOdbcErrorCollection>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcMetaDataCollectionNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0700762A-92AB-575D-BEA3-60B153DA20D7}']
  { static fields getter & setter } 

   function __fakeFieldGet_Columns: string;
   function __fakeFieldGet_Indexes: string;
   function __fakeFieldGet_Procedures: string;
   function __fakeFieldGet_ProcedureColumns: string;
   function __fakeFieldGet_ProcedureParameters: string;
   function __fakeFieldGet_Tables: string;
   function __fakeFieldGet_Views: string;

  { static fields } 

    ///<summary>A constant for use with the GetSchema method that represents the Columns collection.</summary>
    {class} property Columns: string read __fakeFieldGet_Columns;
    ///<summary>A constant for use with the GetSchema method that represents the Indexes collection.</summary>
    {class} property Indexes: string read __fakeFieldGet_Indexes;
    ///<summary>A constant for use with the GetSchema method that represents the Procedures collection. </summary>
    {class} property Procedures: string read __fakeFieldGet_Procedures;
    ///<summary>A constant for use with the GetSchema method that represents the ProcedureColumns collection.</summary>
    {class} property ProcedureColumns: string read __fakeFieldGet_ProcedureColumns;
    ///<summary>A constant for use with the GetSchema method that represents the ProcedureParameters collection.</summary>
    {class} property ProcedureParameters: string read __fakeFieldGet_ProcedureParameters;
    ///<summary>A constant for use with the GetSchema method that represents the Tables collection.</summary>
    {class} property Tables: string read __fakeFieldGet_Tables;
    ///<summary>A constant for use with the GetSchema method that represents the Views collection.</summary>
    {class} property Views: string read __fakeFieldGet_Views;

  end;

  ///<summary>Provides a list of constants for use with the GetSchema method to retrieve metadata collections.</summary>
  [DNTypeName('System.Data.Odbc.OdbcMetaDataCollectionNames')]
  DNOdbcMetaDataCollectionNames = interface(DDN.mscorlib.DNObject)
  ['{253D780B-BB5D-35CE-B7F9-65DD8EB74A8F}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOdbcMetaDataCollectionNames = class(TDNGenericImport<DNOdbcMetaDataCollectionNamesClass, DNOdbcMetaDataCollectionNames>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcMetaDataColumnNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{80133A1A-C9B9-5E30-8124-598B9EB7D00F}']
  { static fields getter & setter } 

   function __fakeFieldGet_BooleanFalseLiteral: string;
   function __fakeFieldGet_BooleanTrueLiteral: string;
   function __fakeFieldGet_SQLType: string;

  { static fields } 

    ///<summary>Used by the GetSchema method to create the BooleanFalseLiteral column.</summary>
    {class} property BooleanFalseLiteral: string read __fakeFieldGet_BooleanFalseLiteral;
    ///<summary>Used by the GetSchema method to create the BooleanTrueLiteral column.</summary>
    {class} property BooleanTrueLiteral: string read __fakeFieldGet_BooleanTrueLiteral;
    ///<summary>Used by the GetSchema method to create the SQLType column. </summary>
    {class} property SQLType: string read __fakeFieldGet_SQLType;

  end;

  ///<summary>Provides static values that are used for the column names in the <see cref="T:System.Data.Odbc.OdbcMetaDataCollectionNames" />
  ///  objects contained in the <see cref="T:System.Data.DataTable" />
  ///  . The <see cref="T:System.Data.DataTable" />
  ///  is created by the GetSchema method.</summary>
  [DNTypeName('System.Data.Odbc.OdbcMetaDataColumnNames')]
  DNOdbcMetaDataColumnNames = interface(DDN.mscorlib.DNObject)
  ['{F1A3BC88-55E3-32E2-A075-7E3D54AAC6B6}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOdbcMetaDataColumnNames = class(TDNGenericImport<DNOdbcMetaDataColumnNamesClass, DNOdbcMetaDataColumnNames>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbEnumeratorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{FDFD8658-6872-5D3C-8E01-698B91CF3BED}']
  { constructors } 

    ///<summary>Creates an instance of the <see cref="T:System.Data.OleDb.OleDbEnumerator" />
    ///  class.</summary>
    {class} function init: DNOleDbEnumerator;

  { static methods } 

    ///<summary>Uses a specific OLE DB enumerator to return an <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  that contains information about the currently installed OLE DB providers, without requiring an instance of the <see cref="T:System.Data.OleDb.OleDbEnumerator" />
    ///  class.</summary>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  .</param>
    ///<returns>Returns an <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  that contains information about the requested OLE DB providers, using the specified OLE DB enumerator.</returns>
    ///<exception cref="T:System.InvalidCastException">The provider does not support ISourcesRowset.</exception><exception cref="T:System.Data.OleDb.OleDbException">An exception has occurred in the underlying provider.</exception>
    {class} function GetEnumerator(&type: DDN.mscorlib.DNType): DNOleDbDataReader;
    ///<summary>Returns an <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  that contains information about the currently installed OLE DB providers, without requiring an instance of the <see cref="T:System.Data.OleDb.OleDbEnumerator" />
    ///  class.</summary>
    ///<returns>Returns a <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  that contains information about the visible OLE DB providers.</returns>
    ///<exception cref="T:System.InvalidCastException">The provider does not support ISourcesRowset.</exception><exception cref="T:System.Data.OleDb.OleDbException">Exception has occurred in the underlying provider.</exception>
    {class} function GetRootEnumerator: DNOleDbDataReader;

  end;

  ///<summary>Provides a mechanism for enumerating all available OLE DB providers within the local network.</summary>
  [DNTypeName('System.Data.OleDb.OleDbEnumerator')]
  DNOleDbEnumerator = interface(DDN.mscorlib.DNObject)
  ['{D54552B5-4B35-36C6-96E2-18EF097B802A}']
  { methods } 

    ///<summary>Retrieves a <see cref="T:System.Data.DataTable" />
    ///  that contains information about all visible OLE DB providers.</summary>
    ///<returns>Returns a <see cref="T:System.Data.DataTable" />
    ///  that contains information about the visible OLE DB providers.</returns>
    ///<exception cref="T:System.InvalidCastException">The provider does not support ISourcesRowset.</exception><exception cref="T:System.Data.OleDb.OleDbException">Exception has occurred in the underlying provider.</exception>
    function GetElements: DNDataTable;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOleDbEnumerator = class(TDNGenericImport<DNOleDbEnumeratorClass, DNOleDbEnumerator>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbErrorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D8C97E12-5EE5-5E51-A46A-FE515DE7E174}']
  end;

  ///<summary>Collects information relevant to a warning or error returned by the data source.</summary>
  [DNTypeName('System.Data.OleDb.OleDbError')]
  DNOleDbError = interface(DDN.mscorlib.DNObject)
  ['{6DEE0079-201B-3ACC-AF36-ADEAD0308B64}']
  { getters & setters } 

    function get_Message: string;
    function get_NativeError: Int32;
    function get_Source: string;
    function get_SQLState: string;

  { methods } 

    ///<summary>Gets the complete text of the error message.</summary>
    ///<returns>The complete text of the error.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a short description of the error.</summary>
    ///<returns>A short description of the error.</returns>
    property Message: string read get_Message;
    ///<summary>Gets the database-specific error information.</summary>
    ///<returns>The database-specific error information.</returns>
    property NativeError: Int32 read get_NativeError;
    ///<summary>Gets the name of the provider that generated the error.</summary>
    ///<returns>The name of the provider that generated the error.</returns>
    property Source: string read get_Source;
    ///<summary>Gets the five-character error code following the ANSI SQL standard for the database.</summary>
    ///<returns>The five-character error code, which identifies the source of the error, if the error can be issued from more than one place.</returns>
    property SQLState: string read get_SQLState;
  end;

  TDNOleDbError = class(TDNGenericImport<DNOleDbErrorClass, DNOleDbError>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbErrorCollectionClass = interface(DNObjectClass)
  ['{88780DC4-86A7-5189-B822-0324A96846F6}']
  end;

  ///<summary>Collects all errors generated by the .NET Framework Data Provider for OLE DB. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.OleDb.OleDbErrorCollection')]
  DNOleDbErrorCollection = interface(DDN.mscorlib.DNICollection)
  ['{21D1CE24-A06B-323C-A36B-F0FFCBB7363A}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(index: Int32): DNOleDbError;

  { methods } 

    ///<summary>Copies the elements of the <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  into an <see cref="T:System.Array" />
    ///  , starting at the specified index within the <see cref="T:System.Array" />
    ///  .</summary>
    ///  <param name="array">The <see cref="T:System.Array" />
    ///  into which to copy the elements. </param>
    ///  <param name="index">The starting index of the <paramref name="array" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The sum of <paramref name="index" />
    ///  and the number of elements in the <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  is greater than the length of the <see cref="T:System.Array" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index" />
    ///  is not valid for <paramref name="array" />
    ///  . </exception>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  to the specified <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  starting at the specified destination index.</summary>
    ///  <param name="array">The <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  . </param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Data.OleDb.OleDbErrorCollection" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: TArray<DNOleDbError>; index: Int32); overload;
    ///<summary>Exposes the <see cref="M:System.Collections.IEnumerable.GetEnumerator" />
    ///  method, which supports a simple iteration over a collection by a .NET Framework data provider.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of errors in the collection.</summary>
    ///<returns>The total number of errors in the collection.</returns>
    property Count: Int32 read get_Count;
    property Item[index: Int32]: DNOleDbError read get_Item; default;
  end;

  TDNOleDbErrorCollection = class(TDNGenericImport<DNOleDbErrorCollectionClass, DNOleDbErrorCollection>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbMetaDataCollectionNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{2582E8C2-D758-58A1-90D9-2966721C642A}']
  { static fields getter & setter } 

   function __fakeFieldGet_Catalogs: string;
   function __fakeFieldGet_Collations: string;
   function __fakeFieldGet_Columns: string;
   function __fakeFieldGet_Indexes: string;
   function __fakeFieldGet_Procedures: string;
   function __fakeFieldGet_ProcedureColumns: string;
   function __fakeFieldGet_ProcedureParameters: string;
   function __fakeFieldGet_Tables: string;
   function __fakeFieldGet_Views: string;

  { static fields } 

    ///<summary>A constant for use with the GetSchema method that represents the Catalogs collection.</summary>
    {class} property Catalogs: string read __fakeFieldGet_Catalogs;
    ///<summary>A constant for use with the GetSchema method that represents the Collations collection.</summary>
    {class} property Collations: string read __fakeFieldGet_Collations;
    ///<summary>A constant for use with the GetSchema method that represents the Columns collection.</summary>
    {class} property Columns: string read __fakeFieldGet_Columns;
    ///<summary>A constant for use with the GetSchema method that represents the Indexes collection.</summary>
    {class} property Indexes: string read __fakeFieldGet_Indexes;
    ///<summary>A constant for use with the GetSchema method that represents the Procedures collection.</summary>
    {class} property Procedures: string read __fakeFieldGet_Procedures;
    ///<summary>A constant for use with the GetSchema method that represents the ProcedureColumns collection.</summary>
    {class} property ProcedureColumns: string read __fakeFieldGet_ProcedureColumns;
    ///<summary>A constant for use with the GetSchema method that represents the ProcedureParameters collection.</summary>
    {class} property ProcedureParameters: string read __fakeFieldGet_ProcedureParameters;
    ///<summary>A constant for use with the GetSchema method that represents the Tables collection.</summary>
    {class} property Tables: string read __fakeFieldGet_Tables;
    ///<summary>A constant for use with the GetSchema method that represents the Views collection. </summary>
    {class} property Views: string read __fakeFieldGet_Views;

  end;

  ///<summary>Provides a list of constants for use with the GetSchema method to retrieve metadata collections.</summary>
  [DNTypeName('System.Data.OleDb.OleDbMetaDataCollectionNames')]
  DNOleDbMetaDataCollectionNames = interface(DDN.mscorlib.DNObject)
  ['{059103F6-79E3-3980-8E0C-E3DA2C048531}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOleDbMetaDataCollectionNames = class(TDNGenericImport<DNOleDbMetaDataCollectionNamesClass, DNOleDbMetaDataCollectionNames>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbMetaDataColumnNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F1D80889-C3AA-5EAF-A0BB-53F632AB41E9}']
  { static fields getter & setter } 

   function __fakeFieldGet_BooleanFalseLiteral: string;
   function __fakeFieldGet_BooleanTrueLiteral: string;
   function __fakeFieldGet_NativeDataType: string;
   function __fakeFieldGet_DateTimeDigits: string;

  { static fields } 

    ///<summary>Used by the GetSchema method to create the BooleanFalseLiteral column.</summary>
    {class} property BooleanFalseLiteral: string read __fakeFieldGet_BooleanFalseLiteral;
    ///<summary>Used by the GetSchema method to create the BooleanTrueLiteral column.</summary>
    {class} property BooleanTrueLiteral: string read __fakeFieldGet_BooleanTrueLiteral;
    ///<summary>Used by the GetSchema method to create the NativeDataType column.</summary>
    {class} property NativeDataType: string read __fakeFieldGet_NativeDataType;
    ///<summary>Used by the GetSchema method to create the DateTimeDigits column. </summary>
    {class} property DateTimeDigits: string read __fakeFieldGet_DateTimeDigits;

  end;

  ///<summary>Provides static values that are used for the column names in the <see cref="T:System.Data.OleDb.OleDbMetaDataCollectionNames" />
  ///  objects contained in the <see cref="T:System.Data.DataTable" />
  ///  . The <see cref="T:System.Data.DataTable" />
  ///  is created by the GetSchema method.</summary>
  [DNTypeName('System.Data.OleDb.OleDbMetaDataColumnNames')]
  DNOleDbMetaDataColumnNames = interface(DDN.mscorlib.DNObject)
  ['{B960D5F6-C8C0-3112-9948-05740A2828C4}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOleDbMetaDataColumnNames = class(TDNGenericImport<DNOleDbMetaDataColumnNamesClass, DNOleDbMetaDataColumnNames>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbSchemaGuidClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0A471583-FCB2-5584-85F0-F0369E6FC121}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbSchemaGuid" />
    ///  class.</summary>
    {class} function init: DNOleDbSchemaGuid;

  { static fields getter & setter } 

   function __fakeFieldGet_Tables_Info: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Trustee: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Assertions: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Catalogs: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Character_Sets: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Collations: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Columns: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Check_Constraints: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Constraint_Column_Usage: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Constraint_Table_Usage: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Key_Column_Usage: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Referential_Constraints: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Table_Constraints: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Column_Domain_Usage: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Indexes: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Column_Privileges: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Table_Privileges: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Usage_Privileges: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Procedures: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Schemata: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Sql_Languages: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Statistics: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Tables: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Translations: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Provider_Types: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Views: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_View_Column_Usage: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_View_Table_Usage: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Procedure_Parameters: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Foreign_Keys: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Primary_Keys: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Procedure_Columns: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Table_Statistics: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_Check_Constraints_By_Table: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_SchemaGuids: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_DbInfoKeywords: DDN.mscorlib.DNGuid;
   function __fakeFieldGet_DbInfoLiterals: DDN.mscorlib.DNGuid;

  { static fields } 

    ///<summary>Returns the tables (including views) that are accessible to a given user.</summary>
    {class} property Tables_Info: DDN.mscorlib.DNGuid read __fakeFieldGet_Tables_Info;
    ///<summary>Identifies the trustees defined in the data source.</summary>
    {class} property Trustee: DDN.mscorlib.DNGuid read __fakeFieldGet_Trustee;
    ///<summary>Returns the assertions defined in the catalog that is owned by a given user.</summary>
    {class} property Assertions: DDN.mscorlib.DNGuid read __fakeFieldGet_Assertions;
    ///<summary>Returns the physical attributes associated with catalogs accessible from the data source. Returns the assertions defined in the catalog that is owned by a given user.</summary>
    {class} property Catalogs: DDN.mscorlib.DNGuid read __fakeFieldGet_Catalogs;
    ///<summary>Returns the character sets defined in the catalog that is accessible to a given user.</summary>
    {class} property Character_Sets: DDN.mscorlib.DNGuid read __fakeFieldGet_Character_Sets;
    ///<summary>Returns the character collations defined in the catalog that is accessible to a given user.</summary>
    {class} property Collations: DDN.mscorlib.DNGuid read __fakeFieldGet_Collations;
    ///<summary>Returns the columns of tables (including views) defined in the catalog that is accessible to a given user.</summary>
    {class} property Columns: DDN.mscorlib.DNGuid read __fakeFieldGet_Columns;
    ///<summary>Returns the check constraints defined in the catalog that is owned by a given user.</summary>
    {class} property Check_Constraints: DDN.mscorlib.DNGuid read __fakeFieldGet_Check_Constraints;
    ///<summary>Returns the columns used by referential constraints, unique constraints, check constraints, and assertions, defined in the catalog and owned by a given user.</summary>
    {class} property Constraint_Column_Usage: DDN.mscorlib.DNGuid read __fakeFieldGet_Constraint_Column_Usage;
    ///<summary>Returns the tables that are used by referential constraints, unique constraints, check constraints, and assertions defined in the catalog and owned by a given user.</summary>
    {class} property Constraint_Table_Usage: DDN.mscorlib.DNGuid read __fakeFieldGet_Constraint_Table_Usage;
    ///<summary>Returns the columns defined in the catalog that is constrained as keys by a given user.</summary>
    {class} property Key_Column_Usage: DDN.mscorlib.DNGuid read __fakeFieldGet_Key_Column_Usage;
    ///<summary>Returns the referential constraints defined in the catalog that is owned by a given user.</summary>
    {class} property Referential_Constraints: DDN.mscorlib.DNGuid read __fakeFieldGet_Referential_Constraints;
    ///<summary>Returns the table constraints defined in the catalog that is owned by a given user.</summary>
    {class} property Table_Constraints: DDN.mscorlib.DNGuid read __fakeFieldGet_Table_Constraints;
    ///<summary>Returns the columns defined in the catalog that are dependent on a domain defined in the catalog and owned by a given user.</summary>
    {class} property Column_Domain_Usage: DDN.mscorlib.DNGuid read __fakeFieldGet_Column_Domain_Usage;
    ///<summary>Returns the indexes defined in the catalog that is owned by a given user.</summary>
    {class} property Indexes: DDN.mscorlib.DNGuid read __fakeFieldGet_Indexes;
    ///<summary>Returns the privileges on columns of tables defined in the catalog that are available to or granted by a given user.</summary>
    {class} property Column_Privileges: DDN.mscorlib.DNGuid read __fakeFieldGet_Column_Privileges;
    ///<summary>Returns the privileges on tables defined in the catalog that are available to, or granted by, a given user.</summary>
    {class} property Table_Privileges: DDN.mscorlib.DNGuid read __fakeFieldGet_Table_Privileges;
    ///<summary>Returns the USAGE privileges on objects defined in the catalog that are available to or granted by a given user.</summary>
    {class} property Usage_Privileges: DDN.mscorlib.DNGuid read __fakeFieldGet_Usage_Privileges;
    ///<summary>Returns the procedures defined in the catalog that is owned by a given user.</summary>
    {class} property Procedures: DDN.mscorlib.DNGuid read __fakeFieldGet_Procedures;
    ///<summary>Returns the schema objects that are owned by a given user.</summary>
    {class} property Schemata: DDN.mscorlib.DNGuid read __fakeFieldGet_Schemata;
    ///<summary>Returns the conformance levels, options, and dialects supported by the SQL-implementation processing data defined in the catalog.</summary>
    {class} property Sql_Languages: DDN.mscorlib.DNGuid read __fakeFieldGet_Sql_Languages;
    ///<summary>Returns the statistics defined in the catalog that is owned by a given user.</summary>
    {class} property Statistics: DDN.mscorlib.DNGuid read __fakeFieldGet_Statistics;
    ///<summary>Returns the tables (including views) defined in the catalog that are accessible to a given user.</summary>
    {class} property Tables: DDN.mscorlib.DNGuid read __fakeFieldGet_Tables;
    ///<summary>Returns the character translations defined in the catalog that is accessible to a given user.</summary>
    {class} property Translations: DDN.mscorlib.DNGuid read __fakeFieldGet_Translations;
    ///<summary>Returns the base data types supported by the .NET Framework Data Provider for OLE DB.</summary>
    {class} property Provider_Types: DDN.mscorlib.DNGuid read __fakeFieldGet_Provider_Types;
    ///<summary>Returns the views defined in the catalog that is accessible to a given user.</summary>
    {class} property Views: DDN.mscorlib.DNGuid read __fakeFieldGet_Views;
    ///<summary>Returns the columns on which viewed tables depend, as defined in the catalog and owned by a given user.</summary>
    {class} property View_Column_Usage: DDN.mscorlib.DNGuid read __fakeFieldGet_View_Column_Usage;
    ///<summary>Returns the tables on which viewed tables, defined in the catalog and owned by a given user, are dependent.</summary>
    {class} property View_Table_Usage: DDN.mscorlib.DNGuid read __fakeFieldGet_View_Table_Usage;
    ///<summary>Returns information about the parameters and return codes of procedures.</summary>
    {class} property Procedure_Parameters: DDN.mscorlib.DNGuid read __fakeFieldGet_Procedure_Parameters;
    ///<summary>Returns the foreign key columns defined in the catalog by a given user.</summary>
    {class} property Foreign_Keys: DDN.mscorlib.DNGuid read __fakeFieldGet_Foreign_Keys;
    ///<summary>Returns the primary key columns defined in the catalog by a given user.</summary>
    {class} property Primary_Keys: DDN.mscorlib.DNGuid read __fakeFieldGet_Primary_Keys;
    ///<summary>Returns information about the columns of rowsets returned by procedures.</summary>
    {class} property Procedure_Columns: DDN.mscorlib.DNGuid read __fakeFieldGet_Procedure_Columns;
    ///<summary>Describes the available set of statistics on tables in the provider.</summary>
    {class} property Table_Statistics: DDN.mscorlib.DNGuid read __fakeFieldGet_Table_Statistics;
    ///<summary>Returns the check constraints defined in the catalog that is owned by a given user.</summary>
    {class} property Check_Constraints_By_Table: DDN.mscorlib.DNGuid read __fakeFieldGet_Check_Constraints_By_Table;
    ///<summary>Returns a list of schema rowsets, identified by their GUIDs, and a pointer to the descriptions of the restriction columns.</summary>
    {class} property SchemaGuids: DDN.mscorlib.DNGuid read __fakeFieldGet_SchemaGuids;
    ///<summary>Returns a list of provider-specific keywords.</summary>
    {class} property DbInfoKeywords: DDN.mscorlib.DNGuid read __fakeFieldGet_DbInfoKeywords;
    ///<summary>Returns a list of provider-specific literals used in text commands.</summary>
    {class} property DbInfoLiterals: DDN.mscorlib.DNGuid read __fakeFieldGet_DbInfoLiterals;

  end;

  ///<summary>Returns the type of schema table specified by the <see cref="M:System.Data.OleDb.OleDbConnection.GetOleDbSchemaTable(System.Guid,System.Object[])" />
  ///  method.</summary>
  [DNTypeName('System.Data.OleDb.OleDbSchemaGuid')]
  DNOleDbSchemaGuid = interface(DDN.mscorlib.DNObject)
  ['{24F82AA5-56BC-300A-8199-9A9A3FD77ABC}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOleDbSchemaGuid = class(TDNGenericImport<DNOleDbSchemaGuidClass, DNOleDbSchemaGuid>) end;

  //-------------namespace: System.Data.Sql----------------
  DNSqlNotificationRequestClass = interface(DDN.mscorlib.DNObjectClass)
  ['{EC582921-76B1-5D1F-AB29-F1ED6D6ED44C}']
  { constructors } 

    ///<summary>Creates a new instance of the <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  class with default values.</summary>
    {class} function init: DNSqlNotificationRequest; overload;
    ///<summary>Creates a new instance of the <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  class with a user-defined string that identifies a particular notification request, the name of a predefined SQL Server 2005 Service Broker service name, and the time-out period, measured in seconds.</summary>
    ///  <param name="userData">A string that contains an application-specific identifier for this notification. It is not used by the notifications infrastructure, but it allows you to associate notifications with the application state. The value indicated in this parameter is included in the Service Broker queue message. </param>
    ///  <param name="options">A string that contains the Service Broker service name where notification messages are posted, and it must include a database name or a Service Broker instance GUID that restricts the scope of the service name lookup to a particular database.For more information about the format of the <paramref name="options" />
    ///  parameter, see <see cref="P:System.Data.Sql.SqlNotificationRequest.Options" />
    ///  .</param>
    ///  <param name="timeout">The time, in seconds, to wait for a notification message. </param>
    ///<exception cref="T:System.ArgumentNullException">The value of the <paramref name="options" />
    ///  parameter is NULL. </exception><exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="options" />
    ///  or <paramref name="userData" />
    ///  parameter is longer than <see langword="uint16.MaxValue" />
    ///  or the value in the <paramref name="timeout" />
    ///  parameter is less than zero. </exception>
    {class} function init(userData: string; options: string; timeout: Int32): DNSqlNotificationRequest; overload;

  end;

  ///<summary>Represents a request for notification for a given command. </summary>
  [DNTypeName('System.Data.Sql.SqlNotificationRequest')]
  DNSqlNotificationRequest = interface(DDN.mscorlib.DNObject)
  ['{DE4AC26B-F2EA-33B8-83EA-A252F0B2E17D}']
  { getters & setters } 

    function get_Options: string;
    procedure set_Options(value: string);
    function get_Timeout: Int32;
    procedure set_Timeout(value: Int32);
    function get_UserData: string;
    procedure set_UserData(value: string);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the SQL Server Service Broker service name where notification messages are posted.</summary>
    ///<returns><see langword="string" />
    ///  that contains the SQL Server 2005 Service Broker service name where notification messages are posted and the database or service broker instance GUID to scope the server name lookup.</returns>
    ///<exception cref="T:System.ArgumentNullException">The value is NULL. </exception><exception cref="T:System.ArgumentException">The value is longer than <see langword="uint16.MaxValue" />
    ///  . </exception>
    property Options: string read get_Options write set_Options;
    ///<summary>Gets or sets a value that specifies how long SQL Server waits for a change to occur before the operation times out.</summary>
    ///<returns>A signed integer value that specifies, in seconds, how long SQL Server waits for a change to occur before the operation times out.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The value is less than zero. </exception>
    property Timeout: Int32 read get_Timeout write set_Timeout;
    ///<summary>Gets or sets an application-specific identifier for this notification.</summary>
    ///<returns>A <see langword="string" />
    ///  value of the application-specific identifier for this notification.</returns>
    ///<exception cref="T:System.ArgumentException">The value is longer than <see langword="uint16.MaxValue" />
    ///  . </exception>
    property UserData: string read get_UserData write set_UserData;
  end;

  TDNSqlNotificationRequest = class(TDNGenericImport<DNSqlNotificationRequestClass, DNSqlNotificationRequest>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlAuthenticationInitializerClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F7270086-3DDC-5D87-8A80-782DF57D0B33}']
  end;

  [DNTypeName('System.Data.SqlClient.SqlAuthenticationInitializer')]
  DNSqlAuthenticationInitializer = interface(DDN.mscorlib.DNObject)
  ['{27D7788D-A96E-3512-8829-C0069BC6EBC9}']
  { methods } 

    procedure Initialize;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlAuthenticationInitializer = class(TDNGenericImport<DNSqlAuthenticationInitializerClass, DNSqlAuthenticationInitializer>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlAuthenticationParametersClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D2F6F6B3-D5BA-5FC6-9E01-469E59506280}']
  end;

  [DNTypeName('System.Data.SqlClient.SqlAuthenticationParameters')]
  DNSqlAuthenticationParameters = interface(DDN.mscorlib.DNObject)
  ['{393A36B7-14F1-3474-8785-1FDECC1B0E4A}']
  { getters & setters } 

    function get_AuthenticationMethod: DNSqlAuthenticationMethod;
    function get_Resource: string;
    function get_Authority: string;
    function get_UserId: string;
    function get_Password: string;
    function get_ConnectionId: DDN.mscorlib.DNGuid;
    function get_ServerName: string;
    function get_DatabaseName: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property AuthenticationMethod: DNSqlAuthenticationMethod read get_AuthenticationMethod;
    property Resource: string read get_Resource;
    property Authority: string read get_Authority;
    property UserId: string read get_UserId;
    property Password: string read get_Password;
    property ConnectionId: DDN.mscorlib.DNGuid read get_ConnectionId;
    property ServerName: string read get_ServerName;
    property DatabaseName: string read get_DatabaseName;
  end;

  TDNSqlAuthenticationParameters = class(TDNGenericImport<DNSqlAuthenticationParametersClass, DNSqlAuthenticationParameters>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlAuthenticationProviderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{061610E4-19F3-5313-92D3-30909FA5C7A3}']
  { static methods } 

    {class} function GetProvider(authenticationMethod: DNSqlAuthenticationMethod): DNSqlAuthenticationProvider;
    {class} function SetProvider(authenticationMethod: DNSqlAuthenticationMethod; provider: DNSqlAuthenticationProvider): Boolean;

  end;

  [DNTypeName('System.Data.SqlClient.SqlAuthenticationProvider')]
  DNSqlAuthenticationProvider = interface(DDN.mscorlib.DNObject)
  ['{EC1CDE39-B318-33C5-9B28-2311BEC05605}']
  { methods } 

    procedure BeforeLoad(authenticationMethod: DNSqlAuthenticationMethod);
    procedure BeforeUnload(authenticationMethod: DNSqlAuthenticationMethod);
    function IsSupported(authenticationMethod: DNSqlAuthenticationMethod): Boolean;
    function AcquireTokenAsync(parameters: DNSqlAuthenticationParameters): DDN.mscorlib.DNTask<DNSqlAuthenticationToken>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlAuthenticationProvider = class(TDNGenericImport<DNSqlAuthenticationProviderClass, DNSqlAuthenticationProvider>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlAuthenticationTokenClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0ECFDB2E-CBC4-5F2B-BF46-019E8FF86071}']
  { constructors } 

    {class} function init(accessToken: string; expiresOn: DDN.mscorlib.DNDateTimeOffset): DNSqlAuthenticationToken;

  end;

  [DNTypeName('System.Data.SqlClient.SqlAuthenticationToken')]
  DNSqlAuthenticationToken = interface(DDN.mscorlib.DNObject)
  ['{2BA7088E-C49D-3A0F-A85D-4F216B6166A2}']
  { getters & setters } 

    function get_ExpiresOn: DDN.mscorlib.DNDateTimeOffset;
    function get_AccessToken: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property ExpiresOn: DDN.mscorlib.DNDateTimeOffset read get_ExpiresOn;
    property AccessToken: string read get_AccessToken;
  end;

  TDNSqlAuthenticationToken = class(TDNGenericImport<DNSqlAuthenticationTokenClass, DNSqlAuthenticationToken>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlBulkCopyClass = interface(DNObjectClass)
  ['{1228D3A5-047C-5B0D-92E2-38181E5D7731}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  class using the specified open instance of <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  . </summary>
    ///  <param name="connection">The already open <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  instance that will be used to perform the bulk copy operation. If your connection string does not use <see langword="Integrated Security = true" />
    ///  , you can use <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.</param>
    {class} function init(connection: DNSqlConnection): DNSqlBulkCopy; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  class using the supplied existing open instance of <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  . The <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  instance behaves according to options supplied in the <paramref name="copyOptions" />
    ///  parameter. If a non-null <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  is supplied, the copy operations will be performed within that transaction.</summary>
    ///  <param name="connection">The already open <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  instance that will be used to perform the bulk copy. If your connection string does not use <see langword="Integrated Security = true" />
    ///  , you can use <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.</param>
    ///  <param name="copyOptions">A combination of values from the <see cref="T:System.Data.SqlClient.SqlBulkCopyOptions" />
    ///  enumeration that determines which data source rows are copied to the destination table.</param>
    ///  <param name="externalTransaction">An existing <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  instance under which the bulk copy will occur.</param>
    {class} function init(connection: DNSqlConnection; copyOptions: DNSqlBulkCopyOptions; externalTransaction: DNSqlTransaction): DNSqlBulkCopy; overload;
    ///<summary>Initializes and opens a new instance of <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  based on the supplied <paramref name="connectionString" />
    ///  . The constructor uses the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  to initialize a new instance of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  class.</summary>
    ///  <param name="connectionString">The string defining the connection that will be opened for use by the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  instance. If your connection string does not use <see langword="Integrated Security = true" />
    ///  , you can use <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection)" />
    ///  or <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlBulkCopyOptions,System.Data.SqlClient.SqlTransaction)" />
    ///  and <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.</param>
    {class} function init(connectionString: string): DNSqlBulkCopy; overload;
    ///<summary>Initializes and opens a new instance of <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  based on the supplied <paramref name="connectionString" />
    ///  . The constructor uses that <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  to initialize a new instance of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  class. The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  instance behaves according to options supplied in the <paramref name="copyOptions" />
    ///  parameter.</summary>
    ///  <param name="connectionString">The string defining the connection that will be opened for use by the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  instance. If your connection string does not use <see langword="Integrated Security = true" />
    ///  , you can use <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection)" />
    ///  or <see cref="M:System.Data.SqlClient.SqlBulkCopy.#ctor(System.Data.SqlClient.SqlConnection,System.Data.SqlClient.SqlBulkCopyOptions,System.Data.SqlClient.SqlTransaction)" />
    ///  and <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.</param>
    ///  <param name="copyOptions">A combination of values from the <see cref="T:System.Data.SqlClient.SqlBulkCopyOptions" />
    ///  enumeration that determines which data source rows are copied to the destination table.</param>
    {class} function init(connectionString: string; copyOptions: DNSqlBulkCopyOptions): DNSqlBulkCopy; overload;

  end;

  ///<summary>Lets you efficiently bulk load a SQL Server table with data from another source.</summary>
  [DNTypeName('System.Data.SqlClient.SqlBulkCopy')]
  DNSqlBulkCopy = interface(DDN.mscorlib.DNIDisposable)
  ['{57734AA7-5E91-3868-8716-17A3B9780BA6}']
  { getters & setters } 

    function get_BatchSize: Int32;
    procedure set_BatchSize(value: Int32);
    function get_BulkCopyTimeout: Int32;
    procedure set_BulkCopyTimeout(value: Int32);
    function get_EnableStreaming: Boolean;
    procedure set_EnableStreaming(value: Boolean);
    function get_ColumnMappings: DNSqlBulkCopyColumnMappingCollection;
    function get_DestinationTableName: string;
    procedure set_DestinationTableName(value: string);
    function get_NotifyAfter: Int32;
    procedure set_NotifyAfter(value: Int32);

  { events } 

    procedure add_SqlRowsCopied(value: DNSqlRowsCopiedEventHandler);
    procedure remove_SqlRowsCopied(value: DNSqlRowsCopiedEventHandler);

  { methods } 

    ///<summary>Copies all rows from the supplied <see cref="T:System.Data.Common.DbDataReader" />
    ///  array to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.Common.DbDataReader" />
    ///  whose rows will be copied to the destination table.</param>
    procedure WriteToServer(reader: DNDbDataReader); overload;
    ///<summary>Copies all rows in the supplied <see cref="T:System.Data.IDataReader" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.IDataReader" />
    ///  whose rows will be copied to the destination table.</param>
    procedure WriteToServer(reader: DNIDataReader); overload;
    ///<summary>Copies all rows in the supplied <see cref="T:System.Data.DataTable" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  whose rows will be copied to the destination table.</param>
    procedure WriteToServer(table: DNDataTable); overload;
    ///<summary>Copies only rows that match the supplied row state in the supplied <see cref="T:System.Data.DataTable" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  whose rows will be copied to the destination table.</param>
    ///  <param name="rowState">A value from the <see cref="T:System.Data.DataRowState" />
    ///  enumeration. Only rows matching the row state are copied to the destination.</param>
    procedure WriteToServer(table: DNDataTable; rowState: DNDataRowState); overload;
    ///<summary>Copies all rows from the supplied <see cref="T:System.Data.DataRow" />
    ///  array to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="rows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects that will be copied to the destination table.</param>
    procedure WriteToServer(rows: TArray<DNDataRow>); overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />
    ///  , which copies all rows from the supplied <see cref="T:System.Data.DataRow" />
    ///  array to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="rows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects that will be copied to the destination table.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(rows: TArray<DNDataRow>): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)" />
    ///  , which copies all rows from the supplied <see cref="T:System.Data.Common.DbDataReader" />
    ///  array to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.Common.DbDataReader" />
    ///  whose rows will be copied to the destination table.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    function WriteToServerAsync(reader: DNDbDataReader): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.Common.DbDataReader)" />
    ///  , which copies all rows from the supplied <see cref="T:System.Data.Common.DbDataReader" />
    ///  array to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.Common.DbDataReader" />
    ///  whose rows will be copied to the destination table.</param>
    ///  <param name="cancellationToken">The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" />
    ///  value in this parameter makes this method equivalent to <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.Common.DbDataReader)" />
    ///  .</param>
    ///<returns>Returns <see cref="T:System.Threading.Tasks.Task" />
    ///  .</returns>
    function WriteToServerAsync(reader: DNDbDataReader; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />
    ///  , which copies all rows in the supplied <see cref="T:System.Data.IDataReader" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.IDataReader" />
    ///  whose rows will be copied to the destination table.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.The <see cref="T:System.Data.IDataReader" />
    ///  was closed before the completed <see cref="T:System.Threading.Tasks.Task" />
    ///  returned.The <see cref="T:System.Data.IDataReader" />
    ///  's associated connection was closed before the completed <see cref="T:System.Threading.Tasks.Task" />
    ///  returned.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(reader: DNIDataReader): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />
    ///  , which copies all rows in the supplied <see cref="T:System.Data.IDataReader" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="reader">A <see cref="T:System.Data.IDataReader" />
    ///  whose rows will be copied to the destination table.</param>
    ///  <param name="cancellationToken">The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" />
    ///  value in this parameter makes this method equivalent to <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  .</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.IDataReader)" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.IDataReader)" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.The <see cref="T:System.Data.IDataReader" />
    ///  was closed before the completed <see cref="T:System.Threading.Tasks.Task" />
    ///  returned.The <see cref="T:System.Data.IDataReader" />
    ///  's associated connection was closed before the completed <see cref="T:System.Threading.Tasks.Task" />
    ///  returned.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(reader: DNIDataReader; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />
    ///  , which copies all rows in the supplied <see cref="T:System.Data.DataTable" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  whose rows will be copied to the destination table.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(table: DNDataTable): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />
    ///  , which copies all rows in the supplied <see cref="T:System.Data.DataTable" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  whose rows will be copied to the destination table.</param>
    ///  <param name="cancellationToken">The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" />
    ///  value in this parameter makes this method equivalent to <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  .</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable)" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(table: DNDataTable; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />
    ///  , which copies only rows that match the supplied row state in the supplied <see cref="T:System.Data.DataTable" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  whose rows will be copied to the destination table.</param>
    ///  <param name="rowState">A value from the <see cref="T:System.Data.DataRowState" />
    ///  enumeration. Only rows matching the row state are copied to the destination.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(table: DNDataTable; rowState: DNDataRowState): DDN.mscorlib.DNTask; overload;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />
    ///  , which copies only rows that match the supplied row state in the supplied <see cref="T:System.Data.DataTable" />
    ///  to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="table">A <see cref="T:System.Data.DataTable" />
    ///  whose rows will be copied to the destination table.</param>
    ///  <param name="rowState">A value from the <see cref="T:System.Data.DataRowState" />
    ///  enumeration. Only rows matching the row state are copied to the destination.</param>
    ///  <param name="cancellationToken">The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" />
    ///  value in this parameter makes this method equivalent to <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  .</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataTable,System.Data.DataRowState)" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable,System.Data.DataRowState)" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(table: DNDataTable; rowState: DNDataRowState; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>Closes the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  instance.</summary>
    procedure Close;
    ///<summary>The asynchronous version of <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />
    ///  , which copies all rows from the supplied <see cref="T:System.Data.DataRow" />
    ///  array to a destination table specified by the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="rows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects that will be copied to the destination table.</param>
    ///  <param name="cancellationToken">The cancellation instruction. A <see cref="P:System.Threading.CancellationToken.None" />
    ///  value in this parameter makes this method equivalent to <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataTable)" />
    ///  .</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
    ///  multiple times for the same instance before task completion.Calling <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
    ///  and <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServer(System.Data.DataRow[])" />
    ///  for the same instance before task completion.The connection drops or is closed during <see cref="M:System.Data.SqlClient.SqlBulkCopy.WriteToServerAsync(System.Data.DataRow[])" />
    ///  execution.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object was closed during the method execution.Returned in the task object, there was a connection pool timeout.Returned in the task object, the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object is closed before method execution.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">Returned in the task object, any error returned by SQL Server that occurred while opening the connection.</exception>
    function WriteToServerAsync(rows: TArray<DNDataRow>; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Number of rows in each batch. At the end of each batch, the rows in the batch are sent to the server.</summary>
    ///<returns>The integer value of the <see cref="P:System.Data.SqlClient.SqlBulkCopy.BatchSize" />
    ///  property, or zero if no value has been set.</returns>
    property BatchSize: Int32 read get_BatchSize write set_BatchSize;
    ///<summary>Number of seconds for the operation to complete before it times out.</summary>
    ///<returns>The integer value of the <see cref="P:System.Data.SqlClient.SqlBulkCopy.BulkCopyTimeout" />
    ///  property. The default is 30 seconds. A value of 0 indicates no limit; the bulk copy will wait indefinitely.</returns>
    property BulkCopyTimeout: Int32 read get_BulkCopyTimeout write set_BulkCopyTimeout;
    ///<summary>Enables or disables a <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object to stream data from an <see cref="T:System.Data.IDataReader" />
    ///  object</summary>
    ///<returns><see langword="true" />
    ///  if a <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
    ///  object can stream data from an <see cref="T:System.Data.IDataReader" />
    ///  object; otherwise, false. The default is <see langword="false" />
    ///  .</returns>
    property EnableStreaming: Boolean read get_EnableStreaming write set_EnableStreaming;
    ///<summary>Returns a collection of <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  items. Column mappings define the relationships between columns in the data source and columns in the destination.</summary>
    ///<returns>A collection of column mappings. By default, it is an empty collection.</returns>
    property ColumnMappings: DNSqlBulkCopyColumnMappingCollection read get_ColumnMappings;
    ///<summary>Name of the destination table on the server. </summary>
    ///<returns>The string value of the <see cref="P:System.Data.SqlClient.SqlBulkCopy.DestinationTableName" />
    ///  property, or null if none as been supplied.</returns>
    property DestinationTableName: string read get_DestinationTableName write set_DestinationTableName;
    ///<summary>Defines the number of rows to be processed before generating a notification event.</summary>
    ///<returns>The integer value of the <see cref="P:System.Data.SqlClient.SqlBulkCopy.NotifyAfter" />
    ///  property, or zero if the property has not been set.</returns>
    property NotifyAfter: Int32 read get_NotifyAfter write set_NotifyAfter;
  end;

  TDNSqlBulkCopy = class(TDNGenericImport<DNSqlBulkCopyClass, DNSqlBulkCopy>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlBulkCopyColumnMappingClass = interface(DDN.mscorlib.DNObjectClass)
  ['{5A477E7A-B2C4-5C4F-B6BF-FD9E8A495B01}']
  { constructors } 

    ///<summary>Default constructor that initializes a new <see cref="T:System.Data.SqlClient.SqlBulkCopyColumnMapping" />
    ///  object.</summary>
    {class} function init: DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new column mapping, using column names to refer to source and destination columns.</summary>
    ///  <param name="sourceColumn">The name of the source column within the data source.</param>
    ///  <param name="destinationColumn">The name of the destination column within the destination table.</param>
    {class} function init(sourceColumn: string; destinationColumn: string): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new column mapping, using a column ordinal to refer to the source column and a column name for the target column.</summary>
    ///  <param name="sourceColumnOrdinal">The ordinal position of the source column within the data source.</param>
    ///  <param name="destinationColumn">The name of the destination column within the destination table.</param>
    {class} function init(sourceColumnOrdinal: Int32; destinationColumn: string): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new column mapping, using a column name to refer to the source column and a column ordinal for the target column.</summary>
    ///  <param name="sourceColumn">The name of the source column within the data source.</param>
    ///  <param name="destinationOrdinal">The ordinal position of the destination column within the destination table.</param>
    {class} function init(sourceColumn: string; destinationOrdinal: Int32): DNSqlBulkCopyColumnMapping; overload;
    ///<summary>Creates a new column mapping, using column ordinals to refer to source and destination columns.</summary>
    ///  <param name="sourceColumnOrdinal">The ordinal position of the source column within the data source.</param>
    ///  <param name="destinationOrdinal">The ordinal position of the destination column within the destination table.</param>
    {class} function init(sourceColumnOrdinal: Int32; destinationOrdinal: Int32): DNSqlBulkCopyColumnMapping; overload;

  end;

  ///<summary>Defines the mapping between a column in a <see cref="T:System.Data.SqlClient.SqlBulkCopy" />
  ///  instance's data source and a column in the instance's destination table. </summary>
  [DNTypeName('System.Data.SqlClient.SqlBulkCopyColumnMapping')]
  DNSqlBulkCopyColumnMapping = interface(DDN.mscorlib.DNObject)
  ['{F38FDFF7-9580-30EA-9A4A-A47FA9B8579D}']
  { getters & setters } 

    function get_DestinationColumn: string;
    procedure set_DestinationColumn(value: string);
    function get_DestinationOrdinal: Int32;
    procedure set_DestinationOrdinal(value: Int32);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);
    function get_SourceOrdinal: Int32;
    procedure set_SourceOrdinal(value: Int32);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Name of the column being mapped in the destination database table.</summary>
    ///<returns>The string value of the <see cref="P:System.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationColumn" />
    ///  property.</returns>
    property DestinationColumn: string read get_DestinationColumn write set_DestinationColumn;
    ///<summary>Ordinal value of the destination column within the destination table.</summary>
    ///<returns>The integer value of the <see cref="P:System.Data.SqlClient.SqlBulkCopyColumnMapping.DestinationOrdinal" />
    ///  property, or -1 if the property has not been set.</returns>
    property DestinationOrdinal: Int32 read get_DestinationOrdinal write set_DestinationOrdinal;
    ///<summary>Name of the column being mapped in the data source.</summary>
    ///<returns>The string value of the <see cref="P:System.Data.SqlClient.SqlBulkCopyColumnMapping.SourceColumn" />
    ///  property.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
    ///<summary>The ordinal position of the source column within the data source.</summary>
    ///<returns>The integer value of the <see cref="P:System.Data.SqlClient.SqlBulkCopyColumnMapping.SourceOrdinal" />
    ///  property.</returns>
    property SourceOrdinal: Int32 read get_SourceOrdinal write set_SourceOrdinal;
  end;

  TDNSqlBulkCopyColumnMapping = class(TDNGenericImport<DNSqlBulkCopyColumnMappingClass, DNSqlBulkCopyColumnMapping>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlClientLoggerClass = interface(DDN.mscorlib.DNObjectClass)
  ['{64189E45-81B5-5D7D-8AC5-8EC6A77582C9}']
  { constructors } 

    {class} function init: DNSqlClientLogger;

  end;

  [DNTypeName('System.Data.SqlClient.SqlClientLogger')]
  DNSqlClientLogger = interface(DDN.mscorlib.DNObject)
  ['{4BAAEB14-707D-3264-B28B-A37B7012AD88}']
  { getters & setters } 

    function get_IsLoggingEnabled: Boolean;

  { methods } 

    procedure LogInfo(&type: string; method: string; message: string);
    procedure LogError(&type: string; method: string; message: string);
    function LogAssert(value: Boolean; &type: string; method: string; message: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsLoggingEnabled: Boolean read get_IsLoggingEnabled;
  end;

  TDNSqlClientLogger = class(TDNGenericImport<DNSqlClientLoggerClass, DNSqlClientLogger>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlClientMetaDataCollectionNamesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{A0B61192-D759-556C-A951-65776B6C3690}']
  { static fields getter & setter } 

   function __fakeFieldGet_Columns: string;
   function __fakeFieldGet_Databases: string;
   function __fakeFieldGet_ForeignKeys: string;
   function __fakeFieldGet_IndexColumns: string;
   function __fakeFieldGet_Indexes: string;
   function __fakeFieldGet_Parameters: string;
   function __fakeFieldGet_ProcedureColumns: string;
   function __fakeFieldGet_Procedures: string;
   function __fakeFieldGet_Tables: string;
   function __fakeFieldGet_UserDefinedTypes: string;
   function __fakeFieldGet_Users: string;
   function __fakeFieldGet_ViewColumns: string;
   function __fakeFieldGet_Views: string;

  { static fields } 

    ///<summary>A constant for use with the GetSchema method that represents the Columns collection.</summary>
    {class} property Columns: string read __fakeFieldGet_Columns;
    ///<summary>A constant for use with the GetSchema method that represents the Databases collection.</summary>
    {class} property Databases: string read __fakeFieldGet_Databases;
    ///<summary>A constant for use with the GetSchema method that represents the ForeignKeys collection.</summary>
    {class} property ForeignKeys: string read __fakeFieldGet_ForeignKeys;
    ///<summary>A constant for use with the GetSchema method that represents the IndexColumns collection.</summary>
    {class} property IndexColumns: string read __fakeFieldGet_IndexColumns;
    ///<summary>A constant for use with the GetSchema method that represents the Indexes collection.</summary>
    {class} property Indexes: string read __fakeFieldGet_Indexes;
    ///<summary>A constant for use with the GetSchema method that represents the Parameters collection.</summary>
    {class} property Parameters: string read __fakeFieldGet_Parameters;
    ///<summary>A constant for use with the GetSchema method that represents the ProcedureColumns collection.</summary>
    {class} property ProcedureColumns: string read __fakeFieldGet_ProcedureColumns;
    ///<summary>A constant for use with the GetSchema method that represents the Procedures collection.</summary>
    {class} property Procedures: string read __fakeFieldGet_Procedures;
    ///<summary>A constant for use with the GetSchema method that represents the Tables collection.</summary>
    {class} property Tables: string read __fakeFieldGet_Tables;
    ///<summary>A constant for use with the GetSchema method that represents the UserDefinedTypes collection.</summary>
    {class} property UserDefinedTypes: string read __fakeFieldGet_UserDefinedTypes;
    ///<summary>A constant for use with the GetSchema method that represents the Users collection.</summary>
    {class} property Users: string read __fakeFieldGet_Users;
    ///<summary>A constant for use with the GetSchema method that represents the ViewColumns collection.</summary>
    {class} property ViewColumns: string read __fakeFieldGet_ViewColumns;
    ///<summary>A constant for use with the GetSchema method that represents the Views collection. </summary>
    {class} property Views: string read __fakeFieldGet_Views;

  end;

  ///<summary>Provides a list of constants for use with the GetSchema method to retrieve metadata collections.</summary>
  [DNTypeName('System.Data.SqlClient.SqlClientMetaDataCollectionNames')]
  DNSqlClientMetaDataCollectionNames = interface(DDN.mscorlib.DNObject)
  ['{15984A17-E56C-3454-AC1A-B363CDDECE3C}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlClientMetaDataCollectionNames = class(TDNGenericImport<DNSqlClientMetaDataCollectionNamesClass, DNSqlClientMetaDataCollectionNames>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlColumnEncryptionEnclaveProviderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0636B43D-3B0C-5D3A-8645-EB692270D29A}']
  end;

  [DNTypeName('System.Data.SqlClient.SqlColumnEncryptionEnclaveProvider')]
  DNSqlColumnEncryptionEnclaveProvider = interface(DDN.mscorlib.DNObject)
  ['{9F73C055-7997-3654-BDA2-2F55FC8D8BB1}']
  { methods } 

    procedure GetEnclaveSession(serverName: string; attestationUrl: string; out sqlEnclaveSession: DNSqlEnclaveSession; out counter: Int64);
    function GetAttestationParameters: DNSqlEnclaveAttestationParameters;
    procedure CreateEnclaveSession(enclaveAttestationInfo: TArray<Byte>; clientDiffieHellmanKey: DDN.System.Core.DNECDiffieHellmanCng; attestationUrl: string; servername: string; out sqlEnclaveSession: DNSqlEnclaveSession; out counter: Int64);
    procedure InvalidateEnclaveSession(serverName: string; enclaveAttestationUrl: string; enclaveSession: DNSqlEnclaveSession);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlColumnEncryptionEnclaveProvider = class(TDNGenericImport<DNSqlColumnEncryptionEnclaveProviderClass, DNSqlColumnEncryptionEnclaveProvider>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlColumnEncryptionKeyStoreProviderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{E90EA962-BDCF-52EA-BAEA-39C4F47CD0C8}']
  end;

  ///<summary>Base class for all key store providers. A custom provider must derive from this class and override its member functions and then register it using SqlConnection.RegisterColumnEncryptionKeyStoreProviders(). For details see, Always Encrypted.</summary>
  [DNTypeName('System.Data.SqlClient.SqlColumnEncryptionKeyStoreProvider')]
  DNSqlColumnEncryptionKeyStoreProvider = interface(DDN.mscorlib.DNObject)
  ['{646E24F4-8540-3AA6-A2E0-60458F6E96EF}']
  { methods } 

    function SignColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean): TArray<Byte>;
    function VerifyColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean; signature: TArray<Byte>): Boolean;
    ///<summary>Decrypts the specified encrypted value of a column encryption key. The encrypted value is expected to be encrypted using the column master key with the specified key path and using the specified algorithm.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm.</param>
    ///  <param name="encryptedColumnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>Returns <see cref="T:System.Byte" />
    ///  . The decrypted column encryption key.</returns>
    function DecryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; encryptedColumnEncryptionKey: TArray<Byte>): TArray<Byte>;
    ///<summary>Encrypts a column encryption key using the column master key with the specified key path and using the specified algorithm.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm.</param>
    ///  <param name="columnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>Returns <see cref="T:System.Byte" />
    ///  . The encrypted column encryption key.</returns>
    function EncryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; columnEncryptionKey: TArray<Byte>): TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlColumnEncryptionKeyStoreProvider = class(TDNGenericImport<DNSqlColumnEncryptionKeyStoreProviderClass, DNSqlColumnEncryptionKeyStoreProvider>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlColumnEncryptionCertificateStoreProviderClass = interface(DNSqlColumnEncryptionKeyStoreProviderClass)
  ['{B8B51DFD-7D44-58B9-B217-4FD1DE7A9AE5}']
  { constructors } 

    ///<summary>Key store provider for Windows Certificate Store.</summary>
    {class} function init: DNSqlColumnEncryptionCertificateStoreProvider;

  { static fields getter & setter } 

   function __fakeFieldGet_ProviderName: string;

  { static fields } 

    ///<summary>The provider name.</summary>
    ///<returns>The provider name.</returns>
    {class} property ProviderName: string read __fakeFieldGet_ProviderName;

  end;

  ///<summary>The implementation of the key store provider for Windows Certificate Store. This class enables using certificates stored in the Windows Certificate Store as column master keys. For details, see Always Encrypted.</summary>
  [DNTypeName('System.Data.SqlClient.SqlColumnEncryptionCertificateStoreProvider')]
  DNSqlColumnEncryptionCertificateStoreProvider = interface(DNSqlColumnEncryptionKeyStoreProvider)
  ['{D6655E9D-3A56-3F1C-A126-4B9DE18E6F38}']
  { methods } 

    function SignColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean): TArray<Byte>;
    function VerifyColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean; signature: TArray<Byte>): Boolean;
    ///<summary>Decrypts the specified encrypted value of a column encryption key. The encrypted value is expected to be encrypted using the certificate with the specified key path and using the specified algorithm. The format of the key path should be “Local Machine/My/&lt;certificate_thumbrint&gt;” or “Current User/My/&lt;certificate_thumbprint&gt;”.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm. Currently, the only valid value is: RSA_OAEP</param>
    ///  <param name="encryptedColumnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>Returns <see cref="T:System.Byte" />
    ///  . The decrypted column encryption key.</returns>
    function DecryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; encryptedColumnEncryptionKey: TArray<Byte>): TArray<Byte>;
    ///<summary>Encrypts a column encryption key using the certificate with the specified key path and using the specified algorithm. The format of the key path should be “Local Machine/My/&lt;certificate_thumbrint&gt;” or “Current User/My/&lt;certificate_thumbprint&gt;”.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm. Currently, the only valid value is: RSA_OAEP</param>
    ///  <param name="columnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>Returns <see cref="T:System.Byte" />
    ///  . The encrypted column encryption key.</returns>
    function EncryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; columnEncryptionKey: TArray<Byte>): TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlColumnEncryptionCertificateStoreProvider = class(TDNGenericImport<DNSqlColumnEncryptionCertificateStoreProviderClass, DNSqlColumnEncryptionCertificateStoreProvider>)
  public const
    ///<summary>The provider name.</summary>
    ///<returns>The provider name.</returns>
   ProviderName = 'MSSQL_CERTIFICATE_STORE';
  end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlColumnEncryptionCngProviderClass = interface(DNSqlColumnEncryptionKeyStoreProviderClass)
  ['{96EB1852-D628-5B64-90F3-28900438FCF9}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlColumnEncryptionCngProvider" />
    ///  class.</summary>
    {class} function init: DNSqlColumnEncryptionCngProvider;

  { static fields getter & setter } 

   function __fakeFieldGet_ProviderName: string;

  { static fields } 

    ///<summary>A constant string for the provider name 'MSSQL_CNG_STORE'.</summary>
    ///<returns>The provider name.</returns>
    {class} property ProviderName: string read __fakeFieldGet_ProviderName;

  end;

  ///<summary>The CMK Store provider implementation for using the Microsoft Cryptography API: Next Generation (CNG) with Always Encrypted.   </summary>
  [DNTypeName('System.Data.SqlClient.SqlColumnEncryptionCngProvider')]
  DNSqlColumnEncryptionCngProvider = interface(DNSqlColumnEncryptionKeyStoreProvider)
  ['{3110E653-1689-3CD0-A5EC-1AF2CEE19911}']
  { methods } 

    function SignColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean): TArray<Byte>;
    function VerifyColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean; signature: TArray<Byte>): Boolean;
    ///<summary>Decrypts the given encrypted value using an asymmetric key specified by the key path and the specified algorithm. The key path will be in the format of [ProviderName]/KeyIdentifier and should be an asymmetric key stored in the specified CNG key store provider. The valid algorithm used to encrypt/decrypt the CEK is 'RSA_OAEP'.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm.</param>
    ///  <param name="encryptedColumnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>The decrypted column encryption key.</returns>
    function DecryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; encryptedColumnEncryptionKey: TArray<Byte>): TArray<Byte>;
    ///<summary>Encrypts the given plain text column encryption key using an asymmetric key specified by the key path and the specified algorithm. The key path will be in the format of [ProviderName]/KeyIdentifier and should be an asymmetric key stored in the specified CNG key store provider. The valid algorithm used to encrypt/decrypt the CEK is 'RSA_OAEP'.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm.</param>
    ///  <param name="columnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>The encrypted column encryption key.</returns>
    function EncryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; columnEncryptionKey: TArray<Byte>): TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlColumnEncryptionCngProvider = class(TDNGenericImport<DNSqlColumnEncryptionCngProviderClass, DNSqlColumnEncryptionCngProvider>)
  public const
    ///<summary>A constant string for the provider name 'MSSQL_CNG_STORE'.</summary>
    ///<returns>The provider name.</returns>
   ProviderName = 'MSSQL_CNG_STORE';
  end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlColumnEncryptionCspProviderClass = interface(DNSqlColumnEncryptionKeyStoreProviderClass)
  ['{085DE0C4-0A9B-576C-BFF0-D4F579D3C0DF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlColumnEncryptionCspProvider" />
    ///  class.</summary>
    {class} function init: DNSqlColumnEncryptionCspProvider;

  { static fields getter & setter } 

   function __fakeFieldGet_ProviderName: string;

  { static fields } 

    ///<summary>A constant string for the provider name 'MSSQL_CSP_PROVIDER'.</summary>
    ///<returns>The provider name.</returns>
    {class} property ProviderName: string read __fakeFieldGet_ProviderName;

  end;

  ///<summary>The CMK Store provider implementation for using  Microsoft CAPI based Cryptographic Service Providers (CSP) with Always Encrypted.</summary>
  [DNTypeName('System.Data.SqlClient.SqlColumnEncryptionCspProvider')]
  DNSqlColumnEncryptionCspProvider = interface(DNSqlColumnEncryptionKeyStoreProvider)
  ['{B67DE20E-CF5F-3762-A4E2-39ADDBE5CCFD}']
  { methods } 

    function SignColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean): TArray<Byte>;
    function VerifyColumnMasterKeyMetadata(masterKeyPath: string; allowEnclaveComputations: Boolean; signature: TArray<Byte>): Boolean;
    ///<summary>Decrypts the given encrypted value using an asymmetric key specified by the key path and algorithm. The key path will be in the format of [ProviderName]/KeyIdentifier and should be an asymmetric key stored in the specified CSP provider. The valid algorithm used to encrypt/decrypt the CEK is 'RSA_OAEP'.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm. </param>
    ///  <param name="encryptedColumnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>The decrypted column encryption key.</returns>
    function DecryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; encryptedColumnEncryptionKey: TArray<Byte>): TArray<Byte>;
    ///<summary>Encrypts the given plain text column encryption key using an asymmetric key specified by the key path and the specified algorithm. The key path will be in the format of [ProviderName]/KeyIdentifier and should be an asymmetric key stored in the specified CSP provider. The valid algorithm used to encrypt/decrypt the CEK is 'RSA_OAEP'.</summary>
    ///  <param name="masterKeyPath">The master key path.</param>
    ///  <param name="encryptionAlgorithm">The encryption algorithm. </param>
    ///  <param name="columnEncryptionKey">The encrypted column encryption key.</param>
    ///<returns>The encrypted column encryption key.</returns>
    function EncryptColumnEncryptionKey(masterKeyPath: string; encryptionAlgorithm: string; columnEncryptionKey: TArray<Byte>): TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlColumnEncryptionCspProvider = class(TDNGenericImport<DNSqlColumnEncryptionCspProviderClass, DNSqlColumnEncryptionCspProvider>)
  public const
    ///<summary>A constant string for the provider name 'MSSQL_CSP_PROVIDER'.</summary>
    ///<returns>The provider name.</returns>
   ProviderName = 'MSSQL_CSP_PROVIDER';
  end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlCredentialClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6E65E795-8FC1-5812-8149-412DEBA4EF7B}']
  { constructors } 

    ///<summary>Creates an object of type <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  .</summary>
    ///  <param name="userId">The user id.</param>
    ///  <param name="password">The password; a <see cref="T:System.Security.SecureString" />
    ///  value marked as read-only.  Passing a read/write <see cref="T:System.Security.SecureString" />
    ///  parameter will raise an <see cref="T:System.ArgumentException" />
    ///  .</param>
    {class} function init(userId: string; password: DDN.mscorlib.DNSecureString): DNSqlCredential;

  end;

  ///<summary><see cref="T:System.Data.SqlClient.SqlCredential" />
  ///  provides a more secure way to specify the password for a login attempt using SQL Server Authentication.
  ///<see cref="T:System.Data.SqlClient.SqlCredential" />
  ///  is comprised of a user id and a password that will be used for SQL Server Authentication. The password in a <see cref="T:System.Data.SqlClient.SqlCredential" />
  ///  object is of type <see cref="T:System.Security.SecureString" />
  ///  .
  ///<see cref="T:System.Data.SqlClient.SqlCredential" />
  ///  cannot be inherited.Windows Authentication (<see langword="Integrated Security = true" />
  ///  ) remains the most secure way to log in to a SQL Server database.</summary>
  [DNTypeName('System.Data.SqlClient.SqlCredential')]
  DNSqlCredential = interface(DDN.mscorlib.DNObject)
  ['{8D53DB41-BFD1-3E10-9414-DF8D7A1CB2CE}']
  { getters & setters } 

    function get_UserId: string;
    function get_Password: DDN.mscorlib.DNSecureString;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Returns the user ID component of the <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object.</summary>
    ///<returns>Returns the user ID component of the <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object..</returns>
    property UserId: string read get_UserId;
    ///<summary>Returns the password component of the <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object.</summary>
    ///<returns>Returns the password component of the <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object.</returns>
    property Password: DDN.mscorlib.DNSecureString read get_Password;
  end;

  TDNSqlCredential = class(TDNGenericImport<DNSqlCredentialClass, DNSqlCredential>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSQLDebuggingClass = interface(DDN.mscorlib.DNObjectClass)
  ['{CC0784DE-7976-5E8F-AE68-9A671B344113}']
  { constructors } 

    ///<summary>Included to support debugging applications. Not intended for direct use.</summary>
    {class} function init: DNSQLDebugging;

  end;

  ///<summary>Included to support debugging applications. Not intended for direct use.</summary>
  [DNTypeName('System.Data.SqlClient.SQLDebugging')]
  DNSQLDebugging = interface(DDN.mscorlib.DNObject)
  ['{AFEF65AD-4577-447A-A148-83ACADD3D4B9}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSQLDebugging = class(TDNGenericImport<DNSQLDebuggingClass, DNSQLDebugging>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlDependencyClass = interface(DDN.mscorlib.DNObjectClass)
  ['{89A4C3EF-90CF-5252-92A6-7CA9735C17DF}']
  { constructors } 

    ///<summary>Creates a new instance of the <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  class with the default settings.</summary>
    {class} function init: DNSqlDependency; overload;
    ///<summary>Creates a new instance of the <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  class and associates it with the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  parameter.</summary>
    ///  <param name="command">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object to associate with this <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  object. The constructor will set up a <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  object and bind it to the command. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="command" />
    ///  parameter is NULL. </exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object already has a <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  object assigned to its <see cref="P:System.Data.SqlClient.SqlCommand.Notification" />
    ///  property, and that <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  is not associated with this dependency. </exception>
    {class} function init(command: DNSqlCommand): DNSqlDependency; overload;
    ///<summary>Creates a new instance of the <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  class, associates it with the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  parameter, and specifies notification options and a time-out value.</summary>
    ///  <param name="command">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object to associate with this <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  object. The constructor sets up a <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  object and bind it to the command.</param>
    ///  <param name="options">The notification request options to be used by this dependency.  <paramref name="null" />
    ///  to use the default service. </param>
    ///  <param name="timeout">The time-out for this notification in seconds. The default is 0, indicating that the server's time-out should be used.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="command" />
    ///  parameter is NULL. </exception><exception cref="T:System.ArgumentOutOfRangeException">The time-out value is less than zero.</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object already has a <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  object assigned to its <see cref="P:System.Data.SqlClient.SqlCommand.Notification" />
    ///  property and that <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  is not associated with this dependency.An attempt was made to create a SqlDependency instance from within SQLCLR.</exception>
    {class} function init(command: DNSqlCommand; options: string; timeout: Int32): DNSqlDependency; overload;

  { static methods } 

    ///<summary>Starts the listener for receiving dependency change notifications from the instance of SQL Server specified by the connection string.</summary>
    ///  <param name="connectionString">The connection string for the instance of SQL Server from which to obtain change notifications.</param>
    ///<returns>
    ///  true if the listener initialized successfully; false if a compatible listener already exists.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="connectionString" />
    ///  parameter is NULL.</exception><exception cref="T:System.InvalidOperationException">The <paramref name="connectionString" />
    ///  parameter is the same as a previous call to this method, but the parameters are different.The method was called from within the CLR.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  code access security (CAS) permission.</exception><exception cref="T:System.Data.SqlClient.SqlException">A subsequent call to the method has been made with an equivalent <paramref name="connectionString" />
    ///  parameter with a different user, or a user that does not default to the same schema.Also, any underlying SqlClient exceptions.</exception>
    {class} function Start(connectionString: string): Boolean; overload;
    ///<summary>Starts the listener for receiving dependency change notifications from the instance of SQL Server specified by the connection string using the specified SQL Server Service Broker queue.</summary>
    ///  <param name="connectionString">The connection string for the instance of SQL Server from which to obtain change notifications.</param>
    ///  <param name="queue">An existing SQL Server Service Broker queue to be used. If <see langword="null" />
    ///  , the default queue is used.</param>
    ///<returns>
    ///  true if the listener initialized successfully; false if a compatible listener already exists.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="connectionString" />
    ///  parameter is NULL.</exception><exception cref="T:System.InvalidOperationException">The <paramref name="connectionString" />
    ///  parameter is the same as a previous call to this method, but the parameters are different.The method was called from within the CLR.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  code access security (CAS) permission.</exception><exception cref="T:System.Data.SqlClient.SqlException">A subsequent call to the method has been made with an equivalent <paramref name="connectionString" />
    ///  parameter but a different user, or a user that does not default to the same schema.Also, any underlying SqlClient exceptions.</exception>
    {class} function Start(connectionString: string; queue: string): Boolean; overload;
    ///<summary>Stops a listener for a connection specified in a previous <see cref="Overload:System.Data.SqlClient.SqlDependency.Start" />
    ///  call.</summary>
    ///  <param name="connectionString">Connection string for the instance of SQL Server that was used in a previous <see cref="M:System.Data.SqlClient.SqlDependency.Start(System.String)" />
    ///  call.</param>
    ///<returns>
    ///  true if the listener was completely stopped; false if the <see cref="T:System.AppDomain" />
    ///  was unbound from the listener, but there are is at least one other <see cref="T:System.AppDomain" />
    ///  using the same listener.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="connectionString" />
    ///  parameter is NULL. </exception><exception cref="T:System.InvalidOperationException">The method was called from within SQLCLR.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  code access security (CAS) permission.</exception><exception cref="T:System.Data.SqlClient.SqlException">An underlying SqlClient exception occurred.</exception>
    {class} function Stop(connectionString: string): Boolean; overload;
    ///<summary>Stops a listener for a connection specified in a previous <see cref="Overload:System.Data.SqlClient.SqlDependency.Start" />
    ///  call.</summary>
    ///  <param name="connectionString">Connection string for the instance of SQL Server that was used in a previous <see cref="M:System.Data.SqlClient.SqlDependency.Start(System.String,System.String)" />
    ///  call.</param>
    ///  <param name="queue">The SQL Server Service Broker queue that was used in a previous <see cref="M:System.Data.SqlClient.SqlDependency.Start(System.String,System.String)" />
    ///  call.</param>
    ///<returns>
    ///  true if the listener was completely stopped; false if the <see cref="T:System.AppDomain" />
    ///  was unbound from the listener, but there is at least one other <see cref="T:System.AppDomain" />
    ///  using the same listener.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="connectionString" />
    ///  parameter is NULL. </exception><exception cref="T:System.InvalidOperationException">The method was called from within SQLCLR.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  code access security (CAS) permission.</exception><exception cref="T:System.Data.SqlClient.SqlException">And underlying SqlClient exception occurred.</exception>
    {class} function Stop(connectionString: string; queue: string): Boolean; overload;

  end;

  ///<summary>The <see cref="T:System.Data.SqlClient.SqlDependency" />
  ///  object represents a query notification dependency between an application and an instance of SQL Server. An application can create a <see cref="T:System.Data.SqlClient.SqlDependency" />
  ///  object and register to receive notifications via the <see cref="T:System.Data.SqlClient.OnChangeEventHandler" />
  ///  event handler.</summary>
  [DNTypeName('System.Data.SqlClient.SqlDependency')]
  DNSqlDependency = interface(DDN.mscorlib.DNObject)
  ['{3426F3A6-F249-3D9C-80EE-C5B0708DA11F}']
  { getters & setters } 

    function get_HasChanges: Boolean;
    function get_Id: string;

  { events } 

    procedure add_OnChange(value: DNOnChangeEventHandler);
    procedure remove_OnChange(value: DNOnChangeEventHandler);

  { methods } 

    ///<summary>Associates a <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object with this <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  instance.</summary>
    ///  <param name="command">A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object containing a statement that is valid for notifications. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="command" />
    ///  parameter is null. </exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object already has a <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  object assigned to its <see cref="P:System.Data.SqlClient.SqlCommand.Notification" />
    ///  property, and that <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  is not associated with this dependency. </exception>
    procedure AddCommandDependency(command: DNSqlCommand);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates whether one of the result sets associated with the dependency has changed.</summary>
    ///<returns>A Boolean value indicating whether one of the result sets has changed.</returns>
    property HasChanges: Boolean read get_HasChanges;
    ///<summary>Gets a value that uniquely identifies this instance of the <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  class.</summary>
    ///<returns>A string representation of a GUID that is generated for each instance of the <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  class.</returns>
    property Id: string read get_Id;
  end;

  TDNSqlDependency = class(TDNGenericImport<DNSqlDependencyClass, DNSqlDependency>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlEnclaveAttestationParametersClass = interface(DDN.mscorlib.DNObjectClass)
  ['{57FF4CDC-BDF5-5F76-945A-F66AFBFDE08E}']
  { constructors } 

    {class} function init(protocol: Int32; input: TArray<Byte>; clientDiffieHellmanKey: DDN.System.Core.DNECDiffieHellmanCng): DNSqlEnclaveAttestationParameters;

  end;

  [DNTypeName('System.Data.SqlClient.SqlEnclaveAttestationParameters')]
  DNSqlEnclaveAttestationParameters = interface(DDN.mscorlib.DNObject)
  ['{E2D7782F-5C8D-3D37-9F7E-8642EA0D53B6}']
  { getters & setters } 

    function get_Protocol: Int32;
    function get_ClientDiffieHellmanKey: DDN.System.Core.DNECDiffieHellmanCng;

  { methods } 

    function GetInput: TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Protocol: Int32 read get_Protocol;
    property ClientDiffieHellmanKey: DDN.System.Core.DNECDiffieHellmanCng read get_ClientDiffieHellmanKey;
  end;

  TDNSqlEnclaveAttestationParameters = class(TDNGenericImport<DNSqlEnclaveAttestationParametersClass, DNSqlEnclaveAttestationParameters>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlEnclaveSessionClass = interface(DDN.mscorlib.DNObjectClass)
  ['{08727787-DA4B-554B-A8D5-2E6709598CE7}']
  { constructors } 

    {class} function init(sessionKey: TArray<Byte>; sessionId: Int64): DNSqlEnclaveSession;

  end;

  [DNTypeName('System.Data.SqlClient.SqlEnclaveSession')]
  DNSqlEnclaveSession = interface(DDN.mscorlib.DNObject)
  ['{2ADE2ADA-6EEA-3FDE-8060-76CF16B7C301}']
  { getters & setters } 

    function get_SessionId: Int64;

  { methods } 

    function GetSessionKey: TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property SessionId: Int64 read get_SessionId;
  end;

  TDNSqlEnclaveSession = class(TDNGenericImport<DNSqlEnclaveSessionClass, DNSqlEnclaveSession>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlErrorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{08B747E8-D736-5A73-BB28-8D0E63072594}']
  end;

  ///<summary>Collects information relevant to a warning or error returned by SQL Server.</summary>
  [DNTypeName('System.Data.SqlClient.SqlError')]
  DNSqlError = interface(DDN.mscorlib.DNObject)
  ['{3300A145-13B0-3DFB-A833-E6DE462FAB99}']
  { getters & setters } 

    function get_Source: string;
    function get_Number: Int32;
    function get_State: Byte;
    function get_Class: Byte;
    function get_Server: string;
    function get_Message: string;
    function get_Procedure: string;
    function get_LineNumber: Int32;

  { methods } 

    ///<summary>Gets the complete text of the error message.</summary>
    ///<returns>The complete text of the error.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the name of the provider that generated the error.</summary>
    ///<returns>The name of the provider that generated the error.</returns>
    property Source: string read get_Source;
    ///<summary>Gets a number that identifies the type of error.</summary>
    ///<returns>The number that identifies the type of error.</returns>
    property Number: Int32 read get_Number;
    ///<summary>Some error messages can be raised at multiple points in the code for the Database Engine. For example, an 1105 error can be raised for several different conditions. Each specific condition that raises an error assigns a unique state code.</summary>
    ///<returns>The state code.</returns>
    property State: Byte read get_State;
    ///<summary>Gets the severity level of the error returned from SQL Server.</summary>
    ///<returns>A value from 1 to 25 that indicates the severity level of the error. The default is 0.</returns>
    property &Class: Byte read get_Class;
    ///<summary>Gets the name of the instance of SQL Server that generated the error.</summary>
    ///<returns>The name of the instance of SQL Server.</returns>
    property Server: string read get_Server;
    ///<summary>Gets the text describing the error.</summary>
    ///<returns>The text describing the error.For more information on errors generated by SQL Server, see SQL Server Books Online.</returns>
    property Message: string read get_Message;
    ///<summary>Gets the name of the stored procedure or remote procedure call (RPC) that generated the error.</summary>
    ///<returns>The name of the stored procedure or RPC.For more information on errors generated by SQL Server, see SQL Server Books Online.</returns>
    property &Procedure: string read get_Procedure;
    ///<summary>Gets the line number within the Transact-SQL command batch or stored procedure that contains the error.</summary>
    ///<returns>The line number within the Transact-SQL command batch or stored procedure that contains the error.</returns>
    property LineNumber: Int32 read get_LineNumber;
  end;

  TDNSqlError = class(TDNGenericImport<DNSqlErrorClass, DNSqlError>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlErrorCollectionClass = interface(DNObjectClass)
  ['{55018440-F371-5229-97E5-3A5E88D0F36D}']
  end;

  ///<summary>Collects all errors generated by the .NET Framework Data Provider for SQL Server. This class cannot be inherited. </summary>
  [DNTypeName('System.Data.SqlClient.SqlErrorCollection')]
  DNSqlErrorCollection = interface(DDN.mscorlib.DNICollection)
  ['{0D3E24E8-3729-3195-8732-80902BC548FC}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(index: Int32): DNSqlError;

  { methods } 

    ///<summary>Copies the elements of the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  collection into an <see cref="T:System.Array" />
    ///  , starting at the specified index.</summary>
    ///  <param name="array">The <see cref="T:System.Array" />
    ///  to copy elements into. </param>
    ///  <param name="index">The index from which to start copying into the <paramref name="array" />
    ///  parameter. </param>
    ///<exception cref="T:System.ArgumentException">The sum of <paramref name="index" />
    ///  and the number of elements in the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  collection is greater than the <see cref="P:System.Array.Length" />
    ///  of the <see cref="T:System.Array" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index" />
    ///  is not valid for <paramref name="array" />
    ///  . </exception>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Copies the elements of the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  collection into a <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  , starting at the specified index.</summary>
    ///  <param name="array">The <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  to copy the elements into.</param>
    ///  <param name="index">The index from which to start copying into the <paramref name="array" />
    ///  parameter.</param>
    ///<exception cref="T:System.ArgumentException">The sum of <paramref name="index" />
    ///  and the number of elements in the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  collection is greater than the length of the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index" />
    ///  is not valid for <paramref name="array" />
    ///  . </exception>
    procedure CopyTo(&array: TArray<DNSqlError>; index: Int32); overload;
    ///<summary>Returns an enumerator that iterates through the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the <see cref="T:System.Data.SqlClient.SqlErrorCollection" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of errors in the collection.</summary>
    ///<returns>The total number of errors in the collection.</returns>
    property Count: Int32 read get_Count;
    property Item[index: Int32]: DNSqlError read get_Item; default;
  end;

  TDNSqlErrorCollection = class(TDNGenericImport<DNSqlErrorCollectionClass, DNSqlErrorCollection>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlBytesClass = interface(DNObjectClass)
  ['{3AD176CF-E8C3-5490-9208-7DB1326D4517}']
  { static getter & setter } 

    {class} function get_Null: DNSqlBytes;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  class.</summary>
    {class} function init: DNSqlBytes; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  class based on the specified byte array.</summary>
    ///  <param name="buffer">The array of unsigned bytes. </param>
    {class} function init(buffer: TArray<Byte>): DNSqlBytes; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  class based on the specified <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  value.</summary>
    ///  <param name="value">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  value.</param>
    {class} function init(value: DNSqlBinary): DNSqlBytes; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  class based on the specified <see cref="T:System.IO.Stream" />
    ///  value.</summary>
    ///  <param name="s">A <see cref="T:System.IO.Stream" />
    ///  . </param>
    {class} function init(s: DDN.mscorlib.DNStream): DNSqlBytes; overload;

  { static methods } 

    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  that indicates the XSD of the specified <see langword="XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  { static propertys } 

    ///<summary>Returns a null instance of this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</summary>
    ///<returns>Returns an instance in such a way that <see cref="P:System.Data.SqlTypes.SqlBytes.IsNull" />
    ///  returns <see langword="true" />
    ///  .</returns>
    {class} property Null: DNSqlBytes read get_Null;
  end;

  ///<summary>Represents a mutable reference type that wraps either a <see cref="P:System.Data.SqlTypes.SqlBytes.Buffer" />
  ///  or a <see cref="P:System.Data.SqlTypes.SqlBytes.Stream" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlTypes.SqlBytes')]
  DNSqlBytes = interface(DNINullable)
  ['{DFEA266A-B66D-341F-8DE1-ACAB8A9C6564}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Buffer: TArray<Byte>;
    function get_Length: Int64;
    function get_MaxLength: Int64;
    function get_Value: TArray<Byte>;
    function get_Item(offset: Int64): Byte;
    procedure set_Item(offset: Int64; value: Byte);
    function get_Storage: DNStorageState;
    function get_Stream: DDN.mscorlib.DNStream;
    procedure set_Stream(value: DDN.mscorlib.DNStream);

  { methods } 

    ///<summary>Sets this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance to null.</summary>
    procedure SetNull;
    ///<summary>Sets the length of this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</summary>
    ///  <param name="value">The <see cref="T:System.Int64" />
    ///  long value representing the length.</param>
    procedure SetLength(value: Int64);
    ///<summary>Copies bytes from this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance to the passed-in buffer and returns the number of copied bytes.</summary>
    ///  <param name="offset">An <see cref="T:System.Int64" />
    ///  long value offset into the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</param>
    ///  <param name="buffer">The byte array buffer to copy into.</param>
    ///  <param name="offsetInBuffer">An <see cref="T:System.Int32" />
    ///  integer offset into the buffer to start copying into.</param>
    ///  <param name="count">An <see cref="T:System.Int32" />
    ///  integer representing the number of bytes to copy.</param>
    ///<returns>An <see cref="T:System.Int64" />
    ///  long value representing the number of copied bytes.</returns>
    function Read(offset: Int64; buffer: TArray<Byte>; offsetInBuffer: Int32; count: Int32): Int64;
    ///<summary>Copies bytes from the passed-in buffer to this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</summary>
    ///  <param name="offset">An <see cref="T:System.Int64" />
    ///  long value offset into the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</param>
    ///  <param name="buffer">The byte array buffer to copy into.</param>
    ///  <param name="offsetInBuffer">An <see cref="T:System.Int32" />
    ///  integer offset into the buffer to start copying into.</param>
    ///  <param name="count">An <see cref="T:System.Int32" />
    ///  integer representing the number of bytes to copy.</param>
    procedure Write(offset: Int64; buffer: TArray<Byte>; offsetInBuffer: Int32; count: Int32);
    ///<summary>Constructs and returns a <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  from this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  from this instance.</returns>
    function ToSqlBinary: DNSqlBinary;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  is null.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  is null, <see langword="false" />
    ///  otherwise.</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Returns a reference to the internal buffer. </summary>
    ///<returns>Returns a reference to the internal buffer. For <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instances created on top of unmanaged pointers, it returns a managed copy of the internal buffer.</returns>
    property Buffer: TArray<Byte> read get_Buffer;
    ///<summary>Gets the length of the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</summary>
    ///<returns>A <see cref="T:System.Int64" />
    ///  value representing the length of the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance. Returns -1 if no buffer is available to the instance or if the value is null. Returns a <see cref="P:System.IO.Stream.Length" />
    ///  for a stream-wrapped instance.</returns>
    property Length: Int64 read get_Length;
    ///<summary>Gets the maximum length of the value of the internal buffer of this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</summary>
    ///<returns>A long representing the maximum length of the value of the internal buffer. Returns -1 for a stream-wrapped <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</returns>
    property MaxLength: Int64 read get_MaxLength;
    ///<summary>Returns a managed copy of the value held by this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</summary>
    ///<returns>The value of this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  as an array of bytes.</returns>
    property Value: TArray<Byte> read get_Value;
    property Item[offset: Int64]: Byte read get_Item write set_Item; default;
    ///<summary>Returns information about the storage state of this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  instance.</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.StorageState" />
    ///  enumeration.</returns>
    property Storage: DNStorageState read get_Storage;
    ///<summary>Gets or sets the data of this <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  as a stream.</summary>
    ///<returns>The stream that contains the SqlBytes data.</returns>
    property Stream: DDN.mscorlib.DNStream read get_Stream write set_Stream;
  end;

  TDNSqlBytes = class(TDNGenericImport<DNSqlBytesClass, DNSqlBytes>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlCharsClass = interface(DNObjectClass)
  ['{402C3B2D-44A0-5FCC-92E5-902F2DEDD826}']
  { static getter & setter } 

    {class} function get_Null: DNSqlChars;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  class.</summary>
    {class} function init: DNSqlChars; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  class based on the specified character array.</summary>
    ///  <param name="buffer">A <see cref="T:System.Char" />
    ///  array.</param>
    {class} function init(buffer: TArray<Char>): DNSqlChars; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  class based on the specified <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  value.</summary>
    ///  <param name="value">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</param>
    {class} function init(value: DNSqlString): DNSqlChars; overload;

  { static methods } 

    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  { static propertys } 

    ///<summary>Returns a null instance of this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</summary>
    ///<returns>Returns an instance in such a way that <see cref="P:System.Data.SqlTypes.SqlChars.IsNull" />
    ///  returns <see langword="true" />
    ///  . For more information, see Handling Null Values.</returns>
    {class} property Null: DNSqlChars read get_Null;
  end;

  ///<summary><see cref="T:System.Data.SqlTypes.SqlChars" />
  ///  is a mutable reference type that wraps a <see cref="T:System.Char" />
  ///  array or a <see cref="T:System.Data.SqlTypes.SqlString" />
  ///  instance.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlChars')]
  DNSqlChars = interface(DNINullable)
  ['{445D8429-C2BC-30B2-94DF-D51131301951}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Buffer: TArray<Char>;
    function get_Length: Int64;
    function get_MaxLength: Int64;
    function get_Value: TArray<Char>;
    function get_Item(offset: Int64): Char;
    procedure set_Item(offset: Int64; value: Char);
    function get_Storage: DNStorageState;

  { methods } 

    ///<summary>Sets this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance to null.</summary>
    procedure SetNull;
    ///<summary>Sets the length of this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.</summary>
    ///  <param name="value">The <see cref="T:System.Int64" />
    ///<see langword="long" />
    ///  value representing the length.</param>
    procedure SetLength(value: Int64);
    ///<summary>Copies characters from this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance to the passed-in buffer and returns the number of copied characters.</summary>
    ///  <param name="offset">An <see cref="T:System.Int64" />
    ///<see langword="long" />
    ///  value offset into the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.</param>
    ///  <param name="buffer">The character array buffer to copy into.</param>
    ///  <param name="offsetInBuffer">An <see cref="T:System.Int32" />
    ///  integer offset into the buffer to start copying into.</param>
    ///  <param name="count">An <see cref="T:System.Int32" />
    ///  integer value representing the number of characters to copy.</param>
    ///<returns>An <see cref="T:System.Int64" />
    ///<see langword="long" />
    ///  value representing the number of copied bytes.</returns>
    function Read(offset: Int64; buffer: TArray<Char>; offsetInBuffer: Int32; count: Int32): Int64;
    ///<summary>Copies characters from the passed-in buffer to this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.</summary>
    ///  <param name="offset">A <see langword="long" />
    ///  value offset into the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.</param>
    ///  <param name="buffer">The character array buffer to copy into.</param>
    ///  <param name="offsetInBuffer">An <see cref="T:System.Int32" />
    ///  integer offset into the buffer to start copying into.</param>
    ///  <param name="count">An <see cref="T:System.Int32" />
    ///  integer representing the number of characters to copy.</param>
    procedure Write(offset: Int64; buffer: TArray<Char>; offsetInBuffer: Int32; count: Int32);
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance to its equivalent <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  representation.</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  representation of this type.</returns>
    function ToSqlString: DNSqlString;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  is null.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  is null. Otherwise, <see langword="false" />
    ///  . </returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Returns a reference to the internal buffer. </summary>
    ///<returns>Returns a reference to the internal buffer. For <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instances created on top of unmanaged pointers, it returns a managed copy of the internal buffer.</returns>
    property Buffer: TArray<Char> read get_Buffer;
    ///<summary>Gets the length of the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.</summary>
    ///<returns>A <see cref="T:System.Int64" />
    ///  value that indicates the length in characters of the value that is contained in the <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.Returns -1 if no buffer is available to the instance, or if the value is null. Returns a <see cref="P:System.IO.Stream.Length" />
    ///  for a stream-wrapped instance.</returns>
    property Length: Int64 read get_Length;
    ///<summary>Gets the maximum length in two-byte characters of the value the internal buffer can hold.</summary>
    ///<returns>An <see cref="T:System.Int64" />
    ///  value representing the maximum length in two-byte characters of the value of the internal buffer. Returns -1 for a stream-wrapped <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</returns>
    property MaxLength: Int64 read get_MaxLength;
    ///<summary>Returns a managed copy of the value held by this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</summary>
    ///<returns>The value of this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  as an array of characters.</returns>
    property Value: TArray<Char> read get_Value;
    property Item[offset: Int64]: Char read get_Item write set_Item; default;
    ///<summary>Returns information about the storage state of this <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  instance.</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.StorageState" />
    ///  enumeration.</returns>
    property Storage: DNStorageState read get_Storage;
  end;

  TDNSqlChars = class(TDNGenericImport<DNSqlCharsClass, DNSqlChars>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlXmlClass = interface(DNObjectClass)
  ['{2DA5915F-CEFB-54C3-8860-97DD634A514F}']
  { static getter & setter } 

    {class} function get_Null: DNSqlXml;

  { constructors } 

    ///<summary>Creates a new <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  instance.</summary>
    {class} function init: DNSqlXml; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  instance and associates it with the content of the supplied <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="value">An <see cref="T:System.Xml.XmlReader" />
    ///  -derived class instance to be used as the value of the new <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  instance.</param>
    {class} function init(value: DDN.System.Xml.DNXmlReader): DNSqlXml; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  instance, supplying the XML value from the supplied <see cref="T:System.IO.Stream" />
    ///  -derived instance.</summary>
    ///  <param name="value">A <see cref="T:System.IO.Stream" />
    ///  -derived instance (such as <see cref="T:System.IO.FileStream" />
    ///  ) from which to load the <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  instance's Xml content.</param>
    {class} function init(value: DDN.mscorlib.DNStream): DNSqlXml; overload;

  { static methods } 

    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A string that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  . </returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  { static propertys } 

    ///<summary>Represents a null instance of the <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  type.</summary>
    ///<returns>A null instance of the <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  type.</returns>
    {class} property Null: DNSqlXml read get_Null;
  end;

  ///<summary>Represents XML data stored in or retrieved from a server.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlXml')]
  DNSqlXml = interface(DNINullable)
  ['{D2B9B85D-34A6-3D8E-B78F-88919F51DF17}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: string;

  { methods } 

    ///<summary>Gets the value of the XML content of this <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  as a <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Xml.XmlReader" />
    ///  -derived instance that contains the XML content. The actual type may vary (for example, the return value might be <see cref="T:System.Xml.XmlTextReader" />
    ///  ) depending on how the information is represented internally, on the server.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">Attempt was made to access this property on a null instance of <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  .</exception>
    function CreateReader: DDN.System.Xml.DNXmlReader;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates whether this instance represents a null <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  value.</summary>
    ///<returns><see langword="true" />
    ///  if <see langword="Value" />
    ///  is null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the string representation of the XML content of this <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  instance.</summary>
    ///<returns>The string representation of the XML content.</returns>
    property Value: string read get_Value;
  end;

  TDNSqlXml = class(TDNGenericImport<DNSqlXmlClass, DNSqlXml>) end;

  //-------------namespace: System.Data----------------
  DNTypedDataSetGeneratorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{424002BC-971E-549B-9E79-079006F30562}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.TypedDataSetGenerator" />
    ///  class.</summary>
    {class} function init: DNTypedDataSetGenerator;

  { static methods } 

    ///<summary>Generates a strongly typed <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The source <see cref="T:System.Data.DataSet" />
    ///  that specifies the metadata for the typed <see cref="T:System.Data.DataSet" />
    ///  . </param>
    ///  <param name="codeNamespace">The namespace that provides the target namespace for the typed <see cref="T:System.Data.DataSet" />
    ///  . </param>
    ///  <param name="codeGen">The generator used to create the typed <see cref="T:System.Data.DataSet" />
    ///  . </param>
    {class} procedure Generate(dataSet: DNDataSet; codeNamespace: DDN.System.DNCodeNamespace; codeGen: DDN.System.DNICodeGenerator);
    ///<summary>Transforms a string in a valid, typed <see cref="T:System.Data.DataSet" />
    ///  name.</summary>
    ///  <param name="name">The source name to transform into a valid, typed <see cref="T:System.Data.DataSet" />
    ///  name. </param>
    ///  <param name="codeGen">The generator used to perform the conversion. </param>
    ///<returns>A string that is the converted name.</returns>
    {class} function GenerateIdName(name: string; codeGen: DDN.System.DNICodeGenerator): string;

  end;

  ///<summary>Used to create a strongly typed <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.TypedDataSetGenerator')]
  DNTypedDataSetGenerator = interface(DDN.mscorlib.DNObject)
  ['{6E1E89F6-487E-306B-8210-8E5812529515}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypedDataSetGenerator = class(TDNGenericImport<DNTypedDataSetGeneratorClass, DNTypedDataSetGenerator>) end;

  //-------------namespace: System.Data.Common----------------
  DNRowUpdatedEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{89985335-8E9C-5B28-8478-0D1C0E5763BA}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatedEventArgs" />
    ///  class.</summary>
    ///  <param name="dataRow">The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="command">The <see cref="T:System.Data.IDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called. </param>
    ///  <param name="statementType">The type of SQL statement executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(dataRow: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNRowUpdatedEventArgs;

  end;

  ///<summary>Provides data for the <see langword="RowUpdated" />
  ///  event of a .NET Framework data provider.</summary>
  [DNTypeName('System.Data.Common.RowUpdatedEventArgs')]
  DNRowUpdatedEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{E4D48765-DD05-3535-BED1-90F0D496B1A4}']
  { getters & setters } 

    function get_Command: DNIDbCommand;
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_RecordsAffected: Int32;
    function get_Row: DNDataRow;
    function get_RowCount: Int32;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    ///<summary>Copies references to the modified rows into the provided array.</summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>); overload;
    ///<summary>Copies references to the modified rows into the provided array. </summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    ///  <param name="arrayIndex">The index in the array to start copying into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>; arrayIndex: Int32); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.IDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</summary>
    ///<returns>The <see cref="T:System.Data.IDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</returns>
    property Command: DNIDbCommand read get_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the number of rows processed in a batch of updated records.</summary>
    ///<returns><see langword="int" />
    ///  that specifies the number of row processed.</returns>
    property RowCount: Int32 read get_RowCount;
    ///<summary>Gets the type of SQL statement executed.</summary>
    ///<returns>The type of SQL statement executed.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNRowUpdatedEventArgs = class(TDNGenericImport<DNRowUpdatedEventArgsClass, DNRowUpdatedEventArgs>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcRowUpdatedEventArgsClass = interface(DNRowUpdatedEventArgsClass)
  ['{F2D68EE2-75ED-50C3-BF19-98F72E1393C0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcRowUpdatedEventArgs" />
    ///  class.</summary>
    ///  <param name="row">The <see langword="DataRow" />
    ///  sent through an update operation. </param>
    ///  <param name="command">The <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called. </param>
    ///  <param name="statementType">One of the <see cref="T:System.Data.StatementType" />
    ///  values that specifies the type of query executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(row: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNOdbcRowUpdatedEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.Odbc.OdbcDataAdapter.RowUpdated" />
  ///  event.</summary>
  [DNTypeName('System.Data.Odbc.OdbcRowUpdatedEventArgs')]
  DNOdbcRowUpdatedEventArgs = interface(DNRowUpdatedEventArgs)
  ['{53700BD6-7A75-3375-9080-8DB368360D17}']
  { getters & setters } 

    function get_Command: DNOdbcCommand;
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_RecordsAffected: Int32;
    function get_Row: DNDataRow;
    function get_RowCount: Int32;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    ///<summary>Copies references to the modified rows into the provided array.</summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>); overload;
    ///<summary>Copies references to the modified rows into the provided array. </summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    ///  <param name="arrayIndex">The index in the array to start copying into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>; arrayIndex: Int32); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</summary>
    ///<returns>The <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</returns>
    property Command: DNOdbcCommand read get_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the number of rows processed in a batch of updated records.</summary>
    ///<returns><see langword="int" />
    ///  that specifies the number of row processed.</returns>
    property RowCount: Int32 read get_RowCount;
    ///<summary>Gets the type of SQL statement executed.</summary>
    ///<returns>The type of SQL statement executed.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNOdbcRowUpdatedEventArgs = class(TDNGenericImport<DNOdbcRowUpdatedEventArgsClass, DNOdbcRowUpdatedEventArgs>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbRowUpdatedEventArgsClass = interface(DNRowUpdatedEventArgsClass)
  ['{56141D82-BAFA-5E86-B398-960869F2C9C6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbRowUpdatedEventArgs" />
    ///  class.</summary>
    ///  <param name="dataRow">The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="command">The <see cref="T:System.Data.IDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called. </param>
    ///  <param name="statementType">One of the <see cref="T:System.Data.StatementType" />
    ///  values that specifies the type of query executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(dataRow: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNOleDbRowUpdatedEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.OleDb.OleDbDataAdapter.RowUpdated" />
  ///  event.</summary>
  [DNTypeName('System.Data.OleDb.OleDbRowUpdatedEventArgs')]
  DNOleDbRowUpdatedEventArgs = interface(DNRowUpdatedEventArgs)
  ['{38DF6A4D-0373-34A1-9390-E7721215A819}']
  { getters & setters } 

    function get_Command: DNOleDbCommand;
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_RecordsAffected: Int32;
    function get_Row: DNDataRow;
    function get_RowCount: Int32;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    ///<summary>Copies references to the modified rows into the provided array.</summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>); overload;
    ///<summary>Copies references to the modified rows into the provided array. </summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    ///  <param name="arrayIndex">The index in the array to start copying into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>; arrayIndex: Int32); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</summary>
    ///<returns>The <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</returns>
    property Command: DNOleDbCommand read get_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the number of rows processed in a batch of updated records.</summary>
    ///<returns><see langword="int" />
    ///  that specifies the number of row processed.</returns>
    property RowCount: Int32 read get_RowCount;
    ///<summary>Gets the type of SQL statement executed.</summary>
    ///<returns>The type of SQL statement executed.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNOleDbRowUpdatedEventArgs = class(TDNGenericImport<DNOleDbRowUpdatedEventArgsClass, DNOleDbRowUpdatedEventArgs>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlRowUpdatedEventArgsClass = interface(DNRowUpdatedEventArgsClass)
  ['{4ECDEFDA-047A-55CF-BE59-A558FFA247E4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlRowUpdatedEventArgs" />
    ///  class.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="command">The <see cref="T:System.Data.IDbCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called. </param>
    ///  <param name="statementType">One of the <see cref="T:System.Data.StatementType" />
    ///  values that specifies the type of query executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</param>
    {class} function init(row: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNSqlRowUpdatedEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.SqlClient.SqlDataAdapter.RowUpdated" />
  ///  event.</summary>
  [DNTypeName('System.Data.SqlClient.SqlRowUpdatedEventArgs')]
  DNSqlRowUpdatedEventArgs = interface(DNRowUpdatedEventArgs)
  ['{FDDC357F-D7FC-3269-B46E-B015DD784F78}']
  { getters & setters } 

    function get_Command: DNSqlCommand;
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_RecordsAffected: Int32;
    function get_Row: DNDataRow;
    function get_RowCount: Int32;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    ///<summary>Copies references to the modified rows into the provided array.</summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>); overload;
    ///<summary>Copies references to the modified rows into the provided array. </summary>
    ///  <param name="array">The array of <see cref="T:System.Data.DataRow" />
    ///  to copy into.</param>
    ///  <param name="arrayIndex">The index in the array to start copying into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>; arrayIndex: Int32); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</summary>
    ///<returns>The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  executed when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</returns>
    property Command: DNSqlCommand read get_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  was executed.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the number of rows processed in a batch of updated records.</summary>
    ///<returns><see langword="int" />
    ///  that specifies the number of row processed.</returns>
    property RowCount: Int32 read get_RowCount;
    ///<summary>Gets the type of SQL statement executed.</summary>
    ///<returns>The type of SQL statement executed.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNSqlRowUpdatedEventArgs = class(TDNGenericImport<DNSqlRowUpdatedEventArgsClass, DNSqlRowUpdatedEventArgs>) end;

  //-------------namespace: System.Data.Common----------------
  DNRowUpdatingEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{1E3BE921-4ED7-52D7-9782-0CCCD4BB37A4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.RowUpdatingEventArgs" />
    ///  class.</summary>
    ///  <param name="dataRow">The <see cref="T:System.Data.DataRow" />
    ///  to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="command">The <see cref="T:System.Data.IDbCommand" />
    ///  to execute when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called. </param>
    ///  <param name="statementType">The type of SQL statement to execute. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(dataRow: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNRowUpdatingEventArgs;

  end;

  ///<summary>Provides the data for the RowUpdating event of a .NET Framework data provider.</summary>
  [DNTypeName('System.Data.Common.RowUpdatingEventArgs')]
  DNRowUpdatingEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{BC6E44BB-A58E-3156-ACC2-50D167FCCF44}']
  { getters & setters } 

    function get_Command: DNIDbCommand;
    procedure set_Command(value: DNIDbCommand);
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_Row: DNDataRow;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.IDbCommand" />
    ///  to execute during the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  operation.</summary>
    ///<returns>The <see cref="T:System.Data.IDbCommand" />
    ///  to execute during the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Command: DNIDbCommand read get_Command write set_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  that will be sent to the server as part of an insert, update, or delete operation.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  to send through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the type of SQL statement to execute.</summary>
    ///<returns>The type of SQL statement to execute.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets or sets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNRowUpdatingEventArgs = class(TDNGenericImport<DNRowUpdatingEventArgsClass, DNRowUpdatingEventArgs>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcRowUpdatingEventArgsClass = interface(DNRowUpdatingEventArgsClass)
  ['{160B0195-9D6A-5DB9-A9A1-33A63490242D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcRowUpdatingEventArgs" />
    ///  class.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  to update. </param>
    ///  <param name="command">The <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  to execute during the update operation. </param>
    ///  <param name="statementType">One of the <see cref="T:System.Data.StatementType" />
    ///  values that specifies the type of query executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(row: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNOdbcRowUpdatingEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.Odbc.OdbcDataAdapter.RowUpdating" />
  ///  event.</summary>
  [DNTypeName('System.Data.Odbc.OdbcRowUpdatingEventArgs')]
  DNOdbcRowUpdatingEventArgs = interface(DNRowUpdatingEventArgs)
  ['{91EF26F3-E833-3246-B66F-94F20A490FE6}']
  { getters & setters } 

    function get_Command: DNOdbcCommand;
    procedure set_Command(value: DNOdbcCommand);
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_Row: DNDataRow;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  to execute when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</summary>
    ///<returns>The <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  to execute when <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  is called.</returns>
    property Command: DNOdbcCommand read get_Command write set_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  that will be sent to the server as part of an insert, update, or delete operation.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  to send through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the type of SQL statement to execute.</summary>
    ///<returns>The type of SQL statement to execute.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets or sets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNOdbcRowUpdatingEventArgs = class(TDNGenericImport<DNOdbcRowUpdatingEventArgsClass, DNOdbcRowUpdatingEventArgs>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbRowUpdatingEventArgsClass = interface(DNRowUpdatingEventArgsClass)
  ['{E99F5526-9820-549C-9CB7-F932F6E70B40}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbRowUpdatingEventArgs" />
    ///  class.</summary>
    ///  <param name="dataRow">The <see cref="T:System.Data.DataRow" />
    ///  to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="command">The <see cref="T:System.Data.IDbCommand" />
    ///  to execute during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="statementType">One of the <see cref="T:System.Data.StatementType" />
    ///  values that specifies the type of query executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(dataRow: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNOleDbRowUpdatingEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.OleDb.OleDbDataAdapter.RowUpdating" />
  ///  event. </summary>
  [DNTypeName('System.Data.OleDb.OleDbRowUpdatingEventArgs')]
  DNOleDbRowUpdatingEventArgs = interface(DNRowUpdatingEventArgs)
  ['{EDB4D7FF-9268-3EF6-A9CB-6DABDD7DB263}']
  { getters & setters } 

    function get_Command: DNOleDbCommand;
    procedure set_Command(value: DNOleDbCommand);
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_Row: DNDataRow;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  to execute when performing the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  to execute when performing the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Command: DNOleDbCommand read get_Command write set_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  that will be sent to the server as part of an insert, update, or delete operation.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  to send through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the type of SQL statement to execute.</summary>
    ///<returns>The type of SQL statement to execute.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets or sets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNOleDbRowUpdatingEventArgs = class(TDNGenericImport<DNOleDbRowUpdatingEventArgsClass, DNOleDbRowUpdatingEventArgs>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlRowUpdatingEventArgsClass = interface(DNRowUpdatingEventArgsClass)
  ['{ADFF2CC7-B2FA-57BD-83C1-A4DE3BE365F5}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlRowUpdatingEventArgs" />
    ///  class.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  to <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="command">The <see cref="T:System.Data.IDbCommand" />
    ///  to execute during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    ///  <param name="statementType">One of the <see cref="T:System.Data.StatementType" />
    ///  values that specifies the type of query executed. </param>
    ///  <param name="tableMapping">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  sent through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  . </param>
    {class} function init(row: DNDataRow; command: DNIDbCommand; statementType: DNStatementType; tableMapping: DNDataTableMapping): DNSqlRowUpdatingEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.SqlClient.SqlDataAdapter.RowUpdating" />
  ///  event.</summary>
  [DNTypeName('System.Data.SqlClient.SqlRowUpdatingEventArgs')]
  DNSqlRowUpdatingEventArgs = interface(DNRowUpdatingEventArgs)
  ['{64F42CA7-B456-3308-80B0-18D165B29007}']
  { getters & setters } 

    function get_Command: DNSqlCommand;
    procedure set_Command(value: DNSqlCommand);
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_Row: DNDataRow;
    function get_StatementType: DNStatementType;
    function get_Status: DNUpdateStatus;
    procedure set_Status(value: DNUpdateStatus);
    function get_TableMapping: DNDataTableMapping;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  to execute when performing the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  to execute when performing the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Command: DNSqlCommand read get_Command write set_Command;
    ///<summary>Gets any errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</summary>
    ///<returns>The errors generated by the .NET Framework data provider when the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  executes.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  that will be sent to the server as part of an insert, update, or delete operation.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  to send through an <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the type of SQL statement to execute.</summary>
    ///<returns>The type of SQL statement to execute.</returns>
    property StatementType: DNStatementType read get_StatementType;
    ///<summary>Gets or sets the <see cref="T:System.Data.UpdateStatus" />
    ///  of the <see cref="P:System.Data.Common.RowUpdatedEventArgs.Command" />
    ///  property.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateStatus" />
    ///  values. The default is <see langword="Continue" />
    ///  .</returns>
    property Status: DNUpdateStatus read get_Status write set_Status;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to send through the <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  .</returns>
    property TableMapping: DNDataTableMapping read get_TableMapping;
  end;

  TDNSqlRowUpdatingEventArgs = class(TDNGenericImport<DNSqlRowUpdatingEventArgsClass, DNSqlRowUpdatingEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNDataColumnChangeEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{E093AF51-E23D-5B0E-BFF1-DEA4554E8CCC}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataColumnChangeEventArgs" />
    ///  class.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  of the column with the changing value. </param>
    ///  <param name="column">The <see cref="T:System.Data.DataColumn" />
    ///  with the changing value. </param>
    ///  <param name="value">The new value. </param>
    {class} function init(row: DNDataRow; column: DNDataColumn; value: DDN.mscorlib.DNObject): DNDataColumnChangeEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.DataTable.ColumnChanging" />
  ///  event.</summary>
  [DNTypeName('System.Data.DataColumnChangeEventArgs')]
  DNDataColumnChangeEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{F3D0A1DA-D027-3E0A-95CB-4CD3B25F3E9D}']
  { getters & setters } 

    function get_Column: DNDataColumn;
    function get_Row: DNDataRow;
    function get_ProposedValue: DDN.mscorlib.DNObject;
    procedure set_ProposedValue(value: DDN.mscorlib.DNObject);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.DataColumn" />
    ///  with a changing value.</summary>
    ///<returns>The <see cref="T:System.Data.DataColumn" />
    ///  with a changing value.</returns>
    property Column: DNDataColumn read get_Column;
    ///<summary>Gets the <see cref="T:System.Data.DataRow" />
    ///  of the column with a changing value.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  of the column with a changing value.</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets or sets the proposed new value for the column.</summary>
    ///<returns>The proposed value, of type <see cref="T:System.Object" />
    ///  .</returns>
    property ProposedValue: DDN.mscorlib.DNObject read get_ProposedValue write set_ProposedValue;
  end;

  TDNDataColumnChangeEventArgs = class(TDNGenericImport<DNDataColumnChangeEventArgsClass, DNDataColumnChangeEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNDataRowChangeEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{EACF8D2A-F76A-5DCD-ADE6-3BD171C9C6F7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataRowChangeEventArgs" />
    ///  class.</summary>
    ///  <param name="row">The <see cref="T:System.Data.DataRow" />
    ///  upon which an action is occuring. </param>
    ///  <param name="action">One of the <see cref="T:System.Data.DataRowAction" />
    ///  values. </param>
    {class} function init(row: DNDataRow; action: DNDataRowAction): DNDataRowChangeEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.DataTable.RowChanged" />
  ///  , <see cref="E:System.Data.DataTable.RowChanging" />
  ///  , <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
  ///  , and <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
  ///  events.</summary>
  [DNTypeName('System.Data.DataRowChangeEventArgs')]
  DNDataRowChangeEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{BE27FF81-9AE9-3583-99C1-9D8F15D8832F}']
  { getters & setters } 

    function get_Row: DNDataRow;
    function get_Action: DNDataRowAction;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the row upon which an action has occurred.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  upon which an action has occurred.</returns>
    property Row: DNDataRow read get_Row;
    ///<summary>Gets the action that has occurred on a <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowAction" />
    ///  values.</returns>
    property Action: DNDataRowAction read get_Action;
  end;

  TDNDataRowChangeEventArgs = class(TDNGenericImport<DNDataRowChangeEventArgsClass, DNDataRowChangeEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNDataTableClearEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{3FAA835A-6B33-5E6E-9249-759E8E8179BA}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataTableClearEventArgs" />
    ///  class.</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  whose rows are being cleared.</param>
    {class} function init(dataTable: DNDataTable): DNDataTableClearEventArgs;

  end;

  ///<summary>Provides data for the <see cref="M:System.Data.DataTable.Clear" />
  ///  method.</summary>
  [DNTypeName('System.Data.DataTableClearEventArgs')]
  DNDataTableClearEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{1C828E83-1DA2-3ED3-A238-E68B1B66E5CF}']
  { getters & setters } 

    function get_Table: DNDataTable;
    function get_TableName: string;
    function get_TableNamespace: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the table whose rows are being cleared.</summary>
    ///<returns>The <see cref="T:System.Data.DataTable" />
    ///  whose rows are being cleared.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>Gets the table name whose rows are being cleared.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  indicating the table name.</returns>
    property TableName: string read get_TableName;
    ///<summary>Gets the namespace of the table whose rows are being cleared.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  indicating the namespace name.</returns>
    property TableNamespace: string read get_TableNamespace;
  end;

  TDNDataTableClearEventArgs = class(TDNGenericImport<DNDataTableClearEventArgsClass, DNDataTableClearEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNDataTableNewRowEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{DD55550D-4643-5E2A-BFA7-33BDA30D720F}']
  { constructors } 

    ///<summary>Initializes a new instance of <see cref="T:System.Data.DataTableNewRowEventArgs" />
    ///  .</summary>
    ///  <param name="dataRow">The <see cref="T:System.Data.DataRow" />
    ///  being added.</param>
    {class} function init(dataRow: DNDataRow): DNDataTableNewRowEventArgs;

  end;

  ///<summary>Provides data for the <see cref="M:System.Data.DataTable.NewRow" />
  ///  method.</summary>
  [DNTypeName('System.Data.DataTableNewRowEventArgs')]
  DNDataTableNewRowEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{8DA50CAC-EA82-38BE-8041-D721195CBBAB}']
  { getters & setters } 

    function get_Row: DNDataRow;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the row that is being added.</summary>
    ///<returns>The <see cref="T:System.Data.DataRow" />
    ///  that is being added. </returns>
    property Row: DNDataRow read get_Row;
  end;

  TDNDataTableNewRowEventArgs = class(TDNGenericImport<DNDataTableNewRowEventArgsClass, DNDataTableNewRowEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNFillErrorEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{A7082645-C257-58BC-8E25-4B2074DA6356}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.FillErrorEventArgs" />
    ///  class.</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  being updated. </param>
    ///  <param name="values">The values for the row being updated. </param>
    {class} function init(dataTable: DNDataTable; values: TArray<DDN.mscorlib.DNObject>): DNFillErrorEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Data.Common.DataAdapter.FillError" />
  ///  event of a <see cref="T:System.Data.Common.DbDataAdapter" />
  ///  .</summary>
  [DNTypeName('System.Data.FillErrorEventArgs')]
  DNFillErrorEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{23695D73-5ED9-3965-90A8-66488560DF52}']
  { getters & setters } 

    function get_Continue: Boolean;
    procedure set_Continue(value: Boolean);
    function get_DataTable: DNDataTable;
    function get_Errors: DDN.mscorlib.DNException;
    procedure set_Errors(value: DDN.mscorlib.DNException);
    function get_Values: TArray<DDN.mscorlib.DNObject>;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether to continue the fill operation despite the error.</summary>
    ///<returns><see langword="true" />
    ///  if the fill operation should continue; otherwise, <see langword="false" />
    ///  .</returns>
    property &Continue: Boolean read get_Continue write set_Continue;
    ///<summary>Gets the <see cref="T:System.Data.DataTable" />
    ///  being updated when the error occurred.</summary>
    ///<returns>The <see cref="T:System.Data.DataTable" />
    ///  being updated.</returns>
    property DataTable: DNDataTable read get_DataTable;
    ///<summary>Gets the errors being handled.</summary>
    ///<returns>The errors being handled.</returns>
    property Errors: DDN.mscorlib.DNException read get_Errors write set_Errors;
    ///<summary>Gets the values for the row being updated when the error occurred.</summary>
    ///<returns>The values for the row being updated.</returns>
    property Values: TArray<DDN.mscorlib.DNObject> read get_Values;
  end;

  TDNFillErrorEventArgs = class(TDNGenericImport<DNFillErrorEventArgsClass, DNFillErrorEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNMergeFailedEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{609582C1-8731-5867-89A8-F23BF6C3B576}']
  { constructors } 

    ///<summary>Initializes a new instance of a <see cref="T:System.Data.MergeFailedEventArgs" />
    ///  class with the <see cref="T:System.Data.DataTable" />
    ///  and a description of the merge conflict.</summary>
    ///  <param name="table">The <see cref="T:System.Data.DataTable" />
    ///  object. </param>
    ///  <param name="conflict">A description of the merge conflict. </param>
    {class} function init(table: DNDataTable; conflict: string): DNMergeFailedEventArgs;

  end;

  ///<summary>Occurs when a target and source <see langword="DataRow" />
  ///  have the same primary key value, and the <see cref="P:System.Data.DataSet.EnforceConstraints" />
  ///  property is set to true.</summary>
  [DNTypeName('System.Data.MergeFailedEventArgs')]
  DNMergeFailedEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{08B4397F-E667-341F-8B61-6303224951F2}']
  { getters & setters } 

    function get_Table: DNDataTable;
    function get_Conflict: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Returns the <see cref="T:System.Data.DataTable" />
    ///  object.</summary>
    ///<returns>The <see cref="T:System.Data.DataTable" />
    ///  object.</returns>
    property Table: DNDataTable read get_Table;
    ///<summary>Returns a description of the merge conflict.</summary>
    ///<returns>A description of the merge conflict.</returns>
    property Conflict: string read get_Conflict;
  end;

  TDNMergeFailedEventArgs = class(TDNGenericImport<DNMergeFailedEventArgsClass, DNMergeFailedEventArgs>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcInfoMessageEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{160DA715-EFFD-5C56-B980-D7EAC9039620}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Data.Odbc.OdbcConnection.InfoMessage" />
  ///  event.</summary>
  [DNTypeName('System.Data.Odbc.OdbcInfoMessageEventArgs')]
  DNOdbcInfoMessageEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{278F49B4-1D34-35F9-B853-AD9E5C0693CF}']
  { getters & setters } 

    function get_Errors: DNOdbcErrorCollection;
    function get_Message: string;

  { methods } 

    ///<summary>Retrieves a string representation of the <see cref="E:System.Data.Odbc.OdbcConnection.InfoMessage" />
    ///  event.</summary>
    ///<returns>A string representing the <see cref="E:System.Data.Odbc.OdbcConnection.InfoMessage" />
    ///  event.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the collection of warnings sent from the data source.</summary>
    ///<returns>The collection of warnings sent from the data source.</returns>
    property Errors: DNOdbcErrorCollection read get_Errors;
    ///<summary>Gets the full text of the error sent from the database.</summary>
    ///<returns>The full text of the error.</returns>
    property Message: string read get_Message;
  end;

  TDNOdbcInfoMessageEventArgs = class(TDNGenericImport<DNOdbcInfoMessageEventArgsClass, DNOdbcInfoMessageEventArgs>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbInfoMessageEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{7BA4AD22-7E73-5E3E-9A5D-0FEC17EACC17}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Data.OleDb.OleDbConnection.InfoMessage" />
  ///  event. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.OleDb.OleDbInfoMessageEventArgs')]
  DNOleDbInfoMessageEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{F7FCAC61-B247-3EA0-A99E-9761E4FB85F5}']
  { getters & setters } 

    function get_ErrorCode: Int32;
    function get_Errors: DNOleDbErrorCollection;
    function get_Message: string;
    function get_Source: string;

  { methods } 

    ///<summary>Retrieves a string representation of the <see cref="E:System.Data.OleDb.OleDbConnection.InfoMessage" />
    ///  event.</summary>
    ///<returns>A string representing the <see cref="E:System.Data.OleDb.OleDbConnection.InfoMessage" />
    ///  event.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the HRESULT following the ANSI SQL standard for the database.</summary>
    ///<returns>The HRESULT, which identifies the source of the error, if the error can be issued from more than one place.</returns>
    property ErrorCode: Int32 read get_ErrorCode;
    ///<summary>Gets the collection of warnings sent from the data source.</summary>
    ///<returns>The collection of warnings sent from the data source.</returns>
    property Errors: DNOleDbErrorCollection read get_Errors;
    ///<summary>Gets the full text of the error sent from the data source.</summary>
    ///<returns>The full text of the error.</returns>
    property Message: string read get_Message;
    ///<summary>Gets the name of the object that generated the error.</summary>
    ///<returns>The name of the object that generated the error.</returns>
    property Source: string read get_Source;
  end;

  TDNOleDbInfoMessageEventArgs = class(TDNGenericImport<DNOleDbInfoMessageEventArgsClass, DNOleDbInfoMessageEventArgs>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlInfoMessageEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{481F2F6B-6013-5B28-B3AF-FBDF5112B463}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
  ///  event.</summary>
  [DNTypeName('System.Data.SqlClient.SqlInfoMessageEventArgs')]
  DNSqlInfoMessageEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{BD38BC5F-E6CA-35CF-9BCE-087D6285E1A5}']
  { getters & setters } 

    function get_Errors: DNSqlErrorCollection;
    function get_Message: string;
    function get_Source: string;

  { methods } 

    ///<summary>Retrieves a string representation of the <see cref="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
    ///  event.</summary>
    ///<returns>A string representing the <see cref="E:System.Data.SqlClient.SqlConnection.InfoMessage" />
    ///  event.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the collection of warnings sent from the server.</summary>
    ///<returns>The collection of warnings sent from the server.</returns>
    property Errors: DNSqlErrorCollection read get_Errors;
    ///<summary>Gets the full text of the error sent from the database.</summary>
    ///<returns>The full text of the error.</returns>
    property Message: string read get_Message;
    ///<summary>Gets the name of the object that generated the error.</summary>
    ///<returns>The name of the object that generated the error.</returns>
    property Source: string read get_Source;
  end;

  TDNSqlInfoMessageEventArgs = class(TDNGenericImport<DNSqlInfoMessageEventArgsClass, DNSqlInfoMessageEventArgs>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlNotificationEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{A4BD358D-CFDA-55A3-B654-2D53532E78B5}']
  { constructors } 

    ///<summary>Creates a new instance of the <see cref="T:System.Data.SqlClient.SqlNotificationEventArgs" />
    ///  object. </summary>
    ///  <param name="type"><see cref="T:System.Data.SqlClient.SqlNotificationType" />
    ///  value that indicates whether this notification is generated because of an actual change, or by the subscription. </param>
    ///  <param name="info"><see cref="T:System.Data.SqlClient.SqlNotificationInfo" />
    ///  value that indicates the reason for the notification event. This may occur because the data in the store actually changed, or the notification became invalid (for example, it timed out). </param>
    ///  <param name="source"><see cref="T:System.Data.SqlClient.SqlNotificationSource" />
    ///  value that indicates the source that generated the notification. </param>
    {class} function init(&type: DNSqlNotificationType; info: DNSqlNotificationInfo; source: DNSqlNotificationSource): DNSqlNotificationEventArgs;

  end;

  ///<summary>Represents the set of arguments passed to the notification event handler.</summary>
  [DNTypeName('System.Data.SqlClient.SqlNotificationEventArgs')]
  DNSqlNotificationEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{EA5B7613-CB34-3120-AC57-58124910F1A9}']
  { getters & setters } 

    function get_Type: DNSqlNotificationType;
    function get_Info: DNSqlNotificationInfo;
    function get_Source: DNSqlNotificationSource;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates whether this notification is generated because of an actual change, or by the subscription.</summary>
    ///<returns>A value indicating whether the notification was generated by a change or a subscription.</returns>
    property &Type: DNSqlNotificationType read get_Type;
    ///<summary>Gets a value that indicates the reason for the notification event, such as a row in the database being modified or a table being truncated.</summary>
    ///<returns>The notification event reason.</returns>
    property Info: DNSqlNotificationInfo read get_Info;
    ///<summary>Gets a value that indicates the source that generated the notification, such as a change to the query data or the database’s state.</summary>
    ///<returns>The source of the notification.</returns>
    property Source: DNSqlNotificationSource read get_Source;
  end;

  TDNSqlNotificationEventArgs = class(TDNGenericImport<DNSqlNotificationEventArgsClass, DNSqlNotificationEventArgs>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlRowsCopiedEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{5B49A0E8-C46B-52FD-ADEE-583B28D5E1CA}']
  { constructors } 

    ///<summary>Creates a new instance of the <see cref="T:System.Data.SqlClient.SqlRowsCopiedEventArgs" />
    ///  object.</summary>
    ///  <param name="rowsCopied">An <see cref="T:System.Int64" />
    ///  that indicates the number of rows copied during the current bulk copy operation. </param>
    {class} function init(rowsCopied: Int64): DNSqlRowsCopiedEventArgs;

  end;

  ///<summary>Represents the set of arguments passed to the <see cref="T:System.Data.SqlClient.SqlRowsCopiedEventHandler" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlClient.SqlRowsCopiedEventArgs')]
  DNSqlRowsCopiedEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{C6D8CE5F-556F-36DF-845D-AFA25B58F2A5}']
  { getters & setters } 

    function get_Abort: Boolean;
    procedure set_Abort(value: Boolean);
    function get_RowsCopied: Int64;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that indicates whether the bulk copy operation should be aborted.</summary>
    ///<returns><see langword="true" />
    ///  if the bulk copy operation should be aborted; otherwise <see langword="false" />
    ///  .</returns>
    property &Abort: Boolean read get_Abort write set_Abort;
    ///<summary>Gets a value that returns the number of rows copied during the current bulk copy operation.</summary>
    ///<returns><see langword="int" />
    ///  that returns the number of rows copied.</returns>
    property RowsCopied: Int64 read get_RowsCopied;
  end;

  TDNSqlRowsCopiedEventArgs = class(TDNGenericImport<DNSqlRowsCopiedEventArgsClass, DNSqlRowsCopiedEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNStateChangeEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{62F1B9D0-E4D8-5961-A5C4-37DC95CA1F4F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.StateChangeEventArgs" />
    ///  class, when given the original state and the current state of the object.</summary>
    ///  <param name="originalState">One of the <see cref="T:System.Data.ConnectionState" />
    ///  values. </param>
    ///  <param name="currentState">One of the <see cref="T:System.Data.ConnectionState" />
    ///  values. </param>
    {class} function init(originalState: DNConnectionState; currentState: DNConnectionState): DNStateChangeEventArgs;

  end;

  ///<summary>Provides data for the state change event of a .NET Framework data provider.</summary>
  [DNTypeName('System.Data.StateChangeEventArgs')]
  DNStateChangeEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{1579DF95-26A0-392F-9B07-AFA8F2EC8639}']
  { getters & setters } 

    function get_CurrentState: DNConnectionState;
    function get_OriginalState: DNConnectionState;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the new state of the connection. The connection object will be in the new state already when the event is fired.</summary>
    ///<returns>One of the <see cref="T:System.Data.ConnectionState" />
    ///  values.</returns>
    property CurrentState: DNConnectionState read get_CurrentState;
    ///<summary>Gets the original state of the connection.</summary>
    ///<returns>One of the <see cref="T:System.Data.ConnectionState" />
    ///  values.</returns>
    property OriginalState: DNConnectionState read get_OriginalState;
  end;

  TDNStateChangeEventArgs = class(TDNGenericImport<DNStateChangeEventArgsClass, DNStateChangeEventArgs>) end;

  //-------------namespace: System.Data----------------
  DNStatementCompletedEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{8AA5531F-E032-59BE-B470-0E1D4EC9BB32}']
  { constructors } 

    ///<summary>Creates a new instance of the <see cref="T:System.Data.StatementCompletedEventArgs" />
    ///  class.</summary>
    ///  <param name="recordCount">Indicates the number of rows affected by the statement that caused the <see cref="E:System.Data.SqlClient.SqlCommand.StatementCompleted" />
    ///  event to occur.</param>
    {class} function init(recordCount: Int32): DNStatementCompletedEventArgs;

  end;

  ///<summary>Provides additional information for the <see cref="E:System.Data.SqlClient.SqlCommand.StatementCompleted" />
  ///  event.</summary>
  [DNTypeName('System.Data.StatementCompletedEventArgs')]
  DNStatementCompletedEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{965D4C7C-4A5F-31D4-BBE7-8700B9D563B7}']
  { getters & setters } 

    function get_RecordCount: Int32;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Indicates the number of rows affected by the statement that caused the <see cref="E:System.Data.SqlClient.SqlCommand.StatementCompleted" />
    ///  event to occur.</summary>
    ///<returns>The number of rows affected.</returns>
    property RecordCount: Int32 read get_RecordCount;
  end;

  TDNStatementCompletedEventArgs = class(TDNGenericImport<DNStatementCompletedEventArgsClass, DNStatementCompletedEventArgs>) end;

  //-------------namespace: Microsoft.SqlServer.Server----------------
  DNInvalidUdtExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{EC111D83-C8E9-5C18-A193-CCDE6188E558}']
  end;

  ///<summary>Thrown when SQL Server or the ADO.NET <see cref="N:System.Data.SqlClient" />
  ///  provider detects an invalid user-defined type (UDT). </summary>
  [DNTypeName('Microsoft.SqlServer.Server.InvalidUdtException')]
  DNInvalidUdtException = interface(DDN.mscorlib.DNSystemException)
  ['{5E0FFDED-B506-31B9-9323-C6FDDD7663E0}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see cref="T:Microsoft.SqlServer.Server.InvalidUdtException" />
    ///  properties into the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  class for the given <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  .</summary>
    ///  <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object.</param>
    procedure GetObjectData(si: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInvalidUdtException = class(TDNGenericImport<DNInvalidUdtExceptionClass, DNInvalidUdtException>) end;

  //-------------namespace: System.Data----------------
  DNDataExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{DCA79D6D-7247-5D5F-8C3F-00AEE99AFCB0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataException" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNDataException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNDataException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataException" />
    ///  class with the specified string and inner exception.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    ///  <param name="innerException">A reference to an inner exception. </param>
    {class} function init(s: string; innerException: DDN.mscorlib.DNException): DNDataException; overload;

  end;

  ///<summary>Represents the exception that is thrown when errors are generated using ADO.NET components.</summary>
  [DNTypeName('System.Data.DataException')]
  DNDataException = interface(DDN.mscorlib.DNSystemException)
  ['{95332F7A-E0C0-3F4C-B43E-37A649E5D82F}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNDataException = class(TDNGenericImport<DNDataExceptionClass, DNDataException>) end;

  //-------------namespace: System.Data----------------
  DNConstraintExceptionClass = interface(DNDataExceptionClass)
  ['{B4AE4F67-FBE7-59F6-93E7-88493B8EEFE8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ConstraintException" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNConstraintException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ConstraintException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNConstraintException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ConstraintException" />
    ///  class using the specified string and inner exception.</summary>
    ///  <param name="message">The string to display when the exception is thrown. </param>
    ///  <param name="innerException">Gets the <see langword="Exception" />
    ///  instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNConstraintException; overload;

  end;

  ///<summary>Represents the exception that is thrown when attempting an action that violates a constraint.</summary>
  [DNTypeName('System.Data.ConstraintException')]
  DNConstraintException = interface(DNDataException)
  ['{4F5DB157-1B87-3BFA-A646-EA9626CC305B}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNConstraintException = class(TDNGenericImport<DNConstraintExceptionClass, DNConstraintException>) end;

  //-------------namespace: System.Data----------------
  DNDeletedRowInaccessibleExceptionClass = interface(DNDataExceptionClass)
  ['{FF807492-9CA0-5209-8CC7-79286D0E9B36}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DeletedRowInaccessibleException" />
    ///  class.</summary>
    {class} function init: DNDeletedRowInaccessibleException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DeletedRowInaccessibleException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNDeletedRowInaccessibleException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DeletedRowInaccessibleException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNDeletedRowInaccessibleException; overload;

  end;

  ///<summary>Represents the exception that is thrown when an action is tried on a <see cref="T:System.Data.DataRow" />
  ///  that has been deleted.</summary>
  [DNTypeName('System.Data.DeletedRowInaccessibleException')]
  DNDeletedRowInaccessibleException = interface(DNDataException)
  ['{EEAF5688-A1A4-3A06-9BD4-5D2CE72925A1}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNDeletedRowInaccessibleException = class(TDNGenericImport<DNDeletedRowInaccessibleExceptionClass, DNDeletedRowInaccessibleException>) end;

  //-------------namespace: System.Data----------------
  DNDuplicateNameExceptionClass = interface(DNDataExceptionClass)
  ['{1F635599-B4F7-560A-BD82-9E3764926E59}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DuplicateNameException" />
    ///  class.</summary>
    {class} function init: DNDuplicateNameException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DuplicateNameException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNDuplicateNameException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DuplicateNameException" />
    ///  class with the specified string and exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNDuplicateNameException; overload;

  end;

  ///<summary>Represents the exception that is thrown when a duplicate database object name is encountered during an add operation in a <see cref="T:System.Data.DataSet" />
  ///  -related object.</summary>
  [DNTypeName('System.Data.DuplicateNameException')]
  DNDuplicateNameException = interface(DNDataException)
  ['{35B3B69B-F044-38A4-B605-C7C0A305B5BB}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNDuplicateNameException = class(TDNGenericImport<DNDuplicateNameExceptionClass, DNDuplicateNameException>) end;

  //-------------namespace: System.Data----------------
  DNInRowChangingEventExceptionClass = interface(DNDataExceptionClass)
  ['{7E614671-D11E-5D8A-BE1F-07A03D9B1F7D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InRowChangingEventException" />
    ///  class.</summary>
    {class} function init: DNInRowChangingEventException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InRowChangingEventException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNInRowChangingEventException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InRowChangingEventException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNInRowChangingEventException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you call the <see cref="M:System.Data.DataRow.EndEdit" />
  ///  method within the <see cref="E:System.Data.DataTable.RowChanging" />
  ///  event.</summary>
  [DNTypeName('System.Data.InRowChangingEventException')]
  DNInRowChangingEventException = interface(DNDataException)
  ['{10A5490A-C1C0-3E1F-A5F9-DB5B1277EA9D}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInRowChangingEventException = class(TDNGenericImport<DNInRowChangingEventExceptionClass, DNInRowChangingEventException>) end;

  //-------------namespace: System.Data----------------
  DNInvalidConstraintExceptionClass = interface(DNDataExceptionClass)
  ['{19521912-F8E0-5C32-888E-55944DA4A376}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InvalidConstraintException" />
    ///  class.</summary>
    {class} function init: DNInvalidConstraintException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InvalidConstraintException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNInvalidConstraintException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InvalidConstraintException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNInvalidConstraintException; overload;

  end;

  ///<summary>Represents the exception that is thrown when incorrectly trying to create or access a relation.</summary>
  [DNTypeName('System.Data.InvalidConstraintException')]
  DNInvalidConstraintException = interface(DNDataException)
  ['{E5C5CFB3-1213-3B38-9C87-64C614F3F121}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInvalidConstraintException = class(TDNGenericImport<DNInvalidConstraintExceptionClass, DNInvalidConstraintException>) end;

  //-------------namespace: System.Data----------------
  DNInvalidExpressionExceptionClass = interface(DNDataExceptionClass)
  ['{FF0025DA-14BE-5F10-B9C5-14DD08895A97}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InvalidExpressionException" />
    ///  class.</summary>
    {class} function init: DNInvalidExpressionException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InvalidExpressionException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNInvalidExpressionException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.InvalidExpressionException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNInvalidExpressionException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you try to add a <see cref="T:System.Data.DataColumn" />
  ///  that contains an invalid <see cref="P:System.Data.DataColumn.Expression" />
  ///  to a <see cref="T:System.Data.DataColumnCollection" />
  ///  .</summary>
  [DNTypeName('System.Data.InvalidExpressionException')]
  DNInvalidExpressionException = interface(DNDataException)
  ['{E3D6CB57-9EE1-32B6-8A2B-AB50D1936FD2}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInvalidExpressionException = class(TDNGenericImport<DNInvalidExpressionExceptionClass, DNInvalidExpressionException>) end;

  //-------------namespace: System.Data----------------
  DNEvaluateExceptionClass = interface(DNInvalidExpressionExceptionClass)
  ['{87E2CD6F-5A80-5E67-B821-C60776F58FFE}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.EvaluateException" />
    ///  class.</summary>
    {class} function init: DNEvaluateException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.EvaluateException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNEvaluateException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.EvaluateException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNEvaluateException; overload;

  end;

  ///<summary>Represents the exception that is thrown when the <see cref="P:System.Data.DataColumn.Expression" />
  ///  property of a <see cref="T:System.Data.DataColumn" />
  ///  cannot be evaluated.</summary>
  [DNTypeName('System.Data.EvaluateException')]
  DNEvaluateException = interface(DNInvalidExpressionException)
  ['{62788F22-F1CE-3059-8384-7AC4AFCF6BDA}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNEvaluateException = class(TDNGenericImport<DNEvaluateExceptionClass, DNEvaluateException>) end;

  //-------------namespace: System.Data----------------
  DNSyntaxErrorExceptionClass = interface(DNInvalidExpressionExceptionClass)
  ['{BA387326-FAE3-593B-91D4-39FD83844E69}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SyntaxErrorException" />
    ///  class.</summary>
    {class} function init: DNSyntaxErrorException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SyntaxErrorException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNSyntaxErrorException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SyntaxErrorException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNSyntaxErrorException; overload;

  end;

  ///<summary>Represents the exception that is thrown when the <see cref="P:System.Data.DataColumn.Expression" />
  ///  property of a <see cref="T:System.Data.DataColumn" />
  ///  contains a syntax error.</summary>
  [DNTypeName('System.Data.SyntaxErrorException')]
  DNSyntaxErrorException = interface(DNInvalidExpressionException)
  ['{0D4EEFDA-E8FC-392D-A2CC-0EC26C4A25F4}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNSyntaxErrorException = class(TDNGenericImport<DNSyntaxErrorExceptionClass, DNSyntaxErrorException>) end;

  //-------------namespace: System.Data----------------
  DNMissingPrimaryKeyExceptionClass = interface(DNDataExceptionClass)
  ['{13DC3B41-8488-56C1-988A-91F94E2C4F3B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.MissingPrimaryKeyException" />
    ///  class.</summary>
    {class} function init: DNMissingPrimaryKeyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.MissingPrimaryKeyException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNMissingPrimaryKeyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.MissingPrimaryKeyException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNMissingPrimaryKeyException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you try to access a row in a table that has no primary key.</summary>
  [DNTypeName('System.Data.MissingPrimaryKeyException')]
  DNMissingPrimaryKeyException = interface(DNDataException)
  ['{28292C62-2A34-3475-9254-2C9D16607AE0}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNMissingPrimaryKeyException = class(TDNGenericImport<DNMissingPrimaryKeyExceptionClass, DNMissingPrimaryKeyException>) end;

  //-------------namespace: System.Data----------------
  DNNoNullAllowedExceptionClass = interface(DNDataExceptionClass)
  ['{2F4AC106-B26B-5614-9694-2B2B43ECDB59}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.NoNullAllowedException" />
    ///  class.</summary>
    {class} function init: DNNoNullAllowedException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.NoNullAllowedException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNNoNullAllowedException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.NoNullAllowedException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNNoNullAllowedException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you try to insert a null value into a column where <see cref="P:System.Data.DataColumn.AllowDBNull" />
  ///  is set to <see langword="false" />
  ///  .</summary>
  [DNTypeName('System.Data.NoNullAllowedException')]
  DNNoNullAllowedException = interface(DNDataException)
  ['{F44D3CD4-B00A-35CB-8517-48B88157FE44}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNNoNullAllowedException = class(TDNGenericImport<DNNoNullAllowedExceptionClass, DNNoNullAllowedException>) end;

  //-------------namespace: System.Data----------------
  DNReadOnlyExceptionClass = interface(DNDataExceptionClass)
  ['{BC446F6F-D209-5BD7-BE03-CA2A74A86A82}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ReadOnlyException" />
    ///  class.</summary>
    {class} function init: DNReadOnlyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ReadOnlyException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNReadOnlyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.ReadOnlyException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNReadOnlyException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you try to change the value of a read-only column.</summary>
  [DNTypeName('System.Data.ReadOnlyException')]
  DNReadOnlyException = interface(DNDataException)
  ['{D41F90F6-251A-3A54-B633-EBE4D14D6EA6}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNReadOnlyException = class(TDNGenericImport<DNReadOnlyExceptionClass, DNReadOnlyException>) end;

  //-------------namespace: System.Data----------------
  DNRowNotInTableExceptionClass = interface(DNDataExceptionClass)
  ['{E0C567B8-D8B1-5AC9-BAB8-FC9808BE68F2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.RowNotInTableException" />
    ///  class.</summary>
    {class} function init: DNRowNotInTableException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.RowNotInTableException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNRowNotInTableException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.RowNotInTableException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNRowNotInTableException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you try to perform an operation on a <see cref="T:System.Data.DataRow" />
  ///  that is not in a <see cref="T:System.Data.DataTable" />
  ///  .</summary>
  [DNTypeName('System.Data.RowNotInTableException')]
  DNRowNotInTableException = interface(DNDataException)
  ['{644C9CEC-12AD-373D-8F72-A407B4F8FF15}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNRowNotInTableException = class(TDNGenericImport<DNRowNotInTableExceptionClass, DNRowNotInTableException>) end;

  //-------------namespace: System.Data----------------
  DNStrongTypingExceptionClass = interface(DNDataExceptionClass)
  ['{6379B64C-50EE-5DF4-9902-EF0D512EC335}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.StrongTypingException" />
    ///  class.</summary>
    {class} function init: DNStrongTypingException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.StrongTypingException" />
    ///  class with the specified string.</summary>
    ///  <param name="message">The string to display when the exception is thrown. </param>
    {class} function init(message: string): DNStrongTypingException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.StrongTypingException" />
    ///  class with the specified string and inner exception.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    ///  <param name="innerException">A reference to an inner exception. </param>
    {class} function init(s: string; innerException: DDN.mscorlib.DNException): DNStrongTypingException; overload;

  end;

  ///<summary>The exception that is thrown by a strongly typed <see cref="T:System.Data.DataSet" />
  ///  when the user accesses a <see langword="DBNull" />
  ///  value.</summary>
  [DNTypeName('System.Data.StrongTypingException')]
  DNStrongTypingException = interface(DNDataException)
  ['{0344E365-016C-346C-B029-84E053C98510}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNStrongTypingException = class(TDNGenericImport<DNStrongTypingExceptionClass, DNStrongTypingException>) end;

  //-------------namespace: System.Data----------------
  DNTypedDataSetGeneratorExceptionClass = interface(DNDataExceptionClass)
  ['{5E7A7584-B217-57B5-A3C9-83056183DA24}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.TypedDataSetGeneratorException" />
    ///  class.</summary>
    {class} function init: DNTypedDataSetGeneratorException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.TypedDataSetGeneratorException" />
    ///  class with the specified string. </summary>
    ///  <param name="message">The string to display when the exception is thrown.</param>
    {class} function init(message: string): DNTypedDataSetGeneratorException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.TypedDataSetGeneratorException" />
    ///  class with the specified string and inner exception. </summary>
    ///  <param name="message">The string to display when the exception is thrown.</param>
    ///  <param name="innerException">A reference to an inner exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNTypedDataSetGeneratorException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.TypedDataSetGeneratorException" />
    ///  class.</summary>
    ///  <param name="list"><see cref="T:System.Collections.ArrayList" />
    ///  object containing a dynamic list of exceptions. </param>
    {class} function init(list: DDN.mscorlib.DNArrayList): DNTypedDataSetGeneratorException; overload;

  end;

  ///<summary>The exception that is thrown when a name conflict occurs while generating a strongly typed <see cref="T:System.Data.DataSet" />
  ///  . </summary>
  [DNTypeName('System.Data.TypedDataSetGeneratorException')]
  DNTypedDataSetGeneratorException = interface(DNDataException)
  ['{7368AA2F-95D3-3E49-88D8-4566C0020FB0}']
  { getters & setters } 

    function get_ErrorList: DDN.mscorlib.DNArrayList;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Implements the <see langword="ISerializable" />
    ///  interface and returns the data needed to serialize the <see cref="T:System.Data.TypedDataSetGeneratorException" />
    ///  object.</summary>
    ///  <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object. </param>
    ///  <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  structure. </param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a dynamic list of generated errors.</summary>
    ///<returns><see cref="T:System.Collections.ArrayList" />
    ///  object.</returns>
    property ErrorList: DDN.mscorlib.DNArrayList read get_ErrorList;
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNTypedDataSetGeneratorException = class(TDNGenericImport<DNTypedDataSetGeneratorExceptionClass, DNTypedDataSetGeneratorException>) end;

  //-------------namespace: System.Data----------------
  DNVersionNotFoundExceptionClass = interface(DNDataExceptionClass)
  ['{08A44480-0613-50F6-BF52-B08F2A39AC98}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.VersionNotFoundException" />
    ///  class.</summary>
    {class} function init: DNVersionNotFoundException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.VersionNotFoundException" />
    ///  class with the specified string.</summary>
    ///  <param name="s">The string to display when the exception is thrown. </param>
    {class} function init(s: string): DNVersionNotFoundException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.VersionNotFoundException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNVersionNotFoundException; overload;

  end;

  ///<summary>Represents the exception that is thrown when you try to return a version of a <see cref="T:System.Data.DataRow" />
  ///  that has been deleted.</summary>
  [DNTypeName('System.Data.VersionNotFoundException')]
  DNVersionNotFoundException = interface(DNDataException)
  ['{B5F91CF5-31D5-311B-A974-09AE28E1C261}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNVersionNotFoundException = class(TDNGenericImport<DNVersionNotFoundExceptionClass, DNVersionNotFoundException>) end;

  //-------------namespace: System.Data----------------
  DNDBConcurrencyExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{AC5878F3-9C4C-5BD5-A7F7-E3C39A9ED264}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DBConcurrencyException" />
    ///  class.</summary>
    {class} function init: DNDBConcurrencyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DBConcurrencyException" />
    ///  class.</summary>
    ///  <param name="message">The text string describing the details of the exception. </param>
    {class} function init(message: string): DNDBConcurrencyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DBConcurrencyException" />
    ///  class.</summary>
    ///  <param name="message">The text string describing the details of the exception. </param>
    ///  <param name="inner">A reference to an inner exception. </param>
    {class} function init(message: string; inner: DDN.mscorlib.DNException): DNDBConcurrencyException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DBConcurrencyException" />
    ///  class.</summary>
    ///  <param name="message">The error message that explains the reason for this exception.</param>
    ///  <param name="inner">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if no inner exception is specified.</param>
    ///  <param name="dataRows">An array containing the <see cref="T:System.Data.DataRow" />
    ///  objects whose update failure generated this exception.</param>
    {class} function init(message: string; inner: DDN.mscorlib.DNException; dataRows: TArray<DNDataRow>): DNDBConcurrencyException; overload;

  end;

  ///<summary>The exception that is thrown by the <see cref="T:System.Data.Common.DataAdapter" />
  ///  during an insert, update, or delete operation if the number of rows affected equals zero.</summary>
  [DNTypeName('System.Data.DBConcurrencyException')]
  DNDBConcurrencyException = interface(DDN.mscorlib.DNSystemException)
  ['{41AC822C-4053-3239-89CD-D09EAACBA9A9}']
  { getters & setters } 

    function get_Row: DNDataRow;
    procedure set_Row(value: DNDataRow);
    function get_RowCount: Int32;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Populates the aprcified serialization information object with the data needed to serialize the <see cref="T:System.Data.DBConcurrencyException" />
    ///  .</summary>
    ///  <param name="si">A <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  that holds the serialized data associated with the <see cref="T:System.Data.DBConcurrencyException" />
    ///  .</param>
    ///  <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DBConcurrencyException" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="info" />
    ///  parameter is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    procedure GetObjectData(si: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    ///<summary>Copies the <see cref="T:System.Data.DataRow" />
    ///  objects whose update failure generated this exception, to the specified array of <see cref="T:System.Data.DataRow" />
    ///  objects.</summary>
    ///  <param name="array">The one-dimensional array of <see cref="T:System.Data.DataRow" />
    ///  objects to copy the <see cref="T:System.Data.DataRow" />
    ///  objects into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>); overload;
    ///<summary>Copies the <see cref="T:System.Data.DataRow" />
    ///  objects whose update failure generated this exception, to the specified array of <see cref="T:System.Data.DataRow" />
    ///  objects, starting at the specified destination array index.</summary>
    ///  <param name="array">The one-dimensional array of <see cref="T:System.Data.DataRow" />
    ///  objects to copy the <see cref="T:System.Data.DataRow" />
    ///  objects into.</param>
    ///  <param name="arrayIndex">The destination array index to start copying into.</param>
    procedure CopyToRows(&array: TArray<DNDataRow>; arrayIndex: Int32); overload;
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the value of the <see cref="T:System.Data.DataRow" />
    ///  that generated the <see cref="T:System.Data.DBConcurrencyException" />
    ///  .</summary>
    ///<returns>The value of the <see cref="T:System.Data.DataRow" />
    ///  .</returns>
    property Row: DNDataRow read get_Row write set_Row;
    ///<summary>Gets the number of rows whose update failed, generating this exception.</summary>
    ///<returns>An integer containing a count of the number of rows whose update failed.</returns>
    property RowCount: Int32 read get_RowCount;
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNDBConcurrencyException = class(TDNGenericImport<DNDBConcurrencyExceptionClass, DNDBConcurrencyException>) end;

  //-------------namespace: System.Data----------------
  DNOperationAbortedExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{4A232F22-A431-5790-B874-8D332F3507B7}']
  end;

  ///<summary>This exception is thrown when an ongoing operation is aborted by the user. </summary>
  [DNTypeName('System.Data.OperationAbortedException')]
  DNOperationAbortedException = interface(DDN.mscorlib.DNSystemException)
  ['{73B53162-443B-3457-91A5-D7262A82BD92}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNOperationAbortedException = class(TDNGenericImport<DNOperationAbortedExceptionClass, DNOperationAbortedException>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlTypeExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{9625EB0F-3854-513A-9DEB-912C57E7FE35}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlTypeException" />
    ///  class.</summary>
    {class} function init: DNSqlTypeException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlTypeException" />
    ///  class with a specified error message.</summary>
    ///  <param name="message">The error message that explains the reason for the exception.</param>
    {class} function init(message: string): DNSqlTypeException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlTypeException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture. </param>
    ///  <param name="e">The exception that is the cause of the current exception. If the <paramref name="innerException" />
    ///  parameter is not <see langword="null" />
    ///  , the current exception is raised in a <see langword="catch" />
    ///  block that handles the inner exception. </param>
    {class} function init(message: string; e: DDN.mscorlib.DNException): DNSqlTypeException; overload;

  end;

  ///<summary>The base exception class for the <see cref="N:System.Data.SqlTypes" />
  ///  .</summary>
  [DNTypeName('System.Data.SqlTypes.SqlTypeException')]
  DNSqlTypeException = interface(DDN.mscorlib.DNSystemException)
  ['{7678DA29-71E3-3FBA-A739-077120A6869D}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNSqlTypeException = class(TDNGenericImport<DNSqlTypeExceptionClass, DNSqlTypeException>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlAlreadyFilledExceptionClass = interface(DNSqlTypeExceptionClass)
  ['{1EC3BB71-A3E3-59EF-B7E1-103E67845349}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlAlreadyFilledException" />
    ///  class.</summary>
    {class} function init: DNSqlAlreadyFilledException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlAlreadyFilledException" />
    ///  class.</summary>
    ///  <param name="message">The string to display when the exception is thrown.</param>
    {class} function init(message: string): DNSqlAlreadyFilledException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlAlreadyFilledException" />
    ///  class.</summary>
    ///  <param name="message">The string to display when the exception is thrown.</param>
    ///  <param name="e">A reference to an inner exception.</param>
    {class} function init(message: string; e: DDN.mscorlib.DNException): DNSqlAlreadyFilledException; overload;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.SqlAlreadyFilledException" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.SqlAlreadyFilledException')]
  DNSqlAlreadyFilledException = interface(DNSqlTypeException)
  ['{E9E525F9-1084-3C76-A305-D7C371D88327}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNSqlAlreadyFilledException = class(TDNGenericImport<DNSqlAlreadyFilledExceptionClass, DNSqlAlreadyFilledException>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlNotFilledExceptionClass = interface(DNSqlTypeExceptionClass)
  ['{55CE0BCE-3C74-5576-88B2-7774E1A6E73B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlNotFilledException" />
    ///  class.</summary>
    {class} function init: DNSqlNotFilledException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlNotFilledException" />
    ///  class.</summary>
    ///  <param name="message">The string to display when the exception is thrown.</param>
    {class} function init(message: string): DNSqlNotFilledException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlNotFilledException" />
    ///  class.</summary>
    ///  <param name="message">The string to display when the exception is thrown.</param>
    ///  <param name="e">A reference to an inner exception.</param>
    {class} function init(message: string; e: DDN.mscorlib.DNException): DNSqlNotFilledException; overload;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.SqlNotFilledException" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlNotFilledException')]
  DNSqlNotFilledException = interface(DNSqlTypeException)
  ['{72878FEE-1263-3C0F-93B9-022BBEF05490}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNSqlNotFilledException = class(TDNGenericImport<DNSqlNotFilledExceptionClass, DNSqlNotFilledException>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlNullValueExceptionClass = interface(DNSqlTypeExceptionClass)
  ['{4CEC667A-12E6-5029-9825-7D491314ABD6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlNullValueException" />
    ///  class with a system-supplied message that describes the error.</summary>
    {class} function init: DNSqlNullValueException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlNullValueException" />
    ///  class with a specified message that describes the error.</summary>
    ///  <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture.</param>
    {class} function init(message: string): DNSqlNullValueException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlNullValueException" />
    ///  class with a specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The message that describes the exception. The caller of this constructor is required to ensure that this string has been localized for the current system culture. </param>
    ///  <param name="e">The exception that is the cause of the current exception. If the <paramref name="innerException" />
    ///  parameter is not <see langword="null" />
    ///  , the current exception is raised in a <see langword="catch" />
    ///  block that handles the inner exception. </param>
    {class} function init(message: string; e: DDN.mscorlib.DNException): DNSqlNullValueException; overload;

  end;

  ///<summary>The exception that is thrown when the <see langword="Value" />
  ///  property of a <see cref="N:System.Data.SqlTypes" />
  ///  structure is set to null.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlNullValueException')]
  DNSqlNullValueException = interface(DNSqlTypeException)
  ['{13C65320-A71B-3473-860D-DFDEBCCE58A6}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNSqlNullValueException = class(TDNGenericImport<DNSqlNullValueExceptionClass, DNSqlNullValueException>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlTruncateExceptionClass = interface(DNSqlTypeExceptionClass)
  ['{213C7C6E-7316-50CE-80F5-F756A08A4FA2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlTruncateException" />
    ///  class.</summary>
    {class} function init: DNSqlTruncateException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlTruncateException" />
    ///  class with a specified error message.</summary>
    ///  <param name="message">The error message that explains the reason for the exception. </param>
    {class} function init(message: string): DNSqlTruncateException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlTruncateException" />
    ///  class with a specified error message and a reference to the <see cref="T:System.Exception" />
    ///  .</summary>
    ///  <param name="message">The error message that explains the reason for the exception. </param>
    ///  <param name="e">A reference to an inner <see cref="T:System.Exception" />
    ///  . </param>
    {class} function init(message: string; e: DDN.mscorlib.DNException): DNSqlTruncateException; overload;

  end;

  ///<summary>The exception that is thrown when you set a value into a <see cref="N:System.Data.SqlTypes" />
  ///  structure would truncate that value.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlTruncateException')]
  DNSqlTruncateException = interface(DNSqlTypeException)
  ['{03DD07B2-755B-3B9D-ADCE-6ABB51CAF504}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNSqlTruncateException = class(TDNGenericImport<DNSqlTruncateExceptionClass, DNSqlTruncateException>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbExceptionClass = interface(DDN.mscorlib.DNExternalExceptionClass)
  ['{6F0ACD2C-DDFC-5B6E-AFEF-087170AD944A}']
  end;

  ///<summary>The base class for all exceptions thrown on behalf of the data source.</summary>
  [DNTypeName('System.Data.Common.DbException')]
  DNDbException = interface(DDN.mscorlib.DNExternalException)
  ['{61AD995A-DA04-3139-BD92-150C4935184D}']
  { getters & setters } 

    function get_ErrorCode: Int32;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function ToString: string;
    function GetBaseException: DDN.mscorlib.DNException;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property ErrorCode: Int32 read get_ErrorCode;
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNDbException = class(TDNGenericImport<DNDbExceptionClass, DNDbException>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcExceptionClass = interface(DNDbExceptionClass)
  ['{6F22F2C1-7272-5F68-8728-2F33AB5FD7A4}']
  end;

  ///<summary>The exception that is generated when a warning or error is returned by an ODBC data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcException')]
  DNOdbcException = interface(DNDbException)
  ['{25963533-A5F8-3BE2-A6A8-952B0F856310}']
  { getters & setters } 

    function get_Errors: DNOdbcErrorCollection;
    function get_Source: string;
    function get_ErrorCode: Int32;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>This member overrides <see cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
    ///  .</summary>
    ///  <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  that holds the serialized object data about the exception being thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  that contains contextual information about the source or destination.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="si" />
    ///  parameter is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    procedure GetObjectData(si: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function ToString: string;
    function GetBaseException: DDN.mscorlib.DNException;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a collection of one or more <see cref="T:System.Data.Odbc.OdbcError" />
    ///  objects that give detailed information about exceptions generated by the .NET Framework Data Provider for ODBC.</summary>
    ///<returns>The collected instances of the <see cref="T:System.Data.Odbc.OdbcError" />
    ///  class.</returns>
    property Errors: DNOdbcErrorCollection read get_Errors;
    ///<summary>Gets the name of the ODBC driver that generated the error.</summary>
    ///<returns>The name of the ODBC driver that generated the error.</returns>
    property Source: string read get_Source;
    property ErrorCode: Int32 read get_ErrorCode;
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property HResult: Int32 read get_HResult;
  end;

  TDNOdbcException = class(TDNGenericImport<DNOdbcExceptionClass, DNOdbcException>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbExceptionClass = interface(DNDbExceptionClass)
  ['{D1BA5C2A-6D6C-5DA1-988A-438E0789CBC5}']
  end;

  ///<summary>The exception that is thrown when the underlying provider returns a warning or error for an OLE DB data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.OleDb.OleDbException')]
  DNOleDbException = interface(DNDbException)
  ['{7D375F63-68C8-3955-8A75-A69EE8E96A8D}']
  { getters & setters } 

    function get_ErrorCode: Int32;
    function get_Errors: DNOleDbErrorCollection;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>This member overrides <see cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
    ///  .</summary>
    ///  <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  that holds the serialized object data about the exception being thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  that contains contextual information about the source or destination.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="si" />
    ///  parameter is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    procedure GetObjectData(si: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function ToString: string;
    function GetBaseException: DDN.mscorlib.DNException;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the HRESULT of the error.</summary>
    ///<returns>The HRESULT of the error.</returns>
    property ErrorCode: Int32 read get_ErrorCode;
    ///<summary>Gets a collection of one or more <see cref="T:System.Data.OleDb.OleDbError" />
    ///  objects that give detailed information about exceptions generated by the .NET Framework Data Provider for OLE DB.</summary>
    ///<returns>The collected instances of the <see cref="T:System.Data.OleDb.OleDbError" />
    ///  class.</returns>
    property Errors: DNOleDbErrorCollection read get_Errors;
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNOleDbException = class(TDNGenericImport<DNOleDbExceptionClass, DNOleDbException>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlExceptionClass = interface(DNDbExceptionClass)
  ['{80A5A752-E801-5490-91C5-550B2386497C}']
  end;

  ///<summary>The exception that is thrown when SQL Server returns a warning or error. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.SqlClient.SqlException')]
  DNSqlException = interface(DNDbException)
  ['{B85AC0F9-3A9B-3DAE-B9DB-96F517A25B1A}']
  { getters & setters } 

    function get_Errors: DNSqlErrorCollection;
    function get_ClientConnectionId: DDN.mscorlib.DNGuid;
    function get_Class: Byte;
    function get_LineNumber: Int32;
    function get_Number: Int32;
    function get_Procedure: string;
    function get_Server: string;
    function get_State: Byte;
    function get_Source: string;
    function get_ErrorCode: Int32;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Returns a string that represents the current <see cref="T:System.Data.SqlClient.SqlException" />
    ///  object, and includes the client connection ID (for more information, see <see cref="P:System.Data.SqlClient.SqlException.ClientConnectionId" />
    ///  ).</summary>
    ///<returns>A string that represents the current <see cref="T:System.Data.SqlClient.SqlException" />
    ///  object.<see cref="T:System.String" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  with information about the exception.</summary>
    ///  <param name="si">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  that holds the serialized object data about the exception being thrown. </param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  that contains contextual information about the source or destination.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="si" />
    ///  parameter is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</exception>
    procedure GetObjectData(si: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a collection of one or more <see cref="T:System.Data.SqlClient.SqlError" />
    ///  objects that give detailed information about exceptions generated by the .NET Framework Data Provider for SQL Server.</summary>
    ///<returns>The collected instances of the <see cref="T:System.Data.SqlClient.SqlError" />
    ///  class.</returns>
    property Errors: DNSqlErrorCollection read get_Errors;
    ///<summary>Represents the client connection ID. For more information, see Data Tracing in ADO.NET.</summary>
    ///<returns>Returns the client connection ID.</returns>
    property ClientConnectionId: DDN.mscorlib.DNGuid read get_ClientConnectionId;
    ///<summary>Gets the severity level of the error returned from the .NET Framework Data Provider for SQL Server.</summary>
    ///<returns>A value from 1 to 25 that indicates the severity level of the error.</returns>
    property &Class: Byte read get_Class;
    ///<summary>Gets the line number within the Transact-SQL command batch or stored procedure that generated the error.</summary>
    ///<returns>The line number within the Transact-SQL command batch or stored procedure that generated the error.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets a number that identifies the type of error.</summary>
    ///<returns>The number that identifies the type of error.</returns>
    property Number: Int32 read get_Number;
    ///<summary>Gets the name of the stored procedure or remote procedure call (RPC) that generated the error.</summary>
    ///<returns>The name of the stored procedure or RPC.</returns>
    property &Procedure: string read get_Procedure;
    ///<summary>Gets the name of the computer that is running an instance of SQL Server that generated the error.</summary>
    ///<returns>The name of the computer running an instance of SQL Server.</returns>
    property Server: string read get_Server;
    ///<summary>Gets a numeric error code from SQL Server that represents an error, warning or "no data found" message. For more information about how to decode these values, see SQL Server Books Online.</summary>
    ///<returns>The number representing the error code.</returns>
    property State: Byte read get_State;
    ///<summary>Gets the name of the provider that generated the error.</summary>
    ///<returns>The name of the provider that generated the error.</returns>
    property Source: string read get_Source;
    property ErrorCode: Int32 read get_ErrorCode;
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property HResult: Int32 read get_HResult;
  end;

  TDNSqlException = class(TDNGenericImport<DNSqlExceptionClass, DNSqlException>) end;

  //-------------namespace: System.Data.Common----------------
  DNDataAdapterClass = interface(DNObjectClass)
  ['{50CE4E0C-5D83-5588-8AEA-C7B1C12699A5}']
  end;

  ///<summary>Represents a set of SQL commands and a database connection that are used to fill the <see cref="T:System.Data.DataSet" />
  ///  and update the data source.</summary>
  [DNTypeName('System.Data.Common.DataAdapter')]
  DNDataAdapter = interface(DNObject)
  ['{FF7BB96D-D9D5-35F0-BE9F-61B28F6B42D4}']
  { getters & setters } 

    function get_AcceptChangesDuringFill: Boolean;
    procedure set_AcceptChangesDuringFill(value: Boolean);
    function get_AcceptChangesDuringUpdate: Boolean;
    procedure set_AcceptChangesDuringUpdate(value: Boolean);
    function get_ContinueUpdateOnError: Boolean;
    procedure set_ContinueUpdateOnError(value: Boolean);
    function get_FillLoadOption: DNLoadOption;
    procedure set_FillLoadOption(value: DNLoadOption);
    function get_MissingMappingAction: DNMissingMappingAction;
    procedure set_MissingMappingAction(value: DNMissingMappingAction);
    function get_MissingSchemaAction: DNMissingSchemaAction;
    procedure set_MissingSchemaAction(value: DNMissingSchemaAction);
    function get_ReturnProviderSpecificTypes: Boolean;
    procedure set_ReturnProviderSpecificTypes(value: Boolean);
    function get_TableMappings: DNDataTableMappingCollection;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_FillError(value: DNFillErrorEventHandler);
    procedure remove_FillError(value: DNFillErrorEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Determines whether the <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
    ///  property should be persisted.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
    ///  property is persisted; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeAcceptChangesDuringFill: Boolean;
    ///<summary>Determines whether the <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" />
    ///  property should be persisted.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" />
    ///  property is persisted; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeFillLoadOption: Boolean;
    ///<summary>Resets <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" />
    ///  to its default state and causes <see cref="M:System.Data.Common.DataAdapter.Fill(System.Data.DataSet)" />
    ///  to honor <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
    ///  .</summary>
    procedure ResetFillLoadOption;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  to be filled with the schema from the data source. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  object that contains schema information returned from the data source.</returns>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType): TArray<DNDataTable>;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataSet: DNDataSet): Int32;
    ///<summary>Gets the parameters set by the user when executing an SQL SELECT statement.</summary>
    ///<returns>An array of <see cref="T:System.Data.IDataParameter" />
    ///  objects that contains the parameters set by the user.</returns>
    function GetFillParameters: TArray<DNIDataParameter>;
    ///<summary>Calls the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />
    ///  from a <see cref="T:System.Data.DataTable" />
    ///  named "Table."</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet): Int32;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called on a <see cref="T:System.Data.DataRow" />
    ///  after it is added to the <see cref="T:System.Data.DataTable" />
    ///  during any of the Fill operations.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called on the <see cref="T:System.Data.DataRow" />
    ///  ; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property AcceptChangesDuringFill: Boolean read get_AcceptChangesDuringFill write set_AcceptChangesDuringFill;
    ///<summary>Gets or sets whether <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called during a <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called during an <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />
    ///  ; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property AcceptChangesDuringUpdate: Boolean read get_AcceptChangesDuringUpdate write set_AcceptChangesDuringUpdate;
    ///<summary>Gets or sets a value that specifies whether to generate an exception when an error is encountered during a row update.</summary>
    ///<returns><see langword="true" />
    ///  to continue the update without generating an exception; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property ContinueUpdateOnError: Boolean read get_ContinueUpdateOnError write set_ContinueUpdateOnError;
    ///<summary>Gets or sets the <see cref="T:System.Data.LoadOption" />
    ///  that determines how the adapter fills the <see cref="T:System.Data.DataTable" />
    ///  from the <see cref="T:System.Data.Common.DbDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.LoadOption" />
    ///  value.</returns>
    property FillLoadOption: DNLoadOption read get_FillLoadOption write set_FillLoadOption;
    ///<summary>Determines the action to take when incoming data does not have a matching table or column.</summary>
    ///<returns>One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. The default is <see langword="Passthrough" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value set is not one of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </exception>
    property MissingMappingAction: DNMissingMappingAction read get_MissingMappingAction write set_MissingMappingAction;
    ///<summary>Determines the action to take when existing <see cref="T:System.Data.DataSet" />
    ///  schema does not match incoming data.</summary>
    ///<returns>One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. The default is <see langword="Add" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value set is not one of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </exception>
    property MissingSchemaAction: DNMissingSchemaAction read get_MissingSchemaAction write set_MissingSchemaAction;
    ///<summary>Gets or sets whether the <see langword="Fill" />
    ///  method should return provider-specific values or common CLS-compliant values.</summary>
    ///<returns><see langword="true" />
    ///  if the <see langword="Fill" />
    ///  method should return provider-specific values; otherwise <see langword="false" />
    ///  to return common CLS-compliant values.</returns>
    property ReturnProviderSpecificTypes: Boolean read get_ReturnProviderSpecificTypes write set_ReturnProviderSpecificTypes;
    ///<summary>Gets a collection that provides the master mapping between a source table and a <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A collection that provides the master mapping between the returned records and the <see cref="T:System.Data.DataSet" />
    ///  . The default value is an empty collection.</returns>
    property TableMappings: DNDataTableMappingCollection read get_TableMappings;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNDataAdapter = class(TDNGenericImport<DNDataAdapterClass, DNDataAdapter>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbDataAdapterClass = interface(DNDataAdapterClass)
  ['{E2F24866-4CE2-5DE5-92BB-5847AD6F39C2}']
  { static fields getter & setter } 

   function __fakeFieldGet_DefaultSourceTableName: string;

  { static fields } 

    ///<summary>The default name used by the <see cref="T:System.Data.Common.DataAdapter" />
    ///  object for table mappings.</summary>
    {class} property DefaultSourceTableName: string read __fakeFieldGet_DefaultSourceTableName;

  end;

  ///<summary>Aids implementation of the <see cref="T:System.Data.IDbDataAdapter" />
  ///  interface. Inheritors of <see cref="T:System.Data.Common.DbDataAdapter" />
  ///  implement a set of functions to provide strong typing, but inherit most of the functionality needed to fully implement a DataAdapter. </summary>
  [DNTypeName('System.Data.Common.DbDataAdapter')]
  DNDbDataAdapter = interface(DNDataAdapter)
  ['{709CDBCC-26E5-3D11-A73A-5AA9BF436DB4}']
  { getters & setters } 

    function get_DeleteCommand: DNDbCommand;
    procedure set_DeleteCommand(value: DNDbCommand);
    function get_InsertCommand: DNDbCommand;
    procedure set_InsertCommand(value: DNDbCommand);
    function get_SelectCommand: DNDbCommand;
    procedure set_SelectCommand(value: DNDbCommand);
    function get_UpdateBatchSize: Int32;
    procedure set_UpdateBatchSize(value: Int32);
    function get_UpdateCommand: DNDbCommand;
    procedure set_UpdateCommand(value: DNDbCommand);
    function get_AcceptChangesDuringFill: Boolean;
    procedure set_AcceptChangesDuringFill(value: Boolean);
    function get_AcceptChangesDuringUpdate: Boolean;
    procedure set_AcceptChangesDuringUpdate(value: Boolean);
    function get_ContinueUpdateOnError: Boolean;
    procedure set_ContinueUpdateOnError(value: Boolean);
    function get_FillLoadOption: DNLoadOption;
    procedure set_FillLoadOption(value: DNLoadOption);
    function get_MissingMappingAction: DNMissingMappingAction;
    procedure set_MissingMappingAction(value: DNMissingMappingAction);
    function get_MissingSchemaAction: DNMissingSchemaAction;
    procedure set_MissingSchemaAction(value: DNMissingSchemaAction);
    function get_ReturnProviderSpecificTypes: Boolean;
    procedure set_ReturnProviderSpecificTypes(value: Boolean);
    function get_TableMappings: DNDataTableMappingCollection;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_FillError(value: DNFillErrorEventHandler);
    procedure remove_FillError(value: DNFillErrorEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Configures the schema of the specified <see cref="T:System.Data.DataTable" />
    ///  based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  to be filled with the schema from the data source. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information returned from the data source.</returns>
    function FillSchema(dataTable: DNDataTable; schemaType: DNSchemaType): DNDataTable; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  named "Table" to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType): TArray<DNDataTable>; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based upon the specified <see cref="T:System.Data.SchemaType" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">A source table from which to get the schema could not be found. </exception>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType; srcTable: string): TArray<DNDataTable>; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataSet: DNDataSet): Int32; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The source table is invalid. </exception>
    function Fill(dataSet: DNDataSet; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid.-or- The connection is invalid. </exception><exception cref="T:System.InvalidCastException">The connection could not be found. </exception><exception cref="T:System.ArgumentException">The <paramref name="startRecord" />
    ///  parameter is less than 0.-or- The <paramref name="maxRecords" />
    ///  parameter is less than 0. </exception>
    function Fill(dataSet: DNDataSet; startRecord: Int32; maxRecords: Int32; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataTable">The name of the <see cref="T:System.Data.DataTable" />
    ///  to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception>
    function Fill(dataTable: DNDataTable): Int32; overload;
    ///<summary>Adds or refreshes rows in a <see cref="T:System.Data.DataTable" />
    ///  to match those in the data source starting at the specified record and retrieving up to the specified maximum number of records.</summary>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="dataTables">The <see cref="T:System.Data.DataTable" />
    ///  objects to fill from the data source.</param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />
    ///  . This value does not include rows affected by statements that do not return rows.</returns>
    function Fill(startRecord: Int32; maxRecords: Int32; dataTables: TArray<DNDataTable>): Int32; overload;
    ///<summary>Gets the parameters set by the user when executing an SQL SELECT statement.</summary>
    ///<returns>An array of <see cref="T:System.Data.IDataParameter" />
    ///  objects that contains the parameters set by the user.</returns>
    function GetFillParameters: TArray<DNIDataParameter>;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataRows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataRows: TArray<DNDataRow>): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataTable: DNDataTable): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" />
    ///  with the specified <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  to use to update the data source. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet; srcTable: string): Int32; overload;
    ///<summary>Determines whether the <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
    ///  property should be persisted.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
    ///  property is persisted; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeAcceptChangesDuringFill: Boolean;
    ///<summary>Determines whether the <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" />
    ///  property should be persisted.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" />
    ///  property is persisted; otherwise <see langword="false" />
    ///  .</returns>
    function ShouldSerializeFillLoadOption: Boolean;
    ///<summary>Resets <see cref="P:System.Data.Common.DataAdapter.FillLoadOption" />
    ///  to its default state and causes <see cref="M:System.Data.Common.DataAdapter.Fill(System.Data.DataSet)" />
    ///  to honor <see cref="P:System.Data.Common.DataAdapter.AcceptChangesDuringFill" />
    ///  .</summary>
    procedure ResetFillLoadOption;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets a command for deleting records from the data set.</summary>
    ///<returns>An <see cref="T:System.Data.IDbCommand" />
    ///  used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
    ///  to delete records in the data source for deleted rows in the data set.</returns>
    property DeleteCommand: DNDbCommand read get_DeleteCommand write set_DeleteCommand;
    ///<summary>Gets or sets a command used to insert new records into the data source.</summary>
    ///<returns>A <see cref="T:System.Data.IDbCommand" />
    ///  used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
    ///  to insert records in the data source for new rows in the data set.</returns>
    property InsertCommand: DNDbCommand read get_InsertCommand write set_InsertCommand;
    ///<summary>Gets or sets a command used to select records in the data source.</summary>
    ///<returns>A <see cref="T:System.Data.IDbCommand" />
    ///  that is used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
    ///  to select records from data source for placement in the data set.</returns>
    property SelectCommand: DNDbCommand read get_SelectCommand write set_SelectCommand;
    ///<summary>Gets or sets a value that enables or disables batch processing support, and specifies the number of commands that can be executed in a batch. </summary>
    ///<returns>The number of rows to process per batch. Value isEffect0There is no limit on the batch size.1Disables batch updating.&gt; 1Changes are sent using batches of <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
    ///  operations at a time.When setting this to a value other than 1 ,all the commands associated with the <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  must have their <see cref="P:System.Data.IDbCommand.UpdatedRowSource" />
    ///  property set to None or OutputParameters. An exception will be thrown otherwise. </returns>
    property UpdateBatchSize: Int32 read get_UpdateBatchSize write set_UpdateBatchSize;
    ///<summary>Gets or sets a command used to update records in the data source.</summary>
    ///<returns>A <see cref="T:System.Data.IDbCommand" />
    ///  used during <see cref="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
    ///  to update records in the data source for modified rows in the data set.</returns>
    property UpdateCommand: DNDbCommand read get_UpdateCommand write set_UpdateCommand;
    ///<summary>Gets or sets a value indicating whether <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called on a <see cref="T:System.Data.DataRow" />
    ///  after it is added to the <see cref="T:System.Data.DataTable" />
    ///  during any of the Fill operations.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called on the <see cref="T:System.Data.DataRow" />
    ///  ; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property AcceptChangesDuringFill: Boolean read get_AcceptChangesDuringFill write set_AcceptChangesDuringFill;
    ///<summary>Gets or sets whether <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called during a <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Data.DataRow.AcceptChanges" />
    ///  is called during an <see cref="M:System.Data.Common.DataAdapter.Update(System.Data.DataSet)" />
    ///  ; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property AcceptChangesDuringUpdate: Boolean read get_AcceptChangesDuringUpdate write set_AcceptChangesDuringUpdate;
    ///<summary>Gets or sets a value that specifies whether to generate an exception when an error is encountered during a row update.</summary>
    ///<returns><see langword="true" />
    ///  to continue the update without generating an exception; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property ContinueUpdateOnError: Boolean read get_ContinueUpdateOnError write set_ContinueUpdateOnError;
    ///<summary>Gets or sets the <see cref="T:System.Data.LoadOption" />
    ///  that determines how the adapter fills the <see cref="T:System.Data.DataTable" />
    ///  from the <see cref="T:System.Data.Common.DbDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.LoadOption" />
    ///  value.</returns>
    property FillLoadOption: DNLoadOption read get_FillLoadOption write set_FillLoadOption;
    ///<summary>Determines the action to take when incoming data does not have a matching table or column.</summary>
    ///<returns>One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. The default is <see langword="Passthrough" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value set is not one of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </exception>
    property MissingMappingAction: DNMissingMappingAction read get_MissingMappingAction write set_MissingMappingAction;
    ///<summary>Determines the action to take when existing <see cref="T:System.Data.DataSet" />
    ///  schema does not match incoming data.</summary>
    ///<returns>One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. The default is <see langword="Add" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value set is not one of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </exception>
    property MissingSchemaAction: DNMissingSchemaAction read get_MissingSchemaAction write set_MissingSchemaAction;
    ///<summary>Gets or sets whether the <see langword="Fill" />
    ///  method should return provider-specific values or common CLS-compliant values.</summary>
    ///<returns><see langword="true" />
    ///  if the <see langword="Fill" />
    ///  method should return provider-specific values; otherwise <see langword="false" />
    ///  to return common CLS-compliant values.</returns>
    property ReturnProviderSpecificTypes: Boolean read get_ReturnProviderSpecificTypes write set_ReturnProviderSpecificTypes;
    ///<summary>Gets a collection that provides the master mapping between a source table and a <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A collection that provides the master mapping between the returned records and the <see cref="T:System.Data.DataSet" />
    ///  . The default value is an empty collection.</returns>
    property TableMappings: DNDataTableMappingCollection read get_TableMappings;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNDbDataAdapter = class(TDNGenericImport<DNDbDataAdapterClass, DNDbDataAdapter>)
  public const
    ///<summary>The default name used by the <see cref="T:System.Data.Common.DataAdapter" />
    ///  object for table mappings.</summary>
   DefaultSourceTableName = 'Table';
  end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcDataAdapterClass = interface(DNDbDataAdapterClass)
  ['{4A2CECDD-5203-528C-B34B-3077D060F7F3}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  class.</summary>
    {class} function init: DNOdbcDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  class with the specified SQL SELECT statement.</summary>
    ///  <param name="selectCommand">An <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  that is an SQL SELECT statement or stored procedure, and is set as the <see cref="P:System.Data.Odbc.OdbcDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  . </param>
    {class} function init(selectCommand: DNOdbcCommand): DNOdbcDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  class with an SQL SELECT statement and an <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  .</summary>
    ///  <param name="selectCommandText">A string that is a SQL SELECT statement or stored procedure to be used by the <see cref="P:System.Data.Odbc.OdbcDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  . </param>
    ///  <param name="selectConnection">An <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  that represents the connection. </param>
    {class} function init(selectCommandText: string; selectConnection: DNOdbcConnection): DNOdbcDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  class with an SQL SELECT statement and a connection string.</summary>
    ///  <param name="selectCommandText">A string that is a SQL SELECT statement or stored procedure to be used by the <see cref="P:System.Data.Odbc.OdbcDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  . </param>
    ///  <param name="selectConnectionString">The connection string. </param>
    {class} function init(selectCommandText: string; selectConnectionString: string): DNOdbcDataAdapter; overload;

  end;

  ///<summary>Represents a set of data commands and a connection to a data source that are used to fill the <see cref="T:System.Data.DataSet" />
  ///  and update the data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcDataAdapter')]
  DNOdbcDataAdapter = interface(DNDbDataAdapter)
  ['{C84DB417-A3DD-3F46-B15E-21873853E324}']
  { getters & setters } 

    function get_DeleteCommand: DNOdbcCommand;
    procedure set_DeleteCommand(value: DNOdbcCommand);
    function get_InsertCommand: DNOdbcCommand;
    procedure set_InsertCommand(value: DNOdbcCommand);
    function get_SelectCommand: DNOdbcCommand;
    procedure set_SelectCommand(value: DNOdbcCommand);
    function get_UpdateCommand: DNOdbcCommand;
    procedure set_UpdateCommand(value: DNOdbcCommand);
    function get_UpdateBatchSize: Int32;
    procedure set_UpdateBatchSize(value: Int32);
    function get_AcceptChangesDuringFill: Boolean;
    procedure set_AcceptChangesDuringFill(value: Boolean);
    function get_AcceptChangesDuringUpdate: Boolean;
    procedure set_AcceptChangesDuringUpdate(value: Boolean);
    function get_ContinueUpdateOnError: Boolean;
    procedure set_ContinueUpdateOnError(value: Boolean);
    function get_FillLoadOption: DNLoadOption;
    procedure set_FillLoadOption(value: DNLoadOption);
    function get_MissingMappingAction: DNMissingMappingAction;
    procedure set_MissingMappingAction(value: DNMissingMappingAction);
    function get_MissingSchemaAction: DNMissingSchemaAction;
    procedure set_MissingSchemaAction(value: DNMissingSchemaAction);
    function get_ReturnProviderSpecificTypes: Boolean;
    procedure set_ReturnProviderSpecificTypes(value: Boolean);
    function get_TableMappings: DNDataTableMappingCollection;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_RowUpdated(value: DNOdbcRowUpdatedEventHandler);
    procedure remove_RowUpdated(value: DNOdbcRowUpdatedEventHandler);
    procedure add_RowUpdating(value: DNOdbcRowUpdatingEventHandler);
    procedure remove_RowUpdating(value: DNOdbcRowUpdatingEventHandler);
    procedure add_FillError(value: DNFillErrorEventHandler);
    procedure remove_FillError(value: DNFillErrorEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Configures the schema of the specified <see cref="T:System.Data.DataTable" />
    ///  based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  to be filled with the schema from the data source. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information returned from the data source.</returns>
    function FillSchema(dataTable: DNDataTable; schemaType: DNSchemaType): DNDataTable; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  named "Table" to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType): TArray<DNDataTable>; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based upon the specified <see cref="T:System.Data.SchemaType" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">A source table from which to get the schema could not be found. </exception>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType; srcTable: string): TArray<DNDataTable>; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataSet: DNDataSet): Int32; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The source table is invalid. </exception>
    function Fill(dataSet: DNDataSet; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid.-or- The connection is invalid. </exception><exception cref="T:System.InvalidCastException">The connection could not be found. </exception><exception cref="T:System.ArgumentException">The <paramref name="startRecord" />
    ///  parameter is less than 0.-or- The <paramref name="maxRecords" />
    ///  parameter is less than 0. </exception>
    function Fill(dataSet: DNDataSet; startRecord: Int32; maxRecords: Int32; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataTable">The name of the <see cref="T:System.Data.DataTable" />
    ///  to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception>
    function Fill(dataTable: DNDataTable): Int32; overload;
    ///<summary>Adds or refreshes rows in a <see cref="T:System.Data.DataTable" />
    ///  to match those in the data source starting at the specified record and retrieving up to the specified maximum number of records.</summary>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="dataTables">The <see cref="T:System.Data.DataTable" />
    ///  objects to fill from the data source.</param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />
    ///  . This value does not include rows affected by statements that do not return rows.</returns>
    function Fill(startRecord: Int32; maxRecords: Int32; dataTables: TArray<DNDataTable>): Int32; overload;
    ///<summary>Gets the parameters set by the user when executing an SQL SELECT statement.</summary>
    ///<returns>An array of <see cref="T:System.Data.IDataParameter" />
    ///  objects that contains the parameters set by the user.</returns>
    function GetFillParameters: TArray<DNIDataParameter>;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataRows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataRows: TArray<DNDataRow>): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataTable: DNDataTable): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" />
    ///  with the specified <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  to use to update the data source. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet; srcTable: string): Int32; overload;
    function ShouldSerializeAcceptChangesDuringFill: Boolean;
    function ShouldSerializeFillLoadOption: Boolean;
    procedure ResetFillLoadOption;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets an SQL statement or stored procedure used to delete records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  used during an update operation to delete records in the data source that correspond to deleted rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property DeleteCommand: DNOdbcCommand read get_DeleteCommand write set_DeleteCommand;
    ///<summary>Gets or sets an SQL statement or stored procedure used to insert new records into the data source.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  used during an update operation to insert records in the data source that correspond to new rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property InsertCommand: DNOdbcCommand read get_InsertCommand write set_InsertCommand;
    ///<summary>Gets or sets an SQL statement or stored procedure used to select records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  that is used during a fill operation to select records from data source for placement in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property SelectCommand: DNOdbcCommand read get_SelectCommand write set_SelectCommand;
    ///<summary>Gets or sets an SQL statement or stored procedure used to update records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  used during an update operation to update records in the data source that correspond to modified rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property UpdateCommand: DNOdbcCommand read get_UpdateCommand write set_UpdateCommand;
    ///<summary>Gets or sets a value that enables or disables batch processing support, and specifies the number of commands that can be executed in a batch. </summary>
    ///<returns>The number of rows to process per batch. Value isEffect0There is no limit on the batch size.1Disables batch updating.&gt; 1Changes are sent using batches of <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
    ///  operations at a time.When setting this to a value other than 1 ,all the commands associated with the <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  must have their <see cref="P:System.Data.IDbCommand.UpdatedRowSource" />
    ///  property set to None or OutputParameters. An exception will be thrown otherwise. </returns>
    property UpdateBatchSize: Int32 read get_UpdateBatchSize write set_UpdateBatchSize;
    property AcceptChangesDuringFill: Boolean read get_AcceptChangesDuringFill write set_AcceptChangesDuringFill;
    property AcceptChangesDuringUpdate: Boolean read get_AcceptChangesDuringUpdate write set_AcceptChangesDuringUpdate;
    property ContinueUpdateOnError: Boolean read get_ContinueUpdateOnError write set_ContinueUpdateOnError;
    property FillLoadOption: DNLoadOption read get_FillLoadOption write set_FillLoadOption;
    property MissingMappingAction: DNMissingMappingAction read get_MissingMappingAction write set_MissingMappingAction;
    property MissingSchemaAction: DNMissingSchemaAction read get_MissingSchemaAction write set_MissingSchemaAction;
    property ReturnProviderSpecificTypes: Boolean read get_ReturnProviderSpecificTypes write set_ReturnProviderSpecificTypes;
    property TableMappings: DNDataTableMappingCollection read get_TableMappings;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOdbcDataAdapter = class(TDNGenericImport<DNOdbcDataAdapterClass, DNOdbcDataAdapter>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbDataAdapterClass = interface(DNDbDataAdapterClass)
  ['{E7B972FA-EBBF-5D7A-99A4-B671DF3C4756}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  class.</summary>
    {class} function init: DNOleDbDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  class with the specified <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  as the <see cref="P:System.Data.OleDb.OleDbDataAdapter.SelectCommand" />
    ///  property.</summary>
    ///  <param name="selectCommand">An <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  that is a SELECT statement or stored procedure, and is set as the <see cref="P:System.Data.OleDb.OleDbDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  .</param>
    {class} function init(selectCommand: DNOleDbCommand): DNOleDbDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  class with a <see cref="P:System.Data.OleDb.OleDbDataAdapter.SelectCommand" />
    ///  .</summary>
    ///  <param name="selectCommandText">A string that is an SQL SELECT statement or stored procedure to be used by the <see cref="P:System.Data.OleDb.OleDbDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  . </param>
    ///  <param name="selectConnectionString">The connection string. </param>
    {class} function init(selectCommandText: string; selectConnectionString: string): DNOleDbDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  class with a <see cref="P:System.Data.OleDb.OleDbDataAdapter.SelectCommand" />
    ///  .</summary>
    ///  <param name="selectCommandText">A string that is an SQL SELECT statement or stored procedure to be used by the <see cref="P:System.Data.OleDb.OleDbDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  . </param>
    ///  <param name="selectConnection">An <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  that represents the connection. </param>
    {class} function init(selectCommandText: string; selectConnection: DNOleDbConnection): DNOleDbDataAdapter; overload;

  end;

  ///<summary>Represents a set of data commands and a database connection that are used to fill the <see cref="T:System.Data.DataSet" />
  ///  and update the data source.</summary>
  [DNTypeName('System.Data.OleDb.OleDbDataAdapter')]
  DNOleDbDataAdapter = interface(DNDbDataAdapter)
  ['{01C0E727-85AB-3B18-9A25-85648F0DB50C}']
  { getters & setters } 

    function get_DeleteCommand: DNOleDbCommand;
    procedure set_DeleteCommand(value: DNOleDbCommand);
    function get_InsertCommand: DNOleDbCommand;
    procedure set_InsertCommand(value: DNOleDbCommand);
    function get_SelectCommand: DNOleDbCommand;
    procedure set_SelectCommand(value: DNOleDbCommand);
    function get_UpdateCommand: DNOleDbCommand;
    procedure set_UpdateCommand(value: DNOleDbCommand);
    function get_UpdateBatchSize: Int32;
    procedure set_UpdateBatchSize(value: Int32);
    function get_AcceptChangesDuringFill: Boolean;
    procedure set_AcceptChangesDuringFill(value: Boolean);
    function get_AcceptChangesDuringUpdate: Boolean;
    procedure set_AcceptChangesDuringUpdate(value: Boolean);
    function get_ContinueUpdateOnError: Boolean;
    procedure set_ContinueUpdateOnError(value: Boolean);
    function get_FillLoadOption: DNLoadOption;
    procedure set_FillLoadOption(value: DNLoadOption);
    function get_MissingMappingAction: DNMissingMappingAction;
    procedure set_MissingMappingAction(value: DNMissingMappingAction);
    function get_MissingSchemaAction: DNMissingSchemaAction;
    procedure set_MissingSchemaAction(value: DNMissingSchemaAction);
    function get_ReturnProviderSpecificTypes: Boolean;
    procedure set_ReturnProviderSpecificTypes(value: Boolean);
    function get_TableMappings: DNDataTableMappingCollection;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_RowUpdated(value: DNOleDbRowUpdatedEventHandler);
    procedure remove_RowUpdated(value: DNOleDbRowUpdatedEventHandler);
    procedure add_RowUpdating(value: DNOleDbRowUpdatingEventHandler);
    procedure remove_RowUpdating(value: DNOleDbRowUpdatingEventHandler);
    procedure add_FillError(value: DNFillErrorEventHandler);
    procedure remove_FillError(value: DNFillErrorEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Adds or refreshes rows in a <see cref="T:System.Data.DataTable" />
    ///  to match those in an ADO <see langword="Recordset" />
    ///  or <see langword="Record" />
    ///  object using the specified <see cref="T:System.Data.DataTable" />
    ///  and ADO objects.</summary>
    ///  <param name="dataTable">A <see cref="T:System.Data.DataTable" />
    ///  to fill with records and, if it is required, schema. </param>
    ///  <param name="ADODBRecordSet">An ADO <see langword="Recordset" />
    ///  or <see langword="Record" />
    ///  object. </param>
    ///<returns>The number of rows successfully refreshed to the <see cref="T:System.Data.DataTable" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataTable: DNDataTable; ADODBRecordSet: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in an ADO <see langword="Recordset" />
    ///  or <see langword="Record" />
    ///  object using the specified <see cref="T:System.Data.DataSet" />
    ///  , ADO object, and source table name.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if it is required, schema. </param>
    ///  <param name="ADODBRecordSet">An ADO <see langword="Recordset" />
    ///  or <see langword="Record" />
    ///  object. </param>
    ///  <param name="srcTable">The source table used for the table mappings. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The source table is invalid. </exception>
    function Fill(dataSet: DNDataSet; ADODBRecordSet: DDN.mscorlib.DNObject; srcTable: string): Int32; overload;
    ///<summary>Configures the schema of the specified <see cref="T:System.Data.DataTable" />
    ///  based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  to be filled with the schema from the data source. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information returned from the data source.</returns>
    function FillSchema(dataTable: DNDataTable; schemaType: DNSchemaType): DNDataTable; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  named "Table" to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType): TArray<DNDataTable>; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based upon the specified <see cref="T:System.Data.SchemaType" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">A source table from which to get the schema could not be found. </exception>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType; srcTable: string): TArray<DNDataTable>; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataSet: DNDataSet): Int32; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The source table is invalid. </exception>
    function Fill(dataSet: DNDataSet; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid.-or- The connection is invalid. </exception><exception cref="T:System.InvalidCastException">The connection could not be found. </exception><exception cref="T:System.ArgumentException">The <paramref name="startRecord" />
    ///  parameter is less than 0.-or- The <paramref name="maxRecords" />
    ///  parameter is less than 0. </exception>
    function Fill(dataSet: DNDataSet; startRecord: Int32; maxRecords: Int32; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataTable">The name of the <see cref="T:System.Data.DataTable" />
    ///  to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception>
    function Fill(dataTable: DNDataTable): Int32; overload;
    ///<summary>Adds or refreshes rows in a <see cref="T:System.Data.DataTable" />
    ///  to match those in the data source starting at the specified record and retrieving up to the specified maximum number of records.</summary>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="dataTables">The <see cref="T:System.Data.DataTable" />
    ///  objects to fill from the data source.</param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />
    ///  . This value does not include rows affected by statements that do not return rows.</returns>
    function Fill(startRecord: Int32; maxRecords: Int32; dataTables: TArray<DNDataTable>): Int32; overload;
    ///<summary>Gets the parameters set by the user when executing an SQL SELECT statement.</summary>
    ///<returns>An array of <see cref="T:System.Data.IDataParameter" />
    ///  objects that contains the parameters set by the user.</returns>
    function GetFillParameters: TArray<DNIDataParameter>;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataRows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataRows: TArray<DNDataRow>): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataTable: DNDataTable): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" />
    ///  with the specified <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  to use to update the data source. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet; srcTable: string): Int32; overload;
    function ShouldSerializeAcceptChangesDuringFill: Boolean;
    function ShouldSerializeFillLoadOption: Boolean;
    procedure ResetFillLoadOption;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets an SQL statement or stored procedure for deleting records from the data set.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to delete records in the data source that correspond to deleted rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property DeleteCommand: DNOleDbCommand read get_DeleteCommand write set_DeleteCommand;
    ///<summary>Gets or sets an SQL statement or stored procedure used to insert new records into the data source.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to insert records in the data source that correspond to new rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property InsertCommand: DNOleDbCommand read get_InsertCommand write set_InsertCommand;
    ///<summary>Gets or sets an SQL statement or stored procedure used to select records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  that is used during <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
    ///  to select records from data source for placement in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property SelectCommand: DNOleDbCommand read get_SelectCommand write set_SelectCommand;
    ///<summary>Gets or sets an SQL statement or stored procedure used to update records in the data source.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to update records in the data source that correspond to modified rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property UpdateCommand: DNOleDbCommand read get_UpdateCommand write set_UpdateCommand;
    ///<summary>Gets or sets a value that enables or disables batch processing support, and specifies the number of commands that can be executed in a batch. </summary>
    ///<returns>The number of rows to process per batch. Value isEffect0There is no limit on the batch size.1Disables batch updating.&gt; 1Changes are sent using batches of <see cref="P:System.Data.Common.DbDataAdapter.UpdateBatchSize" />
    ///  operations at a time.When setting this to a value other than 1 ,all the commands associated with the <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  must have their <see cref="P:System.Data.IDbCommand.UpdatedRowSource" />
    ///  property set to None or OutputParameters. An exception will be thrown otherwise. </returns>
    property UpdateBatchSize: Int32 read get_UpdateBatchSize write set_UpdateBatchSize;
    property AcceptChangesDuringFill: Boolean read get_AcceptChangesDuringFill write set_AcceptChangesDuringFill;
    property AcceptChangesDuringUpdate: Boolean read get_AcceptChangesDuringUpdate write set_AcceptChangesDuringUpdate;
    property ContinueUpdateOnError: Boolean read get_ContinueUpdateOnError write set_ContinueUpdateOnError;
    property FillLoadOption: DNLoadOption read get_FillLoadOption write set_FillLoadOption;
    property MissingMappingAction: DNMissingMappingAction read get_MissingMappingAction write set_MissingMappingAction;
    property MissingSchemaAction: DNMissingSchemaAction read get_MissingSchemaAction write set_MissingSchemaAction;
    property ReturnProviderSpecificTypes: Boolean read get_ReturnProviderSpecificTypes write set_ReturnProviderSpecificTypes;
    property TableMappings: DNDataTableMappingCollection read get_TableMappings;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOleDbDataAdapter = class(TDNGenericImport<DNOleDbDataAdapterClass, DNOleDbDataAdapter>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlDataAdapterClass = interface(DNDbDataAdapterClass)
  ['{C63B489B-515B-5A38-A872-42B4EF5882DA}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  class.</summary>
    {class} function init: DNSqlDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  class with the specified <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  as the <see cref="P:System.Data.SqlClient.SqlDataAdapter.SelectCommand" />
    ///  property.</summary>
    ///  <param name="selectCommand">A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  that is a Transact-SQL SELECT statement or stored procedure and is set as the <see cref="P:System.Data.SqlClient.SqlDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  . </param>
    {class} function init(selectCommand: DNSqlCommand): DNSqlDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  class with a <see cref="P:System.Data.SqlClient.SqlDataAdapter.SelectCommand" />
    ///  and a connection string.</summary>
    ///  <param name="selectCommandText">A <see cref="T:System.String" />
    ///  that is a Transact-SQL SELECT statement or stored procedure to be used by the <see cref="P:System.Data.SqlClient.SqlDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  . </param>
    ///  <param name="selectConnectionString">The connection string. If your connection string does not use <see langword="Integrated Security = true" />
    ///  , you can use <see cref="M:System.Data.SqlClient.SqlDataAdapter.#ctor(System.String,System.Data.SqlClient.SqlConnection)" />
    ///  and <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.</param>
    {class} function init(selectCommandText: string; selectConnectionString: string): DNSqlDataAdapter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  class with a <see cref="P:System.Data.SqlClient.SqlDataAdapter.SelectCommand" />
    ///  and a <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object.</summary>
    ///  <param name="selectCommandText">A <see cref="T:System.String" />
    ///  that is a Transact-SQL SELECT statement or stored procedure to be used by the <see cref="P:System.Data.SqlClient.SqlDataAdapter.SelectCommand" />
    ///  property of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  . </param>
    ///  <param name="selectConnection">A <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  that represents the connection. If your connection string does not use <see langword="Integrated Security = true" />
    ///  , you can use <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  to pass the user ID and password more securely than by specifying the user ID and password as text in the connection string.</param>
    {class} function init(selectCommandText: string; selectConnection: DNSqlConnection): DNSqlDataAdapter; overload;

  end;

  ///<summary>Represents a set of data commands and a database connection that are used to fill the <see cref="T:System.Data.DataSet" />
  ///  and update a SQL Server database. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.SqlClient.SqlDataAdapter')]
  DNSqlDataAdapter = interface(DNDbDataAdapter)
  ['{27A46983-6FE5-3792-9ABA-2BBA046C6F7B}']
  { getters & setters } 

    function get_DeleteCommand: DNSqlCommand;
    procedure set_DeleteCommand(value: DNSqlCommand);
    function get_InsertCommand: DNSqlCommand;
    procedure set_InsertCommand(value: DNSqlCommand);
    function get_SelectCommand: DNSqlCommand;
    procedure set_SelectCommand(value: DNSqlCommand);
    function get_UpdateBatchSize: Int32;
    procedure set_UpdateBatchSize(value: Int32);
    function get_UpdateCommand: DNSqlCommand;
    procedure set_UpdateCommand(value: DNSqlCommand);
    function get_AcceptChangesDuringFill: Boolean;
    procedure set_AcceptChangesDuringFill(value: Boolean);
    function get_AcceptChangesDuringUpdate: Boolean;
    procedure set_AcceptChangesDuringUpdate(value: Boolean);
    function get_ContinueUpdateOnError: Boolean;
    procedure set_ContinueUpdateOnError(value: Boolean);
    function get_FillLoadOption: DNLoadOption;
    procedure set_FillLoadOption(value: DNLoadOption);
    function get_MissingMappingAction: DNMissingMappingAction;
    procedure set_MissingMappingAction(value: DNMissingMappingAction);
    function get_MissingSchemaAction: DNMissingSchemaAction;
    procedure set_MissingSchemaAction(value: DNMissingSchemaAction);
    function get_ReturnProviderSpecificTypes: Boolean;
    procedure set_ReturnProviderSpecificTypes(value: Boolean);
    function get_TableMappings: DNDataTableMappingCollection;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_RowUpdated(value: DNSqlRowUpdatedEventHandler);
    procedure remove_RowUpdated(value: DNSqlRowUpdatedEventHandler);
    procedure add_RowUpdating(value: DNSqlRowUpdatingEventHandler);
    procedure remove_RowUpdating(value: DNSqlRowUpdatingEventHandler);
    procedure add_FillError(value: DNFillErrorEventHandler);
    procedure remove_FillError(value: DNFillErrorEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Configures the schema of the specified <see cref="T:System.Data.DataTable" />
    ///  based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  to be filled with the schema from the data source. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information returned from the data source.</returns>
    function FillSchema(dataTable: DNDataTable; schemaType: DNSchemaType): DNDataTable; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  named "Table" to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based on the specified <see cref="T:System.Data.SchemaType" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType): TArray<DNDataTable>; overload;
    ///<summary>Adds a <see cref="T:System.Data.DataTable" />
    ///  to the specified <see cref="T:System.Data.DataSet" />
    ///  and configures the schema to match that in the data source based upon the specified <see cref="T:System.Data.SchemaType" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to insert the schema in. </param>
    ///  <param name="schemaType">One of the <see cref="T:System.Data.SchemaType" />
    ///  values that specify how to insert the schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>A reference to a collection of <see cref="T:System.Data.DataTable" />
    ///  objects that were added to the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">A source table from which to get the schema could not be found. </exception>
    function FillSchema(dataSet: DNDataSet; schemaType: DNSchemaType; srcTable: string): TArray<DNDataTable>; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    function Fill(dataSet: DNDataSet): Int32; overload;
    ///<summary>Adds or refreshes rows in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The source table is invalid. </exception>
    function Fill(dataSet: DNDataSet; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataSet" />
    ///  and <see cref="T:System.Data.DataTable" />
    ///  names.</summary>
    ///  <param name="dataSet">A <see cref="T:System.Data.DataSet" />
    ///  to fill with records and, if necessary, schema. </param>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.SystemException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid.-or- The connection is invalid. </exception><exception cref="T:System.InvalidCastException">The connection could not be found. </exception><exception cref="T:System.ArgumentException">The <paramref name="startRecord" />
    ///  parameter is less than 0.-or- The <paramref name="maxRecords" />
    ///  parameter is less than 0. </exception>
    function Fill(dataSet: DNDataSet; startRecord: Int32; maxRecords: Int32; srcTable: string): Int32; overload;
    ///<summary>Adds or refreshes rows in a specified range in the <see cref="T:System.Data.DataSet" />
    ///  to match those in the data source using the <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataTable">The name of the <see cref="T:System.Data.DataTable" />
    ///  to use for table mapping. </param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataSet" />
    ///  . This does not include rows affected by statements that do not return rows.</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception>
    function Fill(dataTable: DNDataTable): Int32; overload;
    ///<summary>Adds or refreshes rows in a <see cref="T:System.Data.DataTable" />
    ///  to match those in the data source starting at the specified record and retrieving up to the specified maximum number of records.</summary>
    ///  <param name="startRecord">The zero-based record number to start with. </param>
    ///  <param name="maxRecords">The maximum number of records to retrieve. </param>
    ///  <param name="dataTables">The <see cref="T:System.Data.DataTable" />
    ///  objects to fill from the data source.</param>
    ///<returns>The number of rows successfully added to or refreshed in the <see cref="T:System.Data.DataTable" />
    ///  . This value does not include rows affected by statements that do not return rows.</returns>
    function Fill(startRecord: Int32; maxRecords: Int32; dataTables: TArray<DNDataTable>): Int32; overload;
    ///<summary>Gets the parameters set by the user when executing an SQL SELECT statement.</summary>
    ///<returns>An array of <see cref="T:System.Data.IDataParameter" />
    ///  objects that contains the parameters set by the user.</returns>
    function GetFillParameters: TArray<DNIDataParameter>;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified array in the <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataRows">An array of <see cref="T:System.Data.DataRow" />
    ///  objects used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataRows: TArray<DNDataRow>): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the specified <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  used to update the data source. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataTable" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.SystemException">No <see cref="T:System.Data.DataRow" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataTable" />
    ///  exists to update.-or- No <see cref="T:System.Data.DataSet" />
    ///  exists to use as a source. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataTable: DNDataTable): Int32; overload;
    ///<summary>Updates the values in the database by executing the respective INSERT, UPDATE, or DELETE statements for each inserted, updated, or deleted row in the <see cref="T:System.Data.DataSet" />
    ///  with the specified <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  to use to update the data source. </param>
    ///  <param name="srcTable">The name of the source table to use for table mapping. </param>
    ///<returns>The number of rows successfully updated from the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Data.DataSet" />
    ///  is invalid. </exception><exception cref="T:System.InvalidOperationException">The source table is invalid. </exception><exception cref="T:System.Data.DBConcurrencyException">An attempt to execute an INSERT, UPDATE, or DELETE statement resulted in zero records affected. </exception>
    function Update(dataSet: DNDataSet; srcTable: string): Int32; overload;
    function ShouldSerializeAcceptChangesDuringFill: Boolean;
    function ShouldSerializeFillLoadOption: Boolean;
    procedure ResetFillLoadOption;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets a Transact-SQL statement or stored procedure to delete records from the data set.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to delete records in the database that correspond to deleted rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property DeleteCommand: DNSqlCommand read get_DeleteCommand write set_DeleteCommand;
    ///<summary>Gets or sets a Transact-SQL statement or stored procedure to insert new records into the data source.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to insert records into the database that correspond to new rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property InsertCommand: DNSqlCommand read get_InsertCommand write set_InsertCommand;
    ///<summary>Gets or sets a Transact-SQL statement or stored procedure used to select records in the data source.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)" />
    ///  to select records from the database for placement in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property SelectCommand: DNSqlCommand read get_SelectCommand write set_SelectCommand;
    ///<summary>Gets or sets the number of rows that are processed in each round-trip to the server.</summary>
    ///<returns>The number of rows to process per-batch. Value isEffect0There is no limit on the batch size..1Disables batch updating.&gt;1Changes are sent using batches of <see cref="P:System.Data.SqlClient.SqlDataAdapter.UpdateBatchSize" />
    ///  operations at a time.When setting this to a value other than 1, all the commands associated with the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  have to have their UpdatedRowSource property set to <see langword="None" />
    ///  or <see langword="OutputParameters" />
    ///  . An exception is thrown otherwise.</returns>
    property UpdateBatchSize: Int32 read get_UpdateBatchSize write set_UpdateBatchSize;
    ///<summary>Gets or sets a Transact-SQL statement or stored procedure used to update records in the data source.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  used during <see cref="M:System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)" />
    ///  to update records in the database that correspond to modified rows in the <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property UpdateCommand: DNSqlCommand read get_UpdateCommand write set_UpdateCommand;
    property AcceptChangesDuringFill: Boolean read get_AcceptChangesDuringFill write set_AcceptChangesDuringFill;
    property AcceptChangesDuringUpdate: Boolean read get_AcceptChangesDuringUpdate write set_AcceptChangesDuringUpdate;
    property ContinueUpdateOnError: Boolean read get_ContinueUpdateOnError write set_ContinueUpdateOnError;
    property FillLoadOption: DNLoadOption read get_FillLoadOption write set_FillLoadOption;
    property MissingMappingAction: DNMissingMappingAction read get_MissingMappingAction write set_MissingMappingAction;
    property MissingSchemaAction: DNMissingSchemaAction read get_MissingSchemaAction write set_MissingSchemaAction;
    property ReturnProviderSpecificTypes: Boolean read get_ReturnProviderSpecificTypes write set_ReturnProviderSpecificTypes;
    property TableMappings: DNDataTableMappingCollection read get_TableMappings;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNSqlDataAdapter = class(TDNGenericImport<DNSqlDataAdapterClass, DNSqlDataAdapter>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbCommandClass = interface(DNObjectClass)
  ['{E455D831-9C37-5B53-9804-FD467C53D206}']
  end;

  ///<summary>Represents an SQL statement or stored procedure to execute against a data source. Provides a base class for database-specific classes that represent commands. <see cref="Overload:System.Data.Common.DbCommand.ExecuteNonQueryAsync" />
  ///</summary>
  [DNTypeName('System.Data.Common.DbCommand')]
  DNDbCommand = interface(DNObject)
  ['{00E5A1B0-8B83-3CF0-B5EC-EE6EDC19D2D2}']
  { getters & setters } 

    function get_CommandText: string;
    procedure set_CommandText(value: string);
    function get_CommandTimeout: Int32;
    procedure set_CommandTimeout(value: Int32);
    function get_CommandType: DNCommandType;
    procedure set_CommandType(value: DNCommandType);
    function get_Connection: DNDbConnection;
    procedure set_Connection(value: DNDbConnection);
    function get_DesignTimeVisible: Boolean;
    procedure set_DesignTimeVisible(value: Boolean);
    function get_Parameters: DNDbParameterCollection;
    function get_Transaction: DNDbTransaction;
    procedure set_Transaction(value: DNDbTransaction);
    function get_UpdatedRowSource: DNUpdateRowSource;
    procedure set_UpdatedRowSource(value: DNUpdateRowSource);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Attempts to cancels the execution of a <see cref="T:System.Data.Common.DbCommand" />
    ///  .</summary>
    procedure Cancel;
    ///<summary>Creates a new instance of a <see cref="T:System.Data.Common.DbParameter" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.Data.Common.DbParameter" />
    ///  object.</returns>
    function CreateParameter: DNDbParameter;
    ///<summary>Executes a SQL statement against a connection object.</summary>
    ///<returns>The number of rows affected.</returns>
    function ExecuteNonQuery: Int32;
    ///<summary>Executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  , and returns an <see cref="T:System.Data.Common.DbDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</returns>
    function ExecuteReader: DNDbDataReader; overload;
    ///<summary>Executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  , and returns an <see cref="T:System.Data.Common.DbDataReader" />
    ///  using one of the <see cref="T:System.Data.CommandBehavior" />
    ///  values. </summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///<returns>An <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</returns>
    function ExecuteReader(behavior: DNCommandBehavior): DNDbDataReader; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  , which executes a SQL statement against a connection object.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync: DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  . Providers should override with an appropriate implementation. The cancellation token may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellation token.  Exceptions thrown by <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbCommand" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync: DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  . This method propagates a notification that operations should be canceled.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  , which executes the query and returns the first column of the first row in the result set returned by the query. All other columns and rows are ignored.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  . Providers should override with an appropriate implementation. The cancellation token may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellation token. Exceptions thrown by ExecuteScalar will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbCommand" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    ///<summary>Executes the query and returns the first column of the first row in the result set returned by the query. All other columns and rows are ignored.</summary>
    ///<returns>The first column of the first row in the result set.</returns>
    function ExecuteScalar: DDN.mscorlib.DNObject;
    ///<summary>Creates a prepared (or compiled) version of the command on the data source.</summary>
    procedure Prepare;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the text command to run against the data source.</summary>
    ///<returns>The text command to execute. The default value is an empty string ("").</returns>
    property CommandText: string read get_CommandText write set_CommandText;
    ///<summary>Gets or sets the wait time before terminating the attempt to execute a command and generating an error.</summary>
    ///<returns>The time in seconds to wait for the command to execute.</returns>
    property CommandTimeout: Int32 read get_CommandTimeout write set_CommandTimeout;
    ///<summary>Indicates or specifies how the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  property is interpreted.</summary>
    ///<returns>One of the <see cref="T:System.Data.CommandType" />
    ///  values. The default is <see langword="Text" />
    ///  .</returns>
    property CommandType: DNCommandType read get_CommandType write set_CommandType;
    ///<summary>Gets or sets the <see cref="T:System.Data.Common.DbConnection" />
    ///  used by this <see cref="T:System.Data.Common.DbCommand" />
    ///  .</summary>
    ///<returns>The connection to the data source.</returns>
    property Connection: DNDbConnection read get_Connection write set_Connection;
    ///<summary>Gets or sets a value indicating whether the command object should be visible in a customized interface control.</summary>
    ///<returns><see langword="true" />
    ///  , if the command object should be visible in a control; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property DesignTimeVisible: Boolean read get_DesignTimeVisible write set_DesignTimeVisible;
    ///<summary>Gets the collection of <see cref="T:System.Data.Common.DbParameter" />
    ///  objects. For more information on parameters, see Configuring Parameters and Parameter Data Types.</summary>
    ///<returns>The parameters of the SQL statement or stored procedure.</returns>
    property Parameters: DNDbParameterCollection read get_Parameters;
    ///<summary>Gets or sets the <see cref="T:System.Data.Common.DbTransaction" />
    ///  within which this <see cref="T:System.Data.Common.DbCommand" />
    ///  object executes.</summary>
    ///<returns>The transaction within which a <see langword="Command" />
    ///  object of a .NET Framework data provider executes. The default value is a null reference (<see langword="Nothing" />
    ///  in Visual Basic).</returns>
    property Transaction: DNDbTransaction read get_Transaction write set_Transaction;
    ///<summary>Gets or sets how command results are applied to the <see cref="T:System.Data.DataRow" />
    ///  when used by the Update method of a <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values. The default is <see langword="Both" />
    ///  unless the command is automatically generated. Then the default is <see langword="None" />
    ///  .</returns>
    property UpdatedRowSource: DNUpdateRowSource read get_UpdatedRowSource write set_UpdatedRowSource;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNDbCommand = class(TDNGenericImport<DNDbCommandClass, DNDbCommand>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcCommandClass = interface(DNDbCommandClass)
  ['{C7753A3F-5AB4-5698-A387-E49233BBF875}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  class.</summary>
    {class} function init: DNOdbcCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  class with the text of the query.</summary>
    ///  <param name="cmdText">The text of the query. </param>
    {class} function init(cmdText: string): DNOdbcCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  class with the text of the query and an <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  object.</summary>
    ///  <param name="cmdText">The text of the query. </param>
    ///  <param name="connection">An <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  object that represents the connection to a data source. </param>
    {class} function init(cmdText: string; connection: DNOdbcConnection): DNOdbcCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  class with the text of the query, an <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  object, and the <see cref="P:System.Data.Odbc.OdbcCommand.Transaction" />
    ///  .</summary>
    ///  <param name="cmdText">The text of the query. </param>
    ///  <param name="connection">An <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  object that represents the connection to a data source. </param>
    ///  <param name="transaction">The transaction in which the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  executes. </param>
    {class} function init(cmdText: string; connection: DNOdbcConnection; transaction: DNOdbcTransaction): DNOdbcCommand; overload;

  end;

  ///<summary>Represents an SQL statement or stored procedure to execute against a data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcCommand')]
  DNOdbcCommand = interface(DNDbCommand)
  ['{C24C1018-CD7F-3757-97D9-7F825DE347DC}']
  { getters & setters } 

    function get_CommandText: string;
    procedure set_CommandText(value: string);
    function get_CommandTimeout: Int32;
    procedure set_CommandTimeout(value: Int32);
    function get_CommandType: DNCommandType;
    procedure set_CommandType(value: DNCommandType);
    function get_Connection: DNOdbcConnection;
    procedure set_Connection(value: DNOdbcConnection);
    function get_DesignTimeVisible: Boolean;
    procedure set_DesignTimeVisible(value: Boolean);
    function get_Parameters: DNOdbcParameterCollection;
    function get_Transaction: DNOdbcTransaction;
    procedure set_Transaction(value: DNOdbcTransaction);
    function get_UpdatedRowSource: DNUpdateRowSource;
    procedure set_UpdatedRowSource(value: DNUpdateRowSource);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Tries to cancel the execution of an <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  .</summary>
    procedure Cancel;
    ///<summary>Resets the <see cref="P:System.Data.Odbc.OdbcCommand.CommandTimeout" />
    ///  property to the default value.</summary>
    procedure ResetCommandTimeout;
    ///<summary>Creates a new instance of an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    function CreateParameter: DNOdbcParameter;
    ///<summary>Executes an SQL statement against the <see cref="P:System.Data.Odbc.OdbcCommand.Connection" />
    ///  and returns the number of rows affected.</summary>
    ///<returns>For UPDATE, INSERT, and DELETE statements, the return value is the number of rows affected by the command. For all other types of statements, the return value is -1.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection does not exist.-or- The connection is not open. </exception>
    function ExecuteNonQuery: Int32;
    ///<summary>Sends the <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" />
    ///  to the <see cref="P:System.Data.Odbc.OdbcCommand.Connection" />
    ///  and builds an <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  object.</returns>
    function ExecuteReader: DNOdbcDataReader; overload;
    ///<summary>Sends the <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" />
    ///  to the <see cref="P:System.Data.Odbc.OdbcCommand.Connection" />
    ///  , and builds an <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  using one of the <see langword="CommandBehavior" />
    ///  values.</summary>
    ///  <param name="behavior">One of the <see langword="System.Data.CommandBehavior" />
    ///  values. </param>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  object.</returns>
    function ExecuteReader(behavior: DNCommandBehavior): DNOdbcDataReader; overload;
    ///<summary>Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.</summary>
    ///<returns>The first column of the first row in the result set, or a null reference if the result set is empty.</returns>
    function ExecuteScalar: DDN.mscorlib.DNObject;
    ///<summary>Creates a prepared or compiled version of the command at the data source.</summary>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Data.Odbc.OdbcCommand.Connection" />
    ///  is not set.-or- The <see cref="P:System.Data.Odbc.OdbcCommand.Connection" />
    ///  is not <see cref="M:System.Data.Odbc.OdbcConnection.Open" />
    ///  . </exception>
    procedure Prepare;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  , which executes a SQL statement against a connection object.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync: DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  . Providers should override with an appropriate implementation. The cancellation token may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellation token.  Exceptions thrown by <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbCommand" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync: DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  . This method propagates a notification that operations should be canceled.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  , which executes the query and returns the first column of the first row in the result set returned by the query. All other columns and rows are ignored.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  . Providers should override with an appropriate implementation. The cancellation token may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellation token. Exceptions thrown by ExecuteScalar will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbCommand" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the SQL statement or stored procedure to execute against the data source.</summary>
    ///<returns>The SQL statement or stored procedure to execute. The default value is an empty string ("").</returns>
    property CommandText: string read get_CommandText write set_CommandText;
    ///<summary>Gets or sets the wait time before terminating an attempt to execute a command and generating an error.</summary>
    ///<returns>The time in seconds to wait for the command to execute. The default is 30 seconds.</returns>
    property CommandTimeout: Int32 read get_CommandTimeout write set_CommandTimeout;
    ///<summary>Gets or sets a value that indicates how the <see cref="P:System.Data.Odbc.OdbcCommand.CommandText" />
    ///  property is interpreted.</summary>
    ///<returns>One of the <see cref="T:System.Data.CommandType" />
    ///  values. The default is <see langword="Text" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value was not a valid <see cref="T:System.Data.CommandType" />
    ///  . </exception>
    property CommandType: DNCommandType read get_CommandType write set_CommandType;
    ///<summary>Gets or sets the <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  used by this instance of the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  .</summary>
    ///<returns>The connection to a data source. The default is a null value.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Data.Odbc.OdbcCommand.Connection" />
    ///  property was changed while a transaction was in progress. </exception>
    property Connection: DNOdbcConnection read get_Connection write set_Connection;
    ///<summary>Gets or sets a value that indicates whether the command object should be visible in a customized interface control.</summary>
    ///<returns>
    ///  true, if the command object should be visible in a control; otherwise false. The default is true.</returns>
    property DesignTimeVisible: Boolean read get_DesignTimeVisible write set_DesignTimeVisible;
    ///<summary>Gets the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///<returns>The parameters of the SQL statement or stored procedure. The default is an empty collection.</returns>
    property Parameters: DNOdbcParameterCollection read get_Parameters;
    ///<summary>Gets or sets the <see cref="T:System.Data.Odbc.OdbcTransaction" />
    ///  within which the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  executes.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcTransaction" />
    ///  . The default is a null value.</returns>
    property Transaction: DNOdbcTransaction read get_Transaction write set_Transaction;
    ///<summary>Gets or sets a value that specifies how the Update method should apply command results to the DataRow.</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values.</returns>
    property UpdatedRowSource: DNUpdateRowSource read get_UpdatedRowSource write set_UpdatedRowSource;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOdbcCommand = class(TDNGenericImport<DNOdbcCommandClass, DNOdbcCommand>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbCommandClass = interface(DNDbCommandClass)
  ['{3A2CB0B2-4101-5FB1-87AD-B7F8BD8CBEC5}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  class.</summary>
    {class} function init: DNOleDbCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  class with the text of the query.</summary>
    ///  <param name="cmdText">The text of the query. </param>
    {class} function init(cmdText: string): DNOleDbCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  class with the text of the query and an <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  .</summary>
    ///  <param name="cmdText">The text of the query. </param>
    ///  <param name="connection">An <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  that represents the connection to a data source. </param>
    {class} function init(cmdText: string; connection: DNOleDbConnection): DNOleDbCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  class with the text of the query, an <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  , and the <see cref="P:System.Data.OleDb.OleDbCommand.Transaction" />
    ///  .</summary>
    ///  <param name="cmdText">The text of the query. </param>
    ///  <param name="connection">An <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  that represents the connection to a data source. </param>
    ///  <param name="transaction">The transaction in which the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  executes. </param>
    {class} function init(cmdText: string; connection: DNOleDbConnection; transaction: DNOleDbTransaction): DNOleDbCommand; overload;

  end;

  ///<summary>Represents an SQL statement or stored procedure to execute against a data source.</summary>
  [DNTypeName('System.Data.OleDb.OleDbCommand')]
  DNOleDbCommand = interface(DNDbCommand)
  ['{8297BC84-C7C9-3FF2-82F8-076658B9225A}']
  { getters & setters } 

    function get_CommandText: string;
    procedure set_CommandText(value: string);
    function get_CommandTimeout: Int32;
    procedure set_CommandTimeout(value: Int32);
    function get_CommandType: DNCommandType;
    procedure set_CommandType(value: DNCommandType);
    function get_Connection: DNOleDbConnection;
    procedure set_Connection(value: DNOleDbConnection);
    function get_DesignTimeVisible: Boolean;
    procedure set_DesignTimeVisible(value: Boolean);
    function get_Parameters: DNOleDbParameterCollection;
    function get_Transaction: DNOleDbTransaction;
    procedure set_Transaction(value: DNOleDbTransaction);
    function get_UpdatedRowSource: DNUpdateRowSource;
    procedure set_UpdatedRowSource(value: DNUpdateRowSource);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Resets the <see cref="P:System.Data.OleDb.OleDbCommand.CommandTimeout" />
    ///  property to the default value.</summary>
    procedure ResetCommandTimeout;
    ///<summary>Tries to cancel the execution of an <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  .</summary>
    procedure Cancel;
    ///<summary>Creates a new <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object that is a copy of the current instance.</summary>
    ///<returns>A new <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object that is a copy of this instance.</returns>
    function Clone: DNOleDbCommand;
    ///<summary>Creates a new instance of an <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    function CreateParameter: DNOleDbParameter;
    ///<summary>Sends the <see cref="P:System.Data.OleDb.OleDbCommand.CommandText" />
    ///  to the <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  and builds an <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">Cannot execute a command within a transaction context that differs from the context in which the connection was originally enlisted. </exception>
    function ExecuteReader: DNOleDbDataReader; overload;
    ///<summary>Sends the <see cref="P:System.Data.OleDb.OleDbCommand.CommandText" />
    ///  to the <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  , and builds an <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  using one of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values. </param>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">Cannot execute a command within a transaction context that differs from the context in which the connection was originally enlisted. </exception>
    function ExecuteReader(behavior: DNCommandBehavior): DNOleDbDataReader; overload;
    ///<summary>Executes an SQL statement against the <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  and returns the number of rows affected.</summary>
    ///<returns>The number of rows affected.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection does not exist.-or- The connection is not open.-or- Cannot execute a command within a transaction context that differs from the context in which the connection was originally enlisted. </exception>
    function ExecuteNonQuery: Int32;
    ///<summary>Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.</summary>
    ///<returns>The first column of the first row in the result set, or a null reference if the result set is empty.</returns>
    ///<exception cref="T:System.InvalidOperationException">Cannot execute a command within a transaction context that differs from the context in which the connection was originally enlisted. </exception>
    function ExecuteScalar: DDN.mscorlib.DNObject;
    ///<summary>Creates a prepared (or compiled) version of the command on the data source.</summary>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  is not set.-or- The <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  is not open. </exception>
    procedure Prepare;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  , which executes a SQL statement against a connection object.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync: DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  . Providers should override with an appropriate implementation. The cancellation token may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellation token.  Exceptions thrown by <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbCommand" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync: DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  . This method propagates a notification that operations should be canceled.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="Overload:System.Data.Common.DbCommand.ExecuteReader" />
    ///  , which executes the <see cref="P:System.Data.Common.DbCommand.CommandText" />
    ///  against the <see cref="P:System.Data.Common.DbCommand.Connection" />
    ///  and returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  .Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteDbDataReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  .</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNDbDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  , which executes the query and returns the first column of the first row in the result set returned by the query. All other columns and rows are ignored.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  . Providers should override with an appropriate implementation. The cancellation token may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellation token. Exceptions thrown by ExecuteScalar will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbCommand" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the SQL statement or stored procedure to execute at the data source.</summary>
    ///<returns>The SQL statement or stored procedure to execute. The default value is an empty string.</returns>
    property CommandText: string read get_CommandText write set_CommandText;
    ///<summary>Gets or sets the wait time before terminating an attempt to execute a command and generating an error.</summary>
    ///<returns>The time (in seconds) to wait for the command to execute. The default is 30 seconds.</returns>
    property CommandTimeout: Int32 read get_CommandTimeout write set_CommandTimeout;
    ///<summary>Gets or sets a value that indicates how the <see cref="P:System.Data.OleDb.OleDbCommand.CommandText" />
    ///  property is interpreted.</summary>
    ///<returns>One of the <see cref="P:System.Data.OleDb.OleDbCommand.CommandType" />
    ///  values. The default is Text.</returns>
    ///<exception cref="T:System.ArgumentException">The value was not a valid <see cref="P:System.Data.OleDb.OleDbCommand.CommandType" />
    ///  .</exception>
    property CommandType: DNCommandType read get_CommandType write set_CommandType;
    ///<summary>Gets or sets the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  used by this instance of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  .</summary>
    ///<returns>The connection to a data source. The default value is <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Data.OleDb.OleDbCommand.Connection" />
    ///  property was changed while a transaction was in progress. </exception>
    property Connection: DNOleDbConnection read get_Connection write set_Connection;
    ///<summary>Gets or sets a value that indicates whether the command object should be visible in a customized Windows Forms Designer control.</summary>
    ///<returns>A value that indicates whether the command object should be visible in a control. The default is <see langword="true" />
    ///  .</returns>
    property DesignTimeVisible: Boolean read get_DesignTimeVisible write set_DesignTimeVisible;
    ///<summary>Gets the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///<returns>The parameters of the SQL statement or stored procedure. The default is an empty collection.</returns>
    property Parameters: DNOleDbParameterCollection read get_Parameters;
    ///<summary>Gets or sets the <see cref="T:System.Data.OleDb.OleDbTransaction" />
    ///  within which the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  executes.</summary>
    ///<returns>The <see cref="T:System.Data.OleDb.OleDbTransaction" />
    ///  . The default value is <see langword="null" />
    ///  .</returns>
    property Transaction: DNOleDbTransaction read get_Transaction write set_Transaction;
    ///<summary>Gets or sets how command results are applied to the <see cref="T:System.Data.DataRow" />
    ///  when used by the <see langword="Update" />
    ///  method of the <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values.</returns>
    ///<exception cref="T:System.ArgumentException">The value entered was not one of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values.</exception>
    property UpdatedRowSource: DNUpdateRowSource read get_UpdatedRowSource write set_UpdatedRowSource;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOleDbCommand = class(TDNGenericImport<DNOleDbCommandClass, DNOleDbCommand>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlCommandClass = interface(DNDbCommandClass)
  ['{CC985FF6-C9B0-52BF-902E-E57FAEBF1EAC}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  class.</summary>
    {class} function init: DNSqlCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  class with the text of the query.</summary>
    ///  <param name="cmdText">The text of the query. </param>
    {class} function init(cmdText: string): DNSqlCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  class with the text of the query and a <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  .</summary>
    ///  <param name="cmdText">The text of the query. </param>
    ///  <param name="connection">A <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  that represents the connection to an instance of SQL Server. </param>
    {class} function init(cmdText: string; connection: DNSqlConnection): DNSqlCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  class with the text of the query, a <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  , and the <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  .</summary>
    ///  <param name="cmdText">The text of the query. </param>
    ///  <param name="connection">A <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  that represents the connection to an instance of SQL Server. </param>
    ///  <param name="transaction">The <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  in which the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  executes. </param>
    {class} function init(cmdText: string; connection: DNSqlConnection; transaction: DNSqlTransaction): DNSqlCommand; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  class with specified command text, connection, transaction, and encryption setting.</summary>
    ///  <param name="cmdText">The text of the query.</param>
    ///  <param name="connection">A <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  that represents the connection to an instance of SQL Server.</param>
    ///  <param name="transaction">The <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  in which the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  executes.</param>
    ///  <param name="columnEncryptionSetting">The encryption setting. For more information, see Always Encrypted.</param>
    {class} function init(cmdText: string; connection: DNSqlConnection; transaction: DNSqlTransaction; columnEncryptionSetting: DNSqlCommandColumnEncryptionSetting): DNSqlCommand; overload;

  end;

  ///<summary>Represents a Transact-SQL statement or stored procedure to execute against a SQL Server database. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.SqlClient.SqlCommand')]
  DNSqlCommand = interface(DNDbCommand)
  ['{227D56B1-F0A1-3A78-BCE9-3C145295413D}']
  { getters & setters } 

    function get_Connection: DNSqlConnection;
    procedure set_Connection(value: DNSqlConnection);
    function get_NotificationAutoEnlist: Boolean;
    procedure set_NotificationAutoEnlist(value: Boolean);
    function get_Notification: DNSqlNotificationRequest;
    procedure set_Notification(value: DNSqlNotificationRequest);
    function get_Transaction: DNSqlTransaction;
    procedure set_Transaction(value: DNSqlTransaction);
    function get_CommandText: string;
    procedure set_CommandText(value: string);
    function get_ColumnEncryptionSetting: DNSqlCommandColumnEncryptionSetting;
    function get_CommandTimeout: Int32;
    procedure set_CommandTimeout(value: Int32);
    function get_CommandType: DNCommandType;
    procedure set_CommandType(value: DNCommandType);
    function get_DesignTimeVisible: Boolean;
    procedure set_DesignTimeVisible(value: Boolean);
    function get_Parameters: DNSqlParameterCollection;
    function get_UpdatedRowSource: DNUpdateRowSource;
    procedure set_UpdatedRowSource(value: DNUpdateRowSource);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_StatementCompleted(value: DNStatementCompletedEventHandler);
    procedure remove_StatementCompleted(value: DNStatementCompletedEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Resets the <see cref="P:System.Data.SqlClient.SqlCommand.CommandTimeout" />
    ///  property to its default value.</summary>
    procedure ResetCommandTimeout;
    ///<summary>Creates a prepared version of the command on an instance of SQL Server.</summary>
    procedure Prepare;
    ///<summary>Tries to cancel the execution of a <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .</summary>
    procedure Cancel;
    ///<summary>Creates a new instance of a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    function CreateParameter: DNSqlParameter;
    ///<summary>Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.</summary>
    ///<returns>The first column of the first row in the result set, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if the result set is empty. Returns a maximum of 2033 characters.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteScalar: DDN.mscorlib.DNObject;
    ///<summary>Executes a Transact-SQL statement against the connection and returns the number of rows affected.</summary>
    ///<returns>The number of rows affected.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteNonQuery: Int32;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />
    ///  , which returns the number of affected rows.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteNonQuery: DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  , given a callback procedure and state information.</summary>
    ///  <param name="callback">An <see cref="T:System.AsyncCallback" />
    ///  delegate that is invoked when the command's execution has completed. Pass <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Microsoft Visual Basic) to indicate that no callback is required.</param>
    ///  <param name="stateObject">A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" />
    ///  property.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />
    ///  , which returns the number of affected rows.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteNonQuery(callback: DDN.mscorlib.DNAsyncCallback; stateObject: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Finishes asynchronous execution of a Transact-SQL statement.</summary>
    ///  <param name="asyncResult">The <see cref="T:System.IAsyncResult" />
    ///  returned by the call to <see cref="M:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />
    ///  .</param>
    ///<returns>The number of rows affected (the same behavior as <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteNonQuery" />
    ///  ).</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  parameter is null (<see langword="Nothing" />
    ///  in Microsoft Visual Basic)</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />
    ///  was called more than once for a single command execution, or the method was mismatched against its execution method (for example, the code called <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />
    ///  to complete execution of a call to <see cref="M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">The amount of time specified in <see cref="P:System.Data.SqlClient.SqlCommand.CommandTimeout" />
    ///  elapsed and the asynchronous operation specified with <see cref="Overload:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />
    ///  is not complete.In some situations, <see cref="T:System.IAsyncResult" />
    ///  can be set to <see langword="IsCompleted" />
    ///  incorrectly. If this occurs and <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteNonQuery(System.IAsyncResult)" />
    ///  is called, EndExecuteNonQuery could raise a SqlException error if the amount of time specified in <see cref="P:System.Data.SqlClient.SqlCommand.CommandTimeout" />
    ///  elapsed and the asynchronous operation specified with <see cref="Overload:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />
    ///  is not complete. To correct this situation, you should either increase the value of CommandTimeout or reduce the work being done by the asynchronous operation.</exception>
    function EndExecuteNonQuery(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  and builds an <see cref="T:System.Xml.XmlReader" />
    ///  object.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteXmlReader: DDN.System.Xml.DNXmlReader;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  and returns results as an <see cref="T:System.Xml.XmlReader" />
    ///  object.</summary>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll or wait for results, or both; this value is also needed when invoking <see langword="EndExecuteXmlReader" />
    ///  , which returns a single XML value.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteXmlReader: DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  and returns results as an <see cref="T:System.Xml.XmlReader" />
    ///  object, using a callback procedure.</summary>
    ///  <param name="callback">An <see cref="T:System.AsyncCallback" />
    ///  delegate that is invoked when the command's execution has completed. Pass <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Microsoft Visual Basic) to indicate that no callback is required.</param>
    ///  <param name="stateObject">A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" />
    ///  property.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll, wait for results, or both; this value is also needed when the <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" />
    ///  is called, which returns the results of the command as XML.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteXmlReader(callback: DDN.mscorlib.DNAsyncCallback; stateObject: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Finishes asynchronous execution of a Transact-SQL statement, returning the requested data as XML.</summary>
    ///  <param name="asyncResult">The <see cref="T:System.IAsyncResult" />
    ///  returned by the call to <see cref="M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  object that can be used to fetch the resulting XML data.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  parameter is null (<see langword="Nothing" />
    ///  in Microsoft Visual Basic)</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" />
    ///  was called more than once for a single command execution, or the method was mismatched against its execution method (for example, the code called <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteXmlReader(System.IAsyncResult)" />
    ///  to complete execution of a call to <see cref="M:System.Data.SqlClient.SqlCommand.BeginExecuteNonQuery" />
    ///  .</exception>
    function EndExecuteXmlReader(asyncResult: DDN.mscorlib.DNIAsyncResult): DDN.System.Xml.DNXmlReader;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  , and retrieves one or more result sets from the server.</summary>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />
    ///  , which returns a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  instance that can be used to retrieve the returned rows.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteReader: DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  and retrieves one or more result sets from the server, given a callback procedure and state information.</summary>
    ///  <param name="callback">An <see cref="T:System.AsyncCallback" />
    ///  delegate that is invoked when the command's execution has completed. Pass <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Microsoft Visual Basic) to indicate that no callback is required.</param>
    ///  <param name="stateObject">A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" />
    ///  property.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll, wait for results, or both; this value is also needed when invoking <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />
    ///  , which returns a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  instance which can be used to retrieve the returned rows.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteReader(callback: DDN.mscorlib.DNAsyncCallback; stateObject: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  and builds a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">An exception occurred while executing the command against a locked row. This exception is not generated when you are using Microsoft .NET Framework version 1.0.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The current state of the connection is closed. <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReader" />
    ///  requires an open <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteReader: DNSqlDataReader; overload;
    ///<summary>Sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  , and builds a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  using one of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</param>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteReader(behavior: DNCommandBehavior): DNSqlDataReader; overload;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  using one of the <see cref="T:System.Data.CommandBehavior" />
    ///  values.</summary>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values, indicating options for statement execution and data retrieval.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll, wait for results, or both; this value is also needed when invoking <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />
    ///  , which returns a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  instance that can be used to retrieve the returned rows.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteReader(behavior: DNCommandBehavior): DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  , using one of the <see langword="CommandBehavior" />
    ///  values, and retrieving one or more result sets from the server, given a callback procedure and state information. </summary>
    ///  <param name="callback">An <see cref="T:System.AsyncCallback" />
    ///  delegate that is invoked when the command's execution has completed. Pass <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Microsoft Visual Basic) to indicate that no callback is required.</param>
    ///  <param name="stateObject">A user-defined state object that is passed to the callback procedure. Retrieve this object from within the callback procedure using the <see cref="P:System.IAsyncResult.AsyncState" />
    ///  property.</param>
    ///  <param name="behavior">One of the <see cref="T:System.Data.CommandBehavior" />
    ///  values, indicating options for statement execution and data retrieval.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that can be used to poll or wait for results, or both; this value is also needed when invoking <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />
    ///  , which returns a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  instance which can be used to retrieve the returned rows.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error that occurred while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.InvalidOperationException">The name/value pair "Asynchronous Processing=true" was not included within the connection string defining the connection for this <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function BeginExecuteReader(callback: DDN.mscorlib.DNAsyncCallback; stateObject: DDN.mscorlib.DNObject; behavior: DNCommandBehavior): DDN.mscorlib.DNIAsyncResult; overload;
    ///<summary>Finishes asynchronous execution of a Transact-SQL statement, returning the requested <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .</summary>
    ///  <param name="asyncResult">The <see cref="T:System.IAsyncResult" />
    ///  returned by the call to <see cref="M:System.Data.SqlClient.SqlCommand.BeginExecuteReader" />
    ///  .</param>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  object that can be used to retrieve the requested rows.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  parameter is null (<see langword="Nothing" />
    ///  in Microsoft Visual Basic)</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />
    ///  was called more than once for a single command execution, or the method was mismatched against its execution method (for example, the code called <see cref="M:System.Data.SqlClient.SqlCommand.EndExecuteReader(System.IAsyncResult)" />
    ///  to complete execution of a call to <see cref="M:System.Data.SqlClient.SqlCommand.BeginExecuteXmlReader" />
    ///  .</exception>
    function EndExecuteReader(asyncResult: DDN.mscorlib.DNIAsyncResult): DNSqlDataReader;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteNonQuery" />
    ///  , which executes a Transact-SQL statement against the connection and returns the number of rows affected. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteNonQueryAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReader" />
    ///  , which sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  and builds a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  . Exceptions will be reported via the returned Task object.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReaderAsync" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteReaderAsync: DDN.mscorlib.DNTask<DNSqlDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior)" />
    ///  , which sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  , and builds a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  . Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="behavior">Options for statement execution and data retrieval.  When is set to <see langword="Default" />
    ///  , <see cref="M:System.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  reads the entire row before returning a complete Task.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior): DDN.mscorlib.DNTask<DNSqlDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReader" />
    ///  , which sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  and builds a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteReaderAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNSqlDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior)" />
    ///  , which sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  , and builds a <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="behavior">Options for statement execution and data retrieval.  When is set to <see langword="Default" />
    ///  , <see cref="M:System.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  reads the entire row before returning a complete Task.</param>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.ArgumentException">An invalid <see cref="T:System.Data.CommandBehavior" />
    ///  value.</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteReaderAsync(System.Data.CommandBehavior,System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteReaderAsync(behavior: DNCommandBehavior; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DNSqlDataReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteScalar" />
    ///  , which executes the query asynchronously and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteScalarAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteXmlReader" />
    ///  , which sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  and builds an <see cref="T:System.Xml.XmlReader" />
    ///  object.Exceptions will be reported via the returned Task object.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteXmlReaderAsync: DDN.mscorlib.DNTask<DDN.System.Xml.DNXmlReader>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteXmlReader" />
    ///  , which sends the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  to the <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  and builds an <see cref="T:System.Xml.XmlReader" />
    ///  object.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidCastException">A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Binary or VarBinary was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.Stream" />
    ///  . For more information about streaming, see SqlClient Streaming Support.A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Char, NChar, NVarChar, VarChar, or  Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.IO.TextReader" />
    ///  .A <see cref="P:System.Data.SqlClient.SqlParameter.SqlDbType" />
    ///  other than Xml was used when <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  was set to <see cref="T:System.Xml.XmlReader" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  closed or dropped during a streaming operation. For more information about streaming, see SqlClient Streaming Support.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.A timeout occurred during a streaming operation. For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.IO.IOException">An error occurred in a <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.Stream" />
    ///  , <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object was closed during a streaming operation.  For more information about streaming, see SqlClient Streaming Support.</exception>
    function ExecuteXmlReaderAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<DDN.System.Xml.DNXmlReader>; overload;
    ///<summary>Creates a new <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is a copy of the current instance.</summary>
    ///<returns>A new <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is a copy of this instance.</returns>
    function Clone: DNSqlCommand;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteNonQuery" />
    ///  , which executes a SQL statement against a connection object.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteNonQueryAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteNonQueryAsync: DDN.mscorlib.DNTask<Int32>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbCommand.ExecuteScalar" />
    ///  , which executes the query and returns the first column of the first row in the result set returned by the query. All other columns and rows are ignored.Invokes <see cref="M:System.Data.Common.DbCommand.ExecuteScalarAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ExecuteScalarAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  used by this instance of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  .</summary>
    ///<returns>The connection to a data source. The default value is <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Data.SqlClient.SqlCommand.Connection" />
    ///  property was changed while the command was enlisted in a transaction.. </exception>
    property Connection: DNSqlConnection read get_Connection write set_Connection;
    ///<summary>Gets or sets a value indicating whether the application should automatically receive query notifications from a common <see cref="T:System.Data.SqlClient.SqlDependency" />
    ///  object.</summary>
    ///<returns>
    ///  true if the application should automatically receive query notifications; otherwise false. The default value is true.</returns>
    property NotificationAutoEnlist: Boolean read get_NotificationAutoEnlist write set_NotificationAutoEnlist;
    ///<summary>Gets or sets a value that specifies the <see cref="T:System.Data.Sql.SqlNotificationRequest" />
    ///  object bound to this command.</summary>
    ///<returns>When set to null (default), no notification should be requested.</returns>
    property Notification: DNSqlNotificationRequest read get_Notification write set_Notification;
    ///<summary>Gets or sets the <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  within which the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  executes.</summary>
    ///<returns>The <see cref="T:System.Data.SqlClient.SqlTransaction" />
    ///  . The default value is <see langword="null" />
    ///  .</returns>
    property Transaction: DNSqlTransaction read get_Transaction write set_Transaction;
    ///<summary>Gets or sets the Transact-SQL statement, table name or stored procedure to execute at the data source.</summary>
    ///<returns>The Transact-SQL statement or stored procedure to execute. The default is an empty string.</returns>
    property CommandText: string read get_CommandText write set_CommandText;
    ///<summary>Gets or sets the column encryption setting for this command.</summary>
    ///<returns>The column encryption setting for this command.</returns>
    property ColumnEncryptionSetting: DNSqlCommandColumnEncryptionSetting read get_ColumnEncryptionSetting;
    ///<summary>Gets or sets the wait time before terminating the attempt to execute a command and generating an error.</summary>
    ///<returns>The time in seconds to wait for the command to execute. The default is 30 seconds.</returns>
    property CommandTimeout: Int32 read get_CommandTimeout write set_CommandTimeout;
    ///<summary>Gets or sets a value indicating how the <see cref="P:System.Data.SqlClient.SqlCommand.CommandText" />
    ///  property is to be interpreted.</summary>
    ///<returns>One of the <see cref="T:System.Data.CommandType" />
    ///  values. The default is <see langword="Text" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The value was not a valid <see cref="T:System.Data.CommandType" />
    ///  . </exception>
    property CommandType: DNCommandType read get_CommandType write set_CommandType;
    ///<summary>Gets or sets a value indicating whether the command object should be visible in a Windows Form Designer control.</summary>
    ///<returns>A value indicating whether the command object should be visible in a control. The default is true.</returns>
    property DesignTimeVisible: Boolean read get_DesignTimeVisible write set_DesignTimeVisible;
    ///<summary>Gets the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///<returns>The parameters of the Transact-SQL statement or stored procedure. The default is an empty collection.</returns>
    property Parameters: DNSqlParameterCollection read get_Parameters;
    ///<summary>Gets or sets how command results are applied to the <see cref="T:System.Data.DataRow" />
    ///  when used by the Update method of the <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.UpdateRowSource" />
    ///  values.</returns>
    property UpdatedRowSource: DNUpdateRowSource read get_UpdatedRowSource write set_UpdatedRowSource;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNSqlCommand = class(TDNGenericImport<DNSqlCommandClass, DNSqlCommand>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbCommandBuilderClass = interface(DNObjectClass)
  ['{1CC1E454-A9F1-5AA6-8C86-8B46BD7F387B}']
  end;

  ///<summary>Automatically generates single-table commands used to reconcile changes made to a <see cref="T:System.Data.DataSet" />
  ///  with the associated database. This is an abstract class that can only be inherited.</summary>
  [DNTypeName('System.Data.Common.DbCommandBuilder')]
  DNDbCommandBuilder = interface(DNObject)
  ['{E3ED7AF0-DF9B-31CB-BBF1-0752C94F7459}']
  { getters & setters } 

    function get_ConflictOption: DNConflictOption;
    procedure set_ConflictOption(value: DNConflictOption);
    function get_CatalogLocation: DNCatalogLocation;
    procedure set_CatalogLocation(value: DNCatalogLocation);
    function get_CatalogSeparator: string;
    procedure set_CatalogSeparator(value: string);
    function get_DataAdapter: DNDbDataAdapter;
    procedure set_DataAdapter(value: DNDbDataAdapter);
    function get_QuotePrefix: string;
    procedure set_QuotePrefix(value: string);
    function get_QuoteSuffix: string;
    procedure set_QuoteSuffix(value: string);
    function get_SchemaSeparator: string;
    procedure set_SchemaSeparator(value: string);
    function get_SetAllValues: Boolean;
    procedure set_SetAllValues(value: Boolean);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Clears the commands associated with this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    procedure RefreshSchema;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform insertions at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand: DNDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform insertions at the data source, optionally using columns for parameter names.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand(useColumnsForParameterNames: Boolean): DNDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform updates at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand: DNDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform updates at the data source, optionally using columns for parameter names.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand(useColumnsForParameterNames: Boolean): DNDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform deletions at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand: DNDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform deletions at the data source, optionally using columns for parameter names.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.Common.DbCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand(useColumnsForParameterNames: Boolean): DNDbCommand; overload;
    ///<summary>Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier, including properly escaping any embedded quotes in the identifier.</summary>
    ///  <param name="unquotedIdentifier">The original unquoted identifier.</param>
    ///<returns>The quoted version of the identifier. Embedded quotes within the identifier are properly escaped.</returns>
    function QuoteIdentifier(unquotedIdentifier: string): string;
    ///<summary>Given a quoted identifier, returns the correct unquoted form of that identifier, including properly un-escaping any embedded quotes in the identifier.</summary>
    ///  <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
    ///<returns>The unquoted identifier, with embedded quotes properly un-escaped.</returns>
    function UnquoteIdentifier(quotedIdentifier: string): string;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Specifies which <see cref="T:System.Data.ConflictOption" />
    ///  is to be used by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    ///<returns>Returns one of the <see cref="T:System.Data.ConflictOption" />
    ///  values describing the behavior of this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    property ConflictOption: DNConflictOption read get_ConflictOption write set_ConflictOption;
    ///<summary>Sets or gets the <see cref="T:System.Data.Common.CatalogLocation" />
    ///  for an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A <see cref="T:System.Data.Common.CatalogLocation" />
    ///  object.</returns>
    property CatalogLocation: DNCatalogLocation read get_CatalogLocation write set_CatalogLocation;
    ///<summary>Sets or gets a string used as the catalog separator for an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A string indicating the catalog separator for use with an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</returns>
    property CatalogSeparator: string read get_CatalogSeparator write set_CatalogSeparator;
    ///<summary>Gets or sets a <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  object for which Transact-SQL statements are automatically generated.</summary>
    ///<returns>A <see cref="T:System.Data.Common.DbDataAdapter" />
    ///  object.</returns>
    property DataAdapter: DNDbDataAdapter read get_DataAdapter write set_DataAdapter;
    ///<summary>Gets or sets the beginning character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The beginning character or characters to use. The default is an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">This property cannot be changed after an insert, update, or delete command has been generated. </exception>
    property QuotePrefix: string read get_QuotePrefix write set_QuotePrefix;
    ///<summary>Gets or sets the ending character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The ending character or characters to use. The default is an empty string.</returns>
    property QuoteSuffix: string read get_QuoteSuffix write set_QuoteSuffix;
    ///<summary>Gets or sets the character to be used for the separator between the schema identifier and any other identifiers.</summary>
    ///<returns>The character to be used as the schema separator.</returns>
    property SchemaSeparator: string read get_SchemaSeparator write set_SchemaSeparator;
    ///<summary>Specifies whether all column values in an update statement are included or only changed ones.</summary>
    ///<returns><see langword="true" />
    ///  if the UPDATE statement generated by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  includes all columns; <see langword="false" />
    ///  if it includes only changed columns.</returns>
    property SetAllValues: Boolean read get_SetAllValues write set_SetAllValues;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNDbCommandBuilder = class(TDNGenericImport<DNDbCommandBuilderClass, DNDbCommandBuilder>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcCommandBuilderClass = interface(DNDbCommandBuilderClass)
  ['{EE20785E-84E4-5F70-8C13-7ACA63D3CAD0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcCommandBuilder" />
    ///  class.</summary>
    {class} function init: DNOdbcCommandBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcCommandBuilder" />
    ///  class with the associated <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  object.</summary>
    ///  <param name="adapter">An <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  object to associate with this <see cref="T:System.Data.Odbc.OdbcCommandBuilder" />
    ///  .</param>
    {class} function init(adapter: DNOdbcDataAdapter): DNOdbcCommandBuilder; overload;

  { static methods } 

    ///<summary>Retrieves parameter information from the stored procedure specified in the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  and populates the <see cref="P:System.Data.Odbc.OdbcCommand.Parameters" />
    ///  collection of the specified <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object.</summary>
    ///  <param name="command">The <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  referencing the stored procedure from which the parameter information is to be derived. The derived parameters are added to the <see cref="P:System.Data.Odbc.OdbcCommand.Parameters" />
    ///  collection of the <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  . </param>
    ///<exception cref="T:System.InvalidOperationException">The underlying ODBC driver does not support returning stored procedure parameter information, or the command text is not a valid stored procedure name, or the <see cref="T:System.Data.CommandType" />
    ///  specified was not <see langword="CommandType.StoredProcedure" />
    ///  . </exception>
    {class} procedure DeriveParameters(command: DNOdbcCommand);

  end;

  ///<summary>Automatically generates single-table commands that are used to reconcile changes made to a <see cref="T:System.Data.DataSet" />
  ///  with the associated data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcCommandBuilder')]
  DNOdbcCommandBuilder = interface(DNDbCommandBuilder)
  ['{B3070EF9-1EB5-3D69-A515-4BC58D761A8C}']
  { getters & setters } 

    function get_DataAdapter: DNOdbcDataAdapter;
    procedure set_DataAdapter(value: DNOdbcDataAdapter);
    function get_ConflictOption: DNConflictOption;
    procedure set_ConflictOption(value: DNConflictOption);
    function get_CatalogLocation: DNCatalogLocation;
    procedure set_CatalogLocation(value: DNCatalogLocation);
    function get_CatalogSeparator: string;
    procedure set_CatalogSeparator(value: string);
    function get_QuotePrefix: string;
    procedure set_QuotePrefix(value: string);
    function get_QuoteSuffix: string;
    procedure set_QuoteSuffix(value: string);
    function get_SchemaSeparator: string;
    procedure set_SchemaSeparator(value: string);
    function get_SetAllValues: Boolean;
    procedure set_SetAllValues(value: Boolean);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier. This includes correctly escaping any embedded quotes in the identifier.</summary>
    ///  <param name="unquotedIdentifier">The original unquoted identifier.</param>
    ///<returns>The quoted version of the identifier. Embedded quotes within the identifier are correctly escaped.</returns>
    function QuoteIdentifier(unquotedIdentifier: string): string; overload;
    ///<summary>Given a quoted identifier, returns the correct unquoted form of that identifier, including correctly unescaping any embedded quotes in the identifier.</summary>
    ///  <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
    ///<returns>The unquoted identifier, with embedded quotes correctly unescaped.</returns>
    function UnquoteIdentifier(quotedIdentifier: string): string; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform insertions at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand: DNOdbcCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform insertions at the data source.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if it is possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand(useColumnsForParameterNames: Boolean): DNOdbcCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform updates at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand: DNOdbcCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform updates at the data source.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if it is possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand(useColumnsForParameterNames: Boolean): DNOdbcCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform deletions at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand: DNOdbcCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform deletions at the data source.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if it is possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand(useColumnsForParameterNames: Boolean): DNOdbcCommand; overload;
    ///<summary>Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier. This includes correctly escaping any embedded quotes in the identifier.</summary>
    ///  <param name="unquotedIdentifier">The original unquoted identifier.</param>
    ///  <param name="connection">When a connection is passed, causes the managed wrapper to get the quote character from the ODBC driver, calling SQLGetInfo(SQL_IDENTIFIER_QUOTE_CHAR). When no connection is passed, the string is quoted using values from <see cref="P:System.Data.Common.DbCommandBuilder.QuotePrefix" />
    ///  and <see cref="P:System.Data.Common.DbCommandBuilder.QuoteSuffix" />
    ///  .</param>
    ///<returns>The quoted version of the identifier. Embedded quotes within the identifier are correctly escaped.</returns>
    function QuoteIdentifier(unquotedIdentifier: string; connection: DNOdbcConnection): string; overload;
    ///<summary>Given a quoted identifier, returns the correct unquoted form of that identifier, including correctly unescaping any embedded quotes in the identifier.</summary>
    ///  <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
    ///  <param name="connection">The <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  .</param>
    ///<returns>The unquoted identifier, with embedded quotes correctly unescaped.</returns>
    function UnquoteIdentifier(quotedIdentifier: string; connection: DNOdbcConnection): string; overload;
    ///<summary>Clears the commands associated with this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    procedure RefreshSchema;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets an <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  object for which this <see cref="T:System.Data.Odbc.OdbcCommandBuilder" />
    ///  object will generate SQL statements.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcDataAdapter" />
    ///  object that is associated with this <see cref="T:System.Data.Odbc.OdbcCommandBuilder" />
    ///  .</returns>
    property DataAdapter: DNOdbcDataAdapter read get_DataAdapter write set_DataAdapter;
    ///<summary>Specifies which <see cref="T:System.Data.ConflictOption" />
    ///  is to be used by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    ///<returns>Returns one of the <see cref="T:System.Data.ConflictOption" />
    ///  values describing the behavior of this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    property ConflictOption: DNConflictOption read get_ConflictOption write set_ConflictOption;
    ///<summary>Sets or gets the <see cref="T:System.Data.Common.CatalogLocation" />
    ///  for an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A <see cref="T:System.Data.Common.CatalogLocation" />
    ///  object.</returns>
    property CatalogLocation: DNCatalogLocation read get_CatalogLocation write set_CatalogLocation;
    ///<summary>Sets or gets a string used as the catalog separator for an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A string indicating the catalog separator for use with an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</returns>
    property CatalogSeparator: string read get_CatalogSeparator write set_CatalogSeparator;
    ///<summary>Gets or sets the beginning character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The beginning character or characters to use. The default is an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">This property cannot be changed after an insert, update, or delete command has been generated. </exception>
    property QuotePrefix: string read get_QuotePrefix write set_QuotePrefix;
    ///<summary>Gets or sets the ending character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The ending character or characters to use. The default is an empty string.</returns>
    property QuoteSuffix: string read get_QuoteSuffix write set_QuoteSuffix;
    ///<summary>Gets or sets the character to be used for the separator between the schema identifier and any other identifiers.</summary>
    ///<returns>The character to be used as the schema separator.</returns>
    property SchemaSeparator: string read get_SchemaSeparator write set_SchemaSeparator;
    ///<summary>Specifies whether all column values in an update statement are included or only changed ones.</summary>
    ///<returns><see langword="true" />
    ///  if the UPDATE statement generated by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  includes all columns; <see langword="false" />
    ///  if it includes only changed columns.</returns>
    property SetAllValues: Boolean read get_SetAllValues write set_SetAllValues;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOdbcCommandBuilder = class(TDNGenericImport<DNOdbcCommandBuilderClass, DNOdbcCommandBuilder>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbCommandBuilderClass = interface(DNDbCommandBuilderClass)
  ['{8F35996D-C13E-554B-9A52-D54D292B0915}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbCommandBuilder" />
    ///  class.</summary>
    {class} function init: DNOleDbCommandBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbCommandBuilder" />
    ///  class with the associated <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  object.</summary>
    ///  <param name="adapter">An <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  . </param>
    {class} function init(adapter: DNOleDbDataAdapter): DNOleDbCommandBuilder; overload;

  { static methods } 

    ///<summary>Retrieves parameter information from the stored procedure specified in the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  and populates the <see cref="P:System.Data.OleDb.OleDbCommand.Parameters" />
    ///  collection of the specified <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object.</summary>
    ///  <param name="command">The <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  referencing the stored procedure from which the parameter information is to be derived. The derived parameters are added to the <see cref="P:System.Data.OleDb.OleDbCommand.Parameters" />
    ///  collection of the <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  . </param>
    ///<exception cref="T:System.InvalidOperationException">The underlying OLE DB provider does not support returning stored procedure parameter information, the command text is not a valid stored procedure name, or the <see cref="P:System.Data.OleDb.OleDbCommand.CommandType" />
    ///  specified was not <see langword="StoredProcedure" />
    ///  .</exception>
    {class} procedure DeriveParameters(command: DNOleDbCommand);

  end;

  ///<summary>Automatically generates single-table commands that are used to reconcile changes made to a <see cref="T:System.Data.DataSet" />
  ///  with the associated database. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.OleDb.OleDbCommandBuilder')]
  DNOleDbCommandBuilder = interface(DNDbCommandBuilder)
  ['{37CBF99A-AA08-36FD-94A1-56786EADC080}']
  { getters & setters } 

    function get_DataAdapter: DNOleDbDataAdapter;
    procedure set_DataAdapter(value: DNOleDbDataAdapter);
    function get_ConflictOption: DNConflictOption;
    procedure set_ConflictOption(value: DNConflictOption);
    function get_CatalogLocation: DNCatalogLocation;
    procedure set_CatalogLocation(value: DNCatalogLocation);
    function get_CatalogSeparator: string;
    procedure set_CatalogSeparator(value: string);
    function get_QuotePrefix: string;
    procedure set_QuotePrefix(value: string);
    function get_QuoteSuffix: string;
    procedure set_QuoteSuffix(value: string);
    function get_SchemaSeparator: string;
    procedure set_SchemaSeparator(value: string);
    function get_SetAllValues: Boolean;
    procedure set_SetAllValues(value: Boolean);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier. This includes correctly escaping any embedded quotes in the identifier.</summary>
    ///  <param name="unquotedIdentifier">The original unquoted identifier.</param>
    ///<returns>The quoted version of the identifier. Embedded quotes within the identifier are correctly escaped.</returns>
    function QuoteIdentifier(unquotedIdentifier: string): string; overload;
    ///<summary>Given a quoted identifier, returns the correct unquoted form of that identifier. This includes correctly un-escaping any embedded quotes in the identifier.</summary>
    ///  <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
    ///<returns>The unquoted identifier, with embedded quotes correctly un-escaped.</returns>
    function UnquoteIdentifier(quotedIdentifier: string): string; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform insertions at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand: DNOleDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform insertions at the data source.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if it is possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand(useColumnsForParameterNames: Boolean): DNOleDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform updates at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand: DNOleDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform updates at the data source, optionally using columns for parameter names.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if it is possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand(useColumnsForParameterNames: Boolean): DNOleDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform deletions at the data source.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand: DNOleDbCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform deletions at the data source.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names, if it is possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand(useColumnsForParameterNames: Boolean): DNOleDbCommand; overload;
    ///<summary>Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier. This includes correctly escaping any embedded quotes in the identifier.</summary>
    ///  <param name="unquotedIdentifier">The unquoted identifier to be returned in quoted format.</param>
    ///  <param name="connection">When a connection is passed, causes the managed wrapper to get the quote character from the OLE DB provider. When no connection is passed, the string is quoted using values from <see cref="P:System.Data.Common.DbCommandBuilder.QuotePrefix" />
    ///  and <see cref="P:System.Data.Common.DbCommandBuilder.QuoteSuffix" />
    ///  .</param>
    ///<returns>The quoted version of the identifier. Embedded quotes within the identifier are correctly escaped.</returns>
    function QuoteIdentifier(unquotedIdentifier: string; connection: DNOleDbConnection): string; overload;
    ///<summary>Given a quoted identifier, returns the correct unquoted form of that identifier. This includes correctly un-escaping any embedded quotes in the identifier.</summary>
    ///  <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
    ///  <param name="connection">The <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  .</param>
    ///<returns>The unquoted identifier, with embedded quotes correctly un-escaped.</returns>
    function UnquoteIdentifier(quotedIdentifier: string; connection: DNOleDbConnection): string; overload;
    ///<summary>Clears the commands associated with this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    procedure RefreshSchema;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets an <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  object for which SQL statements are automatically generated.</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbDataAdapter" />
    ///  object.</returns>
    property DataAdapter: DNOleDbDataAdapter read get_DataAdapter write set_DataAdapter;
    ///<summary>Specifies which <see cref="T:System.Data.ConflictOption" />
    ///  is to be used by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    ///<returns>Returns one of the <see cref="T:System.Data.ConflictOption" />
    ///  values describing the behavior of this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    property ConflictOption: DNConflictOption read get_ConflictOption write set_ConflictOption;
    ///<summary>Sets or gets the <see cref="T:System.Data.Common.CatalogLocation" />
    ///  for an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A <see cref="T:System.Data.Common.CatalogLocation" />
    ///  object.</returns>
    property CatalogLocation: DNCatalogLocation read get_CatalogLocation write set_CatalogLocation;
    ///<summary>Sets or gets a string used as the catalog separator for an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</summary>
    ///<returns>A string indicating the catalog separator for use with an instance of the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  class.</returns>
    property CatalogSeparator: string read get_CatalogSeparator write set_CatalogSeparator;
    ///<summary>Gets or sets the beginning character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The beginning character or characters to use. The default is an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">This property cannot be changed after an insert, update, or delete command has been generated. </exception>
    property QuotePrefix: string read get_QuotePrefix write set_QuotePrefix;
    ///<summary>Gets or sets the ending character or characters to use when specifying database objects (for example, tables or columns) whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The ending character or characters to use. The default is an empty string.</returns>
    property QuoteSuffix: string read get_QuoteSuffix write set_QuoteSuffix;
    ///<summary>Gets or sets the character to be used for the separator between the schema identifier and any other identifiers.</summary>
    ///<returns>The character to be used as the schema separator.</returns>
    property SchemaSeparator: string read get_SchemaSeparator write set_SchemaSeparator;
    ///<summary>Specifies whether all column values in an update statement are included or only changed ones.</summary>
    ///<returns><see langword="true" />
    ///  if the UPDATE statement generated by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  includes all columns; <see langword="false" />
    ///  if it includes only changed columns.</returns>
    property SetAllValues: Boolean read get_SetAllValues write set_SetAllValues;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOleDbCommandBuilder = class(TDNGenericImport<DNOleDbCommandBuilderClass, DNOleDbCommandBuilder>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlCommandBuilderClass = interface(DNDbCommandBuilderClass)
  ['{B2CCD562-232F-5195-99E9-3B71EE7DF204}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />
    ///  class.</summary>
    {class} function init: DNSqlCommandBuilder; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />
    ///  class with the associated <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  object.</summary>
    ///  <param name="adapter">The name of the <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  . </param>
    {class} function init(adapter: DNSqlDataAdapter): DNSqlCommandBuilder; overload;

  { static methods } 

    ///<summary>Retrieves parameter information from the stored procedure specified in the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  and populates the <see cref="P:System.Data.SqlClient.SqlCommand.Parameters" />
    ///  collection of the specified <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object.</summary>
    ///  <param name="command">The <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  referencing the stored procedure from which the parameter information is to be derived. The derived parameters are added to the <see cref="P:System.Data.SqlClient.SqlCommand.Parameters" />
    ///  collection of the <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  . </param>
    ///<exception cref="T:System.InvalidOperationException">The command text is not a valid stored procedure name. </exception>
    {class} procedure DeriveParameters(command: DNSqlCommand);

  end;

  ///<summary>Automatically generates single-table commands that are used to reconcile changes made to a <see cref="T:System.Data.DataSet" />
  ///  with the associated SQL Server database. This class cannot be inherited. </summary>
  [DNTypeName('System.Data.SqlClient.SqlCommandBuilder')]
  DNSqlCommandBuilder = interface(DNDbCommandBuilder)
  ['{DF7ADC5F-E439-3079-A773-8954876B15BE}']
  { getters & setters } 

    function get_CatalogLocation: DNCatalogLocation;
    procedure set_CatalogLocation(value: DNCatalogLocation);
    function get_CatalogSeparator: string;
    procedure set_CatalogSeparator(value: string);
    function get_DataAdapter: DNSqlDataAdapter;
    procedure set_DataAdapter(value: DNSqlDataAdapter);
    function get_QuotePrefix: string;
    procedure set_QuotePrefix(value: string);
    function get_QuoteSuffix: string;
    procedure set_QuoteSuffix(value: string);
    function get_SchemaSeparator: string;
    procedure set_SchemaSeparator(value: string);
    function get_ConflictOption: DNConflictOption;
    procedure set_ConflictOption(value: DNConflictOption);
    function get_SetAllValues: Boolean;
    procedure set_SetAllValues(value: Boolean);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Gets the automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform insertions on the database.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform insertions.</returns>
    function GetInsertCommand: DNSqlCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is required to perform insertions on the database.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names if possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is required to perform insertions.</returns>
    function GetInsertCommand(useColumnsForParameterNames: Boolean): DNSqlCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform updates on the database.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is required to perform updates.</returns>
    function GetUpdateCommand: DNSqlCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform updates on the database.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names if possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform updates.</returns>
    function GetUpdateCommand(useColumnsForParameterNames: Boolean): DNSqlCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform deletions on the database.</summary>
    ///<returns>The automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object required to perform deletions.</returns>
    function GetDeleteCommand: DNSqlCommand; overload;
    ///<summary>Gets the automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is required to perform deletions on the database.</summary>
    ///  <param name="useColumnsForParameterNames">If <see langword="true" />
    ///  , generate parameter names matching column names if possible. If <see langword="false" />
    ///  , generate @p1, @p2, and so on.</param>
    ///<returns>The automatically generated <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object that is required to perform deletions.</returns>
    function GetDeleteCommand(useColumnsForParameterNames: Boolean): DNSqlCommand; overload;
    ///<summary>Given an unquoted identifier in the correct catalog case, returns the correct quoted form of that identifier. This includes correctly escaping any embedded quotes in the identifier.</summary>
    ///  <param name="unquotedIdentifier">The original unquoted identifier.</param>
    ///<returns>The quoted version of the identifier. Embedded quotes within the identifier are correctly escaped.</returns>
    function QuoteIdentifier(unquotedIdentifier: string): string;
    ///<summary>Given a quoted identifier, returns the correct unquoted form of that identifier. This includes correctly unescaping any embedded quotes in the identifier.</summary>
    ///  <param name="quotedIdentifier">The identifier that will have its embedded quotes removed.</param>
    ///<returns>The unquoted identifier, with embedded quotes properly unescaped.</returns>
    function UnquoteIdentifier(quotedIdentifier: string): string;
    ///<summary>Clears the commands associated with this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    procedure RefreshSchema;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Sets or gets the <see cref="T:System.Data.Common.CatalogLocation" />
    ///  for an instance of the <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />
    ///  class.</summary>
    ///<returns>A <see cref="T:System.Data.Common.CatalogLocation" />
    ///  object.</returns>
    property CatalogLocation: DNCatalogLocation read get_CatalogLocation write set_CatalogLocation;
    ///<summary>Sets or gets a string used as the catalog separator for an instance of the <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />
    ///  class.</summary>
    ///<returns>A string that indicates the catalog separator for use with an instance of the <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />
    ///  class.</returns>
    property CatalogSeparator: string read get_CatalogSeparator write set_CatalogSeparator;
    ///<summary>Gets or sets a <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  object for which Transact-SQL statements are automatically generated.</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlDataAdapter" />
    ///  object.</returns>
    property DataAdapter: DNSqlDataAdapter read get_DataAdapter write set_DataAdapter;
    ///<summary>Gets or sets the starting character or characters to use when specifying SQL Server database objects, such as tables or columns, whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The starting character or characters to use. The default is an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">This property cannot be changed after an INSERT, UPDATE, or DELETE command has been generated. </exception>
    property QuotePrefix: string read get_QuotePrefix write set_QuotePrefix;
    ///<summary>Gets or sets the ending character or characters to use when specifying SQL Server database objects, such as tables or columns, whose names contain characters such as spaces or reserved tokens.</summary>
    ///<returns>The ending character or characters to use. The default is an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">This property cannot be changed after an insert, update, or delete command has been generated. </exception>
    property QuoteSuffix: string read get_QuoteSuffix write set_QuoteSuffix;
    ///<summary>Gets or sets the character to be used for the separator between the schema identifier and any other identifiers.</summary>
    ///<returns>The character to be used as the schema separator.</returns>
    property SchemaSeparator: string read get_SchemaSeparator write set_SchemaSeparator;
    ///<summary>Specifies which <see cref="T:System.Data.ConflictOption" />
    ///  is to be used by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</summary>
    ///<returns>Returns one of the <see cref="T:System.Data.ConflictOption" />
    ///  values describing the behavior of this <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  .</returns>
    property ConflictOption: DNConflictOption read get_ConflictOption write set_ConflictOption;
    ///<summary>Specifies whether all column values in an update statement are included or only changed ones.</summary>
    ///<returns><see langword="true" />
    ///  if the UPDATE statement generated by the <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  includes all columns; <see langword="false" />
    ///  if it includes only changed columns.</returns>
    property SetAllValues: Boolean read get_SetAllValues write set_SetAllValues;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNSqlCommandBuilder = class(TDNGenericImport<DNSqlCommandBuilderClass, DNSqlCommandBuilder>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbConnectionClass = interface(DNObjectClass)
  ['{62B283BB-1B18-5941-AA2D-22A2D3D7B8B5}']
  end;

  ///<summary>Represents a connection to a database. </summary>
  [DNTypeName('System.Data.Common.DbConnection')]
  DNDbConnection = interface(DNObject)
  ['{4E5995F3-B839-3C89-9E92-54B67A829185}']
  { getters & setters } 

    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_ConnectionTimeout: Int32;
    function get_Database: string;
    function get_DataSource: string;
    function get_ServerVersion: string;
    function get_State: DNConnectionState;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_StateChange(value: DNStateChangeEventHandler);
    procedure remove_StateChange(value: DNStateChangeEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Starts a database transaction.</summary>
    ///<returns>An object representing the new transaction.</returns>
    function BeginTransaction: DNDbTransaction; overload;
    ///<summary>Starts a database transaction with the specified isolation level.</summary>
    ///  <param name="isolationLevel">Specifies the isolation level for the transaction.</param>
    ///<returns>An object representing the new transaction.</returns>
    function BeginTransaction(isolationLevel: DNIsolationLevel): DNDbTransaction; overload;
    ///<summary>Closes the connection to the database. This is the preferred method of closing any open connection.</summary>
    ///<exception cref="T:System.Data.Common.DbException">The connection-level error that occurred while opening the connection. </exception>
    procedure Close;
    ///<summary>Changes the current database for an open connection.</summary>
    ///  <param name="databaseName">Specifies the name of the database for the connection to use.</param>
    procedure ChangeDatabase(databaseName: string);
    ///<summary>Creates and returns a <see cref="T:System.Data.Common.DbCommand" />
    ///  object associated with the current connection.</summary>
    ///<returns>A <see cref="T:System.Data.Common.DbCommand" />
    ///  object.</returns>
    function CreateCommand: DNDbCommand;
    ///<summary>Enlists in the specified transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.Transactions.Transaction" />
    ///  in which to enlist.</param>
    procedure EnlistTransaction(transaction: DDN.System.Transactions.DNTransaction);
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.Common.DbConnection" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema: DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.Common.DbConnection" />
    ///  using the specified string for the schema name.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="collectionName" />
    ///  is specified as null.</exception>
    function GetSchema(collectionName: string): DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.Common.DbConnection" />
    ///  using the specified string for the schema name and the specified string array for the restriction values.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return.</param>
    ///  <param name="restrictionValues">Specifies a set of restriction values for the requested schema.</param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="collectionName" />
    ///  is specified as null.</exception>
    function GetSchema(collectionName: string; restrictionValues: TArray<string>): DNDataTable; overload;
    ///<summary>Opens a database connection with the settings specified by the <see cref="P:System.Data.Common.DbConnection.ConnectionString" />
    ///  .</summary>
    procedure Open;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  , which opens a database connection with the settings specified by the <see cref="P:System.Data.Common.DbConnection.ConnectionString" />
    ///  . This method invokes the virtual method <see cref="M:System.Data.Common.DbConnection.OpenAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  . Providers should override with an appropriate implementation. The cancellation token can optionally be honored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  call and returns a completed task. The default implementation will return a cancelled task if passed an already cancelled cancellationToken. Exceptions thrown by Open will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbConnection" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the string used to open the connection.</summary>
    ///<returns>The connection string used to establish the initial connection. The exact contents of the connection string depend on the specific data source for this connection. The default value is an empty string.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the time to wait while establishing a connection before terminating the attempt and generating an error.</summary>
    ///<returns>The time (in seconds) to wait for a connection to open. The default value is determined by the specific type of connection that you are using.</returns>
    property ConnectionTimeout: Int32 read get_ConnectionTimeout;
    ///<summary>Gets the name of the current database after a connection is opened, or the database name specified in the connection string before the connection is opened.</summary>
    ///<returns>The name of the current database or the name of the database to be used after a connection is opened. The default value is an empty string.</returns>
    property Database: string read get_Database;
    ///<summary>Gets the name of the database server to which to connect.</summary>
    ///<returns>The name of the database server to which to connect. The default value is an empty string.</returns>
    property DataSource: string read get_DataSource;
    ///<summary>Gets a string that represents the version of the server to which the object is connected.</summary>
    ///<returns>The version of the database. The format of the string returned depends on the specific type of connection you are using.</returns>
    ///<exception cref="T:System.InvalidOperationException"><see cref="P:System.Data.Common.DbConnection.ServerVersion" />
    ///  was called while the returned Task was not completed and the connection was not opened after a call to <see cref="Overload:System.Data.Common.DbConnection.OpenAsync" />
    ///  .</exception>
    property ServerVersion: string read get_ServerVersion;
    ///<summary>Gets a string that describes the state of the connection.</summary>
    ///<returns>The state of the connection. The format of the string returned depends on the specific type of connection you are using.</returns>
    property State: DNConnectionState read get_State;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNDbConnection = class(TDNGenericImport<DNDbConnectionClass, DNDbConnection>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcConnectionClass = interface(DNDbConnectionClass)
  ['{CBA938C7-5777-5BAA-A324-FFDE3530E9D7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  class with the specified connection string.</summary>
    ///  <param name="connectionString">The connection used to open the data source. </param>
    {class} function init(connectionString: string): DNOdbcConnection; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  class.</summary>
    {class} function init: DNOdbcConnection; overload;

  { static methods } 

    ///<summary>Indicates that the ODBC Driver Manager environment handle can be released when the last underlying connection is released.</summary>
    {class} procedure ReleaseObjectPool;

  end;

  ///<summary>Represents an open connection to a data source. </summary>
  [DNTypeName('System.Data.Odbc.OdbcConnection')]
  DNOdbcConnection = interface(DNDbConnection)
  ['{67D42822-4C6B-372D-9939-D59B17EBD29D}']
  { getters & setters } 

    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_ConnectionTimeout: Int32;
    procedure set_ConnectionTimeout(value: Int32);
    function get_Database: string;
    function get_DataSource: string;
    function get_ServerVersion: string;
    function get_State: DNConnectionState;
    function get_Driver: string;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_InfoMessage(value: DNOdbcInfoMessageEventHandler);
    procedure remove_InfoMessage(value: DNOdbcInfoMessageEventHandler);
    procedure add_StateChange(value: DNStateChangeEventHandler);
    procedure remove_StateChange(value: DNStateChangeEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Changes the current database associated with an open <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  .</summary>
    ///  <param name="value">The database name. </param>
    ///<exception cref="T:System.ArgumentException">The database name is not valid. </exception><exception cref="T:System.InvalidOperationException">The connection is not open. </exception><exception cref="T:System.Data.Odbc.OdbcException">Cannot change the database. </exception>
    procedure ChangeDatabase(value: string);
    ///<summary>Closes the connection to the data source. </summary>
    procedure Close;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema: DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  using the specified name for the schema name.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return.</param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema(collectionName: string): DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  using the specified string for the schema name and the specified string array for the restriction values.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return.</param>
    ///  <param name="restrictionValues">Specifies a set of restriction values for the requested schema.</param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema(collectionName: string; restrictionValues: TArray<string>): DNDataTable; overload;
    ///<summary>Starts a transaction at the data source.</summary>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.InvalidOperationException">A transaction is currently active. Parallel transactions are not supported. </exception>
    function BeginTransaction: DNOdbcTransaction; overload;
    ///<summary>Starts a transaction at the data source with the specified <see cref="T:System.Data.IsolationLevel" />
    ///  value.</summary>
    ///  <param name="isolevel">The transaction isolation level for this connection. If you do not specify an isolation level, the default isolation level for the driver is used. </param>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.InvalidOperationException">A transaction is currently active. Parallel transactions are not supported. </exception>
    function BeginTransaction(isolevel: DNIsolationLevel): DNOdbcTransaction; overload;
    ///<summary>Creates and returns an <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object associated with the <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcCommand" />
    ///  object.</returns>
    function CreateCommand: DNOdbcCommand;
    ///<summary>Enlists in the specified transaction as a distributed transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.EnterpriseServices.ITransaction" />
    ///  in which to enlist.</param>
    procedure EnlistDistributedTransaction(transaction: DDN.System.EnterpriseServices.DNITransaction);
    ///<summary>Opens a connection to a data source with the property settings specified by the <see cref="P:System.Data.Odbc.OdbcConnection.ConnectionString" />
    ///  .</summary>
    ///<exception cref="T:System.NotSupportedException">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead. </exception>
    procedure Open;
    ///<summary>Enlists in the specified transaction as a distributed transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.Transactions.Transaction" />
    ///  in which to enlist.</param>
    procedure EnlistTransaction(transaction: DDN.System.Transactions.DNTransaction);
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  , which opens a database connection with the settings specified by the <see cref="P:System.Data.Common.DbConnection.ConnectionString" />
    ///  . This method invokes the virtual method <see cref="M:System.Data.Common.DbConnection.OpenAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  . Providers should override with an appropriate implementation. The cancellation token can optionally be honored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  call and returns a completed task. The default implementation will return a cancelled task if passed an already cancelled cancellationToken. Exceptions thrown by Open will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbConnection" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the string used to open a data source.</summary>
    ///<returns>The ODBC driver connection string that includes settings, such as the data source name, needed to establish the initial connection. The default value is an empty string (""). The maximum length is 1024 characters.</returns>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets or sets the time to wait while trying to establish a connection before terminating the attempt and generating an error.</summary>
    ///<returns>The time in seconds to wait for a connection to open. The default value is 15 seconds.</returns>
    ///<exception cref="T:System.ArgumentException">The value set is less than 0. </exception>
    property ConnectionTimeout: Int32 read get_ConnectionTimeout write set_ConnectionTimeout;
    ///<summary>Gets the name of the current database or the database to be used after a connection is opened.</summary>
    ///<returns>The name of the current database. The default value is an empty string ("") until the connection is opened.</returns>
    property Database: string read get_Database;
    ///<summary>Gets the server name or file name of the data source.</summary>
    ///<returns>The server name or file name of the data source. The default value is an empty string ("") until the connection is opened.</returns>
    property DataSource: string read get_DataSource;
    ///<summary>Gets a string that contains the version of the server to which the client is connected.</summary>
    ///<returns>The version of the connected server.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection is closed. </exception>
    property ServerVersion: string read get_ServerVersion;
    ///<summary>Gets the current state of the connection.</summary>
    ///<returns>A bitwise combination of the <see cref="T:System.Data.ConnectionState" />
    ///  values. The default is <see langword="Closed" />
    ///  .</returns>
    property State: DNConnectionState read get_State;
    ///<summary>Gets the name of the ODBC driver specified for the current connection.</summary>
    ///<returns>The name of the ODBC driver. This typically is the DLL name (for example, Sqlsrv32.dll). The default value is an empty string ("") until the connection is opened.</returns>
    property Driver: string read get_Driver;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOdbcConnection = class(TDNGenericImport<DNOdbcConnectionClass, DNOdbcConnection>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbConnectionClass = interface(DNDbConnectionClass)
  ['{047A5A0F-EEC5-51A7-99FD-069EDB7AB0A5}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  class with the specified connection string.</summary>
    ///  <param name="connectionString">The connection used to open the database. </param>
    {class} function init(connectionString: string): DNOleDbConnection; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  class.</summary>
    {class} function init: DNOleDbConnection; overload;

  { static methods } 

    ///<summary>Indicates that the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  object pool can be released when the last underlying connection is released.</summary>
    {class} procedure ReleaseObjectPool;

  end;

  ///<summary>Represents an open connection to a data source.</summary>
  [DNTypeName('System.Data.OleDb.OleDbConnection')]
  DNOleDbConnection = interface(DNDbConnection)
  ['{FF833BE1-7559-39E3-8101-632D1EFCE029}']
  { getters & setters } 

    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_ConnectionTimeout: Int32;
    function get_Database: string;
    function get_DataSource: string;
    function get_Provider: string;
    function get_ServerVersion: string;
    function get_State: DNConnectionState;
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_InfoMessage(value: DNOleDbInfoMessageEventHandler);
    procedure remove_InfoMessage(value: DNOleDbInfoMessageEventHandler);
    procedure add_StateChange(value: DNStateChangeEventHandler);
    procedure remove_StateChange(value: DNStateChangeEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Closes the connection to the data source.</summary>
    procedure Close;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema: DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  using the specified string for the schema name.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema(collectionName: string): DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  using the specified string for the schema name and the specified string array for the restriction values.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return.</param>
    ///  <param name="restrictionValues">Specifies a set of restriction values for the requested schema.</param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema(collectionName: string; restrictionValues: TArray<string>): DNDataTable; overload;
    ///<summary>Updates the <see cref="P:System.Data.OleDb.OleDbConnection.State" />
    ///  property of the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  object.</summary>
    procedure ResetState;
    ///<summary>Starts a database transaction with the current <see cref="T:System.Data.IsolationLevel" />
    ///  value.</summary>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.InvalidOperationException">Parallel transactions are not supported. </exception>
    function BeginTransaction: DNOleDbTransaction; overload;
    ///<summary>Starts a database transaction with the specified isolation level.</summary>
    ///  <param name="isolationLevel">The isolation level under which the transaction should run.</param>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.InvalidOperationException">Parallel transactions are not supported. </exception>
    function BeginTransaction(isolationLevel: DNIsolationLevel): DNOleDbTransaction; overload;
    ///<summary>Changes the current database for an open <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  .</summary>
    ///  <param name="value">The database name. </param>
    ///<exception cref="T:System.ArgumentException">The database name is not valid. </exception><exception cref="T:System.InvalidOperationException">The connection is not open. </exception><exception cref="T:System.Data.OleDb.OleDbException">Cannot change the database. </exception>
    procedure ChangeDatabase(value: string);
    ///<summary>Creates and returns an <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object associated with the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbCommand" />
    ///  object.</returns>
    function CreateCommand: DNOleDbCommand;
    ///<summary>Enlists in the specified transaction as a distributed transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.EnterpriseServices.ITransaction" />
    ///  in which to enlist.</param>
    procedure EnlistDistributedTransaction(transaction: DDN.System.EnterpriseServices.DNITransaction);
    ///<summary>Returns schema information from a data source as indicated by a GUID, and after it applies the specified restrictions.</summary>
    ///  <param name="schema">One of the <see cref="T:System.Data.OleDb.OleDbSchemaGuid" />
    ///  values that specifies the schema table to return. </param>
    ///  <param name="restrictions">An <see cref="T:System.Object" />
    ///  array of restriction values. These are applied in the order of the restriction columns. That is, the first restriction value applies to the first restriction column, the second restriction value applies to the second restriction column, and so on. </param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains the requested schema information.</returns>
    ///<exception cref="T:System.Data.OleDb.OleDbException">The specified set of restrictions is invalid. </exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  is closed. </exception><exception cref="T:System.ArgumentException">The specified schema rowset is not supported by the OLE DB provider.-or- The <paramref name="schema" />
    ///  parameter contains a value of <see cref="F:System.Data.OleDb.OleDbSchemaGuid.DbInfoLiterals" />
    ///  and the <paramref name="restrictions" />
    ///  parameter contains one or more restrictions. </exception>
    function GetOleDbSchemaTable(schema: DDN.mscorlib.DNGuid; restrictions: TArray<DDN.mscorlib.DNObject>): DNDataTable;
    ///<summary>Opens a database connection with the property settings specified by the <see cref="P:System.Data.OleDb.OleDbConnection.ConnectionString" />
    ///  .</summary>
    ///<exception cref="T:System.InvalidOperationException">The connection is already open.</exception><exception cref="T:System.Data.OleDb.OleDbException">A connection-level error occurred while opening the connection.</exception>
    procedure Open;
    ///<summary>Enlists in the specified transaction as a distributed transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.Transactions.Transaction" />
    ///  in which to enlist.</param>
    procedure EnlistTransaction(transaction: DDN.System.Transactions.DNTransaction);
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  , which opens a database connection with the settings specified by the <see cref="P:System.Data.Common.DbConnection.ConnectionString" />
    ///  . This method invokes the virtual method <see cref="M:System.Data.Common.DbConnection.OpenAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  . Providers should override with an appropriate implementation. The cancellation token can optionally be honored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  call and returns a completed task. The default implementation will return a cancelled task if passed an already cancelled cancellationToken. Exceptions thrown by Open will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbConnection" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the string used to open a database.</summary>
    ///<returns>The OLE DB provider connection string that includes the data source name, and other parameters needed to establish the initial connection. The default value is an empty string.</returns>
    ///<exception cref="T:System.ArgumentException">An invalid connection string argument has been supplied or a required connection string argument has not been supplied. </exception>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the time to wait while trying to establish a connection before terminating the attempt and generating an error.</summary>
    ///<returns>The time in seconds to wait for a connection to open. The default value is 15 seconds.</returns>
    ///<exception cref="T:System.ArgumentException">The value set is less than 0. </exception>
    property ConnectionTimeout: Int32 read get_ConnectionTimeout;
    ///<summary>Gets the name of the current database or the database to be used after a connection is opened.</summary>
    ///<returns>The name of the current database or the name of the database to be used after a connection is opened. The default value is an empty string.</returns>
    property Database: string read get_Database;
    ///<summary>Gets the server name or file name of the data source.</summary>
    ///<returns>The server name or file name of the data source. The default value is an empty string.</returns>
    property DataSource: string read get_DataSource;
    ///<summary>Gets the name of the OLE DB provider specified in the "Provider= " clause of the connection string.</summary>
    ///<returns>The name of the provider as specified in the "Provider= " clause of the connection string. The default value is an empty string.</returns>
    property Provider: string read get_Provider;
    ///<summary>Gets a string that contains the version of the server to which the client is connected.</summary>
    ///<returns>The version of the connected server.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection is closed. </exception>
    property ServerVersion: string read get_ServerVersion;
    ///<summary>Gets the current state of the connection.</summary>
    ///<returns>A bitwise combination of the <see cref="T:System.Data.ConnectionState" />
    ///  values. The default is Closed.</returns>
    property State: DNConnectionState read get_State;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNOleDbConnection = class(TDNGenericImport<DNOleDbConnectionClass, DNOleDbConnection>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlConnectionClass = interface(DNDbConnectionClass)
  ['{C469825F-AD4F-5E6A-A8BD-F229AF9A0051}']
  { static getter & setter } 

    {class} function get_ColumnEncryptionTrustedMasterKeyPaths: DDN.mscorlib.DNIDictionary<string, DDN.mscorlib.DNIList<string>>;
    {class} function get_ColumnEncryptionQueryMetadataCacheEnabled: Boolean;
    {class} procedure set_ColumnEncryptionQueryMetadataCacheEnabled(value: Boolean);
    {class} function get_ColumnEncryptionKeyCacheTtl: DDN.mscorlib.DNTimeSpan;
    {class} procedure set_ColumnEncryptionKeyCacheTtl(value: DDN.mscorlib.DNTimeSpan);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  class when given a string that contains the connection string.</summary>
    ///  <param name="connectionString">The connection used to open the SQL Server database.</param>
    {class} function init(connectionString: string): DNSqlConnection; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  class given a connection string, that does not use <see langword="Integrated Security = true" />
    ///  and a <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object that contains the user ID and password.</summary>
    ///  <param name="connectionString">A connection string that does not use any of the following connection string keywords: <see langword="Integrated Security = true" />
    ///  , <see langword="UserId" />
    ///  , or <see langword="Password" />
    ///  ; or that does not use <see langword="ContextConnection = true" />
    ///  .</param>
    ///  <param name="credential">A <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object. If <paramref name="credential" />
    ///  is null, <see cref="M:System.Data.SqlClient.SqlConnection.#ctor(System.String,System.Data.SqlClient.SqlCredential)" />
    ///  is functionally equivalent to <see cref="M:System.Data.SqlClient.SqlConnection.#ctor(System.String)" />
    ///  .</param>
    {class} function init(connectionString: string; credential: DNSqlCredential): DNSqlConnection; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  class.</summary>
    {class} function init: DNSqlConnection; overload;

  { static methods } 

    ///<summary>Empties the connection pool.</summary>
    {class} procedure ClearAllPools;
    {class} procedure RegisterColumnEncryptionKeyStoreProviders(customProviders: DDN.mscorlib.DNIDictionary<string, DNSqlColumnEncryptionKeyStoreProvider>);
    ///<summary>Empties the connection pool associated with the specified connection.</summary>
    ///  <param name="connection">The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  to be cleared from the pool.</param>
    {class} procedure ClearPool(connection: DNSqlConnection);
    ///<summary>Changes the SQL Server password for the user indicated in the connection string to the supplied new password.</summary>
    ///  <param name="connectionString">The connection string that contains enough information to connect to the server that you want. The connection string must contain the user ID and the current password.</param>
    ///  <param name="newPassword">The new password to set. This password must comply with any password security policy set on the server, including minimum length, requirements for specific characters, and so on.</param>
    ///<exception cref="T:System.ArgumentException">The connection string includes the option to use integrated security. Or The <paramref name="newPassword" />
    ///  exceeds 128 characters.</exception><exception cref="T:System.ArgumentNullException">Either the <paramref name="connectionString" />
    ///  or the <paramref name="newPassword" />
    ///  parameter is null.</exception>
    {class} procedure ChangePassword(connectionString: string; newPassword: string); overload;
    ///<summary>Changes the SQL Server password for the user indicated in the <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object.</summary>
    ///  <param name="connectionString">The connection string that contains enough information to connect to a server. The connection string should not use any of the following connection string keywords: <see langword="Integrated Security = true" />
    ///  , <see langword="UserId" />
    ///  , or <see langword="Password" />
    ///  ; or <see langword="ContextConnection = true" />
    ///  .</param>
    ///  <param name="credential">A <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object.</param>
    ///  <param name="newSecurePassword">The new password. <paramref name="newSecurePassword" />
    ///  must be read only. The password must also comply with any password security policy set on the server (for example, minimum length and requirements for specific characters).</param>
    ///<exception cref="T:System.ArgumentException">The connection string contains any combination of <see langword="UserId" />
    ///  , <see langword="Password" />
    ///  , or <see langword="Integrated Security=true" />
    ///  .The connection string contains <see langword="Context Connection=true" />
    ///  .
    ///  <paramref name="newSecurePassword" />
    ///  is greater than 128 characters.
    ///  <paramref name="newSecurePassword" />
    ///  is not read only.
    ///  <paramref name="newSecurePassword" />
    ///  is an empty string.</exception><exception cref="T:System.ArgumentNullException">One of the parameters (<paramref name="connectionString" />
    ///  , <paramref name="credential" />
    ///  , or <paramref name="newSecurePassword" />
    ///  ) is null.</exception>
    {class} procedure ChangePassword(connectionString: string; credential: DNSqlCredential; newSecurePassword: DDN.mscorlib.DNSecureString); overload;

  { static propertys } 

    ///<summary>Allows you to set a list of trusted key paths for a database server. If while processing an application query the driver receives a key path that is not on the list, the query will fail. This property provides additional protection against security attacks that involve a compromised SQL Server providing fake key paths, which may lead to leaking key store credentials.</summary>
    ///<returns>The list of trusted master key paths for the column encryption.</returns>
    {class} property ColumnEncryptionTrustedMasterKeyPaths: DDN.mscorlib.DNIDictionary<string, DDN.mscorlib.DNIList<string>> read get_ColumnEncryptionTrustedMasterKeyPaths;
    ///<summary>Gets or sets a value that indicates whether query metadata caching is enabled (true) or not (false) for parameterized queries running against Always Encrypted enabled databases. The default value is true.</summary>
    ///<returns>Returns true if query metadata caching is enabled; otherwise false. true is the default.</returns>
    {class} property ColumnEncryptionQueryMetadataCacheEnabled: Boolean read get_ColumnEncryptionQueryMetadataCacheEnabled write set_ColumnEncryptionQueryMetadataCacheEnabled;
    ///<summary>Gets or sets the time-to-live for column encryption key entries in the column encryption key cache for the Always Encrypted feature. The default value is 2 hours. 0 means no caching at all.</summary>
    ///<returns>The time interval.</returns>
    {class} property ColumnEncryptionKeyCacheTtl: DDN.mscorlib.DNTimeSpan read get_ColumnEncryptionKeyCacheTtl write set_ColumnEncryptionKeyCacheTtl;
  end;

  ///<summary>Represents an open connection to a SQL Server database. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.SqlClient.SqlConnection')]
  DNSqlConnection = interface(DNDbConnection)
  ['{F8C85934-FC42-3A0A-AB23-EBA6D5B37B8A}']
  { getters & setters } 

    function get_StatisticsEnabled: Boolean;
    procedure set_StatisticsEnabled(value: Boolean);
    function get_AccessToken: string;
    procedure set_AccessToken(value: string);
    function get_ConnectionString: string;
    procedure set_ConnectionString(value: string);
    function get_ConnectionTimeout: Int32;
    function get_Database: string;
    function get_DataSource: string;
    function get_PacketSize: Int32;
    function get_ClientConnectionId: DDN.mscorlib.DNGuid;
    function get_ServerVersion: string;
    function get_State: DNConnectionState;
    function get_WorkstationId: string;
    function get_Credential: DNSqlCredential;
    procedure set_Credential(value: DNSqlCredential);
    function get_FireInfoMessageEventOnUserErrors: Boolean;
    procedure set_FireInfoMessageEventOnUserErrors(value: Boolean);
    function get_Site: DDN.System.DNISite;
    procedure set_Site(value: DDN.System.DNISite);
    function get_Container: DDN.System.DNIContainer;

  { events } 

    procedure add_InfoMessage(value: DNSqlInfoMessageEventHandler);
    procedure remove_InfoMessage(value: DNSqlInfoMessageEventHandler);
    procedure add_StateChange(value: DNStateChangeEventHandler);
    procedure remove_StateChange(value: DNStateChangeEventHandler);
    procedure add_Disposed(value: DDN.mscorlib.DNEventHandler);
    procedure remove_Disposed(value: DDN.mscorlib.DNEventHandler);

  { methods } 

    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  . For more information about scheme, see SQL Server Schema Collections.</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information.</returns>
    function GetSchema: DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  using the specified string for the schema name.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return.</param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information. </returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="collectionName" />
    ///  is specified as null.</exception>
    function GetSchema(collectionName: string): DNDataTable; overload;
    ///<summary>Returns schema information for the data source of this <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  using the specified string for the schema name and the specified string array for the restriction values.</summary>
    ///  <param name="collectionName">Specifies the name of the schema to return.</param>
    ///  <param name="restrictionValues">A set of restriction values for the requested schema.</param>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that contains schema information. </returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="collectionName" />
    ///  is specified as null.</exception>
    function GetSchema(collectionName: string; restrictionValues: TArray<string>): DNDataTable; overload;
    ///<summary>Starts a database transaction.</summary>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.Data.SqlClient.SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception><exception cref="T:System.InvalidOperationException">Parallel transactions are not supported. </exception>
    function BeginTransaction: DNSqlTransaction; overload;
    ///<summary>Starts a database transaction with the specified isolation level.</summary>
    ///  <param name="iso">The isolation level under which the transaction should run. </param>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.Data.SqlClient.SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception><exception cref="T:System.InvalidOperationException">Parallel transactions are not supported. </exception>
    function BeginTransaction(iso: DNIsolationLevel): DNSqlTransaction; overload;
    ///<summary>Starts a database transaction with the specified transaction name.</summary>
    ///  <param name="transactionName">The name of the transaction. </param>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.Data.SqlClient.SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception><exception cref="T:System.InvalidOperationException">Parallel transactions are not supported. </exception>
    function BeginTransaction(transactionName: string): DNSqlTransaction; overload;
    ///<summary>Starts a database transaction with the specified isolation level and transaction name.</summary>
    ///  <param name="iso">The isolation level under which the transaction should run. </param>
    ///  <param name="transactionName">The name of the transaction. </param>
    ///<returns>An object representing the new transaction.</returns>
    ///<exception cref="T:System.Data.SqlClient.SqlException">Parallel transactions are not allowed when using Multiple Active Result Sets (MARS).</exception><exception cref="T:System.InvalidOperationException">Parallel transactions are not supported. </exception>
    function BeginTransaction(iso: DNIsolationLevel; transactionName: string): DNSqlTransaction; overload;
    ///<summary>Changes the current database for an open <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  .</summary>
    ///  <param name="database">The name of the database to use instead of the current database. </param>
    ///<exception cref="T:System.ArgumentException">The database name is not valid.</exception><exception cref="T:System.InvalidOperationException">The connection is not open. </exception><exception cref="T:System.Data.SqlClient.SqlException">Cannot change the database. </exception>
    procedure ChangeDatabase(database: string);
    ///<summary>Closes the connection to the database. This is the preferred method of closing any open connection.</summary>
    ///<exception cref="T:System.Data.SqlClient.SqlException">The connection-level error that occurred while opening the connection. </exception>
    procedure Close;
    ///<summary>Creates and returns a <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object associated with the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlCommand" />
    ///  object.</returns>
    function CreateCommand: DNSqlCommand;
    ///<summary>Enlists in the specified transaction as a distributed transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.EnterpriseServices.ITransaction" />
    ///  in which to enlist.</param>
    procedure EnlistDistributedTransaction(transaction: DDN.System.EnterpriseServices.DNITransaction);
    ///<summary>Opens a database connection with the property settings specified by the <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" />
    ///  .</summary>
    ///<exception cref="T:System.InvalidOperationException">Cannot open a connection without specifying a data source or server.orThe connection is already open.</exception><exception cref="T:System.Data.SqlClient.SqlException">A connection-level error occurred while opening the connection. If the <see cref="P:System.Data.SqlClient.SqlException.Number" />
    ///  property contains the value 18487 or 18488, this indicates that the specified password has expired or must be reset. See the <see cref="M:System.Data.SqlClient.SqlConnection.ChangePassword(System.String,System.String)" />
    ///  method for more information.The <see langword="&lt;system.data.localdb&gt;" />
    ///  tag in the app.config file has invalid or unknown elements.</exception><exception cref="T:System.Configuration.ConfigurationErrorsException">There are two entries with the same name in the <see langword="&lt;localdbinstances&gt;" />
    ///  section.</exception>
    procedure Open;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlConnection.Open" />
    ///  , which opens a database connection with the property settings specified by the <see cref="P:System.Data.SqlClient.SqlConnection.ConnectionString" />
    ///  . The cancellation token can be used to request that the operation be abandoned before the connection timeout elapses.  Exceptions will be propagated via the returned Task. If the connection timeout time elapses without successfully connecting, the returned Task will be marked as faulted with an Exception. The implementation returns a Task without blocking the calling thread for both pooled and non-pooled connections.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.A connection was not available from the connection pool before the connection time out elapsed.</exception><exception cref="T:System.Data.SqlClient.SqlException">Any error returned by SQL Server that occurred while opening the connection.</exception>
    function OpenAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>If statistics gathering is enabled, all values are reset to zero.</summary>
    procedure ResetStatistics;
    ///<summary>Returns a name value pair collection of statistics at the point in time the method is called.</summary>
    ///<returns>Returns a reference of type <see cref="T:System.Collections.IDictionary" />
    ///  of <see cref="T:System.Collections.DictionaryEntry" />
    ///  items.</returns>
    function RetrieveStatistics: DDN.mscorlib.DNIDictionary;
    ///<summary>Enlists in the specified transaction as a distributed transaction.</summary>
    ///  <param name="transaction">A reference to an existing <see cref="T:System.Transactions.Transaction" />
    ///  in which to enlist.</param>
    procedure EnlistTransaction(transaction: DDN.System.Transactions.DNTransaction);
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbConnection.Open" />
    ///  , which opens a database connection with the settings specified by the <see cref="P:System.Data.Common.DbConnection.ConnectionString" />
    ///  . This method invokes the virtual method <see cref="M:System.Data.Common.DbConnection.OpenAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    function OpenAsync: DDN.mscorlib.DNTask; overload;
    procedure Dispose;
    function ToString: string;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>When set to <see langword="true" />
    ///  , enables statistics gathering for the current connection.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if statistics gathering is enabled; otherwise <see langword="false" />
    ///  . <see langword="false" />
    ///  is the default.</returns>
    property StatisticsEnabled: Boolean read get_StatisticsEnabled write set_StatisticsEnabled;
    ///<summary>Gets or sets the access token for the connection.</summary>
    ///<returns>The access token for the connection.</returns>
    property AccessToken: string read get_AccessToken write set_AccessToken;
    ///<summary>Gets or sets the string used to open a SQL Server database.</summary>
    ///<returns>The connection string that includes the source database name, and other parameters needed to establish the initial connection. The default value is an empty string.</returns>
    ///<exception cref="T:System.ArgumentException">An invalid connection string argument has been supplied, or a required connection string argument has not been supplied. </exception>
    property ConnectionString: string read get_ConnectionString write set_ConnectionString;
    ///<summary>Gets the time to wait while trying to establish a connection before terminating the attempt and generating an error.</summary>
    ///<returns>The time (in seconds) to wait for a connection to open. The default value is 15 seconds.</returns>
    ///<exception cref="T:System.ArgumentException">The value set is less than 0. </exception>
    property ConnectionTimeout: Int32 read get_ConnectionTimeout;
    ///<summary>Gets the name of the current database or the database to be used after a connection is opened.</summary>
    ///<returns>The name of the current database or the name of the database to be used after a connection is opened. The default value is an empty string.</returns>
    property Database: string read get_Database;
    ///<summary>Gets the name of the instance of SQL Server to which to connect.</summary>
    ///<returns>The name of the instance of SQL Server to which to connect. The default value is an empty string.</returns>
    property DataSource: string read get_DataSource;
    ///<summary>Gets the size (in bytes) of network packets used to communicate with an instance of SQL Server.</summary>
    ///<returns>The size (in bytes) of network packets. The default value is 8000.</returns>
    property PacketSize: Int32 read get_PacketSize;
    ///<summary>The connection ID of the most recent connection attempt, regardless of whether the attempt succeeded or failed.</summary>
    ///<returns>The connection ID of the most recent connection attempt.</returns>
    property ClientConnectionId: DDN.mscorlib.DNGuid read get_ClientConnectionId;
    ///<summary>Gets a string that contains the version of the instance of SQL Server to which the client is connected.</summary>
    ///<returns>The version of the instance of SQL Server.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection is closed.
    ///<see cref="P:System.Data.SqlClient.SqlConnection.ServerVersion" />
    ///  was called while the returned Task was not completed and the connection was not opened after a call to <see cref="M:System.Data.SqlClient.SqlConnection.OpenAsync(System.Threading.CancellationToken)" />
    ///  .</exception>
    property ServerVersion: string read get_ServerVersion;
    ///<summary>Indicates the state of the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  during the most recent network operation performed on the connection.</summary>
    ///<returns>An <see cref="T:System.Data.ConnectionState" />
    ///  enumeration.</returns>
    property State: DNConnectionState read get_State;
    ///<summary>Gets a string that identifies the database client.</summary>
    ///<returns>A string that identifies the database client. If not specified, the name of the client computer. If neither is specified, the value is an empty string.</returns>
    property WorkstationId: string read get_WorkstationId;
    ///<summary>Gets or sets the <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object for this connection.</summary>
    ///<returns>The <see cref="T:System.Data.SqlClient.SqlCredential" />
    ///  object for this connection.</returns>
    property Credential: DNSqlCredential read get_Credential write set_Credential;
    ///<summary>Gets or sets the <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />
    ///  property.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlClient.SqlConnection.FireInfoMessageEventOnUserErrors" />
    ///  property has been set; otherwise <see langword="false" />
    ///  .</returns>
    property FireInfoMessageEventOnUserErrors: Boolean read get_FireInfoMessageEventOnUserErrors write set_FireInfoMessageEventOnUserErrors;
    property Site: DDN.System.DNISite read get_Site write set_Site;
    property Container: DDN.System.DNIContainer read get_Container;
  end;

  TDNSqlConnection = class(TDNGenericImport<DNSqlConnectionClass, DNSqlConnection>) end;

  //-------------namespace: System.Data.Common----------------
  DNDataColumnMappingClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{C5C847C1-5BCB-525C-B083-B05C3944BB3E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  class.</summary>
    {class} function init: DNDataColumnMapping; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  class with the specified source column name and <see cref="T:System.Data.DataSet" />
    ///  column name to map to.</summary>
    ///  <param name="sourceColumn">The case-sensitive column name from a data source. </param>
    ///  <param name="dataSetColumn">The column name, which is not case sensitive, from a <see cref="T:System.Data.DataSet" />
    ///  to map to. </param>
    {class} function init(sourceColumn: string; dataSetColumn: string): DNDataColumnMapping; overload;

  { static methods } 

    ///<summary>A static version of <see cref="M:System.Data.Common.DataColumnMapping.GetDataColumnBySchemaAction(System.Data.DataTable,System.Type,System.Data.MissingSchemaAction)" />
    ///  that can be called without instantiating a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object.</summary>
    ///  <param name="sourceColumn">The case-sensitive column name from a data source. </param>
    ///  <param name="dataSetColumn">The column name, which is not case sensitive, from a <see cref="T:System.Data.DataSet" />
    ///  to map to. </param>
    ///  <param name="dataTable">An instance of <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///  <param name="dataType">The data type for the column being mapped.</param>
    ///  <param name="schemaAction">Determines the action to take when existing <see cref="T:System.Data.DataSet" />
    ///  schema does not match incoming data.</param>
    ///<returns>A <see cref="T:System.Data.DataColumn" />
    ///  object.</returns>
    {class} function GetDataColumnBySchemaAction(sourceColumn: string; dataSetColumn: string; dataTable: DNDataTable; dataType: DDN.mscorlib.DNType; schemaAction: DNMissingSchemaAction): DNDataColumn; overload;

  end;

  ///<summary>Contains a generic column mapping for an object that inherits from <see cref="T:System.Data.Common.DataAdapter" />
  ///  . This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Common.DataColumnMapping')]
  DNDataColumnMapping = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{39520FE3-6378-3299-AB11-6042EFBED6FE}']
  { getters & setters } 

    function get_DataSetColumn: string;
    procedure set_DataSetColumn(value: string);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);

  { methods } 

    ///<summary>Converts the current <see cref="P:System.Data.Common.DataColumnMapping.SourceColumn" />
    ///  name to a string.</summary>
    ///<returns>The current <see cref="P:System.Data.Common.DataColumnMapping.SourceColumn" />
    ///  name as a string.</returns>
    function ToString: string;
    ///<summary>Gets a <see cref="T:System.Data.DataColumn" />
    ///  from the given <see cref="T:System.Data.DataTable" />
    ///  using the <see cref="T:System.Data.MissingSchemaAction" />
    ///  and the <see cref="P:System.Data.Common.DataColumnMapping.DataSetColumn" />
    ///  property.</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  to get the column from.</param>
    ///  <param name="dataType">The <see cref="T:System.Type" />
    ///  of the data column.</param>
    ///  <param name="schemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values.</param>
    ///<returns>A data column.</returns>
    function GetDataColumnBySchemaAction(dataTable: DNDataTable; dataType: DDN.mscorlib.DNType; schemaAction: DNMissingSchemaAction): DNDataColumn; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the name of the column within the <see cref="T:System.Data.DataSet" />
    ///  to map to.</summary>
    ///<returns>The name of the column within the <see cref="T:System.Data.DataSet" />
    ///  to map to. The name is not case sensitive.</returns>
    property DataSetColumn: string read get_DataSetColumn write set_DataSetColumn;
    ///<summary>Gets or sets the name of the column within the data source to map from. The name is case-sensitive.</summary>
    ///<returns>The case-sensitive name of the column in the data source.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
  end;

  TDNDataColumnMapping = class(TDNGenericImport<DNDataColumnMappingClass, DNDataColumnMapping>) end;

  //-------------namespace: System.Data.Common----------------
  DNDataColumnMappingCollectionClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{E22F8FA0-6B35-5896-B69A-BB82E59330AF}']
  { constructors } 

    ///<summary>Creates an empty <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  .</summary>
    {class} function init: DNDataColumnMappingCollection;

  { static methods } 

    ///<summary>A static method that returns a <see cref="T:System.Data.DataColumn" />
    ///  object without instantiating a <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  object.</summary>
    ///  <param name="columnMappings">The <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  .</param>
    ///  <param name="sourceColumn">The case-sensitive column name from a data source.</param>
    ///  <param name="dataType">The data type for the column being mapped.</param>
    ///  <param name="dataTable">An instance of <see cref="T:System.Data.DataTable" />
    ///  .</param>
    ///  <param name="mappingAction">One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values.</param>
    ///  <param name="schemaAction">Determines the action to take when the existing <see cref="T:System.Data.DataSet" />
    ///  schema does not match incoming data.</param>
    ///<returns>A <see cref="T:System.Data.DataColumn" />
    ///  object.</returns>
    {class} function GetDataColumn(columnMappings: DNDataColumnMappingCollection; sourceColumn: string; dataType: DDN.mscorlib.DNType; dataTable: DNDataTable; mappingAction: DNMissingMappingAction; schemaAction: DNMissingSchemaAction): DNDataColumn;
    ///<summary>Gets a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  for the specified <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  , source column name, and <see cref="T:System.Data.MissingMappingAction" />
    ///  .</summary>
    ///  <param name="columnMappings">The <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  . </param>
    ///  <param name="sourceColumn">The case-sensitive source column name to find. </param>
    ///  <param name="mappingAction">One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <paramref name="mappingAction" />
    ///  parameter was set to <see langword="Error" />
    ///  , and no mapping was specified. </exception>
    {class} function GetColumnMappingBySchemaAction(columnMappings: DNDataColumnMappingCollection; sourceColumn: string; mappingAction: DNMissingMappingAction): DNDataColumnMapping;

  end;

  ///<summary>Contains a collection of <see cref="T:System.Data.Common.DataColumnMapping" />
  ///  objects.</summary>
  [DNTypeName('System.Data.Common.DataColumnMappingCollection')]
  DNDataColumnMappingCollection = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{CA59DC57-554D-3ED3-8CF4-AA921FD38D46}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(index: Int32): DNDataColumnMapping; overload;
    procedure set_Item(index: Int32; value: DNDataColumnMapping); overload;
    function get_Item(sourceColumn: string): DNDataColumnMapping; overload;
    procedure set_Item(sourceColumn: string; value: DNDataColumnMapping); overload;

  { methods } 

    ///<summary>Gets a value indicating whether a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the given source column name exists in the collection.</summary>
    ///  <param name="value">The case-sensitive source column name of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object. </param>
    ///<returns><see langword="true" />
    ///  if collection contains a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source column name; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(value: string): Boolean; overload;
    ///<summary>Gets a value indicating whether a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the given <see cref="T:System.Object" />
    ///  exists in the collection.</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if the collection contains the specified <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidCastException">The object passed in was not a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object. </exception>
    function &Contains(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Copies the elements of the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  to the specified array.</summary>
    ///  <param name="array">An <see cref="T:System.Array" />
    ///  to which to copy <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  elements. </param>
    ///  <param name="index">The starting index of the array. </param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Gets an enumerator that can iterate through the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the location of the specified <see cref="T:System.Object" />
    ///  that is a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  within the collection.</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  to find. </param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Object" />
    ///  that is a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  within the collection.</returns>
    function IndexOf(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object into the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object to insert. </param>
    ///  <param name="value">The <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object. </param>
    procedure Insert(index: Int32; value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified index from the collection.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object to remove. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">There is no <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified index. </exception>
    procedure RemoveAt(index: Int32); overload;
    ///<summary>Removes the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source column name from the collection.</summary>
    ///  <param name="sourceColumn">The case-sensitive source column name. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">There is no <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source column name. </exception>
    procedure RemoveAt(sourceColumn: string); overload;
    ///<summary>Adds a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object to the collection when given a source column name and a <see cref="T:System.Data.DataSet" />
    ///  column name.</summary>
    ///  <param name="sourceColumn">The case-sensitive name of the source column to map to. </param>
    ///  <param name="dataSetColumn">The name, which is not case-sensitive, of the <see cref="T:System.Data.DataSet" />
    ///  column to map to. </param>
    ///<returns>The <see langword="DataColumnMapping" />
    ///  object that was added to the collection.</returns>
    function Add(sourceColumn: string; dataSetColumn: string): DNDataColumnMapping;
    ///<summary>Copies the elements of the specified <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  array to the end of the collection.</summary>
    ///  <param name="values">The array of <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  objects to add to the collection. </param>
    procedure AddRange(values: TArray<DNDataColumnMapping>); overload;
    ///<summary>Copies the elements of the specified <see cref="T:System.Array" />
    ///  to the end of the collection.</summary>
    ///  <param name="values">The <see cref="T:System.Array" />
    ///  to add to the collection.</param>
    procedure AddRange(values: DDN.mscorlib.DNArray); overload;
    ///<summary>Copies the elements of the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  to the specified <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  array.</summary>
    ///  <param name="array">A <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  array to which to copy the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  elements.</param>
    ///  <param name="index">The zero-based index in the <paramref name="array" />
    ///  at which copying begins.</param>
    procedure CopyTo(&array: TArray<DNDataColumnMapping>; index: Int32); overload;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified <see cref="T:System.Data.DataSet" />
    ///  column name.</summary>
    ///  <param name="value">The name, which is not case-sensitive, of the <see cref="T:System.Data.DataSet" />
    ///  column to find. </param>
    ///<returns>The <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified <see cref="T:System.Data.DataSet" />
    ///  column name.</returns>
    function GetByDataSetColumn(value: string): DNDataColumnMapping;
    ///<summary>Gets the location of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  with the specified source column name.</summary>
    ///  <param name="sourceColumn">The case-sensitive name of the source column. </param>
    ///<returns>The zero-based location of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  with the specified case-sensitive source column name.</returns>
    function IndexOf(sourceColumn: string): Int32; overload;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  with the given <see cref="T:System.Data.DataSet" />
    ///  column name.</summary>
    ///  <param name="dataSetColumn">The name, which is not case-sensitive, of the data set column to find. </param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  with the given <see langword="DataSet" />
    ///  column name, or -1 if the <see langword="DataColumnMapping" />
    ///  object does not exist in the collection.</returns>
    function IndexOfDataSetColumn(dataSetColumn: string): Int32;
    ///<summary>Inserts a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object into the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object to insert.</param>
    ///  <param name="value">The <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object.</param>
    procedure Insert(index: Int32; value: DNDataColumnMapping); overload;
    ///<summary>Removes the specified <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  from the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  to remove.</param>
    procedure Remove(value: DNDataColumnMapping);
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  objects in the collection.</summary>
    ///<returns>The number of items in the collection.</returns>
    property Count: Int32 read get_Count;
    property Item[index: Int32]: DNDataColumnMapping read get_Item write set_Item; default;
    property Item[sourceColumn: string]: DNDataColumnMapping read get_Item write set_Item; default;
  end;

  TDNDataColumnMappingCollection = class(TDNGenericImport<DNDataColumnMappingCollectionClass, DNDataColumnMappingCollection>) end;

  //-------------namespace: System.Data.Common----------------
  DNDataTableMappingClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{B5260371-A96F-52A8-A3FC-1093A39A23E4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  class.</summary>
    {class} function init: DNDataTableMapping; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  class with a source when given a source table name and a <see cref="T:System.Data.DataTable" />
    ///  name.</summary>
    ///  <param name="sourceTable">The case-sensitive source table name from a data source. </param>
    ///  <param name="dataSetTable">The table name from a <see cref="T:System.Data.DataSet" />
    ///  to map to. </param>
    {class} function init(sourceTable: string; dataSetTable: string): DNDataTableMapping; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  class when given a source table name, a <see cref="T:System.Data.DataTable" />
    ///  name, and an array of <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  objects.</summary>
    ///  <param name="sourceTable">The case-sensitive source table name from a data source. </param>
    ///  <param name="dataSetTable">The table name from a <see cref="T:System.Data.DataSet" />
    ///  to map to. </param>
    ///  <param name="columnMappings">An array of <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  objects. </param>
    {class} function init(sourceTable: string; dataSetTable: string; columnMappings: TArray<DNDataColumnMapping>): DNDataTableMapping; overload;

  end;

  ///<summary>Contains a description of a mapped relationship between a source table and a <see cref="T:System.Data.DataTable" />
  ///  . This class is used by a <see cref="T:System.Data.Common.DataAdapter" />
  ///  when populating a <see cref="T:System.Data.DataSet" />
  ///  .</summary>
  [DNTypeName('System.Data.Common.DataTableMapping')]
  DNDataTableMapping = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{4A427B61-A253-3B5D-AB26-CF8CB7A391C0}']
  { getters & setters } 

    function get_ColumnMappings: DNDataColumnMappingCollection;
    function get_DataSetTable: string;
    procedure set_DataSetTable(value: string);
    function get_SourceTable: string;
    procedure set_SourceTable(value: string);

  { methods } 

    ///<summary>Converts the current <see cref="P:System.Data.Common.DataTableMapping.SourceTable" />
    ///  name to a string.</summary>
    ///<returns>The current <see cref="P:System.Data.Common.DataTableMapping.SourceTable" />
    ///  name, as a string.</returns>
    function ToString: string;
    ///<summary>Returns a <see cref="T:System.Data.DataColumn" />
    ///  object for a given column name.</summary>
    ///  <param name="sourceColumn">The name of the <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///  <param name="dataType">The data type for <paramref name="sourceColumn" />
    ///  .</param>
    ///  <param name="dataTable">The table name from a <see cref="T:System.Data.DataSet" />
    ///  to map to. </param>
    ///  <param name="mappingAction">One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </param>
    ///  <param name="schemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.DataColumn" />
    ///  object.</returns>
    function GetDataColumn(sourceColumn: string; dataType: DDN.mscorlib.DNType; dataTable: DNDataTable; mappingAction: DNMissingMappingAction; schemaAction: DNMissingSchemaAction): DNDataColumn;
    ///<summary>Gets a <see cref="T:System.Data.DataColumn" />
    ///  from the specified <see cref="T:System.Data.DataTable" />
    ///  using the specified <see cref="T:System.Data.MissingMappingAction" />
    ///  value and the name of the <see cref="T:System.Data.DataColumn" />
    ///  .</summary>
    ///  <param name="sourceColumn">The name of the <see cref="T:System.Data.DataColumn" />
    ///  . </param>
    ///  <param name="mappingAction">One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </param>
    ///<returns>A data column.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <paramref name="mappingAction" />
    ///  parameter was set to <see langword="Error" />
    ///  , and no mapping was specified. </exception>
    function GetColumnMappingBySchemaAction(sourceColumn: string; mappingAction: DNMissingMappingAction): DNDataColumnMapping;
    ///<summary>Gets the current <see cref="T:System.Data.DataTable" />
    ///  for the specified <see cref="T:System.Data.DataSet" />
    ///  using the specified <see cref="T:System.Data.MissingSchemaAction" />
    ///  value.</summary>
    ///  <param name="dataSet">The <see cref="T:System.Data.DataSet" />
    ///  from which to get the <see cref="T:System.Data.DataTable" />
    ///  . </param>
    ///  <param name="schemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" />
    ///  values. </param>
    ///<returns>A data table.</returns>
    function GetDataTableBySchemaAction(dataSet: DNDataSet; schemaAction: DNMissingSchemaAction): DNDataTable;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.Common.DataColumnMappingCollection" />
    ///  for the <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///<returns>A data column mapping collection.</returns>
    property ColumnMappings: DNDataColumnMappingCollection read get_ColumnMappings;
    ///<summary>Gets or sets the table name from a <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///<returns>The table name from a <see cref="T:System.Data.DataSet" />
    ///  .</returns>
    property DataSetTable: string read get_DataSetTable write set_DataSetTable;
    ///<summary>Gets or sets the case-sensitive source table name from a data source.</summary>
    ///<returns>The case-sensitive source table name from a data source.</returns>
    property SourceTable: string read get_SourceTable write set_SourceTable;
  end;

  TDNDataTableMapping = class(TDNGenericImport<DNDataTableMappingClass, DNDataTableMapping>) end;

  //-------------namespace: System.Data.Common----------------
  DNDataTableMappingCollectionClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{97C165F2-70FB-5562-80D6-5536FEA628E6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  class. This new instance is empty, that is, it does not yet contain any <see cref="T:System.Data.Common.DataTableMapping" />
    ///  objects.</summary>
    {class} function init: DNDataTableMappingCollection;

  { static methods } 

    ///<summary>Gets a <see cref="T:System.Data.Common.DataColumnMapping" />
    ///  object with the specified source table name and <see cref="T:System.Data.DataSet" />
    ///  table name, using the given <see cref="T:System.Data.MissingMappingAction" />
    ///  .</summary>
    ///  <param name="tableMappings">The <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  collection to search. </param>
    ///  <param name="sourceTable">The case-sensitive name of the mapped source table. </param>
    ///  <param name="dataSetTable">The name, which is not case-sensitive, of the mapped <see cref="T:System.Data.DataSet" />
    ///  table. </param>
    ///  <param name="mappingAction">One of the <see cref="T:System.Data.MissingMappingAction" />
    ///  values. </param>
    ///<returns>A <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <paramref name="mappingAction" />
    ///  parameter was set to <see langword="Error" />
    ///  , and no mapping was specified. </exception>
    {class} function GetTableMappingBySchemaAction(tableMappings: DNDataTableMappingCollection; sourceTable: string; dataSetTable: string; mappingAction: DNMissingMappingAction): DNDataTableMapping;

  end;

  ///<summary>A collection of <see cref="T:System.Data.Common.DataTableMapping" />
  ///  objects. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Common.DataTableMappingCollection')]
  DNDataTableMappingCollection = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{F3117EC1-489D-39B3-B89E-FF106E64D3E6}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(index: Int32): DNDataTableMapping; overload;
    procedure set_Item(index: Int32; value: DNDataTableMapping); overload;
    function get_Item(sourceTable: string): DNDataTableMapping; overload;
    procedure set_Item(sourceTable: string; value: DNDataTableMapping); overload;

  { methods } 

    ///<summary>Gets a value indicating whether a <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified source table name exists in the collection.</summary>
    ///  <param name="value">The case-sensitive source table name containing the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object. </param>
    ///<returns><see langword="true" />
    ///  if the collection contains a <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with this source table name; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: string): Boolean; overload;
    ///<summary>Gets a value indicating whether the given <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object exists in the collection.</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if this collection contains the specified <see cref="T:System.Data.Common.DataTableMapping" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Copies the elements of the <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  to the specified array.</summary>
    ///  <param name="array">An <see cref="T:System.Array" />
    ///  to which to copy the <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  elements. </param>
    ///  <param name="index">The starting index of the array. </param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Gets an enumerator that can iterate through the collection.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object within the collection.</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to find. </param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object within the collection.</returns>
    function IndexOf(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object into the <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to insert. </param>
    ///  <param name="value">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to insert. </param>
    procedure Insert(index: Int32; value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object located at the specified index from the collection.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to remove. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">A <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object does not exist with the specified index. </exception>
    procedure RemoveAt(index: Int32); overload;
    ///<summary>Removes the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified source table name from the collection.</summary>
    ///  <param name="sourceTable">The case-sensitive source table name to find. </param>
    ///<exception cref="T:System.IndexOutOfRangeException">A <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object does not exist with the specified source table name. </exception>
    procedure RemoveAt(sourceTable: string); overload;
    ///<summary>Copies the elements of the specified <see cref="T:System.Data.Common.DataTableMapping" />
    ///  array to the end of the collection.</summary>
    ///  <param name="values">The array of <see cref="T:System.Data.Common.DataTableMapping" />
    ///  objects to add to the collection. </param>
    procedure AddRange(values: TArray<DNDataTableMapping>); overload;
    ///<summary>Copies the elements of the specified <see cref="T:System.Array" />
    ///  to the end of the collection.</summary>
    ///  <param name="values">An <see cref="T:System.Array" />
    ///  of values to add to the collection.</param>
    procedure AddRange(values: DDN.mscorlib.DNArray); overload;
    ///<summary>Adds a <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to the collection when given a source table name and a <see cref="T:System.Data.DataSet" />
    ///  table name.</summary>
    ///  <param name="sourceTable">The case-sensitive name of the source table to map from. </param>
    ///  <param name="dataSetTable">The name, which is not case-sensitive, of the <see cref="T:System.Data.DataSet" />
    ///  table to map to. </param>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object that was added to the collection.</returns>
    function Add(sourceTable: string; dataSetTable: string): DNDataTableMapping;
    ///<summary>Copies the elements of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to the specified array.</summary>
    ///  <param name="array">A <see cref="T:System.Data.Common.DataTableMapping" />
    ///  to which to copy the <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  elements.</param>
    ///  <param name="index">The starting index of the array.</param>
    procedure CopyTo(&array: TArray<DNDataTableMapping>; index: Int32); overload;
    ///<summary>Gets the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified <see cref="T:System.Data.DataSet" />
    ///  table name.</summary>
    ///  <param name="dataSetTable">The name, which is not case-sensitive, of the <see cref="T:System.Data.DataSet" />
    ///  table to find. </param>
    ///<returns>The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified <see cref="T:System.Data.DataSet" />
    ///  table name.</returns>
    function GetByDataSetTable(dataSetTable: string): DNDataTableMapping;
    ///<summary>Gets the location of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified source table name.</summary>
    ///  <param name="sourceTable">The case-sensitive name of the source table. </param>
    ///<returns>The zero-based location of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified source table name.</returns>
    function IndexOf(sourceTable: string): Int32; overload;
    ///<summary>Gets the location of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the specified <see cref="T:System.Data.DataSet" />
    ///  table name.</summary>
    ///  <param name="dataSetTable">The name, which is not case-sensitive, of the <see langword="DataSet" />
    ///  table to find. </param>
    ///<returns>The zero-based location of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object with the given <see cref="T:System.Data.DataSet" />
    ///  table name, or -1 if the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object does not exist in the collection.</returns>
    function IndexOfDataSetTable(dataSetTable: string): Int32;
    ///<summary>Inserts a <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object into the <see cref="T:System.Data.Common.DataTableMappingCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to insert.</param>
    ///  <param name="value">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to insert.</param>
    procedure Insert(index: Int32; value: DNDataTableMapping); overload;
    ///<summary>Removes the specified <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object from the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Data.Common.DataTableMapping" />
    ///  object to remove.</param>
    procedure Remove(value: DNDataTableMapping);
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of <see cref="T:System.Data.Common.DataTableMapping" />
    ///  objects in the collection.</summary>
    ///<returns>The number of <see langword="DataTableMapping" />
    ///  objects in the collection.</returns>
    property Count: Int32 read get_Count;
    property Item[index: Int32]: DNDataTableMapping read get_Item write set_Item; default;
    property Item[sourceTable: string]: DNDataTableMapping read get_Item write set_Item; default;
  end;

  TDNDataTableMappingCollection = class(TDNGenericImport<DNDataTableMappingCollectionClass, DNDataTableMappingCollection>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbDataReaderClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{AC311513-5303-52B1-90BC-EC46F7579F8F}']
  end;

  ///<summary>Reads a forward-only stream of rows from a data source.</summary>
  [DNTypeName('System.Data.Common.DbDataReader')]
  DNDbDataReader = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{BD84DD06-A2C7-33E9-BD16-288FD41CCD30}']
  { getters & setters } 

    function get_Depth: Int32;
    function get_FieldCount: Int32;
    function get_HasRows: Boolean;
    function get_IsClosed: Boolean;
    function get_RecordsAffected: Int32;
    function get_VisibleFieldCount: Int32;
    function get_Item(ordinal: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;

  { methods } 

    ///<summary>Closes the <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</summary>
    procedure Close;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Data.Common.DbDataReader" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata of the <see cref="T:System.Data.Common.DbDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed. </exception>
    function GetSchemaTable: DNDataTable;
    ///<summary>Returns the provider-specific field type of the specified column.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The <see cref="T:System.Type" />
    ///  object that describes the data type of the specified column.</returns>
    function GetProviderSpecificFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the value of the specified column as an instance of <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    function GetProviderSpecificValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Gets all provider-specific attribute columns in the collection for the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the attribute columns.</param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetProviderSpecificValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:charncharntextnvarchartextvarchar</exception>
    function GetTextReader(ordinal: Int32): DDN.mscorlib.DNTextReader;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values. Optionally, sends a notification that operations should be cancelled.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///  <param name="cancellationToken">The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" />
    ///  makes this method equivalent to <see cref="M:System.Data.Common.DbDataReader.IsDBNullAsync(System.Int32)" />
    ///  . The returned task must be marked as cancelled.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  .  Providers should override with an appropriate implementation. The cancellationToken may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellationToken.  Exceptions thrown by Read will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbDataReader" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  . Providers should override with an appropriate implementation. The <paramref name="cancellationToken" />
    ///  may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled <paramref name="cancellationToken" />
    ///  . Exceptions thrown by <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  will be communicated via the returned Task Exception property.Other methods and properties of the DbDataReader object should not be invoked while the returned Task is not yet completed.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>Gets name of the data type of the specified column.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>A string representing the name of the data type.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDataTypeName(ordinal: Int32): string;
    ///<summary>Returns an <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the rows in the data reader.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the rows in the data reader.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the data type of the specified column.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The data type of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the name of the column, given the zero-based column ordinal.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The name of the specified column.</returns>
    function GetName(ordinal: Int32): string;
    ///<summary>Gets the column ordinal given the name of the column.</summary>
    ///  <param name="name">The name of the column.</param>
    ///<returns>The zero-based column ordinal.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The name specified is not a valid column name.</exception>
    function GetOrdinal(name: string): Int32;
    ///<summary>Gets the value of the specified column as a Boolean.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetBoolean(ordinal: Int32): Boolean;
    ///<summary>Gets the value of the specified column as a byte.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetByte(ordinal: Int32): Byte;
    ///<summary>Reads a stream of bytes from the specified column, starting at location indicated by <paramref name="dataOffset" />
    ///  , into the buffer, starting at the location indicated by <paramref name="bufferOffset" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///  <param name="dataOffset">The index within the row from which to begin the read operation.</param>
    ///  <param name="buffer">The buffer into which to copy the data.</param>
    ///  <param name="bufferOffset">The index with the buffer to which the data will be copied.</param>
    ///  <param name="length">The maximum number of characters to read.</param>
    ///<returns>The actual number of bytes read.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetBytes(ordinal: Int32; dataOffset: Int64; buffer: TArray<Byte>; bufferOffset: Int32; length: Int32): Int64;
    ///<summary>Gets the value of the specified column as a single character.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetChar(ordinal: Int32): Char;
    ///<summary>Reads a stream of characters from the specified column, starting at location indicated by <paramref name="dataOffset" />
    ///  , into the buffer, starting at the location indicated by <paramref name="bufferOffset" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///  <param name="dataOffset">The index within the row from which to begin the read operation.</param>
    ///  <param name="buffer">The buffer into which to copy the data.</param>
    ///  <param name="bufferOffset">The index with the buffer to which the data will be copied.</param>
    ///  <param name="length">The maximum number of characters to read.</param>
    ///<returns>The actual number of characters read.</returns>
    function GetChars(ordinal: Int32; dataOffset: Int64; buffer: TArray<Char>; bufferOffset: Int32; length: Int32): Int64;
    ///<summary>Returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  object for the requested column ordinal.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>A <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</returns>
    function GetData(ordinal: Int32): DNDbDataReader;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDateTime(ordinal: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDecimal(ordinal: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the value of the specified column as a double-precision floating point number.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDouble(ordinal: Int32): Double;
    ///<summary>Gets the value of the specified column as a single-precision floating point number.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetFloat(ordinal: Int32): Single;
    ///<summary>Gets the value of the specified column as a globally-unique identifier (GUID).</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetGuid(ordinal: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the value of the specified column as a 16-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt16(ordinal: Int32): Int16;
    ///<summary>Gets the value of the specified column as a 32-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt32(ordinal: Int32): Int32;
    ///<summary>Gets the value of the specified column as a 64-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt64(ordinal: Int32): Int64;
    ///<summary>Gets the value of the specified column as an instance of <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetString(ordinal: Int32): string;
    ///<summary>Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:binaryimagevarbinaryudt</exception>
    function GetStream(ordinal: Int32): DDN.mscorlib.DNStream;
    ///<summary>Gets the value of the specified column as an instance of <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    function GetValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Populates an array of objects with the column values of the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the attribute columns.</param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets a value that indicates whether the column contains nonexistent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns><see langword="true" />
    ///  if the specified column is equivalent to <see cref="T:System.DBNull" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function IsDBNull(ordinal: Int32): Boolean;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>Advances the reader to the next result when reading the results of a batch of statements.</summary>
    ///<returns><see langword="true" />
    ///  if there are more result sets; otherwise <see langword="false" />
    ///  .</returns>
    function NextResult: Boolean;
    ///<summary>Advances the reader to the next record in a result set.</summary>
    ///<returns><see langword="true" />
    ///  if there are more rows; otherwise <see langword="false" />
    ///  .</returns>
    function Read: Boolean;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  , which advances the reader to the next record in a result set. This method invokes <see cref="M:System.Data.Common.DbDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  , which advances the reader to the next result when reading the results of a batch of statements.Invokes <see cref="M:System.Data.Common.DbDataReader.NextResultAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value indicating the depth of nesting for the current row.</summary>
    ///<returns>The depth of nesting for the current row.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the number of columns in the current row.</summary>
    ///<returns>The number of columns in the current row.</returns>
    ///<exception cref="T:System.NotSupportedException">There is no current connection to an instance of SQL Server. </exception>
    property FieldCount: Int32 read get_FieldCount;
    ///<summary>Gets a value that indicates whether this <see cref="T:System.Data.Common.DbDataReader" />
    ///  contains one or more rows.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbDataReader" />
    ///  contains one or more rows; otherwise <see langword="false" />
    ///  .</returns>
    property HasRows: Boolean read get_HasRows;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed. </exception>
    property IsClosed: Boolean read get_IsClosed;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement. </summary>
    ///<returns>The number of rows changed, inserted, or deleted. -1 for SELECT statements; 0 if no rows were affected or the statement failed.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets the number of fields in the <see cref="T:System.Data.Common.DbDataReader" />
    ///  that are not hidden.</summary>
    ///<returns>The number of fields that are not hidden.</returns>
    property VisibleFieldCount: Int32 read get_VisibleFieldCount;
    property Item[ordinal: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
  end;

  TDNDbDataReader = class(TDNGenericImport<DNDbDataReaderClass, DNDbDataReader>) end;

  //-------------namespace: System.Data----------------
  DNDataTableReaderClass = interface(DNDbDataReaderClass)
  ['{DE013FFE-18A1-549D-BBFE-B7A35A1EC675}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataTableReader" />
    ///  class by using data from the supplied <see cref="T:System.Data.DataTable" />
    ///  .</summary>
    ///  <param name="dataTable">The <see cref="T:System.Data.DataTable" />
    ///  from which the new <see cref="T:System.Data.DataTableReader" />
    ///  obtains its result set. </param>
    {class} function init(dataTable: DNDataTable): DNDataTableReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.DataTableReader" />
    ///  class using the supplied array of <see cref="T:System.Data.DataTable" />
    ///  objects.</summary>
    ///  <param name="dataTables">The array of <see cref="T:System.Data.DataTable" />
    ///  objects that supplies the results for the new <see cref="T:System.Data.DataTableReader" />
    ///  object. </param>
    {class} function init(dataTables: TArray<DNDataTable>): DNDataTableReader; overload;

  end;

  ///<summary>The <see cref="T:System.Data.DataTableReader" />
  ///  obtains the contents of one or more <see cref="T:System.Data.DataTable" />
  ///  objects in the form of one or more read-only, forward-only result sets. </summary>
  [DNTypeName('System.Data.DataTableReader')]
  DNDataTableReader = interface(DNDbDataReader)
  ['{B042F350-345A-3F37-B532-D557D91D5FCA}']
  { getters & setters } 

    function get_Depth: Int32;
    function get_IsClosed: Boolean;
    function get_RecordsAffected: Int32;
    function get_HasRows: Boolean;
    function get_Item(ordinal: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;
    function get_FieldCount: Int32;
    function get_VisibleFieldCount: Int32;

  { methods } 

    ///<summary>Closes the current <see cref="T:System.Data.DataTableReader" />
    ///  .</summary>
    procedure Close;
    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata of the <see cref="T:System.Data.DataTableReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.DataTableReader" />
    ///  is closed. </exception>
    function GetSchemaTable: DNDataTable;
    ///<summary>Advances the <see cref="T:System.Data.DataTableReader" />
    ///  to the next result set, if any.</summary>
    ///<returns><see langword="true" />
    ///  if there was another result set; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An attempt was made to navigate within a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function NextResult: Boolean;
    ///<summary>Advances the <see cref="T:System.Data.DataTableReader" />
    ///  to the next record.</summary>
    ///<returns><see langword="true" />
    ///  if there was another row to read; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function Read: Boolean;
    ///<summary>Gets the type of the specified column in provider-specific format.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The <see cref="T:System.Type" />
    ///  that is the data type of the object.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetProviderSpecificFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the value of the specified column in provider-specific format.</summary>
    ///  <param name="ordinal">The zero-based number of the column whose value is retrieved. </param>
    ///<returns>The value of the specified column in provider-specific format.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///</exception>
    function GetProviderSpecificValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Fills the supplied array with provider-specific type information for all the columns in the <see cref="T:System.Data.DataTableReader" />
    ///  .</summary>
    ///  <param name="values">An array of objects to be filled in with type information for the columns in the <see cref="T:System.Data.DataTableReader" />
    ///  . </param>
    ///<returns>The number of column values copied into the array.</returns>
    ///<exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetProviderSpecificValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets a string representing the data type of the specified column.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>A string representing the column's data type.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetDataTypeName(ordinal: Int32): string;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  that is the data type of the object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The <see cref="T:System.Type" />
    ///  that is the data type of the object.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns>The name of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetName(ordinal: Int32): string;
    ///<summary>Gets the column ordinal, given the name of the column.</summary>
    ///  <param name="name">The name of the column. </param>
    ///<returns>The zero-based column ordinal.</returns>
    ///<exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.ArgumentException">The name specified is not a valid column name. </exception>
    function GetOrdinal(name: string): Int32;
    ///<summary>Returns an enumerator that can be used to iterate through the item collection. </summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that represents the item collection.</returns>
    ///<exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Boolean" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a <see langword="Boolean" />
    ///  . </exception>
    function GetBoolean(ordinal: Int32): Boolean;
    ///<summary>Gets the value of the specified column as a byte.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a byte. </exception>
    function GetByte(ordinal: Int32): Byte;
    ///<summary>Reads a stream of bytes starting at the specified column offset into the buffer as an array starting at the specified buffer offset.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the field from which to start the read operation. </param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferIndex">The index within the buffer at which to start placing the data. </param>
    ///  <param name="length">The maximum length to copy into the buffer. </param>
    ///<returns>The actual number of bytes read.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a byte array. </exception>
    function GetBytes(ordinal: Int32; dataIndex: Int64; buffer: TArray<Byte>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Gets the value of the specified column as a character.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified field does not contain a character. </exception>
    function GetChar(ordinal: Int32): Char;
    ///<summary>Returns the value of the specified column as a character array.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the field from which to start the read operation. </param>
    ///  <param name="buffer">The buffer into which to read the stream of chars. </param>
    ///  <param name="bufferIndex">The index within the buffer at which to start placing the data. </param>
    ///  <param name="length">The maximum length to copy into the buffer. </param>
    ///<returns>The actual number of characters read.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a character array. </exception>
    function GetChars(ordinal: Int32; dataIndex: Int64; buffer: TArray<Char>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a DateTime value. </exception>
    function GetDateTime(ordinal: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Decimal" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a <see langword="Decimal" />
    ///  value. </exception>
    function GetDecimal(ordinal: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the value of the column as a double-precision floating point number.</summary>
    ///  <param name="ordinal">The zero-based ordinal of the column. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see langword="DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a double-precision floating point number. </exception>
    function GetDouble(ordinal: Int32): Double;
    ///<summary>Gets the value of the specified column as a single-precision floating point number.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a single-precision floating point number. </exception>
    function GetFloat(ordinal: Int32): Single;
    ///<summary>Gets the value of the specified column as a globally-unique identifier (GUID).</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a GUID. </exception>
    function GetGuid(ordinal: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the value of the specified column as a 16-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a 16-bit signed integer. </exception>
    function GetInt16(ordinal: Int32): Int16;
    ///<summary>Gets the value of the specified column as a 32-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a 32-bit signed integer value. </exception>
    function GetInt32(ordinal: Int32): Int32;
    ///<summary>Gets the value of the specified column as a 64-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a 64-bit signed integer value. </exception>
    function GetInt64(ordinal: Int32): Int64;
    ///<summary>Gets the value of the specified column as a string.</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The specified column does not contain a string. </exception>
    function GetString(ordinal: Int32): string;
    ///<summary>Gets the value of the specified column in its native format.</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns>The value of the specified column. This method returns <see langword="DBNull" />
    ///  for null columns.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access columns in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Populates an array of objects with the column values of the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the column values from the <see cref="T:System.Data.DataTableReader" />
    ///  .</param>
    ///<returns>The number of column values copied into the array.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1. </exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column ordinal </param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see cref="T:System.DBNull" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1.</exception><exception cref="T:System.Data.DeletedRowInaccessibleException">An attempt was made to retrieve data from a deleted row.</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access a column in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    function IsDBNull(ordinal: Int32): Boolean;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Data.Common.DbDataReader" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:charncharntextnvarchartextvarchar</exception>
    function GetTextReader(ordinal: Int32): DDN.mscorlib.DNTextReader;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values. Optionally, sends a notification that operations should be cancelled.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///  <param name="cancellationToken">The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" />
    ///  makes this method equivalent to <see cref="M:System.Data.Common.DbDataReader.IsDBNullAsync(System.Int32)" />
    ///  . The returned task must be marked as cancelled.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  .  Providers should override with an appropriate implementation. The cancellationToken may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellationToken.  Exceptions thrown by Read will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbDataReader" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  . Providers should override with an appropriate implementation. The <paramref name="cancellationToken" />
    ///  may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled <paramref name="cancellationToken" />
    ///  . Exceptions thrown by <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  will be communicated via the returned Task Exception property.Other methods and properties of the DbDataReader object should not be invoked while the returned Task is not yet completed.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>Returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  object for the requested column ordinal.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>A <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</returns>
    function GetData(ordinal: Int32): DNDbDataReader;
    ///<summary>Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:binaryimagevarbinaryudt</exception>
    function GetStream(ordinal: Int32): DDN.mscorlib.DNStream;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  , which advances the reader to the next record in a result set. This method invokes <see cref="M:System.Data.Common.DbDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  , which advances the reader to the next result when reading the results of a batch of statements.Invokes <see cref="M:System.Data.Common.DbDataReader.NextResultAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The depth of nesting for the current row of the <see cref="T:System.Data.DataTableReader" />
    ///  .</summary>
    ///<returns>The depth of nesting for the current row; always zero.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.DataTableReader" />
    ///  is closed.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Data.DataTableReader" />
    ///  is closed; otherwise, <see langword="false" />
    ///  .</returns>
    property IsClosed: Boolean read get_IsClosed;
    ///<summary>Gets the number of rows inserted, changed, or deleted by execution of the SQL statement.</summary>
    ///<returns>The <see cref="T:System.Data.DataTableReader" />
    ///  does not support this property and always returns 0.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.DataTableReader" />
    ///  contains one or more rows.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.DataTableReader" />
    ///  contains one or more rows; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An attempt was made to retrieve information about a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    property HasRows: Boolean read get_HasRows;
    property Item[ordinal: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
    ///<summary>Returns the number of columns in the current row.</summary>
    ///<returns>When not positioned in a valid result set, 0; otherwise the number of columns in the current row. </returns>
    ///<exception cref="T:System.InvalidOperationException">An attempt was made to retrieve the field count in a closed <see cref="T:System.Data.DataTableReader" />
    ///  .</exception>
    property FieldCount: Int32 read get_FieldCount;
    ///<summary>Gets the number of fields in the <see cref="T:System.Data.Common.DbDataReader" />
    ///  that are not hidden.</summary>
    ///<returns>The number of fields that are not hidden.</returns>
    property VisibleFieldCount: Int32 read get_VisibleFieldCount;
  end;

  TDNDataTableReader = class(TDNGenericImport<DNDataTableReaderClass, DNDataTableReader>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcDataReaderClass = interface(DNDbDataReaderClass)
  ['{2471BE4D-B343-5EE3-9C0A-2DFE24A5479C}']
  end;

  ///<summary>Provides a way of reading a forward-only stream of data rows from a data source. This class cannot be inherited. </summary>
  [DNTypeName('System.Data.Odbc.OdbcDataReader')]
  DNOdbcDataReader = interface(DNDbDataReader)
  ['{3F16877F-1104-31CE-BA29-EE6A4E68DB41}']
  { getters & setters } 

    function get_Depth: Int32;
    function get_FieldCount: Int32;
    function get_HasRows: Boolean;
    function get_IsClosed: Boolean;
    function get_RecordsAffected: Int32;
    function get_Item(i: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(value: string): DDN.mscorlib.DNObject; overload;
    function get_VisibleFieldCount: Int32;

  { methods } 

    ///<summary>Closes the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  object.</summary>
    procedure Close;
    ///<summary>Returns an <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the rows in the data reader.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the rows in the data reader.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets a value that indicates whether the column contains nonexistent or missing values.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see cref="T:System.DBNull" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function IsDBNull(i: Int32): Boolean;
    ///<summary>Gets the value of the specified column as a byte.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a byte.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetByte(i: Int32): Byte;
    ///<summary>Gets the value of the specified column as a character.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a character.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetChar(i: Int32): Char;
    ///<summary>Gets the value of the specified column as a 16-bit signed integer.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a 16-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt16(i: Int32): Int16;
    ///<summary>Gets the value of the specified column as a 32-bit signed integer.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt32(i: Int32): Int32;
    ///<summary>Gets the value of the specified column as a 64-bit signed integer.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt64(i: Int32): Int64;
    ///<summary>Gets the value of the specified column as a Boolean.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>A Boolean that is the value of the column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetBoolean(i: Int32): Boolean;
    ///<summary>Gets the value of the specified column as a single-precision floating-point number.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a single-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetFloat(i: Int32): Single;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDateTime(i: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDecimal(i: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the value of the specified column as a double-precision floating-point number.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDouble(i: Int32): Double;
    ///<summary>Gets the value of the specified column as a globally unique identifier (GUID).</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a GUID.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetGuid(i: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a <see cref="T:System.String" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetString(i: Int32): string;
    ///<summary>Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the particular buffer offset.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the field where the read operation is to start. </param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferIndex">The index within the <paramref name="buffer" />
    ///  where the write operation is to start. </param>
    ///  <param name="length">The number of bytes to read. </param>
    ///<returns>The actual number of bytes read.</returns>
    function GetBytes(i: Int32; dataIndex: Int64; buffer: TArray<Byte>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Reads a stream of characters from the specified column offset into the buffer as an array, starting at the particular buffer offset.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the row where the read operation is to start. </param>
    ///  <param name="buffer">The buffer into which to copy data. </param>
    ///  <param name="bufferIndex">The index within the <paramref name="buffer" />
    ///  where the write operation is to start. </param>
    ///  <param name="length">The number of characters to read. </param>
    ///<returns>The actual number of characters read.</returns>
    function GetChars(i: Int32; dataIndex: Int64; buffer: TArray<Char>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Advances the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  to the next record.</summary>
    ///<returns><see langword="true" />
    ///  if there are more rows; otherwise <see langword="false" />
    ///  .</returns>
    function Read: Boolean;
    ///<summary>Advances the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  to the next result when reading the results of batch SQL statements.</summary>
    ///<returns><see langword="true" />
    ///  if there are more result sets; otherwise <see langword="false" />
    ///  .</returns>
    function NextResult: Boolean;
    ///<summary>Gets the name of the source data type.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The name of the source data type.</returns>
    function GetDataTypeName(i: Int32): string;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  that is the data type of the object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The <see cref="T:System.Type" />
    ///  that is the data type of the object.</returns>
    function GetFieldType(i: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the name of the specified column.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>A string that is the name of the specified column.</returns>
    function GetName(i: Int32): string;
    ///<summary>Gets the column ordinal, given the name of the column.</summary>
    ///  <param name="value">The name of the column. </param>
    ///<returns>The zero-based column ordinal.</returns>
    function GetOrdinal(value: string): Int32;
    ///<summary>Gets the value of the column at the specified ordinal in its native format.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value to return.</returns>
    function GetValue(i: Int32): DDN.mscorlib.DNObject;
    ///<summary>Populates an array of objects with the column values of the current row.</summary>
    ///  <param name="values">An array of type <see cref="T:System.Object" />
    ///  into which to copy the attribute columns. </param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    function GetDate(i: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.TimeSpan" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a <see cref="T:System.TimeSpan" />
    ///  object.</returns>
    function GetTime(i: Int32): DDN.mscorlib.DNTimeSpan;
    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata of the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  is closed. </exception>
    function GetSchemaTable: DNDataTable;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Data.Common.DbDataReader" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Returns the provider-specific field type of the specified column.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The <see cref="T:System.Type" />
    ///  object that describes the data type of the specified column.</returns>
    function GetProviderSpecificFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the value of the specified column as an instance of <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    function GetProviderSpecificValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Gets all provider-specific attribute columns in the collection for the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the attribute columns.</param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetProviderSpecificValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:charncharntextnvarchartextvarchar</exception>
    function GetTextReader(ordinal: Int32): DDN.mscorlib.DNTextReader;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values. Optionally, sends a notification that operations should be cancelled.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///  <param name="cancellationToken">The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" />
    ///  makes this method equivalent to <see cref="M:System.Data.Common.DbDataReader.IsDBNullAsync(System.Int32)" />
    ///  . The returned task must be marked as cancelled.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  .  Providers should override with an appropriate implementation. The cancellationToken may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellationToken.  Exceptions thrown by Read will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbDataReader" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  . Providers should override with an appropriate implementation. The <paramref name="cancellationToken" />
    ///  may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled <paramref name="cancellationToken" />
    ///  . Exceptions thrown by <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  will be communicated via the returned Task Exception property.Other methods and properties of the DbDataReader object should not be invoked while the returned Task is not yet completed.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>Returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  object for the requested column ordinal.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>A <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</returns>
    function GetData(ordinal: Int32): DNDbDataReader;
    ///<summary>Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:binaryimagevarbinaryudt</exception>
    function GetStream(ordinal: Int32): DDN.mscorlib.DNStream;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  , which advances the reader to the next record in a result set. This method invokes <see cref="M:System.Data.Common.DbDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  , which advances the reader to the next result when reading the results of a batch of statements.Invokes <see cref="M:System.Data.Common.DbDataReader.NextResultAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates the depth of nesting for the current row.</summary>
    ///<returns>The depth of nesting for the current row.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the number of columns in the current row.</summary>
    ///<returns>When not positioned in a valid record set, 0; otherwise the number of columns in the current record. The default is -1.</returns>
    ///<exception cref="T:System.NotSupportedException">There is no current connection to a data source. </exception>
    property FieldCount: Int32 read get_FieldCount;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  contains one or more rows.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  contains one or more rows; otherwise <see langword="false" />
    ///  .</returns>
    property HasRows: Boolean read get_HasRows;
    ///<summary>Indicates whether the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  is closed.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcDataReader" />
    ///  is closed; otherwise <see langword="false" />
    ///  .</returns>
    property IsClosed: Boolean read get_IsClosed;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted. -1 for SELECT statements; 0 if no rows were affected, or the statement failed.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    property Item[i: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[value: string]: DDN.mscorlib.DNObject read get_Item; default;
    ///<summary>Gets the number of fields in the <see cref="T:System.Data.Common.DbDataReader" />
    ///  that are not hidden.</summary>
    ///<returns>The number of fields that are not hidden.</returns>
    property VisibleFieldCount: Int32 read get_VisibleFieldCount;
  end;

  TDNOdbcDataReader = class(TDNGenericImport<DNOdbcDataReaderClass, DNOdbcDataReader>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbDataReaderClass = interface(DNDbDataReaderClass)
  ['{5998AC6D-88DE-5E03-8321-2B9F08D92B18}']
  end;

  ///<summary>Provides a way of reading a forward-only stream of data rows from a data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.OleDb.OleDbDataReader')]
  DNOleDbDataReader = interface(DNDbDataReader)
  ['{EC6F90AC-BAD9-3D17-9115-66514B377436}']
  { getters & setters } 

    function get_Depth: Int32;
    function get_FieldCount: Int32;
    function get_HasRows: Boolean;
    function get_IsClosed: Boolean;
    function get_RecordsAffected: Int32;
    function get_Item(index: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;
    function get_VisibleFieldCount: Int32;

  { methods } 

    ///<summary>Gets the value of the specified column as a Boolean.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetBoolean(ordinal: Int32): Boolean;
    ///<summary>Gets the value of the specified column as a byte.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a byte.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetByte(ordinal: Int32): Byte;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDateTime(ordinal: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDecimal(ordinal: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the value of the specified column as a double-precision floating-point number.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDouble(ordinal: Int32): Double;
    ///<summary>Returns an <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the rows in the data reader.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the rows in the data reader.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the value of the specified column as a single-precision floating-point number.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetFloat(ordinal: Int32): Single;
    ///<summary>Gets the value of the specified column as a globally unique identifier (GUID).</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetGuid(ordinal: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the value of the specified column as a 16-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt16(ordinal: Int32): Int16;
    ///<summary>Gets the value of the specified column as a 32-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt32(ordinal: Int32): Int32;
    ///<summary>Gets the value of the specified column as a 64-bit signed integer.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt64(ordinal: Int32): Int64;
    ///<summary>Gets the value of the specified column as a string.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetString(ordinal: Int32): string;
    ///<summary>Gets the value of the column at the specified ordinal in its native format.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value to return.</returns>
    function GetValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Gets a value that indicates whether the column contains nonexistent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see cref="T:System.DBNull" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    function IsDBNull(ordinal: Int32): Boolean;
    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata of the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  is closed. </exception>
    function GetSchemaTable: DNDataTable;
    ///<summary>Closes the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  object.</summary>
    procedure Close;
    ///<summary>Reads a stream of bytes from the specified column offset into the buffer as an array starting at the given buffer offset.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the field from which to start the read operation. </param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferIndex">The index within the <paramref name="buffer" />
    ///  where the write operation is to start. </param>
    ///  <param name="length">The maximum length to copy into the buffer. </param>
    ///<returns>The actual number of bytes read.</returns>
    function GetBytes(ordinal: Int32; dataIndex: Int64; buffer: TArray<Byte>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Reads a stream of characters from the specified column offset into the buffer as an array starting at the given buffer offset.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the row from which to start the read operation. </param>
    ///  <param name="buffer">The buffer into which to copy data. </param>
    ///  <param name="bufferIndex">The index within the <paramref name="buffer" />
    ///  where the write operation is to start. </param>
    ///  <param name="length">The number of characters to read. </param>
    ///<returns>The actual number of characters read.</returns>
    function GetChars(ordinal: Int32; dataIndex: Int64; buffer: TArray<Char>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Gets the value of the specified column as a character.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetChar(ordinal: Int32): Char;
    ///<summary>Returns an <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  object for the requested column ordinal.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  object.</returns>
    function GetData(ordinal: Int32): DNOleDbDataReader;
    ///<summary>Gets the name of the source data type.</summary>
    ///  <param name="index">The zero-based column ordinal. </param>
    ///<returns>The name of the back-end data type. For more information, see SQL Server data types or Access data types.</returns>
    function GetDataTypeName(index: Int32): string;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  that is the data type of the object.</summary>
    ///  <param name="index">The zero-based column ordinal. </param>
    ///<returns>The <see cref="T:System.Type" />
    ///  that is the data type of the object.</returns>
    function GetFieldType(index: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the name of the specified column.</summary>
    ///  <param name="index">The zero-based column ordinal. </param>
    ///<returns>The name of the specified column.</returns>
    function GetName(index: Int32): string;
    ///<summary>Gets the column ordinal, given the name of the column.</summary>
    ///  <param name="name">The name of the column. </param>
    ///<returns>The zero-based column ordinal.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The name specified is not a valid column name. </exception>
    function GetOrdinal(name: string): Int32;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.TimeSpan" />
    ///  object.</summary>
    ///  <param name="ordinal">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetTimeSpan(ordinal: Int32): DDN.mscorlib.DNTimeSpan;
    ///<summary>Populates an array of objects with the column values of the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the attribute columns. </param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Advances the data reader to the next result, when reading the results of batch SQL statements.</summary>
    ///<returns><see langword="true" />
    ///  if there are more result sets; otherwise, <see langword="false" />
    ///  .</returns>
    function NextResult: Boolean;
    ///<summary>Advances the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  to the next record.</summary>
    ///<returns><see langword="true" />
    ///  if there are more rows; otherwise, <see langword="false" />
    ///  .</returns>
    function Read: Boolean;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Data.Common.DbDataReader" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Returns the provider-specific field type of the specified column.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The <see cref="T:System.Type" />
    ///  object that describes the data type of the specified column.</returns>
    function GetProviderSpecificFieldType(ordinal: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the value of the specified column as an instance of <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>The value of the specified column.</returns>
    function GetProviderSpecificValue(ordinal: Int32): DDN.mscorlib.DNObject;
    ///<summary>Gets all provider-specific attribute columns in the collection for the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the attribute columns.</param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetProviderSpecificValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.TextReader" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:charncharntextnvarchartextvarchar</exception>
    function GetTextReader(ordinal: Int32): DDN.mscorlib.DNTextReader;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values. Optionally, sends a notification that operations should be cancelled.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///  <param name="cancellationToken">The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" />
    ///  makes this method equivalent to <see cref="M:System.Data.Common.DbDataReader.IsDBNullAsync(System.Int32)" />
    ///  . The returned task must be marked as cancelled.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  .  Providers should override with an appropriate implementation. The cancellationToken may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled cancellationToken.  Exceptions thrown by Read will be communicated via the returned Task Exception property.Do not invoke other methods and properties of the <see langword="DbDataReader" />
    ///  object until the returned Task is complete.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>This is the asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  . Providers should override with an appropriate implementation. The <paramref name="cancellationToken" />
    ///  may optionally be ignored.The default implementation invokes the synchronous <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  method and returns a completed task, blocking the calling thread. The default implementation will return a cancelled task if passed an already cancelled <paramref name="cancellationToken" />
    ///  . Exceptions thrown by <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  will be communicated via the returned Task Exception property.Other methods and properties of the DbDataReader object should not be invoked while the returned Task is not yet completed.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="ordinal">Retrieves data as a <see cref="T:System.IO.Stream" />
    ///  .</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:binaryimagevarbinaryudt</exception>
    function GetStream(ordinal: Int32): DDN.mscorlib.DNStream;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  , which advances the reader to the next record in a result set. This method invokes <see cref="M:System.Data.Common.DbDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  , which advances the reader to the next result when reading the results of a batch of statements.Invokes <see cref="M:System.Data.Common.DbDataReader.NextResultAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates the depth of nesting for the current row.</summary>
    ///<returns>The depth of nesting for the current row.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the number of columns in the current row.</summary>
    ///<returns>When not positioned in a valid recordset, 0; otherwise the number of columns in the current record. The default is -1.</returns>
    ///<exception cref="T:System.NotSupportedException">There is no current connection to a data source. </exception>
    property FieldCount: Int32 read get_FieldCount;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  contains one or more rows.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  contains one or more rows; otherwise <see langword="false" />
    ///  .</returns>
    property HasRows: Boolean read get_HasRows;
    ///<summary>Indicates whether the data reader is closed.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  is closed; otherwise, <see langword="false" />
    ///  .</returns>
    property IsClosed: Boolean read get_IsClosed;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    property Item[index: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
    ///<summary>Gets the number of fields in the <see cref="T:System.Data.OleDb.OleDbDataReader" />
    ///  that are not hidden.</summary>
    ///<returns>The number of fields that are not hidden.</returns>
    property VisibleFieldCount: Int32 read get_VisibleFieldCount;
  end;

  TDNOleDbDataReader = class(TDNGenericImport<DNOleDbDataReaderClass, DNOleDbDataReader>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlDataReaderClass = interface(DNDbDataReaderClass)
  ['{119ACEE0-904D-5216-A436-ED710B01A3C8}']
  end;

  ///<summary>Provides a way of reading a forward-only stream of rows from a SQL Server database. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.SqlClient.SqlDataReader')]
  DNSqlDataReader = interface(DNDbDataReader)
  ['{071B1B29-B2A1-31D8-B9E6-8C926B02709A}']
  { getters & setters } 

    function get_Depth: Int32;
    function get_FieldCount: Int32;
    function get_HasRows: Boolean;
    function get_IsClosed: Boolean;
    function get_RecordsAffected: Int32;
    function get_VisibleFieldCount: Int32;
    function get_Item(i: Int32): DDN.mscorlib.DNObject; overload;
    function get_Item(name: string): DDN.mscorlib.DNObject; overload;

  { methods } 

    ///<summary>Gets a string representing the data type of the specified column.</summary>
    ///  <param name="i">The zero-based ordinal position of the column to find.</param>
    ///<returns>The string representing the data type of the specified column.</returns>
    function GetDataTypeName(i: Int32): string;
    ///<summary>Returns an <see cref="T:System.Collections.IEnumerator" />
    ///  that iterates through the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  that is the data type of the object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The <see cref="T:System.Type" />
    ///  that is the data type of the object. If the type does not exist on the client, in the case of a User-Defined Type (UDT) returned from the database, GetFieldType returns null.</returns>
    function GetFieldType(i: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the name of the specified column.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The name of the specified column.</returns>
    function GetName(i: Int32): string;
    ///<summary>Gets an <see langword="Object" />
    ///  that is a representation of the underlying provider-specific field type.</summary>
    ///  <param name="i">An <see cref="T:System.Int32" />
    ///  representing the column ordinal. </param>
    ///<returns>Gets an <see cref="T:System.Object" />
    ///  that is a representation of the underlying provider-specific field type.</returns>
    function GetProviderSpecificFieldType(i: Int32): DDN.mscorlib.DNType;
    ///<summary>Gets the column ordinal, given the name of the column.</summary>
    ///  <param name="name">The name of the column. </param>
    ///<returns>The zero-based column ordinal.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">The name specified is not a valid column name. </exception>
    function GetOrdinal(name: string): Int32;
    ///<summary>Gets an <see langword="Object" />
    ///  that is a representation of the underlying provider specific value.</summary>
    ///  <param name="i">An <see cref="T:System.Int32" />
    ///  representing the column ordinal. </param>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is a representation of the underlying provider specific value.</returns>
    function GetProviderSpecificValue(i: Int32): DDN.mscorlib.DNObject;
    ///<summary>Gets an array of objects that are a representation of the underlying provider specific values.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the column values.</param>
    ///<returns>The array of objects that are a representation of the underlying provider specific values.</returns>
    function GetProviderSpecificValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Returns the data value in the specified column as a SQL Server type. </summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlDbType" />
    ///  .</returns>
    function GetSqlValue(i: Int32): DDN.mscorlib.DNObject;
    ///<summary>Gets the value of the specified column in its native format.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>This method returns <see cref="T:System.DBNull" />
    ///  for null database columns.</returns>
    function GetValue(i: Int32): DDN.mscorlib.DNObject;
    ///<summary>Closes the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  object.</summary>
    procedure Close;
    ///<summary>Returns a <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata of the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.DataTable" />
    ///  that describes the column metadata.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed. </exception>
    function GetSchemaTable: DNDataTable;
    ///<summary>Gets the value of the specified column as a Boolean.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetBoolean(i: Int32): Boolean;
    ///<summary>Retrieves data of type XML as an <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="i">The value of the specified column.</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.SqlClient.SqlDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not xml.</exception>
    function GetXmlReader(i: Int32): DDN.System.Xml.DNXmlReader;
    ///<summary>Retrieves binary, image, varbinary, UDT, and variant data types as a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal.</param>
    ///<returns>A stream object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.SqlClient.SqlDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:binaryimagevarbinaryudt</exception>
    function GetStream(i: Int32): DDN.mscorlib.DNStream;
    ///<summary>Gets the value of the specified column as a byte.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column as a byte.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetByte(i: Int32): Byte;
    ///<summary>Reads a stream of bytes from the specified column offset into the buffer an array starting at the given buffer offset.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the field from which to begin the read operation.</param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferIndex">The index within the <paramref name="buffer" />
    ///  where the write operation is to start. </param>
    ///  <param name="length">The maximum length to copy into the buffer. </param>
    ///<returns>The actual number of bytes read.</returns>
    function GetBytes(i: Int32; dataIndex: Int64; buffer: TArray<Byte>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Retrieves Char, NChar, NText, NVarChar, text, varChar, and Variant data types as a <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="i">The column to be retrieved.</param>
    ///<returns>The returned object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.SqlClient.SqlDataReader.Read" />
    ///  hasn't been called, or returned false).Tried to read a previously-read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception><exception cref="T:System.InvalidCastException">The returned type was not one of the types below:charncharntextnvarchartextvarchar</exception>
    function GetTextReader(i: Int32): DDN.mscorlib.DNTextReader;
    ///<summary>Gets the value of the specified column as a single character.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetChar(i: Int32): Char;
    ///<summary>Reads a stream of characters from the specified column offset into the buffer as an array starting at the given buffer offset.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///  <param name="dataIndex">The index within the field from which to begin the read operation.</param>
    ///  <param name="buffer">The buffer into which to read the stream of bytes. </param>
    ///  <param name="bufferIndex">The index within the <paramref name="buffer" />
    ///  where the write operation is to start. </param>
    ///  <param name="length">The maximum length to copy into the buffer. </param>
    ///<returns>The actual number of characters read.</returns>
    function GetChars(i: Int32; dataIndex: Int64; buffer: TArray<Char>; bufferIndex: Int32; length: Int32): Int64;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDateTime(i: Int32): DDN.mscorlib.DNDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDecimal(i: Int32): DDN.mscorlib.DNDecimal;
    ///<summary>Gets the value of the specified column as a double-precision floating point number.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDouble(i: Int32): Double;
    ///<summary>Gets the value of the specified column as a single-precision floating point number.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetFloat(i: Int32): Single;
    ///<summary>Gets the value of the specified column as a globally unique identifier (GUID).</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetGuid(i: Int32): DDN.mscorlib.DNGuid;
    ///<summary>Gets the value of the specified column as a 16-bit signed integer.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt16(i: Int32): Int16;
    ///<summary>Gets the value of the specified column as a 32-bit signed integer.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt32(i: Int32): Int32;
    ///<summary>Gets the value of the specified column as a 64-bit signed integer.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetInt64(i: Int32): Int64;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column.</returns>
    function GetSqlBoolean(i: Int32): DNSqlBoolean;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  .</returns>
    function GetSqlBinary(i: Int32): DNSqlBinary;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a  <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    function GetSqlByte(i: Int32): DNSqlByte;
    ///<summary>Gets the value of the specified column as <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlBytes" />
    ///  .</returns>
    function GetSqlBytes(i: Int32): DNSqlBytes;
    ///<summary>Gets the value of the specified column as <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a  <see cref="T:System.Data.SqlTypes.SqlChars" />
    ///  .</returns>
    function GetSqlChars(i: Int32): DNSqlChars;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a  <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  .</returns>
    function GetSqlDateTime(i: Int32): DNSqlDateTime;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function GetSqlDecimal(i: Int32): DNSqlDecimal;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a  <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</returns>
    function GetSqlGuid(i: Int32): DNSqlGuid;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a  <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    function GetSqlDouble(i: Int32): DNSqlDouble;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</returns>
    function GetSqlInt16(i: Int32): DNSqlInt16;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function GetSqlInt32(i: Int32): DNSqlInt32;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function GetSqlInt64(i: Int32): DNSqlInt64;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function GetSqlMoney(i: Int32): DNSqlMoney;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function GetSqlSingle(i: Int32): DNSqlSingle;
    ///<summary>Gets the value of the specified column as a <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the column expressed as a <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    function GetSqlString(i: Int32): DNSqlString;
    ///<summary>Gets the value of the specified column as an XML value.</summary>
    ///  <param name="i">The zero-based column ordinal.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  value that contains the XML stored within the corresponding field. </returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The index passed was outside the range of 0 to <see cref="P:System.Data.DataTableReader.FieldCount" />
    ///  - 1</exception><exception cref="T:System.InvalidOperationException">An attempt was made to read or access columns in a closed <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The retrieved data is not compatible with the <see cref="T:System.Data.SqlTypes.SqlXml" />
    ///  type.</exception>
    function GetSqlXml(i: Int32): DNSqlXml;
    ///<summary>Fills an array of <see cref="T:System.Object" />
    ///  that contains the values for all the columns in the record, expressed as SQL Server types.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the values. The column values are expressed as SQL Server types.</param>
    ///<returns>An integer indicating the number of columns copied.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="values" />
    ///  is null. </exception>
    function GetSqlValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets the value of the specified column as a string.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetString(i: Int32): string;
    ///<summary>Retrieves the value of the specified column as a <see cref="T:System.TimeSpan" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetTimeSpan(i: Int32): DDN.mscorlib.DNTimeSpan;
    ///<summary>Retrieves the value of the specified column as a <see cref="T:System.DateTimeOffset" />
    ///  object.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns>The value of the specified column.</returns>
    ///<exception cref="T:System.InvalidCastException">The specified cast is not valid. </exception>
    function GetDateTimeOffset(i: Int32): DDN.mscorlib.DNDateTimeOffset;
    ///<summary>Populates an array of objects with the column values of the current row.</summary>
    ///  <param name="values">An array of <see cref="T:System.Object" />
    ///  into which to copy the attribute columns. </param>
    ///<returns>The number of instances of <see cref="T:System.Object" />
    ///  in the array.</returns>
    function GetValues(values: TArray<DDN.mscorlib.DNObject>): Int32;
    ///<summary>Gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="i">The zero-based column ordinal. </param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see cref="T:System.DBNull" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function IsDBNull(i: Int32): Boolean;
    ///<summary>Advances the data reader to the next result, when reading the results of batch Transact-SQL statements.</summary>
    ///<returns><see langword="true" />
    ///  if there are more result sets; otherwise <see langword="false" />
    ///  .</returns>
    function NextResult: Boolean;
    ///<summary>Advances the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  to the next record.</summary>
    ///<returns><see langword="true" />
    ///  if there are more rows; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.</exception>
    function Read: Boolean;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlDataReader.NextResult" />
    ///  , which advances the data reader to the next result, when reading the results of batch Transact-SQL statements.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses.  Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlDataReader.NextResultAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.</exception>
    function NextResultAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlDataReader.Read" />
    ///  , which advances the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  to the next record.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="cancellationToken">The cancellation instruction.</param>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling <see cref="M:System.Data.SqlClient.SqlDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  more than once for the same instance before task completion.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.Data.SqlClient.SqlException">
    ///  SQL Server returned an error while executing the command text.</exception>
    function ReadAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values.The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object.</summary>
    ///  <param name="i">The zero-based column to be retrieved.</param>
    ///  <param name="cancellationToken">The cancellation instruction, which propagates a notification that operations should be canceled. This does not guarantee the cancellation. A setting of <see langword="CancellationToken.None" />
    ///  makes this method equivalent to <see cref="M:System.Data.SqlClient.SqlDataReader.IsDBNull(System.Int32)" />
    ///  . The returned task must be marked as cancelled.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.SqlClient.SqlDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.
    ///<see langword="Context Connection=true" />
    ///  is specified in the connection string.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(i: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Data.Common.DbDataReader" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Returns a <see cref="T:System.Data.Common.DbDataReader" />
    ///  object for the requested column ordinal.</summary>
    ///  <param name="ordinal">The zero-based column ordinal.</param>
    ///<returns>A <see cref="T:System.Data.Common.DbDataReader" />
    ///  object.</returns>
    function GetData(ordinal: Int32): DNDbDataReader;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.IsDBNull(System.Int32)" />
    ///  , which gets a value that indicates whether the column contains non-existent or missing values.</summary>
    ///  <param name="ordinal">The zero-based column to be retrieved.</param>
    ///<returns><see langword="true" />
    ///  if the specified column value is equivalent to <see langword="DBNull" />
    ///  otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The connection drops or is closed during the data retrieval.The <see cref="T:System.Data.Common.DbDataReader" />
    ///  is closed during the data retrieval.There is no data ready to be read (for example, the first <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  hasn't been called, or returned false).Trying to read a previously read column in sequential mode.There was an asynchronous operation in progress. This applies to all Get* methods when running in sequential mode, as they could be called while reading a stream.</exception><exception cref="T:System.IndexOutOfRangeException">Trying to read a column that does not exist.</exception>
    function IsDBNullAsync(ordinal: Int32): DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.Read" />
    ///  , which advances the reader to the next record in a result set. This method invokes <see cref="M:System.Data.Common.DbDataReader.ReadAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    ///<summary>An asynchronous version of <see cref="M:System.Data.Common.DbDataReader.NextResult" />
    ///  , which advances the reader to the next result when reading the results of a batch of statements.Invokes <see cref="M:System.Data.Common.DbDataReader.NextResultAsync(System.Threading.CancellationToken)" />
    ///  with CancellationToken.None.</summary>
    ///<returns>A task representing the asynchronous operation.</returns>
    ///<exception cref="T:System.Data.Common.DbException">An error occurred while executing the command text.</exception>
    function NextResultAsync: DDN.mscorlib.DNTask<Boolean>; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates the depth of nesting for the current row.</summary>
    ///<returns>The depth of nesting for the current row.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the number of columns in the current row.</summary>
    ///<returns>When not positioned in a valid recordset, 0; otherwise the number of columns in the current row. The default is -1.</returns>
    ///<exception cref="T:System.NotSupportedException">There is no current connection to an instance of SQL Server. </exception>
    property FieldCount: Int32 read get_FieldCount;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  contains one or more rows.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  contains one or more rows; otherwise <see langword="false" />
    ///  .</returns>
    property HasRows: Boolean read get_HasRows;
    ///<summary>Retrieves a Boolean value that indicates whether the specified <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  instance has been closed. </summary>
    ///<returns><see langword="true" />
    ///  if the specified <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  instance is closed; otherwise <see langword="false" />
    ///  . </returns>
    property IsClosed: Boolean read get_IsClosed;
    ///<summary>Gets the number of rows changed, inserted, or deleted by execution of the Transact-SQL statement.</summary>
    ///<returns>The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.</returns>
    property RecordsAffected: Int32 read get_RecordsAffected;
    ///<summary>Gets the number of fields in the <see cref="T:System.Data.SqlClient.SqlDataReader" />
    ///  that are not hidden. </summary>
    ///<returns>The number of fields that are not hidden.</returns>
    property VisibleFieldCount: Int32 read get_VisibleFieldCount;
    property Item[i: Int32]: DDN.mscorlib.DNObject read get_Item; default;
    property Item[name: string]: DDN.mscorlib.DNObject read get_Item; default;
  end;

  TDNSqlDataReader = class(TDNGenericImport<DNSqlDataReaderClass, DNSqlDataReader>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbParameterClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{F6963C2C-CA04-5763-A9E1-B6EC207FA30C}']
  end;

  ///<summary>Represents a parameter to a <see cref="T:System.Data.Common.DbCommand" />
  ///  and optionally, its mapping to a <see cref="T:System.Data.DataSet" />
  ///  column. For more information on parameters, see Configuring Parameters and Parameter Data Types.</summary>
  [DNTypeName('System.Data.Common.DbParameter')]
  DNDbParameter = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{C4B6E989-39F9-3A4D-ABFE-52E8C93A7E8B}']
  { getters & setters } 

    function get_DbType: DNDbType;
    procedure set_DbType(value: DNDbType);
    function get_Direction: DNParameterDirection;
    procedure set_Direction(value: DNParameterDirection);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_ParameterName: string;
    procedure set_ParameterName(value: string);
    function get_Precision: Byte;
    procedure set_Precision(value: Byte);
    function get_Scale: Byte;
    procedure set_Scale(value: Byte);
    function get_Size: Int32;
    procedure set_Size(value: Int32);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);
    function get_SourceColumnNullMapping: Boolean;
    procedure set_SourceColumnNullMapping(value: Boolean);
    function get_SourceVersion: DNDataRowVersion;
    procedure set_SourceVersion(value: DNDataRowVersion);
    function get_Value: DDN.mscorlib.DNObject;
    procedure set_Value(value: DDN.mscorlib.DNObject);

  { methods } 

    ///<summary>Resets the DbType property to its original settings.</summary>
    procedure ResetDbType;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.DbType" />
    ///  of the parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.DbType" />
    ///  values. The default is <see cref="F:System.Data.DbType.String" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property is not set to a valid <see cref="T:System.Data.DbType" />
    ///  .</exception>
    property DbType: DNDbType read get_DbType write set_DbType;
    ///<summary>Gets or sets a value that indicates whether the parameter is input-only, output-only, bidirectional, or a stored procedure return value parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. The default is <see langword="Input" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property is not set to one of the valid <see cref="T:System.Data.ParameterDirection" />
    ///  values.</exception>
    property Direction: DNParameterDirection read get_Direction write set_Direction;
    ///<summary>Gets or sets a value that indicates whether the parameter accepts null values.</summary>
    ///<returns><see langword="true" />
    ///  if null values are accepted; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets the name of the <see cref="T:System.Data.Common.DbParameter" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.Common.DbParameter" />
    ///  . The default is an empty string ("").</returns>
    property ParameterName: string read get_ParameterName write set_ParameterName;
    ///<summary>[Supported in the .NET Framework 4.5.1 and later versions] Gets or sets the maximum number of digits used to represent the <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  property.</summary>
    ///<returns>The maximum number of digits used to represent the <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  property.</returns>
    property Precision: Byte read get_Precision write set_Precision;
    ///<summary>Gets or sets the number of decimal places to which <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  is resolved.</summary>
    ///<returns>The number of decimal places to which <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  is resolved.</returns>
    property Scale: Byte read get_Scale write set_Scale;
    ///<summary>Gets or sets the maximum size, in bytes, of the data within the column.</summary>
    ///<returns>The maximum size, in bytes, of the data within the column. The default value is inferred from the parameter value.</returns>
    property Size: Int32 read get_Size write set_Size;
    ///<summary>Gets or sets the name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  and used for loading or returning the <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  .</summary>
    ///<returns>The name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  . The default is an empty string.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
    ///<summary>Sets or gets a value which indicates whether the source column is nullable. This allows <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  to correctly generate Update statements for nullable columns.</summary>
    ///<returns><see langword="true" />
    ///  if the source column is nullable; <see langword="false" />
    ///  if it is not.</returns>
    property SourceColumnNullMapping: Boolean read get_SourceColumnNullMapping write set_SourceColumnNullMapping;
    ///<summary>Gets or sets the <see cref="T:System.Data.DataRowVersion" />
    ///  to use when you load <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. The default is <see langword="Current" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property is not set to one of the <see cref="T:System.Data.DataRowVersion" />
    ///  values.</exception>
    property SourceVersion: DNDataRowVersion read get_SourceVersion write set_SourceVersion;
    ///<summary>Gets or sets the value of the parameter.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is the value of the parameter. The default value is null.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value write set_Value;
  end;

  TDNDbParameter = class(TDNGenericImport<DNDbParameterClass, DNDbParameter>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcParameterClass = interface(DNDbParameterClass)
  ['{E60BBD69-62CF-59DB-B824-4FF4978220E7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class.</summary>
    {class} function init: DNOdbcParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class that uses the parameter name and an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</summary>
    ///  <param name="name">The name of the parameter. </param>
    ///  <param name="value">An <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object. </param>
    {class} function init(name: string; value: DDN.mscorlib.DNObject): DNOdbcParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class that uses the parameter name and data type.</summary>
    ///  <param name="name">The name of the parameter. </param>
    ///  <param name="type">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="type" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(name: string; &type: DNOdbcType): DNOdbcParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class that uses the parameter name, data type, and length.</summary>
    ///  <param name="name">The name of the parameter. </param>
    ///  <param name="type">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="type" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(name: string; &type: DNOdbcType; size: Int32): DNOdbcParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class that uses the parameter name, data type, length, and source column name.</summary>
    ///  <param name="name">The name of the parameter. </param>
    ///  <param name="type">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="sourcecolumn">The name of the source column. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="type" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(name: string; &type: DNOdbcType; size: Int32; sourcecolumn: string): DNOdbcParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class that uses the parameter name, data type, length, source column name, parameter direction, numeric precision, and other properties.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="odbcType">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="parameterDirection">One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. </param>
    ///  <param name="isNullable"><see langword="true" />
    ///  if the value of the field can be null; otherwise <see langword="false" />
    ///  . </param>
    ///  <param name="precision">The total number of digits to the left and right of the decimal point to which <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="scale">The total number of decimal places to which <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="srcColumn">The name of the source column. </param>
    ///  <param name="srcVersion">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. </param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="type" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; odbcType: DNOdbcType; size: Int32; parameterDirection: DNParameterDirection; isNullable: Boolean; precision: Byte; scale: Byte; srcColumn: string; srcVersion: DNDataRowVersion; value: DDN.mscorlib.DNObject): DNOdbcParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  class that uses the parameter name, data type, length, source column name, parameter direction, numeric precision, and other properties.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="odbcType">One of the <see cref="P:System.Data.Odbc.OdbcParameter.OdbcType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="parameterDirection">One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. </param>
    ///  <param name="precision">The total number of digits to the left and right of the decimal point to which <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="scale">The total number of decimal places to which <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="sourceColumn">The name of the source column. </param>
    ///  <param name="sourceVersion">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. </param>
    ///  <param name="sourceColumnNullMapping"><see langword="true" />
    ///  if the corresponding source column is nullable; <see langword="false" />
    ///  if it is not.</param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="type" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; odbcType: DNOdbcType; size: Int32; parameterDirection: DNParameterDirection; precision: Byte; scale: Byte; sourceColumn: string; sourceVersion: DNDataRowVersion; sourceColumnNullMapping: Boolean; value: DDN.mscorlib.DNObject): DNOdbcParameter; overload;

  end;

  ///<summary>Represents a parameter to an <see cref="T:System.Data.Odbc.OdbcCommand" />
  ///  and optionally, its mapping to a <see cref="T:System.Data.DataColumn" />
  ///  . This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcParameter')]
  DNOdbcParameter = interface(DNDbParameter)
  ['{1E022618-1E0C-36DB-BBE6-CE8F6AD07304}']
  { getters & setters } 

    function get_DbType: DNDbType;
    procedure set_DbType(value: DNDbType);
    function get_OdbcType: DNOdbcType;
    procedure set_OdbcType(value: DNOdbcType);
    function get_ParameterName: string;
    procedure set_ParameterName(value: string);
    function get_Precision: Byte;
    procedure set_Precision(value: Byte);
    function get_Scale: Byte;
    procedure set_Scale(value: Byte);
    function get_Value: DDN.mscorlib.DNObject;
    procedure set_Value(value: DDN.mscorlib.DNObject);
    function get_Direction: DNParameterDirection;
    procedure set_Direction(value: DNParameterDirection);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_Size: Int32;
    procedure set_Size(value: Int32);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);
    function get_SourceColumnNullMapping: Boolean;
    procedure set_SourceColumnNullMapping(value: Boolean);
    function get_SourceVersion: DNDataRowVersion;
    procedure set_SourceVersion(value: DNDataRowVersion);

  { methods } 

    ///<summary>Resets the type associated with this <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  .</summary>
    procedure ResetDbType;
    ///<summary>Gets a string that contains the <see cref="P:System.Data.Odbc.OdbcParameter.ParameterName" />
    ///  .</summary>
    ///<returns>A string that contains the <see cref="P:System.Data.Odbc.OdbcParameter.ParameterName" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Resets the type associated with this <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  .</summary>
    procedure ResetOdbcType;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.DbType" />
    ///  of the parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.DbType" />
    ///  values. The default is <see cref="T:System.String" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The property was not set to a valid <see cref="T:System.Data.DbType" />
    ///  . </exception>
    property DbType: DNDbType read get_DbType write set_DbType;
    ///<summary>Gets or sets the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  of the parameter.</summary>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcType" />
    ///  value that is the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  of the parameter. The default is <see langword="Nchar" />
    ///  .</returns>
    property OdbcType: DNOdbcType read get_OdbcType write set_OdbcType;
    ///<summary>Gets or sets the name of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  . The default is an empty string ("").</returns>
    property ParameterName: string read get_ParameterName write set_ParameterName;
    ///<summary>Gets or sets the number of digits used to represent the <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  property.</summary>
    ///<returns>The maximum number of digits used to represent the <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  property. The default value is 0, which indicates that the data provider sets the precision for <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  . </returns>
    property Precision: Byte read get_Precision write set_Precision;
    ///<summary>Gets or sets the number of decimal places to which <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  is resolved.</summary>
    ///<returns>The number of decimal places to which <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  is resolved. The default is 0.</returns>
    property Scale: Byte read get_Scale write set_Scale;
    ///<summary>Gets or sets the value of the parameter.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is the value of the parameter. The default value is null.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value write set_Value;
    ///<summary>Gets or sets a value that indicates whether the parameter is input-only, output-only, bidirectional, or a stored procedure return value parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. The default is <see langword="Input" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property was not set to one of the valid <see cref="T:System.Data.ParameterDirection" />
    ///  values.</exception>
    property Direction: DNParameterDirection read get_Direction write set_Direction;
    ///<summary>Gets or sets a value that indicates whether the parameter accepts null values.</summary>
    ///<returns><see langword="true" />
    ///  if null values are accepted; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets the maximum size of the data within the column.</summary>
    ///<returns>The maximum size of the data within the column. The default value is inferred from the parameter value.</returns>
    property Size: Int32 read get_Size write set_Size;
    ///<summary>Gets or sets the name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  and used for loading or returning the <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  .</summary>
    ///<returns>The name of the source column that will be used to set the value of this parameter. The default is an empty string ("").</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
    ///<summary>Sets or gets a value which indicates whether the source column is nullable. This lets <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  correctly generate Update statements for nullable columns.</summary>
    ///<returns><see langword="true" />
    ///  if the source column is nullable; <see langword="false" />
    ///  if it is not.</returns>
    property SourceColumnNullMapping: Boolean read get_SourceColumnNullMapping write set_SourceColumnNullMapping;
    ///<summary>Gets or sets the <see cref="T:System.Data.DataRowVersion" />
    ///  to use when you load <see cref="P:System.Data.Odbc.OdbcParameter.Value" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. The default is Current.</returns>
    property SourceVersion: DNDataRowVersion read get_SourceVersion write set_SourceVersion;
  end;

  TDNOdbcParameter = class(TDNGenericImport<DNOdbcParameterClass, DNOdbcParameter>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbParameterClass = interface(DNDbParameterClass)
  ['{8FC50BD2-324C-56E6-9486-C4C0BD85DA81}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class.</summary>
    {class} function init: DNOleDbParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class that uses the parameter name and the value of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  .</summary>
    ///  <param name="name">The name of the parameter to map. </param>
    ///  <param name="value">The value of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object. </param>
    {class} function init(name: string; value: DDN.mscorlib.DNObject): DNOleDbParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class that uses the parameter name and data type.</summary>
    ///  <param name="name">The name of the parameter to map. </param>
    ///  <param name="dataType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dataType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(name: string; dataType: DNOleDbType): DNOleDbParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class that uses the parameter name, data type, and length.</summary>
    ///  <param name="name">The name of the parameter to map. </param>
    ///  <param name="dataType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dataType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(name: string; dataType: DNOleDbType; size: Int32): DNOleDbParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class that uses the parameter name, data type, length, and source column name.</summary>
    ///  <param name="name">The name of the parameter to map. </param>
    ///  <param name="dataType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="srcColumn">The name of the source column. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dataType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(name: string; dataType: DNOleDbType; size: Int32; srcColumn: string): DNOleDbParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class that uses the parameter name, data type, length, source column name, parameter direction, numeric precision, and other properties.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="direction">One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. </param>
    ///  <param name="isNullable"><see langword="true" />
    ///  if the value of the field can be null; otherwise <see langword="false" />
    ///  . </param>
    ///  <param name="precision">The total number of digits to the left and right of the decimal point to which <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="scale">The total number of decimal places to which <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="srcColumn">The name of the source column. </param>
    ///  <param name="srcVersion">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. </param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dataType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; dbType: DNOleDbType; size: Int32; direction: DNParameterDirection; isNullable: Boolean; precision: Byte; scale: Byte; srcColumn: string; srcVersion: DNDataRowVersion; value: DDN.mscorlib.DNObject): DNOleDbParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  class that uses the parameter name, data type, length, source column name, parameter direction, numeric precision, and other properties.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="direction">One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. </param>
    ///  <param name="precision">The total number of digits to the left and right of the decimal point to which <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved.</param>
    ///  <param name="scale">The total number of decimal places to which <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved.</param>
    ///  <param name="sourceColumn">The name of the source column.</param>
    ///  <param name="sourceVersion">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values.</param>
    ///  <param name="sourceColumnNullMapping"><see langword="true" />
    ///  if the source column is nullable; <see langword="false" />
    ///  if it is not.</param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dataType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; dbType: DNOleDbType; size: Int32; direction: DNParameterDirection; precision: Byte; scale: Byte; sourceColumn: string; sourceVersion: DNDataRowVersion; sourceColumnNullMapping: Boolean; value: DDN.mscorlib.DNObject): DNOleDbParameter; overload;

  end;

  ///<summary>Represents a parameter to an <see cref="T:System.Data.OleDb.OleDbCommand" />
  ///  and optionally its mapping to a <see cref="T:System.Data.DataSet" />
  ///  column. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.OleDb.OleDbParameter')]
  DNOleDbParameter = interface(DNDbParameter)
  ['{A96E1807-77BF-31AD-A4CE-2DEC5B2C4A62}']
  { getters & setters } 

    function get_DbType: DNDbType;
    procedure set_DbType(value: DNDbType);
    function get_OleDbType: DNOleDbType;
    procedure set_OleDbType(value: DNOleDbType);
    function get_ParameterName: string;
    procedure set_ParameterName(value: string);
    function get_Precision: Byte;
    procedure set_Precision(value: Byte);
    function get_Scale: Byte;
    procedure set_Scale(value: Byte);
    function get_Value: DDN.mscorlib.DNObject;
    procedure set_Value(value: DDN.mscorlib.DNObject);
    function get_Direction: DNParameterDirection;
    procedure set_Direction(value: DNParameterDirection);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_Size: Int32;
    procedure set_Size(value: Int32);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);
    function get_SourceColumnNullMapping: Boolean;
    procedure set_SourceColumnNullMapping(value: Boolean);
    function get_SourceVersion: DNDataRowVersion;
    procedure set_SourceVersion(value: DNDataRowVersion);

  { methods } 

    ///<summary>Resets the type associated with this <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  .</summary>
    procedure ResetDbType;
    ///<summary>Gets a string that contains the <see cref="P:System.Data.OleDb.OleDbParameter.ParameterName" />
    ///  .</summary>
    ///<returns>A string that contains the <see cref="P:System.Data.OleDb.OleDbParameter.ParameterName" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Resets the type associated with this <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  .</summary>
    procedure ResetOleDbType;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Data.DbType" />
    ///  of the parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.DbType" />
    ///  values. The default is <see cref="F:System.Data.DbType.String" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The property was not set to a valid <see cref="T:System.Data.DbType" />
    ///  . </exception>
    property DbType: DNDbType read get_DbType write set_DbType;
    ///<summary>Gets or sets the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  of the parameter.</summary>
    ///<returns>The <see cref="T:System.Data.OleDb.OleDbType" />
    ///  of the parameter. The default is <see cref="F:System.Data.OleDb.OleDbType.VarWChar" />
    ///  .</returns>
    property OleDbType: DNOleDbType read get_OleDbType write set_OleDbType;
    ///<summary>Gets or sets the name of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  . The default is an empty string ("").</returns>
    property ParameterName: string read get_ParameterName write set_ParameterName;
    ///<summary>Gets or sets the maximum number of digits used to represent the <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  property.</summary>
    ///<returns>The maximum number of digits used to represent the <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  property. The default value is 0, which indicates that the data provider sets the precision for <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  .</returns>
    property Precision: Byte read get_Precision write set_Precision;
    ///<summary>Gets or sets the number of decimal places to which <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved.</summary>
    ///<returns>The number of decimal places to which <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  is resolved. The default is 0.</returns>
    property Scale: Byte read get_Scale write set_Scale;
    ///<summary>Gets or sets the value of the parameter.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is the value of the parameter. The default value is null.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value write set_Value;
    ///<summary>Gets or sets a value that indicates whether the parameter is input-only, output-only, bidirectional, or a stored procedure return-value parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. The default is <see langword="Input" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property was not set to one of the valid <see cref="T:System.Data.ParameterDirection" />
    ///  values.</exception>
    property Direction: DNParameterDirection read get_Direction write set_Direction;
    ///<summary>Gets or sets a value that indicates whether the parameter accepts null values.</summary>
    ///<returns><see langword="true" />
    ///  if null values are accepted; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets the maximum size, in bytes, of the data within the column.</summary>
    ///<returns>The maximum size, in bytes, of the data within the column. The default value is inferred from the parameter value.</returns>
    property Size: Int32 read get_Size write set_Size;
    ///<summary>Gets or sets the name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  and used for loading or returning the <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  .</summary>
    ///<returns>The name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  . The default is an empty string.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
    ///<summary>Sets or gets a value which indicates whether the source column is nullable. This allows <see cref="T:System.Data.Common.DbCommandBuilder" />
    ///  to correctly generate Update statements for nullable columns.</summary>
    ///<returns><see langword="true" />
    ///  if the source column is nullable; <see langword="false" />
    ///  if it is not.</returns>
    property SourceColumnNullMapping: Boolean read get_SourceColumnNullMapping write set_SourceColumnNullMapping;
    ///<summary>Gets or sets the <see cref="T:System.Data.DataRowVersion" />
    ///  to use when you load <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. The default is <see langword="Current" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property was not set to one of the <see cref="T:System.Data.DataRowVersion" />
    ///  values.</exception>
    property SourceVersion: DNDataRowVersion read get_SourceVersion write set_SourceVersion;
  end;

  TDNOleDbParameter = class(TDNGenericImport<DNOleDbParameterClass, DNOleDbParameter>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlParameterClass = interface(DNDbParameterClass)
  ['{BA938AC2-82F5-59BE-88BC-E00D81906E86}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class.</summary>
    {class} function init: DNSqlParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class that uses the parameter name, the type of the parameter, the size of the parameter, a <see cref="T:System.Data.ParameterDirection" />
    ///  , the precision of the parameter, the scale of the parameter, the source column, a <see cref="T:System.Data.DataRowVersion" />
    ///  to use, and the value of the parameter.</summary>
    ///  <param name="parameterName">The name of the parameter to map. </param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="direction">One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. </param>
    ///  <param name="isNullable"><see langword="true" />
    ///  if the value of the field can be null; otherwise <see langword="false" />
    ///  . </param>
    ///  <param name="precision">The total number of digits to the left and right of the decimal point to which <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="scale">The total number of decimal places to which <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  is resolved. </param>
    ///  <param name="sourceColumn">The name of the source column (<see cref="P:System.Data.SqlClient.SqlParameter.SourceColumn" />
    ///  ) if this <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  is used in a call to <see cref="Overload:System.Data.Common.DbDataAdapter.Update" />
    ///  .</param>
    ///  <param name="sourceVersion">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. </param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dbType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; dbType: DNSqlDbType; size: Int32; direction: DNParameterDirection; isNullable: Boolean; precision: Byte; scale: Byte; sourceColumn: string; sourceVersion: DNDataRowVersion; value: DDN.mscorlib.DNObject): DNSqlParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class that uses the parameter name, the type of the parameter, the length of the parameter the direction, the precision, the scale, the name of the source column, one of the <see cref="T:System.Data.DataRowVersion" />
    ///  values, a Boolean for source column mapping, the value of the <see langword="SqlParameter" />
    ///  , the name of the database where the schema collection for this XML instance is located, the owning relational schema where the schema collection for this XML instance is located, and the name of the schema collection for this parameter.</summary>
    ///  <param name="parameterName">The name of the parameter to map.</param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values.</param>
    ///  <param name="size">The length of the parameter.</param>
    ///  <param name="direction">One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values.</param>
    ///  <param name="precision">The total number of digits to the left and right of the decimal point to which <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  is resolved.</param>
    ///  <param name="scale">The total number of decimal places to which <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  is resolved.</param>
    ///  <param name="sourceColumn">The name of the source column (<see cref="P:System.Data.SqlClient.SqlParameter.SourceColumn" />
    ///  ) if this <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  is used in a call to <see cref="Overload:System.Data.Common.DbDataAdapter.Update" />
    ///  .</param>
    ///  <param name="sourceVersion">One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. </param>
    ///  <param name="sourceColumnNullMapping"><see langword="true" />
    ///  if the source column is nullable; <see langword="false" />
    ///  if it is not.</param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  .</param>
    ///  <param name="xmlSchemaCollectionDatabase">The name of the database where the schema collection for this XML instance is located.</param>
    ///  <param name="xmlSchemaCollectionOwningSchema">The owning relational schema where the schema collection for this XML instance is located.</param>
    ///  <param name="xmlSchemaCollectionName">The name of the schema collection for this parameter.</param>
    {class} function init(parameterName: string; dbType: DNSqlDbType; size: Int32; direction: DNParameterDirection; precision: Byte; scale: Byte; sourceColumn: string; sourceVersion: DNDataRowVersion; sourceColumnNullMapping: Boolean; value: DDN.mscorlib.DNObject; xmlSchemaCollectionDatabase: string; xmlSchemaCollectionOwningSchema: string; xmlSchemaCollectionName: string): DNSqlParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class that uses the parameter name and the data type.</summary>
    ///  <param name="parameterName">The name of the parameter to map. </param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dbType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; dbType: DNSqlDbType): DNSqlParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class that uses the parameter name and a value of the new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  .</summary>
    ///  <param name="parameterName">The name of the parameter to map. </param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  that is the value of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  . </param>
    {class} function init(parameterName: string; value: DDN.mscorlib.DNObject): DNSqlParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class that uses the parameter name, the <see cref="T:System.Data.SqlDbType" />
    ///  , and the size.</summary>
    ///  <param name="parameterName">The name of the parameter to map. </param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dbType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; dbType: DNSqlDbType; size: Int32): DNSqlParameter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  class that uses the parameter name, the <see cref="T:System.Data.SqlDbType" />
    ///  , the size, and the source column name.</summary>
    ///  <param name="parameterName">The name of the parameter to map. </param>
    ///  <param name="dbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the parameter. </param>
    ///  <param name="sourceColumn">The name of the source column (<see cref="P:System.Data.SqlClient.SqlParameter.SourceColumn" />
    ///  ) if this <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  is used in a call to <see cref="Overload:System.Data.Common.DbDataAdapter.Update" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentException">The value supplied in the <paramref name="dbType" />
    ///  parameter is an invalid back-end data type. </exception>
    {class} function init(parameterName: string; dbType: DNSqlDbType; size: Int32; sourceColumn: string): DNSqlParameter; overload;

  end;

  ///<summary>Represents a parameter to a <see cref="T:System.Data.SqlClient.SqlCommand" />
  ///  and optionally its mapping to <see cref="T:System.Data.DataSet" />
  ///  columns. This class cannot be inherited. For more information on parameters, see Configuring Parameters and Parameter Data Types.</summary>
  [DNTypeName('System.Data.SqlClient.SqlParameter')]
  DNSqlParameter = interface(DNDbParameter)
  ['{FBA6EDCE-D5E7-3E0D-8DF5-18E249F61813}']
  { getters & setters } 

    function get_CompareInfo: DNSqlCompareOptions;
    procedure set_CompareInfo(value: DNSqlCompareOptions);
    function get_XmlSchemaCollectionDatabase: string;
    procedure set_XmlSchemaCollectionDatabase(value: string);
    function get_XmlSchemaCollectionOwningSchema: string;
    procedure set_XmlSchemaCollectionOwningSchema(value: string);
    function get_XmlSchemaCollectionName: string;
    procedure set_XmlSchemaCollectionName(value: string);
    function get_ForceColumnEncryption: Boolean;
    procedure set_ForceColumnEncryption(value: Boolean);
    function get_DbType: DNDbType;
    procedure set_DbType(value: DNDbType);
    function get_LocaleId: Int32;
    procedure set_LocaleId(value: Int32);
    function get_ParameterName: string;
    procedure set_ParameterName(value: string);
    function get_Precision: Byte;
    procedure set_Precision(value: Byte);
    function get_Scale: Byte;
    procedure set_Scale(value: Byte);
    function get_SqlDbType: DNSqlDbType;
    procedure set_SqlDbType(value: DNSqlDbType);
    function get_SqlValue: DDN.mscorlib.DNObject;
    procedure set_SqlValue(value: DDN.mscorlib.DNObject);
    function get_UdtTypeName: string;
    procedure set_UdtTypeName(value: string);
    function get_TypeName: string;
    procedure set_TypeName(value: string);
    function get_Value: DDN.mscorlib.DNObject;
    procedure set_Value(value: DDN.mscorlib.DNObject);
    function get_Direction: DNParameterDirection;
    procedure set_Direction(value: DNParameterDirection);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_Offset: Int32;
    procedure set_Offset(value: Int32);
    function get_Size: Int32;
    procedure set_Size(value: Int32);
    function get_SourceColumn: string;
    procedure set_SourceColumn(value: string);
    function get_SourceColumnNullMapping: Boolean;
    procedure set_SourceColumnNullMapping(value: Boolean);
    function get_SourceVersion: DNDataRowVersion;
    procedure set_SourceVersion(value: DNDataRowVersion);

  { methods } 

    ///<summary>Resets the type associated with this <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  .</summary>
    procedure ResetDbType;
    ///<summary>Gets a string that contains the <see cref="P:System.Data.SqlClient.SqlParameter.ParameterName" />
    ///  .</summary>
    ///<returns>A string that contains the <see cref="P:System.Data.SqlClient.SqlParameter.ParameterName" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Resets the type associated with this <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  .</summary>
    procedure ResetSqlDbType;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Globalization.CompareInfo" />
    ///  object that defines how string comparisons should be performed for this parameter.</summary>
    ///<returns>A <see cref="T:System.Globalization.CompareInfo" />
    ///  object that defines string comparison for this parameter.</returns>
    property CompareInfo: DNSqlCompareOptions read get_CompareInfo write set_CompareInfo;
    ///<summary>Gets the name of the database where the schema collection for this XML instance is located.</summary>
    ///<returns>The name of the database where the schema collection for this XML instance is located.</returns>
    property XmlSchemaCollectionDatabase: string read get_XmlSchemaCollectionDatabase write set_XmlSchemaCollectionDatabase;
    ///<summary>The owning relational schema where the schema collection for this XML instance is located.</summary>
    ///<returns>The owning relational schema for this XML instance.</returns>
    property XmlSchemaCollectionOwningSchema: string read get_XmlSchemaCollectionOwningSchema write set_XmlSchemaCollectionOwningSchema;
    ///<summary>Gets the name of the schema collection for this XML instance.</summary>
    ///<returns>The name of the schema collection for this XML instance.</returns>
    property XmlSchemaCollectionName: string read get_XmlSchemaCollectionName write set_XmlSchemaCollectionName;
    ///<summary>Enforces encryption of a parameter when using Always Encrypted. If SQL Server informs the driver that the parameter does not need to be encrypted, the query using the parameter will fail. This property provides additional protection against security attacks that involve a compromised SQL Server providing incorrect encryption metadata to the client, which may lead to data disclosure.</summary>
    ///<returns><see langword="true" />
    ///  if the parameter has a force column encryption; otherwise, <see langword="false" />
    ///  .</returns>
    property ForceColumnEncryption: Boolean read get_ForceColumnEncryption write set_ForceColumnEncryption;
    ///<summary>Gets or sets the <see cref="T:System.Data.SqlDbType" />
    ///  of the parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. The default is <see langword="NVarChar" />
    ///  .</returns>
    property DbType: DNDbType read get_DbType write set_DbType;
    ///<summary>Gets or sets the locale identifier that determines conventions and language for a particular region.</summary>
    ///<returns>Returns the locale identifier associated with the parameter.</returns>
    property LocaleId: Int32 read get_LocaleId write set_LocaleId;
    ///<summary>Gets or sets the name of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  .</summary>
    ///<returns>The name of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  . The default is an empty string.</returns>
    property ParameterName: string read get_ParameterName write set_ParameterName;
    ///<summary>Gets or sets the maximum number of digits used to represent the <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  property.</summary>
    ///<returns>The maximum number of digits used to represent the <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  property. The default value is 0. This indicates that the data provider sets the precision for <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  .</returns>
    property Precision: Byte read get_Precision write set_Precision;
    ///<summary>Gets or sets the number of decimal places to which <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  is resolved.</summary>
    ///<returns>The number of decimal places to which <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  is resolved. The default is 0.</returns>
    property Scale: Byte read get_Scale write set_Scale;
    ///<summary>Gets or sets the <see cref="T:System.Data.SqlDbType" />
    ///  of the parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. The default is <see langword="NVarChar" />
    ///  .</returns>
    property SqlDbType: DNSqlDbType read get_SqlDbType write set_SqlDbType;
    ///<summary>Gets or sets the value of the parameter as an SQL type.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is the value of the parameter, using SQL types. The default value is null.</returns>
    property SqlValue: DDN.mscorlib.DNObject read get_SqlValue write set_SqlValue;
    ///<summary>Gets or sets a <see langword="string" />
    ///  that represents a user-defined type as a parameter.</summary>
    ///<returns>A <see langword="string" />
    ///  that represents the fully qualified name of a user-defined type in the database.</returns>
    property UdtTypeName: string read get_UdtTypeName write set_UdtTypeName;
    ///<summary>Gets or sets the type name for a table-valued parameter.</summary>
    ///<returns>The type name of the specified table-valued parameter.</returns>
    property TypeName: string read get_TypeName write set_TypeName;
    ///<summary>Gets or sets the value of the parameter.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that is the value of the parameter. The default value is null.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value write set_Value;
    ///<summary>Gets or sets a value that indicates whether the parameter is input-only, output-only, bidirectional, or a stored procedure return value parameter.</summary>
    ///<returns>One of the <see cref="T:System.Data.ParameterDirection" />
    ///  values. The default is <see langword="Input" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The property was not set to one of the valid <see cref="T:System.Data.ParameterDirection" />
    ///  values.</exception>
    property Direction: DNParameterDirection read get_Direction write set_Direction;
    ///<summary>Gets or sets a value that indicates whether the parameter accepts null values. <see cref="P:System.Data.SqlClient.SqlParameter.IsNullable" />
    ///  is not used to validate the parameter’s value and will not prevent sending or receiving a null value when executing a command.</summary>
    ///<returns><see langword="true" />
    ///  if null values are accepted; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets the offset to the <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  property.</summary>
    ///<returns>The offset to the <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///  . The default is 0.</returns>
    property Offset: Int32 read get_Offset write set_Offset;
    ///<summary>Gets or sets the maximum size, in bytes, of the data within the column.</summary>
    ///<returns>The maximum size, in bytes, of the data within the column. The default value is inferred from the parameter value.</returns>
    property Size: Int32 read get_Size write set_Size;
    ///<summary>Gets or sets the name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  and used for loading or returning the <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///</summary>
    ///<returns>The name of the source column mapped to the <see cref="T:System.Data.DataSet" />
    ///  . The default is an empty string.</returns>
    property SourceColumn: string read get_SourceColumn write set_SourceColumn;
    ///<summary>Sets or gets a value which indicates whether the source column is nullable. This allows <see cref="T:System.Data.SqlClient.SqlCommandBuilder" />
    ///  to correctly generate Update statements for nullable columns.</summary>
    ///<returns><see langword="true" />
    ///  if the source column is nullable; <see langword="false" />
    ///  if it is not.</returns>
    property SourceColumnNullMapping: Boolean read get_SourceColumnNullMapping write set_SourceColumnNullMapping;
    ///<summary>Gets or sets the <see cref="T:System.Data.DataRowVersion" />
    ///  to use when you load <see cref="P:System.Data.SqlClient.SqlParameter.Value" />
    ///</summary>
    ///<returns>One of the <see cref="T:System.Data.DataRowVersion" />
    ///  values. The default is <see langword="Current" />
    ///  .</returns>
    property SourceVersion: DNDataRowVersion read get_SourceVersion write set_SourceVersion;
  end;

  TDNSqlParameter = class(TDNGenericImport<DNSqlParameterClass, DNSqlParameter>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbParameterCollectionClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{02F02AC2-2327-5D70-B009-B174A461E656}']
  end;

  ///<summary>The base class for a collection of parameters relevant to a <see cref="T:System.Data.Common.DbCommand" />
  ///  . </summary>
  [DNTypeName('System.Data.Common.DbParameterCollection')]
  DNDbParameterCollection = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{8498DAF2-C125-3F91-9392-5410107143A2}']
  { getters & setters } 

    function get_Count: Int32;
    function get_IsFixedSize: Boolean;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;
    function get_Item(index: Int32): DNDbParameter; overload;
    procedure set_Item(index: Int32; value: DNDbParameter); overload;
    function get_Item(parameterName: string): DNDbParameter; overload;
    procedure set_Item(parameterName: string; value: DNDbParameter); overload;

  { methods } 

    ///<summary>Adds the specified <see cref="T:System.Data.Common.DbParameter" />
    ///  object to the <see cref="T:System.Data.Common.DbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  of the <see cref="T:System.Data.Common.DbParameter" />
    ///  to add to the collection.</param>
    ///<returns>The index of the <see cref="T:System.Data.Common.DbParameter" />
    ///  object in the collection.</returns>
    function Add(value: DDN.mscorlib.DNObject): Int32;
    ///<summary>Adds an array of items with the specified values to the <see cref="T:System.Data.Common.DbParameterCollection" />
    ///  .</summary>
    ///  <param name="values">An array of values of type <see cref="T:System.Data.Common.DbParameter" />
    ///  to add to the collection.</param>
    procedure AddRange(values: DDN.mscorlib.DNArray);
    ///<summary>Indicates whether a <see cref="T:System.Data.Common.DbParameter" />
    ///  with the specified <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  is contained in the collection.</summary>
    ///  <param name="value">The <see cref="P:System.Data.Common.DbParameter.Value" />
    ///  of the <see cref="T:System.Data.Common.DbParameter" />
    ///  to look for in the collection.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbParameter" />
    ///  is in the collection; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Indicates whether a <see cref="T:System.Data.Common.DbParameter" />
    ///  with the specified name exists in the collection.</summary>
    ///  <param name="value">The name of the <see cref="T:System.Data.Common.DbParameter" />
    ///  to look for in the collection.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Common.DbParameter" />
    ///  is in the collection; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: string): Boolean; overload;
    ///<summary>Copies an array of items to the collection starting at the specified index.</summary>
    ///  <param name="array">The array of items to copy to the collection.</param>
    ///  <param name="index">The index in the collection to copy the items.</param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32);
    ///<summary>Removes all <see cref="T:System.Data.Common.DbParameter" />
    ///  values from the <see cref="T:System.Data.Common.DbParameterCollection" />
    ///  .</summary>
    procedure Clear;
    ///<summary>Exposes the <see cref="M:System.Collections.IEnumerable.GetEnumerator" />
    ///  method, which supports a simple iteration over a collection by a .NET Framework data provider.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  that can be used to iterate through the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Returns the index of the specified <see cref="T:System.Data.Common.DbParameter" />
    ///  object.</summary>
    ///  <param name="value">The <see cref="T:System.Data.Common.DbParameter" />
    ///  object in the collection.</param>
    ///<returns>The index of the specified <see cref="T:System.Data.Common.DbParameter" />
    ///  object.</returns>
    function IndexOf(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Returns the index of the <see cref="T:System.Data.Common.DbParameter" />
    ///  object with the specified name.</summary>
    ///  <param name="parameterName">The name of the <see cref="T:System.Data.Common.DbParameter" />
    ///  object in the collection.</param>
    ///<returns>The index of the <see cref="T:System.Data.Common.DbParameter" />
    ///  object with the specified name.</returns>
    function IndexOf(parameterName: string): Int32; overload;
    ///<summary>Inserts the specified index of the <see cref="T:System.Data.Common.DbParameter" />
    ///  object with the specified name into the collection at the specified index.</summary>
    ///  <param name="index">The index at which to insert the <see cref="T:System.Data.Common.DbParameter" />
    ///  object.</param>
    ///  <param name="value">The <see cref="T:System.Data.Common.DbParameter" />
    ///  object to insert into the collection.</param>
    procedure Insert(index: Int32; value: DDN.mscorlib.DNObject);
    ///<summary>Removes the specified <see cref="T:System.Data.Common.DbParameter" />
    ///  object from the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Data.Common.DbParameter" />
    ///  object to remove.</param>
    procedure Remove(value: DDN.mscorlib.DNObject);
    ///<summary>Removes the <see cref="T:System.Data.Common.DbParameter" />
    ///  object at the specified from the collection.</summary>
    ///  <param name="index">The index where the <see cref="T:System.Data.Common.DbParameter" />
    ///  object is located.</param>
    procedure RemoveAt(index: Int32); overload;
    ///<summary>Removes the <see cref="T:System.Data.Common.DbParameter" />
    ///  object with the specified name from the collection.</summary>
    ///  <param name="parameterName">The name of the <see cref="T:System.Data.Common.DbParameter" />
    ///  object to remove.</param>
    procedure RemoveAt(parameterName: string); overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Specifies the number of items in the collection.</summary>
    ///<returns>The number of items in the collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Specifies whether the collection is a fixed size.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is a fixed size; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Specifies whether the collection is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is read-only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Specifies whether the collection is synchronized.</summary>
    ///<returns><see langword="true" />
    ///  if the collection is synchronized; otherwise <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Specifies the <see cref="T:System.Object" />
    ///  to be used to synchronize access to the collection.</summary>
    ///<returns>A <see cref="T:System.Object" />
    ///  to be used to synchronize access to the <see cref="T:System.Data.Common.DbParameterCollection" />
    ///  .</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
    property Item[index: Int32]: DNDbParameter read get_Item write set_Item; default;
    property Item[parameterName: string]: DNDbParameter read get_Item write set_Item; default;
  end;

  TDNDbParameterCollection = class(TDNGenericImport<DNDbParameterCollectionClass, DNDbParameterCollection>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcParameterCollectionClass = interface(DNDbParameterCollectionClass)
  ['{C5E01425-796C-5B08-93D4-AB6EAE258DA8}']
  end;

  ///<summary>Represents a collection of parameters relevant to an <see cref="T:System.Data.Odbc.OdbcCommand" />
  ///  and their respective mappings to columns in a <see cref="T:System.Data.DataSet" />
  ///  . This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcParameterCollection')]
  DNOdbcParameterCollection = interface(DNDbParameterCollection)
  ['{E38F61BA-6E96-3D86-99DF-3E4B7D876070}']
  { getters & setters } 

    function get_Item(index: Int32): DNOdbcParameter; overload;
    procedure set_Item(index: Int32; value: DNOdbcParameter); overload;
    function get_Item(parameterName: string): DNOdbcParameter; overload;
    procedure set_Item(parameterName: string; value: DNOdbcParameter); overload;
    function get_Count: Int32;
    function get_IsFixedSize: Boolean;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Gets a value indicating whether an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object with the specified parameter name exists in the collection.</summary>
    ///  <param name="value">The name of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object to find. </param>
    ///<returns><see langword="true" />
    ///  if the collection contains the parameter; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(value: string): Boolean; overload;
    ///<summary>Adds the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="value">A <see cref="T:System.Object" />
    ///  .</param>
    ///<returns>The index of the new <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object in the collection.</returns>
    function Add(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Removes all <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  objects from the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    procedure Clear;
    ///<summary>Determines whether the specified <see cref="T:System.Object" />
    ///  is in this <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  contains the value otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  to the specified one-dimensional <see cref="T:System.Array" />
    ///  starting at the specified destination <see cref="T:System.Array" />
    ///  index.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Array" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Returns an enumerator that iterates through the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.Generic.IEnumerator" />
    ///  for the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  with the specified name.</summary>
    ///  <param name="parameterName">The case-sensitive name of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  with the specified case-sensitive name.</returns>
    function IndexOf(parameterName: string): Int32; overload;
    ///<summary>Gets the location of the specified <see cref="T:System.Object" />
    ///  within the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Object" />
    ///  that is a <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  within the collection.</returns>
    function IndexOf(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Object" />
    ///  into the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which the object should be inserted.</param>
    ///  <param name="value">A <see cref="T:System.Object" />
    ///  to be inserted in the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</param>
    procedure Insert(index: Int32; value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Object" />
    ///  object from the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="value">A <see cref="T:System.Object" />
    ///  to be removed from the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</param>
    procedure Remove(value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  from the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object to remove.</param>
    procedure RemoveAt(index: Int32); overload;
    ///<summary>Removes the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  from the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  with the specified parameter name.</summary>
    ///  <param name="parameterName">The name of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object to remove.</param>
    procedure RemoveAt(parameterName: string); overload;
    ///<summary>Adds the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to add to the collection. </param>
    ///<returns>The index of the new <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  specified in the <paramref name="value" />
    ///  parameter is already added to this or another <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  parameter is null.</exception>
    function Add(value: DNOdbcParameter): DNOdbcParameter; overload;
    ///<summary>Adds an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  given the parameter name and value.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="value">The <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  of the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to add to the collection. </param>
    ///<returns>The index of the new <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The <paramref name="value" />
    ///  parameter is not an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  . </exception>
    function Add(parameterName: string; value: DDN.mscorlib.DNObject): DNOdbcParameter; overload;
    ///<summary>Adds a value to the end of the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  . </summary>
    ///  <param name="parameterName">The name of the parameter.</param>
    ///  <param name="value">The value to be added.</param>
    ///<returns>An <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    function AddWithValue(parameterName: string; value: DDN.mscorlib.DNObject): DNOdbcParameter;
    ///<summary>Adds an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  , given the parameter name and data type.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="odbcType">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///<returns>The index of the new <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    function Add(parameterName: string; odbcType: DNOdbcType): DNOdbcParameter; overload;
    ///<summary>Adds an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  , given the parameter name, data type, and column length.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="odbcType">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///  <param name="size">The length of the column. </param>
    ///<returns>The index of the new <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    function Add(parameterName: string; odbcType: DNOdbcType; size: Int32): DNOdbcParameter; overload;
    ///<summary>Adds an <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  given the parameter name, data type, column length, and source column name.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="odbcType">One of the <see cref="T:System.Data.Odbc.OdbcType" />
    ///  values. </param>
    ///  <param name="size">The length of the column. </param>
    ///  <param name="sourceColumn">The name of the source column. </param>
    ///<returns>The index of the new <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object.</returns>
    function Add(parameterName: string; odbcType: DNOdbcType; size: Int32; sourceColumn: string): DNOdbcParameter; overload;
    ///<summary>Adds an array of <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  values to the end of the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="values">An array of <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  objects to add to the collection.</param>
    procedure AddRange(values: TArray<DNOdbcParameter>); overload;
    ///<summary>Determines whether the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  is in this <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  is in the collection; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(value: DNOdbcParameter): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  to the specified <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  starting at the specified destination index.</summary>
    ///  <param name="array">The <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: TArray<DNOdbcParameter>; index: Int32); overload;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  within the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object in the collection to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  within the collection.</returns>
    function IndexOf(value: DNOdbcParameter): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object into the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which the object should be inserted.</param>
    ///  <param name="value">A <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object to be inserted in the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</param>
    procedure Insert(index: Int32; value: DNOdbcParameter); overload;
    ///<summary>Removes the <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  from the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="value">A <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  object to remove from the collection.</param>
    ///<exception cref="T:System.InvalidCastException">The parameter is not a <see cref="T:System.Data.Odbc.OdbcParameter" />
    ///  .</exception><exception cref="T:System.SystemException">The parameter does not exist in the collection.</exception>
    procedure Remove(value: DNOdbcParameter); overload;
    ///<summary>Adds an array of values to the end of the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</summary>
    ///  <param name="values">The <see cref="T:System.Array" />
    ///  values to add.</param>
    procedure AddRange(values: DDN.mscorlib.DNArray); overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNOdbcParameter read get_Item write set_Item; default;
    property Item[parameterName: string]: DNOdbcParameter read get_Item write set_Item; default;
    ///<summary>Returns an Integer that contains the number of elements in the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  . Read-only.</summary>
    ///<returns>The number of elements in the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  as an Integer.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  has a fixed size. Read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  has a fixed size, otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  is read only, otherwise, <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  is synchronized. Read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  is synchronized; otherwise, <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  . Read-only.</summary>
    ///<returns>An object that can be used to synchronize access to the <see cref="T:System.Data.Odbc.OdbcParameterCollection" />
    ///  .</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNOdbcParameterCollection = class(TDNGenericImport<DNOdbcParameterCollectionClass, DNOdbcParameterCollection>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbParameterCollectionClass = interface(DNDbParameterCollectionClass)
  ['{EA4A22CE-3244-5F55-BDF5-9011B217D7C7}']
  end;

  ///<summary>Represents a collection of parameters relevant to an <see cref="T:System.Data.OleDb.OleDbCommand" />
  ///  as well as their respective mappings to columns in a <see cref="T:System.Data.DataSet" />
  ///  . </summary>
  [DNTypeName('System.Data.OleDb.OleDbParameterCollection')]
  DNOleDbParameterCollection = interface(DNDbParameterCollection)
  ['{24BFDD33-7845-3726-85E9-21FCB2802C80}']
  { getters & setters } 

    function get_Item(index: Int32): DNOleDbParameter; overload;
    procedure set_Item(index: Int32; value: DNOleDbParameter); overload;
    function get_Item(parameterName: string): DNOleDbParameter; overload;
    procedure set_Item(parameterName: string; value: DNOleDbParameter); overload;
    function get_Count: Int32;
    function get_IsFixedSize: Boolean;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Determines whether the specified <see cref="T:System.String" />
    ///  is in this <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.String" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  contains the value; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: string): Boolean; overload;
    ///<summary>Adds the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">A <see cref="T:System.Object" />
    ///  .</param>
    ///<returns>The index of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object in the collection.</returns>
    function Add(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Removes all <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  objects from the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    procedure Clear;
    ///<summary>Determines whether the specified <see cref="T:System.Object" />
    ///  is in this <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  contains <paramref name="value" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  to the specified one-dimensional <see cref="T:System.Array" />
    ///  starting at the specified destination <see cref="T:System.Array" />
    ///  index.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Array" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Returns an enumerator that iterates through the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.Generic.IEnumerator" />
    ///  for the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  with the specified name.</summary>
    ///  <param name="parameterName">The case-sensitive name of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  with the specified case-sensitive name.</returns>
    function IndexOf(parameterName: string): Int32; overload;
    ///<summary>The location of the specified <see cref="T:System.Object" />
    ///  within the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Object" />
    ///  that is a <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  within the collection.</returns>
    function IndexOf(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Object" />
    ///  into the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which value should be inserted.</param>
    ///  <param name="value">A <see cref="T:System.Object" />
    ///  to be inserted in the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</param>
    procedure Insert(index: Int32; value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Object" />
    ///  object from the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  to be removed from the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</param>
    procedure Remove(value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  from the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object to remove.</param>
    procedure RemoveAt(index: Int32); overload;
    ///<summary>Removes the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  from the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  at the specified parameter name.</summary>
    ///  <param name="parameterName">The name of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object to remove.</param>
    procedure RemoveAt(parameterName: string); overload;
    ///<summary>Adds the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to add to the collection.</param>
    ///<returns>The index of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  specified in the <paramref name="value" />
    ///  parameter is already added to this or another <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  parameter is null. </exception>
    function Add(value: DNOleDbParameter): DNOleDbParameter; overload;
    ///<summary>Adds an <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  given the parameter name and value.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="value">The <see cref="P:System.Data.OleDb.OleDbParameter.Value" />
    ///  of the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to add to the collection. </param>
    ///<returns>The index of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The <paramref name="value" />
    ///  parameter is not an <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  . </exception>
    function Add(parameterName: string; value: DDN.mscorlib.DNObject): DNOleDbParameter; overload;
    ///<summary>Adds a value to the end of the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="parameterName">The name of the parameter.</param>
    ///  <param name="value">The value to be added.</param>
    ///<returns>An <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    function AddWithValue(parameterName: string; value: DDN.mscorlib.DNObject): DNOleDbParameter;
    ///<summary>Adds an <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  , given the parameter name and data type.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="oleDbType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///<returns>The index of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    function Add(parameterName: string; oleDbType: DNOleDbType): DNOleDbParameter; overload;
    ///<summary>Adds an <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  given the parameter name, data type, and column length.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="oleDbType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the column. </param>
    ///<returns>The index of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    function Add(parameterName: string; oleDbType: DNOleDbType; size: Int32): DNOleDbParameter; overload;
    ///<summary>Adds an <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  given the parameter name, data type, column length, and source column name.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="oleDbType">One of the <see cref="T:System.Data.OleDb.OleDbType" />
    ///  values. </param>
    ///  <param name="size">The length of the column. </param>
    ///  <param name="sourceColumn">The name of the source column. </param>
    ///<returns>The index of the new <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object.</returns>
    function Add(parameterName: string; oleDbType: DNOleDbType; size: Int32; sourceColumn: string): DNOleDbParameter; overload;
    ///<summary>Adds an array of <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  values to the end of the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="values">The <see cref="T:System.Data.OleDbParameter" />
    ///  values to add.</param>
    procedure AddRange(values: TArray<DNOleDbParameter>); overload;
    ///<summary>Determines whether the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  is in this <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  is in the collection; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DNOleDbParameter): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  to the specified <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  starting at the specified destination index.</summary>
    ///  <param name="array">The <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: TArray<DNOleDbParameter>; index: Int32); overload;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  within the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object in the collection to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  that is a <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  within the collection.</returns>
    function IndexOf(value: DNOleDbParameter): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object into the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which value should be inserted.</param>
    ///  <param name="value">An <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object to be inserted in the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</param>
    procedure Insert(index: Int32; value: DNOleDbParameter); overload;
    ///<summary>Removes the <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  from the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="value">An <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  object to remove from the collection.</param>
    ///<exception cref="T:System.InvalidCastException">The parameter is not a <see cref="T:System.Data.OleDb.OleDbParameter" />
    ///  . </exception><exception cref="T:System.SystemException">The parameter does not exist in the collection. </exception>
    procedure Remove(value: DNOleDbParameter); overload;
    ///<summary>Adds an array of values to the end of the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</summary>
    ///  <param name="values">The <see cref="T:System.Array" />
    ///  values to add.</param>
    procedure AddRange(values: DDN.mscorlib.DNArray); overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNOleDbParameter read get_Item write set_Item; default;
    property Item[parameterName: string]: DNOleDbParameter read get_Item write set_Item; default;
    ///<summary>Returns an integer that contains the number of elements in the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  . Read-only. </summary>
    ///<returns>The number of elements in the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  as an integer.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  has a fixed size. Read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  has a fixed size; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  is read only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  is synchronized. Read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  is synchronized; otherwise <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  . Read-only.</summary>
    ///<returns>An object that can be used to synchronize access to the <see cref="T:System.Data.OleDb.OleDbParameterCollection" />
    ///  .</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNOleDbParameterCollection = class(TDNGenericImport<DNOleDbParameterCollectionClass, DNOleDbParameterCollection>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlParameterCollectionClass = interface(DNDbParameterCollectionClass)
  ['{A3F23AA6-9B07-5230-8AC8-1B5901EDF5D9}']
  end;

  ///<summary>Represents a collection of parameters associated with a <see cref="T:System.Data.SqlClient.SqlCommand" />
  ///  and their respective mappings to columns in a <see cref="T:System.Data.DataSet" />
  ///  . This class cannot be inherited.</summary>
  [DNTypeName('System.Data.SqlClient.SqlParameterCollection')]
  DNSqlParameterCollection = interface(DNDbParameterCollection)
  ['{AB5F7221-67BB-3AEF-91E1-AD345E07117E}']
  { getters & setters } 

    function get_Item(index: Int32): DNSqlParameter; overload;
    procedure set_Item(index: Int32; value: DNSqlParameter); overload;
    function get_Item(parameterName: string): DNSqlParameter; overload;
    procedure set_Item(parameterName: string; value: DNSqlParameter); overload;
    function get_Count: Int32;
    function get_IsFixedSize: Boolean;
    function get_IsReadOnly: Boolean;
    function get_IsSynchronized: Boolean;
    function get_SyncRoot: DDN.mscorlib.DNObject;

  { methods } 

    ///<summary>Determines whether the specified parameter name is in this <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.String" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  contains the value; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: string): Boolean; overload;
    ///<summary>Adds the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  .</param>
    ///<returns>The index of the new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    function Add(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Removes all the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  objects from the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    procedure Clear;
    ///<summary>Determines whether the specified <see cref="T:System.Object" />
    ///  is in this <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  contains the value; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  to the specified one-dimensional <see cref="T:System.Array" />
    ///  starting at the specified destination <see cref="T:System.Array" />
    ///  index.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Array" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: DDN.mscorlib.DNArray; index: Int32); overload;
    ///<summary>Returns an enumerator that iterates through the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  . </summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  for the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  . </returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  with the specified name.</summary>
    ///  <param name="parameterName">The case-sensitive name of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to find.</param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  with the specified case-sensitive name. Returns -1 when the object does not exist in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</returns>
    function IndexOf(parameterName: string): Int32; overload;
    ///<summary>Gets the location of the specified <see cref="T:System.Object" />
    ///  within the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to find. </param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Object" />
    ///  that is a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  within the collection. Returns -1 when the object does not exist in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</returns>
    function IndexOf(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Inserts an <see cref="T:System.Object" />
    ///  into the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which value should be inserted.</param>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  to be inserted in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</param>
    procedure Insert(index: Int32; value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  from the collection.</summary>
    ///  <param name="value">The object to remove from the collection. </param>
    procedure Remove(value: DDN.mscorlib.DNObject); overload;
    ///<summary>Removes the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  from the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object to remove.</param>
    procedure RemoveAt(index: Int32); overload;
    ///<summary>Removes the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  from the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  at the specified parameter name.</summary>
    ///  <param name="parameterName">The name of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to remove.</param>
    procedure RemoveAt(parameterName: string); overload;
    ///<summary>Adds the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to add to the collection. </param>
    ///<returns>A new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  specified in the <paramref name="value" />
    ///  parameter is already added to this or another <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  . </exception><exception cref="T:System.InvalidCastException">The parameter passed was not a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  parameter is null. </exception>
    function Add(value: DNSqlParameter): DNSqlParameter; overload;
    ///<summary>Adds the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="parameterName">The name of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to add to the collection.</param>
    ///  <param name="value">A <see cref="T:System.Object" />
    ///  .</param>
    ///<returns>A new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.Use caution when you are using this overload of the <see langword="SqlParameterCollection.Add" />
    ///  method to specify integer parameter values. Because this overload takes a <paramref name="value" />
    ///  of type <see cref="T:System.Object" />
    ///  , you must convert the integral value to an <see cref="T:System.Object" />
    ///  type when the value is zero, as the following C# example demonstrates.parameters.Add("@pname", Convert.ToInt32(0));If you do not perform this conversion, the compiler assumes that you are trying to call the <see langword="SqlParameterCollection.Add" />
    ///  (<see langword="string" />
    ///  , <see langword="SqlDbType" />
    ///  ) overload.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  specified in the <paramref name="value" />
    ///  parameter is already added to this or another <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  . </exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  parameter is null. </exception>
    function Add(parameterName: string; value: DDN.mscorlib.DNObject): DNSqlParameter; overload;
    ///<summary>Adds a value to the end of the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="parameterName">The name of the parameter.</param>
    ///  <param name="value">The value to be added. Use <see cref="F:System.DBNull.Value" />
    ///  instead of null, to indicate a null value.</param>
    ///<returns>A <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    function AddWithValue(parameterName: string; value: DDN.mscorlib.DNObject): DNSqlParameter;
    ///<summary>Adds a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  given the parameter name and the data type.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="sqlDbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. </param>
    ///<returns>A new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    function Add(parameterName: string; sqlDbType: DNSqlDbType): DNSqlParameter; overload;
    ///<summary>Adds a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  , given the specified parameter name, <see cref="T:System.Data.SqlDbType" />
    ///  and size.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="sqlDbType">The <see cref="T:System.Data.SqlDbType" />
    ///  of the <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to add to the collection. </param>
    ///  <param name="size">The size as an <see cref="T:System.Int32" />
    ///  .</param>
    ///<returns>A new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    function Add(parameterName: string; sqlDbType: DNSqlDbType; size: Int32): DNSqlParameter; overload;
    ///<summary>Adds a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  with the parameter name, the data type, and the column length.</summary>
    ///  <param name="parameterName">The name of the parameter. </param>
    ///  <param name="sqlDbType">One of the <see cref="T:System.Data.SqlDbType" />
    ///  values. </param>
    ///  <param name="size">The column length.</param>
    ///  <param name="sourceColumn">The name of the source column (<see cref="P:System.Data.SqlClient.SqlParameter.SourceColumn" />
    ///  ) if this <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  is used in a call to <see cref="Overload:System.Data.Common.DbDataAdapter.Update" />
    ///  .</param>
    ///<returns>A new <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object.</returns>
    function Add(parameterName: string; sqlDbType: DNSqlDbType; size: Int32; sourceColumn: string): DNSqlParameter; overload;
    ///<summary>Adds an array of <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  values to the end of the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="values">The <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  values to add.</param>
    procedure AddRange(values: TArray<DNSqlParameter>); overload;
    ///<summary>Determines whether the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  is in this <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  contains the value; otherwise <see langword="false" />
    ///  .</returns>
    function &Contains(value: DNSqlParameter): Boolean; overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  to the specified <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  starting at the specified destination index.</summary>
    ///  <param name="array">The <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  that is the destination of the elements copied from the current <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</param>
    ///  <param name="index">A 32-bit integer that represents the index in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  at which copying starts.</param>
    procedure CopyTo(&array: TArray<DNSqlParameter>; index: Int32); overload;
    ///<summary>Gets the location of the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  within the collection.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  to find. </param>
    ///<returns>The zero-based location of the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  that is a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  within the collection. Returns -1 when the object does not exist in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</returns>
    function IndexOf(value: DNSqlParameter): Int32; overload;
    ///<summary>Inserts a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object into the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which value should be inserted.</param>
    ///  <param name="value">A <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object to be inserted in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</param>
    procedure Insert(index: Int32; value: DNSqlParameter); overload;
    ///<summary>Removes the specified <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  from the collection.</summary>
    ///  <param name="value">A <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  object to remove from the collection. </param>
    ///<exception cref="T:System.InvalidCastException">The parameter is not a <see cref="T:System.Data.SqlClient.SqlParameter" />
    ///  . </exception><exception cref="T:System.SystemException">The parameter does not exist in the collection. </exception>
    procedure Remove(value: DNSqlParameter); overload;
    ///<summary>Adds an array of values to the end of the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</summary>
    ///  <param name="values">The <see cref="T:System.Array" />
    ///  values to add.</param>
    procedure AddRange(values: DDN.mscorlib.DNArray); overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNSqlParameter read get_Item write set_Item; default;
    property Item[parameterName: string]: DNSqlParameter read get_Item write set_Item; default;
    ///<summary>Returns an Integer that contains the number of elements in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  . Read-only. </summary>
    ///<returns>The number of elements in the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  as an Integer.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  has a fixed size. </summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  has a fixed size; otherwise <see langword="false" />
    ///  .</returns>
    property IsFixedSize: Boolean read get_IsFixedSize;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  is read-only. </summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  is read only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets a value that indicates whether the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  is synchronized.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  is synchronized; otherwise <see langword="false" />
    ///  .</returns>
    property IsSynchronized: Boolean read get_IsSynchronized;
    ///<summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  . </summary>
    ///<returns>An object that can be used to synchronize access to the <see cref="T:System.Data.SqlClient.SqlParameterCollection" />
    ///  .</returns>
    property SyncRoot: DDN.mscorlib.DNObject read get_SyncRoot;
  end;

  TDNSqlParameterCollection = class(TDNGenericImport<DNSqlParameterCollectionClass, DNSqlParameterCollection>) end;

  //-------------namespace: System.Data.Common----------------
  DNDbTransactionClass = interface(DDN.mscorlib.DNMarshalByRefObjectClass)
  ['{4FCB2B8F-4FAA-5D96-81E6-8ABFB11C4CD6}']
  end;

  ///<summary>The base class for a transaction. </summary>
  [DNTypeName('System.Data.Common.DbTransaction')]
  DNDbTransaction = interface(DDN.mscorlib.DNMarshalByRefObject)
  ['{D36E8E8B-BE81-3B90-A003-1A472606FDA4}']
  { getters & setters } 

    function get_Connection: DNDbConnection;
    function get_IsolationLevel: DNIsolationLevel;

  { methods } 

    ///<summary>Releases the unmanaged resources used by the <see cref="T:System.Data.Common.DbTransaction" />
    ///  .</summary>
    procedure Dispose;
    ///<summary>Commits the database transaction.</summary>
    procedure Commit;
    ///<summary>Rolls back a transaction from a pending state.</summary>
    procedure Rollback;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Specifies the <see cref="T:System.Data.Common.DbConnection" />
    ///  object associated with the transaction.</summary>
    ///<returns>The <see cref="T:System.Data.Common.DbConnection" />
    ///  object associated with the transaction.</returns>
    property Connection: DNDbConnection read get_Connection;
    ///<summary>Specifies the <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction.</summary>
    ///<returns>The <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction.</returns>
    property IsolationLevel: DNIsolationLevel read get_IsolationLevel;
  end;

  TDNDbTransaction = class(TDNGenericImport<DNDbTransactionClass, DNDbTransaction>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcTransactionClass = interface(DNDbTransactionClass)
  ['{DD4F160B-7362-5ABC-B0B2-19E870F6EA3E}']
  end;

  ///<summary>Represents an SQL transaction to be made at a data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcTransaction')]
  DNOdbcTransaction = interface(DNDbTransaction)
  ['{A9CBC7C8-F01C-3644-93C8-F6FCF7A2076B}']
  { getters & setters } 

    function get_Connection: DNOdbcConnection;
    function get_IsolationLevel: DNIsolationLevel;

  { methods } 

    ///<summary>Commits the database transaction.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Commit;
    ///<summary>Rolls back a transaction from a pending state.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken.</exception>
    procedure Rollback;
    ///<summary>Releases the unmanaged resources used by the <see cref="T:System.Data.Common.DbTransaction" />
    ///  .</summary>
    procedure Dispose;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  object associated with the transaction, or <see langword="null" />
    ///  if the transaction is no longer valid.</summary>
    ///<returns>The <see cref="T:System.Data.Odbc.OdbcConnection" />
    ///  object associated with the transaction.</returns>
    property Connection: DNOdbcConnection read get_Connection;
    ///<summary>Specifies the <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction.</summary>
    ///<returns>The <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction. The default depends on the underlying ODBC driver.</returns>
    property IsolationLevel: DNIsolationLevel read get_IsolationLevel;
  end;

  TDNOdbcTransaction = class(TDNGenericImport<DNOdbcTransactionClass, DNOdbcTransaction>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbTransactionClass = interface(DNDbTransactionClass)
  ['{C7A2649D-1ED1-5730-AC0F-5E744C071EFD}']
  end;

  ///<summary>Represents an SQL transaction to be made at a data source. This class cannot be inherited. </summary>
  [DNTypeName('System.Data.OleDb.OleDbTransaction')]
  DNOleDbTransaction = interface(DNDbTransaction)
  ['{F538329B-0483-3A25-B7C8-92EDBBCF3717}']
  { getters & setters } 

    function get_Connection: DNOleDbConnection;
    function get_IsolationLevel: DNIsolationLevel;

  { methods } 

    ///<summary>Initiates a nested database transaction and specifies the isolation level to use for the new transaction.</summary>
    ///  <param name="isolevel">The isolation level to use for the transaction. </param>
    ///<returns>A nested database transaction.</returns>
    ///<exception cref="T:System.InvalidOperationException">Nested transactions are not supported. </exception>
    function &Begin(isolevel: DNIsolationLevel): DNOleDbTransaction; overload;
    ///<summary>Initiates a nested database transaction.</summary>
    ///<returns>A nested database transaction.</returns>
    ///<exception cref="T:System.InvalidOperationException">Nested transactions are not supported. </exception>
    function &Begin: DNOleDbTransaction; overload;
    ///<summary>Commits the database transaction.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Commit;
    ///<summary>Rolls back a transaction from a pending state.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken.</exception>
    procedure Rollback;
    ///<summary>Releases the unmanaged resources used by the <see cref="T:System.Data.Common.DbTransaction" />
    ///  .</summary>
    procedure Dispose;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  object associated with the transaction, or <see langword="null" />
    ///  if the transaction is no longer valid.</summary>
    ///<returns>The <see cref="T:System.Data.OleDb.OleDbConnection" />
    ///  object associated with the transaction.</returns>
    property Connection: DNOleDbConnection read get_Connection;
    ///<summary>Specifies the <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction.</summary>
    ///<returns>The <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction. The default is <see langword="ReadCommitted" />
    ///  .</returns>
    property IsolationLevel: DNIsolationLevel read get_IsolationLevel;
  end;

  TDNOleDbTransaction = class(TDNGenericImport<DNOleDbTransactionClass, DNOleDbTransaction>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlTransactionClass = interface(DNDbTransactionClass)
  ['{A10EAAC5-D3CB-5942-A02A-969BD9445160}']
  end;

  ///<summary>Represents a Transact-SQL transaction to be made in a SQL Server database. This class cannot be inherited. </summary>
  [DNTypeName('System.Data.SqlClient.SqlTransaction')]
  DNSqlTransaction = interface(DNDbTransaction)
  ['{824F20F8-D6D0-33E5-9A93-A12B97209D56}']
  { getters & setters } 

    function get_Connection: DNSqlConnection;
    function get_IsolationLevel: DNIsolationLevel;

  { methods } 

    ///<summary>Commits the database transaction.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Commit;
    ///<summary>Rolls back a transaction from a pending state.</summary>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Rollback; overload;
    ///<summary>Rolls back a transaction from a pending state, and specifies the transaction or savepoint name.</summary>
    ///  <param name="transactionName">The name of the transaction to roll back, or the savepoint to which to roll back. </param>
    ///<exception cref="T:System.ArgumentException">No transaction name was specified. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Rollback(transactionName: string); overload;
    ///<summary>Creates a savepoint in the transaction that can be used to roll back a part of the transaction, and specifies the savepoint name.</summary>
    ///  <param name="savePointName">The name of the savepoint. </param>
    ///<exception cref="T:System.Exception">An error occurred while trying to commit the transaction. </exception><exception cref="T:System.InvalidOperationException">The transaction has already been committed or rolled back.-or- The connection is broken. </exception>
    procedure Save(savePointName: string);
    ///<summary>Releases the unmanaged resources used by the <see cref="T:System.Data.Common.DbTransaction" />
    ///  .</summary>
    procedure Dispose;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object associated with the transaction, or <see langword="null" />
    ///  if the transaction is no longer valid.</summary>
    ///<returns>The <see cref="T:System.Data.SqlClient.SqlConnection" />
    ///  object associated with the transaction.</returns>
    property Connection: DNSqlConnection read get_Connection;
    ///<summary>Specifies the <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction.</summary>
    ///<returns>The <see cref="T:System.Data.IsolationLevel" />
    ///  for this transaction. The default is <see langword="ReadCommitted" />
    ///  .</returns>
    property IsolationLevel: DNIsolationLevel read get_IsolationLevel;
  end;

  TDNSqlTransaction = class(TDNGenericImport<DNSqlTransactionClass, DNSqlTransaction>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlFileStreamClass = interface(DDN.mscorlib.DNStreamClass)
  ['{E15792ED-276C-5C85-B3BA-8E7F5DC04892}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  class. </summary>
    ///  <param name="path">The logical path to the file. The path can be retrieved by using the Transact-SQL Pathname function on the underlying FILESTREAM column in the table.</param>
    ///  <param name="transactionContext">The transaction context for the <see langword="SqlFileStream" />
    ///  object. Applications should return the byte array returned by calling the GET_FILESTREAM_TRANSACTION_CONTEXT method.</param>
    ///  <param name="access">The access mode to use when opening the file. Supported <see cref="T:System.IO.FileAccess" />
    ///  enumeration values are <see cref="F:System.IO.FileAccess.Read" />
    ///  , <see cref="F:System.IO.FileAccess.Write" />
    ///  , and <see cref="F:System.IO.FileAccess.ReadWrite" />
    ///  . When using <see langword="FileAccess.Read" />
    ///  , the <see langword="SqlFileStream" />
    ///  object can be used to read all of the existing data. When using <see langword="FileAccess.Write" />
    ///  , <see langword="SqlFileStream" />
    ///  points to a zero byte file. Existing data will be overwritten when the object is closed and the transaction is committed. When using <see langword="FileAccess.ReadWrite" />
    ///  , the <see langword="SqlFileStream" />
    ///  points to a file which has all the existing data in it. The handle is positioned at the beginning of the file. You can use one of the <see langword="System.IO" />
    ///<see langword="Seek" />
    ///  methods to move the handle position within the file to write or append new data.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  is a null reference, or <paramref name="transactionContext" />
    ///  is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="path" />
    ///  is an empty string (""), contains only white space, or contains one or more invalid characters.
    ///  <paramref name="path" />
    ///  begins with "\\.\", for example "\\.\PHYSICALDRIVE0 ".The handle returned by the call to NTCreateFile is not of type FILE_TYPE_DISK.
    ///  <paramref name="options" />
    ///  contains an unsupported value.</exception><exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception><exception cref="T:System.IO.IOException">An I/O error occurred.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The specified <paramref name="path" />
    ///  is invalid, such as being on an unmapped drive.</exception><exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path. This occurs when Write or ReadWrite access is specified, and the file or directory is set for read-only access.</exception><exception cref="T:System.InvalidOperationException">NtCreateFile fails with error code set to ERROR_SHARING_VIOLATION.</exception>
    {class} function init(path: string; transactionContext: TArray<Byte>; access: DDN.mscorlib.DNFileAccess): DNSqlFileStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  class. </summary>
    ///  <param name="path">The logical path to the file. The path can be retrieved by using the Transact-SQL Pathname function on the underlying FILESTREAM column in the table.</param>
    ///  <param name="transactionContext">The transaction context for the <see langword="SqlFileStream" />
    ///  object. When set to null, an implicit transaction will be used for the <see langword="SqlFileStream" />
    ///  object. Applications should return the byte array returned by calling the GET_FILESTREAM_TRANSACTION_CONTEXT method.</param>
    ///  <param name="access">The access mode to use when opening the file. Supported <see cref="T:System.IO.FileAccess" />
    ///  enumeration values are <see cref="F:System.IO.FileAccess.Read" />
    ///  , <see cref="F:System.IO.FileAccess.Write" />
    ///  , and <see cref="F:System.IO.FileAccess.ReadWrite" />
    ///  . When using <see langword="FileAccess.Read" />
    ///  , the <see langword="SqlFileStream" />
    ///  object can be used to read all of the existing data. When using <see langword="FileAccess.Write" />
    ///  , <see langword="SqlFileStream" />
    ///  points to a zero byte file. Existing data will be overwritten when the object is closed and the transaction is committed. When using <see langword="FileAccess.ReadWrite" />
    ///  , the <see langword="SqlFileStream" />
    ///  points to a file which has all the existing data in it. The handle is positioned at the beginning of the file. You can use one of the <see langword="System.IO" />
    ///<see langword="Seek" />
    ///  methods to move the handle position within the file to write or append new data.</param>
    ///  <param name="options">Specifies the option to use while opening the file. Supported <see cref="T:System.IO.FileOptions" />
    ///  values are <see cref="F:System.IO.FileOptions.Asynchronous" />
    ///  , <see cref="F:System.IO.FileOptions.WriteThrough" />
    ///  , <see cref="F:System.IO.FileOptions.SequentialScan" />
    ///  , and <see cref="F:System.IO.FileOptions.RandomAccess" />
    ///  .</param>
    ///  <param name="allocationSize">The allocation size to use while creating a file. If set to 0, the default value is used.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  is a null reference, or <paramref name="transactionContext" />
    ///  is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="path" />
    ///  is an empty string (""), contains only white space, or contains one or more invalid characters.
    ///  <paramref name="path" />
    ///  begins with "\\.\", for example "\\.\PHYSICALDRIVE0 ".The handle returned by call to NTCreateFile is not of type FILE_TYPE_DISK.
    ///  <paramref name="options" />
    ///  contains an unsupported value.</exception><exception cref="T:System.IO.FileNotFoundException">The file cannot be found.</exception><exception cref="T:System.IO.IOException">An I/O error occurred.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The specified <paramref name="path" />
    ///  is invalid, such as being on an unmapped drive.</exception><exception cref="T:System.UnauthorizedAccessException">The access requested is not permitted by the operating system for the specified path. This occurs when Write or ReadWrite access is specified, and the file or directory is set for read-only access.</exception><exception cref="T:System.InvalidOperationException">NtCreateFile fails with error code set to ERROR_SHARING_VIOLATION.</exception>
    {class} function init(path: string; transactionContext: TArray<Byte>; access: DDN.mscorlib.DNFileAccess; options: DDN.mscorlib.DNFileOptions; allocationSize: Int64): DNSqlFileStream; overload;

  end;

  ///<summary>Exposes SQL Server data that is stored with the FILESTREAM column attribute as a sequence of bytes. </summary>
  [DNTypeName('System.Data.SqlTypes.SqlFileStream')]
  DNSqlFileStream = interface(DDN.mscorlib.DNStream)
  ['{88EB48AA-4903-354B-B4AF-B7943CD2BFA3}']
  { getters & setters } 

    function get_Name: string;
    function get_TransactionContext: TArray<Byte>;
    function get_CanRead: Boolean;
    function get_CanSeek: Boolean;
    function get_CanTimeout: Boolean;
    function get_CanWrite: Boolean;
    function get_Length: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>clears all buffers for this stream and causes any buffered data to be written to the underlying device.</summary>
    procedure Flush;
    ///<summary>Begins an asynchronous read operation.</summary>
    ///  <param name="buffer">The buffer to read the data into. </param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  at which to begin writing data read from the stream. </param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///  <param name="callback">An optional asynchronous callback, to be called when the read is complete.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that represents the asynchronous read, which could still be pending.</returns>
    ///<exception cref="T:System.NotSupportedException">Reading data is not supported on the stream.</exception>
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Waits for the pending asynchronous read to complete.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request to finish. </param>
    ///<returns>The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.</returns>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.IAsyncResult" />
    ///  object did not come from the corresponding <see langword="BeginRead" />
    ///  method.</exception>
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Begins an asynchronous write operation.</summary>
    ///  <param name="buffer">The buffer to write data from.</param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  from which to begin writing.</param>
    ///  <param name="count">The maximum number of bytes to write.</param>
    ///  <param name="callback">An optional asynchronous callback, to be called when the write is complete.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests. </param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  that represents the asynchronous write, which could still be pending.</returns>
    ///<exception cref="T:System.NotSupportedException">Writing data is not supported on the stream.</exception>
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends an asynchronous write operation.</summary>
    ///  <param name="asyncResult">A reference to the outstanding asynchronous I/O request. </param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.IAsyncResult" />
    ///  object did not come from the corresponding <see langword="BeginWrite" />
    ///  method.</exception>
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Sets the position within the current stream.</summary>
    ///  <param name="offset">A byte offset relative to the <paramref name="origin" />
    ///  parameter</param>
    ///  <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin" />
    ///  indicating the reference point used to obtain the new position</param>
    ///<returns>The new position within the current stream. </returns>
    function Seek(offset: Int64; origin: DDN.mscorlib.DNSeekOrigin): Int64;
    ///<summary>Sets the length of the current stream.</summary>
    ///  <param name="value">The desired length of the current stream in bytes.</param>
    ///<exception cref="T:System.NotSupportedException">The object does not support reading of data.</exception>
    procedure SetLength(value: Int64);
    ///<summary>Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</summary>
    ///  <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset and (offset + count - 1) replaced by the bytes read from the current source. </param>
    ///  <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
    ///  <param name="count">The maximum number of bytes to be read from the current stream.</param>
    ///<returns>The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</returns>
    ///<exception cref="T:System.NotSupportedException">The object does not support reading of data.</exception>
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    ///<summary>Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</summary>
    ///<returns>The unsigned byte cast to an <see cref="T:System.Int32" />
    ///  , or -1 if at the end of the stream.</returns>
    ///<exception cref="T:System.NotSupportedException">The object does not support reading of data.</exception>
    function ReadByte: Int32;
    ///<summary>Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written. </summary>
    ///  <param name="buffer">An array of bytes. This method copies <paramref name="count" />
    ///  bytes from <paramref name="buffer" />
    ///  to the current stream.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream. </param>
    ///  <param name="count">The number of bytes to be written to the current stream. </param>
    ///<exception cref="T:System.NotSupportedException">The object does not support writing of data.</exception>
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    ///<summary>Writes a byte to the current position in the stream and advances the position within the stream by one byte.</summary>
    ///  <param name="value">The byte to write to the stream. </param>
    ///<exception cref="T:System.NotSupportedException">The object does not support writing of data.</exception>
    procedure WriteByte(value: Byte);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the logical path of the <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  passed to the constructor.</summary>
    ///<returns>A string value indicating the name of the <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets or sets the transaction context for this <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  object.</summary>
    ///<returns>The <paramref name="transactionContext" />
    ///  array that was passed to the constructor for this <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  object.</returns>
    property TransactionContext: TArray<Byte> read get_TransactionContext;
    ///<summary>Gets a value indicating whether the current stream supports reading.</summary>
    ///<returns><see langword="true" />
    ///  if the current stream supports reading; otherwise, <see langword="false" />
    ///  .</returns>
    property CanRead: Boolean read get_CanRead;
    ///<summary>Gets a value indicating whether the current stream supports seeking.</summary>
    ///<returns><see langword="true" />
    ///  if the current stream supports seeking; otherwise, <see langword="false" />
    ///  .</returns>
    property CanSeek: Boolean read get_CanSeek;
    ///<summary>Gets a value indicating whether the current stream can time out.</summary>
    ///<returns><see langword="true" />
    ///  if the current stream can time out; otherwise, <see langword="false" />
    ///  .</returns>
    property CanTimeout: Boolean read get_CanTimeout;
    ///<summary>Gets a value indicating whether the current stream supports writing. </summary>
    ///<returns><see langword="true" />
    ///  if the current stream supports writing; otherwise, <see langword="false" />
    ///  .</returns>
    property CanWrite: Boolean read get_CanWrite;
    ///<summary>Gets a value indicating the length of the current stream in bytes.</summary>
    ///<returns>An <see cref="T:System.Int64" />
    ///  indicating the length of the current stream in bytes.</returns>
    property Length: Int64 read get_Length;
    ///<summary>Gets or sets the position within the current stream.</summary>
    ///<returns>The current position within the <see cref="T:System.Data.SqlTypes.SqlFileStream" />
    ///  .</returns>
    property Position: Int64 read get_Position write set_Position;
    ///<summary>Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out.</summary>
    ///<returns>A value, in milliseconds, that determines how long the stream will attempt to read before timing out. </returns>
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    ///<summary>Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.</summary>
    ///<returns>A value, in milliseconds, that determines how long the stream will attempt to write before timing out. </returns>
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNSqlFileStream = class(TDNGenericImport<DNSqlFileStreamClass, DNSqlFileStream>) end;

  //-------------namespace: System.Data.Common----------------
  DNDBDataPermissionClass = interface(DDN.mscorlib.DNCodeAccessPermissionClass)
  ['{117B9E9F-10C2-584B-98C8-821ACA242541}']
  end;

  ///<summary>Enables a .NET Framework data provider to help ensure that a user has a security level adequate for accessing data.</summary>
  [DNTypeName('System.Data.Common.DBDataPermission')]
  DNDBDataPermission = interface(DDN.mscorlib.DNCodeAccessPermission)
  ['{BA3FEDB4-03B9-3044-BFB3-1C5076F9F317}']
  { getters & setters } 

    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);

  { methods } 

    ///<summary>Returns a new permission object representing the intersection of the current permission object and the specified permission object.</summary>
    ///  <param name="target">A permission object to intersect with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the intersection of the current permission object and the specified permission object. This new permission object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if the intersection is empty.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is not a null reference (<see langword="Nothing" />
    ///  in Visual Basic) and is not an instance of the same class as the current permission object. </exception>
    function Intersect(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    ///<summary>Returns a value indicating whether the current permission object is a subset of the specified permission object.</summary>
    ///  <param name="target">A permission object that is to be tested for the subset relationship. This object must be of the same type as the current permission object. </param>
    ///<returns><see langword="true" />
    ///  if the current permission object is a subset of the specified permission object, otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is an object that is not of the same type as the current permission object. </exception>
    function IsSubsetOf(target: DDN.mscorlib.DNIPermission): Boolean;
    ///<summary>Reconstructs a security object with a specified state from an XML encoding.</summary>
    ///  <param name="securityElement">The XML encoding to use to reconstruct the security object. </param>
    procedure FromXml(securityElement: DDN.mscorlib.DNSecurityElement);
    ///<summary>Creates an XML encoding of the security object and its current state.</summary>
    ///<returns>An XML encoding of the security object, including any state information.</returns>
    function ToXml: DDN.mscorlib.DNSecurityElement;
    ///<summary>Adds access for the specified connection string to the existing state of the <see langword="DBDataPermission" />
    ///  . </summary>
    ///  <param name="connectionString">A permitted connection string.</param>
    ///  <param name="restrictions">String that identifies connection string parameters that are allowed or disallowed.</param>
    ///  <param name="behavior">One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  properties.</param>
    procedure Add(connectionString: string; restrictions: string; behavior: DNKeyRestrictionBehavior);
    ///<summary>Creates and returns an identical copy of the current permission object.</summary>
    ///<returns>A copy of the current permission object.</returns>
    function Copy: DDN.mscorlib.DNIPermission;
    ///<summary>Returns a value indicating whether the permission can be represented as unrestricted without any knowledge of the permission semantics.</summary>
    ///<returns><see langword="true" />
    ///  if the permission can be represented as unrestricted.</returns>
    function IsUnrestricted: Boolean;
    ///<summary>Returns a new permission object that is the union of the current and specified permission objects.</summary>
    ///  <param name="target">A permission object to combine with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the union of the current permission object and the specified permission object.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  object is not the same type as the current permission object.</exception>
    function Union(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    procedure Demand;
    procedure Assert;
    procedure Deny;
    procedure PermitOnly;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed, otherwise, <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
  end;

  TDNDBDataPermission = class(TDNGenericImport<DNDBDataPermissionClass, DNDBDataPermission>) end;

  //-------------namespace: System.Data.Odbc----------------
  DNOdbcPermissionClass = interface(DNDBDataPermissionClass)
  ['{0FB40B43-1157-522E-8351-8E5E390EC987}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcPermission" />
    ///  class.</summary>
    {class} function init: DNOdbcPermission; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcPermission" />
    ///  class with one of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values.</summary>
    ///  <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values. </param>
    {class} function init(state: DDN.mscorlib.DNPermissionState): DNOdbcPermission; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.Odbc.OdbcPermission" />
    ///  class.</summary>
    ///  <param name="state">One of the <see langword="System.Security.Permissions.PermissionState" />
    ///  values. </param>
    ///  <param name="allowBlankPassword">Indicates whether a blank password is allowed. </param>
    {class} function init(state: DDN.mscorlib.DNPermissionState; allowBlankPassword: Boolean): DNOdbcPermission; overload;

  end;

  ///<summary>Enables the .NET Framework Data Provider for ODBC to help make sure that a user has a security level sufficient to access an ODBC data source. This class cannot be inherited.</summary>
  [DNTypeName('System.Data.Odbc.OdbcPermission')]
  DNOdbcPermission = interface(DNDBDataPermission)
  ['{2F3993E2-1392-3E28-B725-1D8A8A5FFE2B}']
  { getters & setters } 

    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);

  { methods } 

    ///<summary>Adds access for the specified connection string to the existing state of the permission.</summary>
    ///  <param name="connectionString">A permitted connection string. </param>
    ///  <param name="restrictions">String that identifies connection string parameters that are allowed or disallowed. </param>
    ///  <param name="behavior">One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  values. </param>
    procedure Add(connectionString: string; restrictions: string; behavior: DNKeyRestrictionBehavior);
    ///<summary>Returns the <see cref="T:System.Data.Odbc.OdbcPermission" />
    ///  as an <see cref="T:System.Security.IPermission" />
    ///  .</summary>
    ///<returns>A copy of the current permission object.</returns>
    function Copy: DDN.mscorlib.DNIPermission;
    ///<summary>Returns a new permission object representing the intersection of the current permission object and the specified permission object.</summary>
    ///  <param name="target">A permission object to intersect with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the intersection of the current permission object and the specified permission object. This new permission object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if the intersection is empty.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is not a null reference (<see langword="Nothing" />
    ///  in Visual Basic) and is not an instance of the same class as the current permission object. </exception>
    function Intersect(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    ///<summary>Returns a value indicating whether the current permission object is a subset of the specified permission object.</summary>
    ///  <param name="target">A permission object that is to be tested for the subset relationship. This object must be of the same type as the current permission object. </param>
    ///<returns><see langword="true" />
    ///  if the current permission object is a subset of the specified permission object, otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is an object that is not of the same type as the current permission object. </exception>
    function IsSubsetOf(target: DDN.mscorlib.DNIPermission): Boolean;
    ///<summary>Reconstructs a security object with a specified state from an XML encoding.</summary>
    ///  <param name="securityElement">The XML encoding to use to reconstruct the security object. </param>
    procedure FromXml(securityElement: DDN.mscorlib.DNSecurityElement);
    ///<summary>Creates an XML encoding of the security object and its current state.</summary>
    ///<returns>An XML encoding of the security object, including any state information.</returns>
    function ToXml: DDN.mscorlib.DNSecurityElement;
    ///<summary>Returns a value indicating whether the permission can be represented as unrestricted without any knowledge of the permission semantics.</summary>
    ///<returns><see langword="true" />
    ///  if the permission can be represented as unrestricted.</returns>
    function IsUnrestricted: Boolean;
    ///<summary>Returns a new permission object that is the union of the current and specified permission objects.</summary>
    ///  <param name="target">A permission object to combine with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the union of the current permission object and the specified permission object.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  object is not the same type as the current permission object.</exception>
    function Union(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    procedure Demand;
    procedure Assert;
    procedure Deny;
    procedure PermitOnly;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed, otherwise, <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
  end;

  TDNOdbcPermission = class(TDNGenericImport<DNOdbcPermissionClass, DNOdbcPermission>) end;

  //-------------namespace: System.Data.OleDb----------------
  DNOleDbPermissionClass = interface(DNDBDataPermissionClass)
  ['{AE164ED5-AB45-52C9-A772-DB8F2CE259A1}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbPermission" />
    ///  class.</summary>
    {class} function init: DNOleDbPermission; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbPermission" />
    ///  class.</summary>
    ///  <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values. </param>
    {class} function init(state: DDN.mscorlib.DNPermissionState): DNOleDbPermission; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.OleDb.OleDbPermission" />
    ///  class.</summary>
    ///  <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values. </param>
    ///  <param name="allowBlankPassword">Indicates whether a blank password is allowed. </param>
    {class} function init(state: DDN.mscorlib.DNPermissionState; allowBlankPassword: Boolean): DNOleDbPermission; overload;

  end;

  ///<summary>Enables the .NET Framework Data Provider for OLE DB to help make sure that a user has a security level sufficient to access an OLE DB data source.</summary>
  [DNTypeName('System.Data.OleDb.OleDbPermission')]
  DNOleDbPermission = interface(DNDBDataPermission)
  ['{305402F3-83F5-34CD-922E-02CFFD8D2C37}']
  { getters & setters } 

    function get_Provider: string;
    procedure set_Provider(value: string);
    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);

  { methods } 

    ///<summary>Returns the <see cref="T:System.Data.OleDb.OleDbPermission" />
    ///  as an <see cref="T:System.Security.IPermission" />
    ///  .</summary>
    ///<returns>A copy of the current permission object.</returns>
    function Copy: DDN.mscorlib.DNIPermission;
    ///<summary>Returns a new permission object representing the intersection of the current permission object and the specified permission object.</summary>
    ///  <param name="target">A permission object to intersect with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the intersection of the current permission object and the specified permission object. This new permission object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if the intersection is empty.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is not a null reference (<see langword="Nothing" />
    ///  in Visual Basic) and is not an instance of the same class as the current permission object. </exception>
    function Intersect(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    ///<summary>Returns a value indicating whether the current permission object is a subset of the specified permission object.</summary>
    ///  <param name="target">A permission object that is to be tested for the subset relationship. This object must be of the same type as the current permission object. </param>
    ///<returns><see langword="true" />
    ///  if the current permission object is a subset of the specified permission object, otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is an object that is not of the same type as the current permission object. </exception>
    function IsSubsetOf(target: DDN.mscorlib.DNIPermission): Boolean;
    ///<summary>Reconstructs a security object with a specified state from an XML encoding.</summary>
    ///  <param name="securityElement">The XML encoding to use to reconstruct the security object. </param>
    procedure FromXml(securityElement: DDN.mscorlib.DNSecurityElement);
    ///<summary>Creates an XML encoding of the security object and its current state.</summary>
    ///<returns>An XML encoding of the security object, including any state information.</returns>
    function ToXml: DDN.mscorlib.DNSecurityElement;
    ///<summary>Adds access for the specified connection string to the existing state of the <see langword="DBDataPermission" />
    ///  . </summary>
    ///  <param name="connectionString">A permitted connection string.</param>
    ///  <param name="restrictions">String that identifies connection string parameters that are allowed or disallowed.</param>
    ///  <param name="behavior">One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  properties.</param>
    procedure Add(connectionString: string; restrictions: string; behavior: DNKeyRestrictionBehavior);
    ///<summary>Returns a value indicating whether the permission can be represented as unrestricted without any knowledge of the permission semantics.</summary>
    ///<returns><see langword="true" />
    ///  if the permission can be represented as unrestricted.</returns>
    function IsUnrestricted: Boolean;
    ///<summary>Returns a new permission object that is the union of the current and specified permission objects.</summary>
    ///  <param name="target">A permission object to combine with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the union of the current permission object and the specified permission object.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  object is not the same type as the current permission object.</exception>
    function Union(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    procedure Demand;
    procedure Assert;
    procedure Deny;
    procedure PermitOnly;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>This property has been marked as obsolete. Setting this property will have no effect.</summary>
    ///<returns>This property has been marked as obsolete. Setting this property will have no effect.</returns>
    property Provider: string read get_Provider write set_Provider;
    ///<summary>Gets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed, otherwise, <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
  end;

  TDNOleDbPermission = class(TDNGenericImport<DNOleDbPermissionClass, DNOleDbPermission>) end;

  //-------------namespace: System.Data.SqlClient----------------
  DNSqlClientPermissionClass = interface(DNDBDataPermissionClass)
  ['{ED7E30C1-ACC9-504A-B5FE-4446A357779B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  class.</summary>
    {class} function init: DNSqlClientPermission; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  class.</summary>
    ///  <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values. </param>
    {class} function init(state: DDN.mscorlib.DNPermissionState): DNSqlClientPermission; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  class.</summary>
    ///  <param name="state">One of the <see cref="T:System.Security.Permissions.PermissionState" />
    ///  values. </param>
    ///  <param name="allowBlankPassword">Indicates whether a blank password is allowed. </param>
    {class} function init(state: DDN.mscorlib.DNPermissionState; allowBlankPassword: Boolean): DNSqlClientPermission; overload;

  end;

  ///<summary>Enables the .NET Framework Data Provider for SQL Server to help make sure that a user has a security level sufficient to access a data source. </summary>
  [DNTypeName('System.Data.SqlClient.SqlClientPermission')]
  DNSqlClientPermission = interface(DNDBDataPermission)
  ['{B17C70CA-A6C5-323E-A3AC-9E959F039538}']
  { getters & setters } 

    function get_AllowBlankPassword: Boolean;
    procedure set_AllowBlankPassword(value: Boolean);

  { methods } 

    ///<summary>Adds a new connection string and a set of restricted keywords to the <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  object.</summary>
    ///  <param name="connectionString">The connection string.</param>
    ///  <param name="restrictions">The key restrictions.</param>
    ///  <param name="behavior">One of the <see cref="T:System.Data.KeyRestrictionBehavior" />
    ///  enumerations.</param>
    procedure Add(connectionString: string; restrictions: string; behavior: DNKeyRestrictionBehavior);
    ///<summary>Returns the <see cref="T:System.Data.SqlClient.SqlClientPermission" />
    ///  as an <see cref="T:System.Security.IPermission" />
    ///  .</summary>
    ///<returns>A copy of the current permission object.</returns>
    function Copy: DDN.mscorlib.DNIPermission;
    ///<summary>Returns a new permission object representing the intersection of the current permission object and the specified permission object.</summary>
    ///  <param name="target">A permission object to intersect with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the intersection of the current permission object and the specified permission object. This new permission object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) if the intersection is empty.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is not a null reference (<see langword="Nothing" />
    ///  in Visual Basic) and is not an instance of the same class as the current permission object. </exception>
    function Intersect(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    ///<summary>Returns a value indicating whether the current permission object is a subset of the specified permission object.</summary>
    ///  <param name="target">A permission object that is to be tested for the subset relationship. This object must be of the same type as the current permission object. </param>
    ///<returns><see langword="true" />
    ///  if the current permission object is a subset of the specified permission object, otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  parameter is an object that is not of the same type as the current permission object. </exception>
    function IsSubsetOf(target: DDN.mscorlib.DNIPermission): Boolean;
    ///<summary>Reconstructs a security object with a specified state from an XML encoding.</summary>
    ///  <param name="securityElement">The XML encoding to use to reconstruct the security object. </param>
    procedure FromXml(securityElement: DDN.mscorlib.DNSecurityElement);
    ///<summary>Creates an XML encoding of the security object and its current state.</summary>
    ///<returns>An XML encoding of the security object, including any state information.</returns>
    function ToXml: DDN.mscorlib.DNSecurityElement;
    ///<summary>Returns a value indicating whether the permission can be represented as unrestricted without any knowledge of the permission semantics.</summary>
    ///<returns><see langword="true" />
    ///  if the permission can be represented as unrestricted.</returns>
    function IsUnrestricted: Boolean;
    ///<summary>Returns a new permission object that is the union of the current and specified permission objects.</summary>
    ///  <param name="target">A permission object to combine with the current permission object. It must be of the same type as the current permission object. </param>
    ///<returns>A new permission object that represents the union of the current permission object and the specified permission object.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="target" />
    ///  object is not the same type as the current permission object.</exception>
    function Union(target: DDN.mscorlib.DNIPermission): DDN.mscorlib.DNIPermission;
    procedure Demand;
    procedure Assert;
    procedure Deny;
    procedure PermitOnly;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a value indicating whether a blank password is allowed.</summary>
    ///<returns><see langword="true" />
    ///  if a blank password is allowed, otherwise, <see langword="false" />
    ///  .</returns>
    property AllowBlankPassword: Boolean read get_AllowBlankPassword write set_AllowBlankPassword;
  end;

  TDNSqlClientPermission = class(TDNGenericImport<DNSqlClientPermissionClass, DNSqlClientPermission>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlBinaryClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{BC5F7805-404E-52E2-8980-17E05A908C45}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure, setting the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  property to the contents of the supplied byte array.</summary>
    ///  <param name="value">The byte array to be stored or retrieved. </param>
    {class} function init(value: TArray<Byte>): DNSqlBinary;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlBinary;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure.</summary>
    {class} property Null: DNSqlBinary read __fakeFieldGet_Null;

  { static methods } 

    ///<summary>Concatenates two specified <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  values to create a new <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  that is the concatenated value of x and y.</returns>
    {class} function Add(x: DNSqlBinary; y: DNSqlBinary): DNSqlBinary;
    ///<summary>Concatenates two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to create a new <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>The concatenated values of the <paramref name="x" />
    ///  and <paramref name="y" />
    ///  parameters.</returns>
    {class} function Concat(x: DNSqlBinary; y: DNSqlBinary): DNSqlBinary;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlBinary" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlBinary; y: DNSqlBinary): DNSqlBoolean; overload;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlBinary; y: DNSqlBinary): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlBinary; y: DNSqlBinary): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlBinary; y: DNSqlBinary): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlBinary; y: DNSqlBinary): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structures to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlBinary; y: DNSqlBinary): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  . </summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a variable-length stream of binary data to be stored in or retrieved from a database. </summary>
  [DNTypeName('System.Data.SqlTypes.SqlBinary')]
  DNSqlBinary = interface(DDN.mscorlib.DNValueType)
  ['{786A4E29-6E12-387C-B5BF-64828EB757E4}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: TArray<Byte>;
    function get_Item(index: Int32): Byte;
    function get_Length: Int32;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object to a string.</summary>
    ///<returns>A string that contains the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  . If the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  is null the string will contain "null".</returns>
    function ToString: string;
    ///<summary>Converts this instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  to <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</returns>
    function ToSqlGuid: DNSqlGuid;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object to the supplied object and returns an indication of their relative values.</summary>
    ///  <param name="value">The object to be compared to this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A signed number that indicates the relative values of this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure and the object.Return value Condition Less than zero The value of this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object is less than the object. Zero This <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object is the same as object. Greater than zero This <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object is greater than object.-or- The object is a null reference. </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object to the supplied <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object to be compared to this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. </param>
    ///<returns>A signed number that indicates the relative values of this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure and the object.Return value Condition Less than zero The value of this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object is less than the object. Zero This <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object is the same as object. Greater than zero This <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object is greater than object.-or- The object is a null reference. </returns>
    function CompareTo(value: DNSqlBinary): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure is null. This property is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if <see langword="null" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure. This property is read-only.</summary>
    ///<returns>The value of the <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  structure.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  property is read when the property contains <see cref="F:System.Data.SqlTypes.SqlBinary.Null" />
    ///  . </exception>
    property Value: TArray<Byte> read get_Value;
    property Item[index: Int32]: Byte read get_Item; default;
    ///<summary>Gets the length in bytes of the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  property. This property is read-only.</summary>
    ///<returns>The length of the binary data in the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  property.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The <see cref="P:System.Data.SqlTypes.SqlBinary.Length" />
    ///  property is read when the <see cref="P:System.Data.SqlTypes.SqlBinary.Value" />
    ///  property contains <see cref="F:System.Data.SqlTypes.SqlBinary.Null" />
    ///  . </exception>
    property Length: Int32 read get_Length;
  end;

  TDNSqlBinary = class(TDNGenericImport<DNSqlBinaryClass, DNSqlBinary>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlBooleanClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{BCB78FA4-2432-5072-AF33-969F663AA254}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure using the supplied Boolean value.</summary>
    ///  <param name="value">The value for the new <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure; either <see langword="true" />
    ///  or <see langword="false" />
    ///  . </param>
    {class} function init(value: Boolean): DNSqlBoolean; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure using the specified integer value.</summary>
    ///  <param name="value">The integer whose value is to be used for the new <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    {class} function init(value: Int32): DNSqlBoolean; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_True: DNSqlBoolean;
   function __fakeFieldGet_False: DNSqlBoolean;
   function __fakeFieldGet_Null: DNSqlBoolean;
   function __fakeFieldGet_Zero: DNSqlBoolean;
   function __fakeFieldGet_One: DNSqlBoolean;

  { static fields } 

    ///<summary>Represents a true value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</summary>
    {class} property True: DNSqlBoolean read __fakeFieldGet_True;
    ///<summary>Represents a false value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</summary>
    {class} property False: DNSqlBoolean read __fakeFieldGet_False;
    ///<summary>Represents <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</summary>
    {class} property Null: DNSqlBoolean read __fakeFieldGet_Null;
    ///<summary>Represents a zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlBoolean.ByteValue" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</summary>
    {class} property Zero: DNSqlBoolean read __fakeFieldGet_Zero;
    ///<summary>Represents a one value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlBoolean.ByteValue" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</summary>
    {class} property One: DNSqlBoolean read __fakeFieldGet_One;

  { static methods } 

    ///<summary>Converts the specified <see cref="T:System.String" />
    ///  representation of a logical value to its <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  equivalent.</summary>
    ///  <param name="s">The <see cref="T:System.String" />
    ///  to be converted. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure that contains the parsed value.</returns>
    {class} function Parse(s: string): DNSqlBoolean;
    ///<summary>Performs a one's complement operation on the supplied <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///<returns>The one's complement of the supplied <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</returns>
    {class} function OnesComplement(x: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Computes the bitwise AND operation of two specified <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///<returns>The result of the logical AND operation.</returns>
    {class} function &And(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Performs a bitwise OR operation on the two specified <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure whose Value is the result of the bitwise OR operation.</returns>
    {class} function &Or(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Performs a bitwise exclusive-OR operation on the supplied parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///<returns>The result of the logical XOR operation.</returns>
    {class} function &Xor(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structures to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are not equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function Equals(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean; overload;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  for equality.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see langword="true" />
    ///  if the first instance is greater than the second instance; otherwise <see langword="false" />
    ///  . </returns>
    {class} function GreaterThan(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see langword="true" />
    ///  if the first instance is less than the second instance; otherwise, <see langword="false" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see langword="true" />
    ///  if the first instance is greater than or equal to the second instance; otherwise <see langword="false" />
    ///  .</returns>
    {class} function GreaterThanOrEquals(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see langword="true" />
    ///  if the first instance is less than or equal to the second instance; otherwise, <see langword="false" />
    ///  .</returns>
    {class} function LessThanOrEquals(x: DNSqlBoolean; y: DNSqlBoolean): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents an integer value that is either 1 or 0 to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlBoolean')]
  DNSqlBoolean = interface(DDN.mscorlib.DNValueType)
  ['{B8E24A3F-FC08-3838-9051-1F1CA4323B29}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Boolean;
    function get_IsTrue: Boolean;
    function get_IsFalse: Boolean;
    function get_ByteValue: Byte;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to a string.</summary>
    ///<returns>A string that contains the value of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  . If the value is null, the string will contain "null".</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  , the new <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's value is 1. Otherwise, the new <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's value is 0.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  then the new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's value is 1. Otherwise, the new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's value is 0.</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlInt16" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  then the new <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure's value is 1. Otherwise, the new <see langword="SqlInt16" />
    ///  structure's value is 0.</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlInt32" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  , the new <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure's value is 1. Otherwise, the new <see langword="SqlInt32" />
    ///  structure's value is 0.</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlInt64" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  , the new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure's value is 1. Otherwise, the new <see langword="SqlInt64" />
    ///  structure's value is 0.</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  , the new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  value is 1. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="false" />
    ///  , the new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  value is 0. If <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value is neither 1 nor 0, the new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  value is <see cref="F:System.Data.SqlTypes.SqlMoney.Null" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  then the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's value is 1. Otherwise, the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's value is 0.</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure whose value is 1 or 0.If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals true, the new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure's value is 1; otherwise the new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure's value is 0.</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure whose value is 1 or 0. If the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value equals <see langword="true" />
    ///  then <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure's value is 1. Otherwise, the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure's value is 0.</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure to a specified object and returns an indication of their relative values.</summary>
    ///  <param name="value">An object to compare, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </param>
    ///<returns>A signed number that indicates the relative values of the instance and value.Value Description A negative integer This instance is less than <paramref name="value" />
    ///  . Zero This instance is equal to <paramref name="value" />
    ///  . A positive integer This instance is greater than <paramref name="value" />
    ///  .-or-
    ///  <paramref name="value" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  object to the supplied <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  object and returns an indication of their relative values.</summary>
    ///  <param name="value">A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///<see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  object to compare, or a null reference (<see langword="Nothing" />
    ///  in Visual Basic).  </param>
    ///<returns>A signed number that indicates the relative values of the instance and value.Value Description A negative integer This instance is less than <paramref name="value" />
    ///  . Zero This instance is equal to <paramref name="value" />
    ///  . A positive integer This instance is greater than <paramref name="value" />
    ///  .-or-
    ///  <paramref name="value" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DNSqlBoolean): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  and the two are equal; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure is null; otherwise <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value. This property is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  ; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The property is set to null. </exception>
    property Value: Boolean read get_Value;
    ///<summary>Indicates whether the current <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if <see langword="Value" />
    ///  is <see langword="True" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property IsTrue: Boolean read get_IsTrue;
    ///<summary>Indicates whether the current <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  is <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if <see langword="Value" />
    ///  is <see langword="False" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property IsFalse: Boolean read get_IsFalse;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure as a byte.</summary>
    ///<returns>A byte representing the value of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure.</returns>
    property ByteValue: Byte read get_ByteValue;
  end;

  TDNSqlBoolean = class(TDNGenericImport<DNSqlBooleanClass, DNSqlBoolean>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlByteClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{B0043E6D-8C6A-5CFA-A00A-FC20DBA97B83}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure using the specified byte value.</summary>
    ///  <param name="value">A byte value to be stored in the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  property of the new <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    {class} function init(value: Byte): DNSqlByte;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlByte;
   function __fakeFieldGet_Zero: DNSqlByte;
   function __fakeFieldGet_MinValue: DNSqlByte;
   function __fakeFieldGet_MaxValue: DNSqlByte;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure.</summary>
    {class} property Null: DNSqlByte read __fakeFieldGet_Null;
    ///<summary>Represents a zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure.</summary>
    {class} property Zero: DNSqlByte read __fakeFieldGet_Zero;
    ///<summary>A constant representing the smallest possible value of a <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    {class} property MinValue: DNSqlByte read __fakeFieldGet_MinValue;
    ///<summary>A constant representing the largest possible value of a <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    {class} property MaxValue: DNSqlByte read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its 8-bit unsigned integer equivalent.</summary>
    ///  <param name="s">The <see langword="String" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure that contains the 8-bit number represented by the <see langword="String" />
    ///  parameter.</returns>
    {class} function Parse(s: string): DNSqlByte;
    ///<summary>The ones complement operator performs a bitwise one's complement operation on its <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operand.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  property contains the ones complement of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  parameter.</returns>
    {class} function OnesComplement(x: DNSqlByte): DNSqlByte;
    ///<summary>Computes the sum of the two specified <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see langword="Value" />
    ///  property contains the results of the addition.</returns>
    {class} function Add(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Subtracts the second <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operand from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>The results of subtracting the second <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operand from the first.</returns>
    {class} function Subtract(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Computes the product of the two <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  property contains the product of the multiplication.</returns>
    {class} function Multiply(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Divides its first <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operand by its second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  property contains the results of the division.</returns>
    {class} function Divide(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Computes the remainder after dividing its first <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operand by its second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  contains the remainder.</returns>
    {class} function &Mod(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Divides two <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  values and returns the remainder.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</param>
    ///<returns>The remainder left after division is performed on <paramref name="x" />
    ///  and <paramref name="y" />
    ///  .</returns>
    {class} function Modulus(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Computes the bitwise AND of its <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>The results of the bitwise AND operation.</returns>
    {class} function BitwiseAnd(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Computes the bitwise OR of its two <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>The results of the bitwise OR operation.</returns>
    {class} function BitwiseOr(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Performs a bitwise exclusive-OR operation on the supplied parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>The results of the XOR operation.</returns>
    {class} function &Xor(x: DNSqlByte; y: DNSqlByte): DNSqlByte;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structures to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlByte" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlByte; y: DNSqlByte): DNSqlBoolean; overload;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlByte; y: DNSqlByte): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlByte; y: DNSqlByte): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlByte; y: DNSqlByte): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlByte; y: DNSqlByte): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structures to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlByte; y: DNSqlByte): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents an 8-bit unsigned integer, in the range of 0 through 255, to be stored in or retrieved from a database. </summary>
  [DNTypeName('System.Data.SqlTypes.SqlByte')]
  DNSqlByte = interface(DDN.mscorlib.DNValueType)
  ['{4D1AFAD7-1431-3AFC-8960-D2DE9BE53DE6}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Byte;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to a <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A string that contains the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  . If the <see langword="Value" />
    ///  is null, the <see langword="String" />
    ///  will be a null string.</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A <see langword="SqlDouble" />
    ///  structure with the same value as this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A <see langword="SqlInt16" />
    ///  structure with the same value as this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A <see langword="SqlInt32" />
    ///  structure with the same value as this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A <see langword="SqlInt64" />
    ///  structure who <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  equals the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A <see langword="SqlMoney" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  equals the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure.</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A <see langword="SqlDecimal" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  equals the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure.</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A <see langword="SqlSingle" />
    ///  structure that has the same <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  as this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure.</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see langword="SqlString" />
    ///  that contains the string representation of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this instance to the supplied <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  object and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  object to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlByte): Int32; overload;
    ///<summary>Compares the supplied <see cref="T:System.Object" />
    ///  parameter to the <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  object.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure. This property is read-only </summary>
    ///<returns>The value of the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure.</returns>
    property Value: Byte read get_Value;
  end;

  TDNSqlByte = class(TDNGenericImport<DNSqlByteClass, DNSqlByte>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlDateTimeClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{CFD65AA2-B683-5C7D-8EE2-F2E470823769}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure using the specified <see cref="T:System.DateTime" />
    ///  value.</summary>
    ///  <param name="value">A <see langword="DateTime" />
    ///  structure. </param>
    {class} function init(value: DDN.mscorlib.DNDateTime): DNSqlDateTime; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure using the supplied parameters to initialize the year, month, day.</summary>
    ///  <param name="year">An integer representing the year of the of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="month">An integer value representing the month of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="day">An integer value representing the day number of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    {class} function init(year: Int32; month: Int32; day: Int32): DNSqlDateTime; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure using the supplied parameters to initialize the year, month, day, hour, minute, and second of the new structure.</summary>
    ///  <param name="year">An integer value representing the year of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="month">An integer value representing the month of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="day">An integer value representing the day of the month of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="hour">An integer value representing the hour of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="minute">An integer value representing the minute of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="second">An integer value representing the second of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    {class} function init(year: Int32; month: Int32; day: Int32; hour: Int32; minute: Int32; second: Int32): DNSqlDateTime; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure using the supplied parameters to initialize the year, month, day, hour, minute, second, and millisecond of the new structure.</summary>
    ///  <param name="year">An integer value representing the year of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="month">An integer value representing the month of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="day">An integer value representing the day of the month of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="hour">An integer value representing the hour of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="minute">An integer value representing the minute of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="second">An integer value representing the second of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="millisecond">An double value representing the millisecond of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    {class} function init(year: Int32; month: Int32; day: Int32; hour: Int32; minute: Int32; second: Int32; millisecond: Double): DNSqlDateTime; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure using the supplied parameters to initialize the year, month, day, hour, minute, second, and billisecond of the new structure.</summary>
    ///  <param name="year">An integer value representing the year of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="month">An integer value representing the month of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="day">An integer value representing the day of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="hour">An integer value representing the hour of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="minute">An integer value representing the minute of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="second">An integer value representing the second of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="bilisecond">An integer value representing the bilisecond (billionth of a second) of the new <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    {class} function init(year: Int32; month: Int32; day: Int32; hour: Int32; minute: Int32; second: Int32; bilisecond: Int32): DNSqlDateTime; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure using the supplied parameters.</summary>
    ///  <param name="dayTicks">An integer value that represents the date as ticks. </param>
    ///  <param name="timeTicks">An integer value that represents the time as ticks. </param>
    {class} function init(dayTicks: Int32; timeTicks: Int32): DNSqlDateTime; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_SQLTicksPerSecond: Int32;
   function __fakeFieldGet_SQLTicksPerMinute: Int32;
   function __fakeFieldGet_SQLTicksPerHour: Int32;
   function __fakeFieldGet_MinValue: DNSqlDateTime;
   function __fakeFieldGet_MaxValue: DNSqlDateTime;
   function __fakeFieldGet_Null: DNSqlDateTime;

  { static fields } 

    ///<summary>A constant whose value is the number of ticks equivalent to one second.</summary>
    {class} property SQLTicksPerSecond: Int32 read __fakeFieldGet_SQLTicksPerSecond;
    ///<summary>A constant whose value is the number of ticks equivalent to one minute.</summary>
    {class} property SQLTicksPerMinute: Int32 read __fakeFieldGet_SQLTicksPerMinute;
    ///<summary>A constant whose value is the number of ticks equivalent to one hour.</summary>
    {class} property SQLTicksPerHour: Int32 read __fakeFieldGet_SQLTicksPerHour;
    ///<summary>Represents the minimum valid date value for a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</summary>
    {class} property MinValue: DNSqlDateTime read __fakeFieldGet_MinValue;
    ///<summary>Represents the maximum valid date value for a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</summary>
    {class} property MaxValue: DNSqlDateTime read __fakeFieldGet_MaxValue;
    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</summary>
    {class} property Null: DNSqlDateTime read __fakeFieldGet_Null;

  { static methods } 

    ///<summary>Converts the specified <see cref="T:System.String" />
    ///  representation of a date and time to its <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  equivalent.</summary>
    ///  <param name="s">The <see langword="string" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure equal to the date and time represented by the specified <see langword="string" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlDateTime;
    ///<summary>Adds a <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  to the specified <see langword="TimeSpan" />
    ///  .</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  value.</param>
    ///  <param name="t">A <see langword="Timespan" />
    ///  value.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  value.</returns>
    {class} function Add(x: DNSqlDateTime; t: DDN.mscorlib.DNTimeSpan): DNSqlDateTime;
    ///<summary>Subtracts the specified <see langword="Timespan" />
    ///  from this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  instance.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  value.</param>
    ///  <param name="t">A <see langword="Timespan" />
    ///  value.</param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  value.</returns>
    {class} function Subtract(x: DNSqlDateTime; t: DDN.mscorlib.DNTimeSpan): DNSqlDateTime;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structures to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  .</returns>
    {class} function Equals(x: DNSqlDateTime; y: DNSqlDateTime): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of two instances of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlDateTime; y: DNSqlDateTime): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlDateTime; y: DNSqlDateTime): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlDateTime; y: DNSqlDateTime): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlDateTime; y: DNSqlDateTime): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlDateTime; y: DNSqlDateTime): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents the date and time data ranging in value from January 1, 1753 to December 31, 9999 to an accuracy of 3.33 milliseconds to be stored in or retrieved from a database. The <see cref="T:System.Data.SqlTypes.SqlDateTime" />
  ///  structure has a different underlying data structure from its corresponding .NET Framework type, <see cref="T:System.DateTime" />
  ///  , which can represent any time between 12:00:00 AM 1/1/0001 and 11:59:59 PM 12/31/9999, to the accuracy of 100 nanoseconds. <see cref="T:System.Data.SqlTypes.SqlDateTime" />
  ///  actually stores the relative difference to 00:00:00 AM 1/1/1900. Therefore, a conversion from "00:00:00 AM 1/1/1900" to an integer will return 0.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlDateTime')]
  DNSqlDateTime = interface(DDN.mscorlib.DNValueType)
  ['{C599278A-B83C-358D-96B1-56EA21FCF240}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: DDN.mscorlib.DNDateTime;
    function get_DayTicks: Int32;
    function get_TimeTicks: Int32;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure to a <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see langword="String" />
    ///  representing the <see cref="P:System.Data.SqlTypes.SqlDateTime.Value" />
    ///  property of this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see langword="SqlString" />
    ///  structure whose value is a string representing the date and time that is contained in this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  as Visual Basic). </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure to the supplied <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  . Zero This instance is the same as <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  . Greater than zero This instance is greater than <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  -or-
    ///<see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  is a null reference (<see langword="Nothing " />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlDateTime): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlDateTime.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if the object is an instance of <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Gets the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if null. Otherwise, <see langword="false" />
    ///  . </returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure. This property is read-only.</summary>
    ///<returns>The value of this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The exception that is thrown when the <see langword="Value" />
    ///  property of a <see cref="N:System.Data.SqlTypes" />
    ///  structure is set to null.</exception>
    property Value: DDN.mscorlib.DNDateTime read get_Value;
    ///<summary>Gets the number of ticks representing the date of this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</summary>
    ///<returns>The number of ticks representing the date that is contained in the <see cref="P:System.Data.SqlTypes.SqlDateTime.Value" />
    ///  property of this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The exception that is thrown when the <see langword="Value" />
    ///  property of a <see cref="N:System.Data.SqlTypes" />
    ///  structure is set to null.</exception>
    property DayTicks: Int32 read get_DayTicks;
    ///<summary>Gets the number of ticks representing the time of this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</summary>
    ///<returns>The number of ticks representing the time of this <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  structure.</returns>
    property TimeTicks: Int32 read get_TimeTicks;
  end;

  TDNSqlDateTime = class(TDNGenericImport<DNSqlDateTimeClass, DNSqlDateTime>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlDecimalClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{9F2819B0-E2F3-575A-964E-F4FE05261A86}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure using the supplied <see cref="T:System.Decimal" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Decimal" />
    ///  value to be stored as a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    {class} function init(value: DDN.mscorlib.DNDecimal): DNSqlDecimal; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure using the supplied integer value.</summary>
    ///  <param name="value">The supplied integer value which will the used as the value of the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    {class} function init(value: Int32): DNSqlDecimal; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure using the supplied long integer value.</summary>
    ///  <param name="value">The supplied long integer value which will the used as the value of the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    {class} function init(value: Int64): DNSqlDecimal; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure using the supplied parameters.</summary>
    ///  <param name="bPrecision">The maximum number of digits that can be used to represent the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property of the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="bScale">The number of decimal places to which the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property will be resolved for the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="fPositive">A Boolean value that indicates whether the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure represents a positive or negative number. </param>
    ///  <param name="bits">The 128-bit unsigned integer that provides the value of the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  . </param>
    {class} function init(bPrecision: Byte; bScale: Byte; fPositive: Boolean; bits: TArray<Int32>): DNSqlDecimal; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure using the supplied parameters.</summary>
    ///  <param name="bPrecision">The maximum number of digits that can be used to represent the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property of the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="bScale">The number of decimal places to which the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property will be resolved for the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="fPositive">A Boolean value that indicates whether the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure represents a positive or negative number. </param>
    ///  <param name="data1">An 32-bit unsigned integer which will be combined with data2, data3, and data4 to make up the 128-bit unsigned integer that represents the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structures value. </param>
    ///  <param name="data2">An 32-bit unsigned integer which will be combined with data1, data3, and data4 to make up the 128-bit unsigned integer that represents the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structures value. </param>
    ///  <param name="data3">An 32-bit unsigned integer which will be combined with data1, data2, and data4 to make up the 128-bit unsigned integer that represents the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structures value. </param>
    ///  <param name="data4">An 32-bit unsigned integer which will be combined with data1, data2, and data3 to make up the 128-bit unsigned integer that represents the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structures value. </param>
    {class} function init(bPrecision: Byte; bScale: Byte; fPositive: Boolean; data1: Int32; data2: Int32; data3: Int32; data4: Int32): DNSqlDecimal; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure using the supplied double parameter.</summary>
    ///  <param name="dVal">A double, representing the value for the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    {class} function init(dVal: Double): DNSqlDecimal; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_MaxPrecision: Byte;
   function __fakeFieldGet_MaxScale: Byte;
   function __fakeFieldGet_Null: DNSqlDecimal;
   function __fakeFieldGet_MinValue: DNSqlDecimal;
   function __fakeFieldGet_MaxValue: DNSqlDecimal;

  { static fields } 

    ///<summary>A constant representing the largest possible value for the <see cref="P:System.Data.SqlTypes.SqlDecimal.Precision" />
    ///  property.</summary>
    {class} property MaxPrecision: Byte read __fakeFieldGet_MaxPrecision;
    ///<summary>A constant representing the maximum value for the <see cref="P:System.Data.SqlTypes.SqlDecimal.Scale" />
    ///  property.</summary>
    {class} property MaxScale: Byte read __fakeFieldGet_MaxScale;
    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  class.</summary>
    {class} property Null: DNSqlDecimal read __fakeFieldGet_Null;
    ///<summary>A constant representing the minimum value for a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</summary>
    {class} property MinValue: DNSqlDecimal read __fakeFieldGet_MinValue;
    ///<summary>A constant representing the maximum value of a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</summary>
    {class} property MaxValue: DNSqlDecimal read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  equivalent.</summary>
    ///  <param name="s">The <see langword="String" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlDecimal;
    ///<summary>The scale of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  operand will be adjusted to the number of digits indicated by the digits parameter. Depending on the value of the fRound parameter, the value will either be rounded to the appropriate number of digits or truncated.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to be adjusted. </param>
    ///  <param name="digits">The number of digits in the adjusted structure. </param>
    ///  <param name="fRound">If this parameter is <see langword="true" />
    ///  , the new Value will be rounded, if <see langword="false" />
    ///  , the value will be truncated. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property contains the adjusted number.</returns>
    {class} function AdjustScale(n: DNSqlDecimal; digits: Int32; fRound: Boolean): DNSqlDecimal;
    ///<summary>Adjusts the value of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  operand to the indicated precision and scale.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose value is to be adjusted. </param>
    ///  <param name="precision">The precision for the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="scale">The scale for the new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose Value has been adjusted to the precision and scale indicated in the parameters.</returns>
    {class} function ConvertToPrecScale(n: DNSqlDecimal; precision: Int32; scale: Int32): DNSqlDecimal;
    ///<summary>Calculates the sum of the two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  operators.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property contains the sum.</returns>
    {class} function Add(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlDecimal;
    ///<summary>Calculates the results of subtracting the second <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  operand from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose Value property contains the results of the subtraction.</returns>
    {class} function Subtract(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlDecimal;
    ///<summary>The multiplication operator computes the product of the two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property contains the product of the multiplication.</returns>
    {class} function Multiply(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlDecimal;
    ///<summary>The division operator calculates the results of dividing the first <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  operand by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property contains the results of the division.</returns>
    {class} function Divide(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlDecimal;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  operands to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, the value of the <see langword="SqlDecimal" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  parameters to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlBoolean;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structures to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlBoolean;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structures to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  parameters to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  parameters to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlDecimal; y: DNSqlDecimal): DNSqlBoolean;
    ///<summary>The Abs method gets the absolute value of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  parameter.</summary>
    ///  <param name="n">A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property contains the unsigned number representing the absolute value of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  parameter.</returns>
    {class} function Abs(n: DNSqlDecimal): DNSqlDecimal;
    ///<summary>Returns the smallest whole number greater than or equal to the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure for which the ceiling value is to be calculated. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  representing the smallest whole number greater than or equal to the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</returns>
    {class} function Ceiling(n: DNSqlDecimal): DNSqlDecimal;
    ///<summary>Rounds a specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  number to the next lower whole number.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure for which the floor value is to be calculated. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure that contains the whole number part of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</returns>
    {class} function Floor(n: DNSqlDecimal): DNSqlDecimal;
    ///<summary>Gets a value that indicates the sign of a <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose sign is to be evaluated. </param>
    ///<returns>A number that indicates the sign of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</returns>
    {class} function Sign(n: DNSqlDecimal): DNSqlInt32;
    ///<summary>Gets the number nearest the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's value with the specified precision.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to be rounded. </param>
    ///  <param name="position">The number of significant fractional digits (precision) in the return value. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure that contains the results of the rounding operation.</returns>
    {class} function Round(n: DNSqlDecimal; position: Int32): DNSqlDecimal;
    ///<summary>Truncates the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's value to the that you want position.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to be truncated. </param>
    ///  <param name="position">The decimal position to which the number will be truncated. </param>
    ///<returns>Supply a negative value for the <paramref name="position" />
    ///  parameter in order to truncate the value to the corresponding position to the left of the decimal point.</returns>
    {class} function Truncate(n: DNSqlDecimal; position: Int32): DNSqlDecimal;
    ///<summary>Raises the value of the specified <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to the specified exponential power.</summary>
    ///  <param name="n">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to be raised to a power. </param>
    ///  <param name="exp">A double value that indicates the power to which the number should be raised. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure that contains the results.</returns>
    {class} function Power(n: DNSqlDecimal; exp: Double): DNSqlDecimal;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a numeric value between - 10^38 +1 and 10^38 - 1, with fixed precision and scale. </summary>
  [DNTypeName('System.Data.SqlTypes.SqlDecimal')]
  DNSqlDecimal = interface(DDN.mscorlib.DNValueType)
  ['{BDCFC99C-77C5-3116-BD41-6BE948F47914}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: DDN.mscorlib.DNDecimal;
    function get_IsPositive: Boolean;
    function get_Precision: Byte;
    function get_Scale: Byte;
    function get_Data: TArray<Int32>;
    function get_BinData: TArray<Byte>;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.String" />
    ///  object that contains the string representation of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property.</returns>
    function ToString: string;
    ///<summary>Returns the a double equal to the contents of the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property of this instance.</summary>
    ///<returns>The decimal representation of the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property.</returns>
    function ToDouble: Double;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see langword="Value" />
    ///  equals the <see langword="Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. If the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's Value is <see langword="true" />
    ///  , the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's <see langword="Value" />
    ///  will be 1. Otherwise, the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's <see langword="Value" />
    ///  will be 0.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure with the same value as this instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure with the same value as this instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure with the same value as this instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure with the same value as this instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure with the same value as this instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure with the same value as this instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure whose value is a string representing the value contained in this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  object and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlDecimal): Int32; overload;
    ///<summary>Compares the supplied <see cref="T:System.Object" />
    ///  parameter to the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  instance.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared.</param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  and the two are equal. Otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure is null. Otherwise, <see langword="false" />
    ///  . </returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure. This property is read-only.</summary>
    ///<returns>A number in the range -79,228,162,514,264,337,593,543,950,335 through 79,228,162,514,162,514,264,337,593,543,950,335.</returns>
    property Value: DDN.mscorlib.DNDecimal read get_Value;
    ///<summary>Indicates whether the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure is greater than zero.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  is assigned to null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsPositive: Boolean read get_IsPositive;
    ///<summary>Gets the maximum number of digits used to represent the <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  property.</summary>
    ///<returns>The maximum number of digits used to represent the <see langword="Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</returns>
    property Precision: Byte read get_Precision;
    ///<summary>Gets the number of decimal places to which <see cref="P:System.Data.SqlTypes.SqlDecimal.Value" />
    ///  is resolved.</summary>
    ///<returns>The number of decimal places to which the <see langword="Value" />
    ///  property is resolved.</returns>
    property Scale: Byte read get_Scale;
    ///<summary>Gets the binary representation of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure as an array of integers.</summary>
    ///<returns>An array of integers that contains the binary representation of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure.</returns>
    property Data: TArray<Int32> read get_Data;
    ///<summary>Get the binary representation of the value of this <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure as an array of bytes.</summary>
    ///<returns>An array of bytes that contains the binary representation of the <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure's value.</returns>
    property BinData: TArray<Byte> read get_BinData;
  end;

  TDNSqlDecimal = class(TDNGenericImport<DNSqlDecimalClass, DNSqlDecimal>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlDoubleClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{6CF2800B-3833-5F2C-82F5-D52E4986C67A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure using the supplied double parameter to set the new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  property.</summary>
    ///  <param name="value">A double whose value will be used for the new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  . </param>
    {class} function init(value: Double): DNSqlDouble;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlDouble;
   function __fakeFieldGet_Zero: DNSqlDouble;
   function __fakeFieldGet_MinValue: DNSqlDouble;
   function __fakeFieldGet_MaxValue: DNSqlDouble;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure.</summary>
    {class} property Null: DNSqlDouble read __fakeFieldGet_Null;
    ///<summary>Represents a zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure.</summary>
    {class} property Zero: DNSqlDouble read __fakeFieldGet_Zero;
    ///<summary>A constant representing the minimum possible value of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    {class} property MinValue: DNSqlDouble read __fakeFieldGet_MinValue;
    ///<summary>A constant representing the maximum value for a <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure.</summary>
    {class} property MaxValue: DNSqlDouble read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its double-precision floating point number equivalent.</summary>
    ///  <param name="s">The <see langword="String" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  that contains the value represented by the <see langword="String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlDouble;
    ///<summary>The addition operator computes the sum of the two <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>The sum of the two <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  operands.</returns>
    {class} function Add(x: DNSqlDouble; y: DNSqlDouble): DNSqlDouble;
    ///<summary>The subtraction operator the second <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  operand from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>The results of the subtraction operation.</returns>
    {class} function Subtract(x: DNSqlDouble; y: DNSqlDouble): DNSqlDouble;
    ///<summary>The multiplication operator computes the product of the two <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>The product of the two <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  operands.</returns>
    {class} function Multiply(x: DNSqlDouble; y: DNSqlDouble): DNSqlDouble;
    ///<summary>The division operator divides the first <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  operand by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure that contains the results of the division operation.</returns>
    {class} function Divide(x: DNSqlDouble; y: DNSqlDouble): DNSqlDouble;
    ///<summary>Performs a logical comparison on two instances of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  .</returns>
    {class} function Equals(x: DNSqlDouble; y: DNSqlDouble): DNSqlBoolean; overload;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to determine whether they are notequal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlDouble; y: DNSqlDouble): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlDouble; y: DNSqlDouble): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlDouble; y: DNSqlDouble): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlDouble; y: DNSqlDouble): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlDouble; y: DNSqlDouble): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a floating-point number within the range of -1.79E +308 through 1.79E +308 to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlDouble')]
  DNSqlDouble = interface(DDN.mscorlib.DNValueType)
  ['{15948ECF-16E5-35C7-AB50-F8B22FC235CA}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Double;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to a string.</summary>
    ///<returns>A string representing the <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns>A <see langword="SqlBoolean" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  is non-zero, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  is zero and <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  if the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure is <see cref="F:System.Data.SqlTypes.SqlDouble.Null" />
    ///  .</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see langword="SqlByte" />
    ///  structure whose <see langword="Value" />
    ///  equals the <see langword="Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see langword="Value" />
    ///  equals the integer part of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's value.</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure whose <see langword="Value" />
    ///  equals the integer part of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's value.</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see langword="Value" />
    ///  equals the integer part of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure's value.</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlMoney" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  is equal to the value of this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlDecimal" />
    ///  structure whose converted value equals the rounded value of this <see langword="SqlDouble" />
    ///  .</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlSingle" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  is equal to the <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see langword="SqlString" />
    ///  representing the <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to compare. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing " />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlDouble): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlDateTime.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structre.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Returns a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  instance is null.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="P:System.Data.SqlTypes.SqlDouble.Value" />
    ///  is null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure. This property is read-only.</summary>
    ///<returns>The value of the <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure.</returns>
    property Value: Double read get_Value;
  end;

  TDNSqlDouble = class(TDNGenericImport<DNSqlDoubleClass, DNSqlDouble>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlGuidClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{B91E024B-C566-5CF3-8C05-3B4D709225DC}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure using the supplied byte array parameter.</summary>
    ///  <param name="value">A byte array. </param>
    {class} function init(value: TArray<Byte>): DNSqlGuid; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure using the specified <see cref="T:System.String" />
    ///  parameter.</summary>
    ///  <param name="s">A <see cref="T:System.String" />
    ///  object. </param>
    {class} function init(s: string): DNSqlGuid; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure using the specified <see cref="T:System.Guid" />
    ///  parameter.</summary>
    ///  <param name="g">A <see cref="T:System.Guid" />
    ///</param>
    {class} function init(g: DDN.mscorlib.DNGuid): DNSqlGuid; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure using the specified values.</summary>
    ///  <param name="a">The first four bytes of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="b">The next two bytes of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="c">The next two bytes of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="d">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="e">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="f">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="g">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="h">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="i">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="j">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    ///  <param name="k">The next byte of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  . </param>
    {class} function init(a: Int32; b: Int16; c: Int16; d: Byte; e: Byte; f: Byte; g: Byte; h: Byte; i: Byte; j: Byte; k: Byte): DNSqlGuid; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlGuid;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</summary>
    {class} property Null: DNSqlGuid read __fakeFieldGet_Null;

  { static methods } 

    ///<summary>Converts the specified <see cref="T:System.String" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</summary>
    ///  <param name="s">The <see langword="String" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlGuid;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structures to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlGuid" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlGuid; y: DNSqlGuid): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison on two <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structures to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlGuid; y: DNSqlGuid): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlGuid; y: DNSqlGuid): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlGuid; y: DNSqlGuid): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlGuid; y: DNSqlGuid): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlGuid; y: DNSqlGuid): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a GUID to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlGuid')]
  DNSqlGuid = interface(DDN.mscorlib.DNValueType)
  ['{F0D806DB-2E99-384B-8436-4F44230A9344}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: DDN.mscorlib.DNGuid;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure to a byte array.</summary>
    ///<returns>An array of bytes representing the <see cref="P:System.Data.SqlTypes.SqlGuid.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</returns>
    function ToByteArray: TArray<Byte>;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure to a <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the string representation of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure that contains the string representation of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBinary" />
    ///  .</summary>
    ///<returns>A <see langword="SqlBinary" />
    ///  structure that contains the bytes in the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</returns>
    function ToSqlBinary: DNSqlBinary;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure to the supplied object and returns an indication of their relative values. Compares more than the last 6 bytes, but treats the last 6 bytes as the most significant ones in comparisons.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than object. Zero This instance is the same as object. Greater than zero This instance is greater than object -or- object is a null reference (<see langword="Nothing" />
    ///  ) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure to the supplied <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  and returns an indication of their relative values. Compares more than the last 6 bytes, but treats the last 6 bytes as the most significant ones in comparisons.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than object. Zero This instance is the same as object. Greater than zero This instance is greater than object -or- object is a null reference (<see langword="Nothing" />
    ///  ). </returns>
    function CompareTo(value: DNSqlGuid): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlGuid.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code of this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if <see langword="null" />
    ///  . Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of the <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure. This property is read-only.</summary>
    ///<returns>A <see cref="T:System.Guid" />
    ///  structure.</returns>
    property Value: DDN.mscorlib.DNGuid read get_Value;
  end;

  TDNSqlGuid = class(TDNGenericImport<DNSqlGuidClass, DNSqlGuid>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlInt16Class = interface(DDN.mscorlib.DNValueTypeClass)
  ['{3BF5CA4B-7F76-5731-9FD3-C8C0A300D610}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure using the supplied short integer parameter.</summary>
    ///  <param name="value">A short integer. </param>
    {class} function init(value: Int16): DNSqlInt16;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlInt16;
   function __fakeFieldGet_Zero: DNSqlInt16;
   function __fakeFieldGet_MinValue: DNSqlInt16;
   function __fakeFieldGet_MaxValue: DNSqlInt16;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</summary>
    {class} property Null: DNSqlInt16 read __fakeFieldGet_Null;
    ///<summary>Represents a zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</summary>
    {class} property Zero: DNSqlInt16 read __fakeFieldGet_Zero;
    ///<summary>A constant representing the smallest possible value of a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    {class} property MinValue: DNSqlInt16 read __fakeFieldGet_MinValue;
    ///<summary>A constant representing the largest possible value of a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    {class} property MaxValue: DNSqlInt16 read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its 16-bit signed integer equivalent.</summary>
    ///  <param name="s">The <see langword="String" />
    ///  to be parsed. </param>
    ///<returns>A 16-bit signed integer equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlInt16;
    ///<summary>The ~ operator performs a bitwise one's complement operation on its <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  operand.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property contains the complement of the specified <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    {class} function OnesComplement(x: DNSqlInt16): DNSqlInt16;
    ///<summary>Computes the sum of the two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property contains the sum of the two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  operands.</returns>
    {class} function Add(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Subtracts the second <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  parameter from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property contains the results of the subtraction.</returns>
    {class} function Subtract(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Computes the product of the two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  contains the product of the two parameters.</returns>
    {class} function Multiply(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Divides the first <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  operand by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property contains the results of the division.</returns>
    {class} function Divide(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Computes the remainder after dividing its first <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  operand by its second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  contains the remainder.</returns>
    {class} function &Mod(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Divides two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  values and returns the remainder.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  value.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  value.</param>
    ///<returns>The remainder left after division is performed on <paramref name="x" />
    ///  and <paramref name="y" />
    ///  .</returns>
    {class} function Modulus(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Computes the bitwise AND of its <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property contains the results of the bitwise AND.</returns>
    {class} function BitwiseAnd(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Computes the bitwise OR of its two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property contains the results of the bitwise OR.</returns>
    {class} function BitwiseOr(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Performs a bitwise exclusive-OR operation on the supplied parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure that contains the results of the XOR operation.</returns>
    {class} function &Xor(x: DNSqlInt16; y: DNSqlInt16): DNSqlInt16;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structures to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlInt16" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlInt16; y: DNSqlInt16): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structures to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlInt16; y: DNSqlInt16): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlInt16; y: DNSqlInt16): DNSqlBoolean;
    ///<summary>Compares two instances of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlInt16; y: DNSqlInt16): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structures to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlInt16; y: DNSqlInt16): DNSqlBoolean;
    ///<summary>Compares two <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structures to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlInt16; y: DNSqlInt16): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see cref="T:System.String" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a 16-bit signed integer to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlInt16')]
  DNSqlInt16 = interface(DDN.mscorlib.DNValueType)
  ['{20F45935-DA99-3C1C-9580-217119B0F859}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Int16;

  { methods } 

    ///<summary>Converts a <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  object representing the <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  of this instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  equals the <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. If the value of the <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  is less than 0 or greater than 255, an <see cref="T:System.OverflowException" />
    ///  occurs.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure whose <see langword="Value" />
    ///  equals the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure whose <see langword="Value" />
    ///  equals the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see langword="Value" />
    ///  equals the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure whose <see langword="Value" />
    ///  equals the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure whose <see langword="Value" />
    ///  equals the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure whose <see langword="Value" />
    ///  equals the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  representing the <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  of this instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlInt16): Int32; overload;
    ///<summary>Compares the specified object to the <see cref="P:System.Data.SqlTypes.SqlInt16.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if null. Otherwise, <see langword="false" />
    ///  . For more information, see Handling Null Values.</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of this instance of <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure. This property is read-only.</summary>
    ///<returns>A short integer representing the value of this <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure.</returns>
    property Value: Int16 read get_Value;
  end;

  TDNSqlInt16 = class(TDNGenericImport<DNSqlInt16Class, DNSqlInt16>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlInt32Class = interface(DDN.mscorlib.DNValueTypeClass)
  ['{CF5049B8-ABB5-5D6A-A82C-3A5F655687CF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure using the supplied integer value.</summary>
    ///  <param name="value">The integer to be converted. </param>
    {class} function init(value: Int32): DNSqlInt32;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlInt32;
   function __fakeFieldGet_Zero: DNSqlInt32;
   function __fakeFieldGet_MinValue: DNSqlInt32;
   function __fakeFieldGet_MaxValue: DNSqlInt32;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  class.</summary>
    {class} property Null: DNSqlInt32 read __fakeFieldGet_Null;
    ///<summary>Represents a zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure.</summary>
    {class} property Zero: DNSqlInt32 read __fakeFieldGet_Zero;
    ///<summary>A constant representing the smallest possible value of a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    {class} property MinValue: DNSqlInt32 read __fakeFieldGet_MinValue;
    ///<summary>A constant representing the largest possible value of a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    {class} property MaxValue: DNSqlInt32 read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its 32-bit signed integer equivalent.</summary>
    ///  <param name="s">The <see cref="T:System.String" />
    ///  to be parsed. </param>
    ///<returns>A 32-bit signed integer equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlInt32;
    ///<summary>Performs a bitwise one's complement operation on the specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure that contains the results of the one's complement operation.</returns>
    {class} function OnesComplement(x: DNSqlInt32): DNSqlInt32;
    ///<summary>Computes the sum of the two specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  property contains the sum of the specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structures.</returns>
    {class} function Add(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Subtracts the second <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameter from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  property contains the results of the subtraction.</returns>
    {class} function Subtract(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Computes the product of the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  contains the product of the two parameters.</returns>
    {class} function Multiply(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Divides the first <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameter from the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  whose <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  property contains the results of the division.</returns>
    {class} function Divide(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Computes the remainder after dividing the first <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameter by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  contains the remainder.</returns>
    {class} function &Mod(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Divides two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  values and returns the remainder.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  value.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  value.</param>
    ///<returns>The remainder left after division is performed on <paramref name="x" />
    ///  and <paramref name="y" />
    ///  .</returns>
    {class} function Modulus(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Computes the bitwise AND of its <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure that contains the results of the bitwise AND operation.</returns>
    {class} function BitwiseAnd(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Computes the bitwise OR of the specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure that contains the results of the bitwise OR operation.</returns>
    {class} function BitwiseOr(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Performs a bitwise exclusive-OR operation on the specified <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure that contains the results of the bitwise XOR operation.</returns>
    {class} function &Xor(x: DNSqlInt32; y: DNSqlInt32): DNSqlInt32;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlInt32" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlInt32; y: DNSqlInt32): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlInt32; y: DNSqlInt32): DNSqlBoolean;
    ///<summary>Compares the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlInt32; y: DNSqlInt32): DNSqlBoolean;
    ///<summary>Compares the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlInt32; y: DNSqlInt32): DNSqlBoolean;
    ///<summary>Compares the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlInt32; y: DNSqlInt32): DNSqlBoolean;
    ///<summary>Compares the two <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  parameters to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlInt32; y: DNSqlInt32): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a 32-bit signed integer to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlInt32')]
  DNSqlInt32 = interface(DDN.mscorlib.DNValueType)
  ['{4BDFEF65-38A3-3B4D-A409-223E7AFFA172}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Int32;

  { methods } 

    ///<summary>Converts a <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to a <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see langword="Value" />
    ///  equals the <see langword="Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. If the value of the <see langword="SqlInt32" />
    ///  is less than 0 or greater than 255, an <see cref="T:System.OverflowException" />
    ///  occurs.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlInt32): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure is null.</summary>
    ///<returns>This property is <see langword="true" />
    ///  if <see cref="P:System.Data.SqlTypes.SqlInt32.Value" />
    ///  is null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure. This property is read-only.</summary>
    ///<returns>An integer representing the value of this <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  structure.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The property contains <see cref="F:System.Data.SqlTypes.SqlInt32.Null" />
    ///  . </exception>
    property Value: Int32 read get_Value;
  end;

  TDNSqlInt32 = class(TDNGenericImport<DNSqlInt32Class, DNSqlInt32>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlInt64Class = interface(DDN.mscorlib.DNValueTypeClass)
  ['{12B1DB76-156F-5305-93FE-EE0D0D4FAFE8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure using the supplied long integer.</summary>
    ///  <param name="value">A long integer. </param>
    {class} function init(value: Int64): DNSqlInt64;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlInt64;
   function __fakeFieldGet_Zero: DNSqlInt64;
   function __fakeFieldGet_MinValue: DNSqlInt64;
   function __fakeFieldGet_MaxValue: DNSqlInt64;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure.</summary>
    {class} property Null: DNSqlInt64 read __fakeFieldGet_Null;
    ///<summary>Represents a zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure.</summary>
    {class} property Zero: DNSqlInt64 read __fakeFieldGet_Zero;
    ///<summary>A constant representing the smallest possible value for a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure.</summary>
    {class} property MinValue: DNSqlInt64 read __fakeFieldGet_MinValue;
    ///<summary>A constant representing the largest possible value for a <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure.</summary>
    {class} property MaxValue: DNSqlInt64 read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its 64-bit signed integer equivalent.</summary>
    ///  <param name="s">The <see cref="T:System.String" />
    ///  to be parsed. </param>
    ///<returns>A 64-bit signed integer equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlInt64;
    ///<summary>Performs a bitwise one's complement operation on its <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  operand.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  is equal to the ones complement of the <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameter.</returns>
    {class} function OnesComplement(x: DNSqlInt64): DNSqlInt64;
    ///<summary>Computes the sum of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  is equal to the sum of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters.</returns>
    {class} function Add(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Subtracts the second <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameter from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  property equals the results of the subtraction operation.</returns>
    {class} function Subtract(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Computes the product of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  is equal to the product of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters.</returns>
    {class} function Multiply(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Divides the first <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameter by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  property contains the results of the division operation.</returns>
    {class} function Divide(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Computes the remainder after dividing the first <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameter by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  property contains the remainder.</returns>
    {class} function &Mod(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Divides two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  values and returns the remainder.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  value.</param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  value.</param>
    ///<returns>The remainder left after division is performed on <paramref name="x" />
    ///  and <paramref name="y" />
    ///  .</returns>
    {class} function Modulus(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Computes the bitwise AND of its <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure that contains the results of the bitwise AND operation.</returns>
    {class} function BitwiseAnd(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Computes the bitwise OR of its two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  operands.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure that contains the results of the bitwise OR operation.</returns>
    {class} function BitwiseOr(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Performs a bitwise exclusive-OR operation on the supplied parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure that contains the results of the bitwise XOR operation.</returns>
    {class} function &Xor(x: DNSqlInt64; y: DNSqlInt64): DNSqlInt64;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlInt64" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlInt64; y: DNSqlInt64): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison on the two SqlInt64 parameters to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlInt64; y: DNSqlInt64): DNSqlBoolean;
    ///<summary>Performs a logical comparison on the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlInt64; y: DNSqlInt64): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlInt64; y: DNSqlInt64): DNSqlBoolean;
    ///<summary>Performs a logical comparison on the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlInt64; y: DNSqlInt64): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  parameters to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlInt64; y: DNSqlInt64): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a 64-bit signed integer to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlInt64')]
  DNSqlInt64 = interface(DDN.mscorlib.DNValueType)
  ['{00CBD4D3-846A-301B-B4E5-3C8A0F0F8A22}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Int64;

  { methods } 

    ///<summary>Converts this instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  to <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  representing the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see langword="Value" />
    ///  equals the <see langword="Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. </returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  representing the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing " />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DNSqlInt64): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlInt64.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if object is an instance of <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Returns the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure. This property is read-only.</summary>
    ///<returns>A long integer representing the value of this <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  structure.</returns>
    property Value: Int64 read get_Value;
  end;

  TDNSqlInt64 = class(TDNGenericImport<DNSqlInt64Class, DNSqlInt64>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlMoneyClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{8BEB8FFC-8B77-5B40-862E-C38062667DEE}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class with the specified integer value.</summary>
    ///  <param name="value">The monetary value to initialize. </param>
    {class} function init(value: Int32): DNSqlMoney; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class with the specified long integer value.</summary>
    ///  <param name="value">The monetary value to initialize. </param>
    {class} function init(value: Int64): DNSqlMoney; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class with the specified <see cref="T:System.Decimal" />
    ///  value.</summary>
    ///  <param name="value">The monetary value to initialize. </param>
    {class} function init(value: DDN.mscorlib.DNDecimal): DNSqlMoney; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class with specified double value.</summary>
    ///  <param name="value">The monetary value to initialize. </param>
    {class} function init(value: Double): DNSqlMoney; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlMoney;
   function __fakeFieldGet_Zero: DNSqlMoney;
   function __fakeFieldGet_MinValue: DNSqlMoney;
   function __fakeFieldGet_MaxValue: DNSqlMoney;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class.</summary>
    {class} property Null: DNSqlMoney read __fakeFieldGet_Null;
    ///<summary>Represents the zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class.</summary>
    {class} property Zero: DNSqlMoney read __fakeFieldGet_Zero;
    ///<summary>Represents the minimum value that can be assigned to <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class.</summary>
    {class} property MinValue: DNSqlMoney read __fakeFieldGet_MinValue;
    ///<summary>Represents the maximum value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  class.</summary>
    {class} property MaxValue: DNSqlMoney read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the <see cref="T:System.String" />
    ///  representation of a number to its <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  equivalent.</summary>
    ///  <param name="s">The <see langword="String" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlMoney;
    ///<summary>Calculates the sum of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  stucture whose <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  contains the sum of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters.</returns>
    {class} function Add(x: DNSqlMoney; y: DNSqlMoney): DNSqlMoney;
    ///<summary>The subtraction operator subtracts the second <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameter from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure that contains the results of the subtraction.</returns>
    {class} function Subtract(x: DNSqlMoney; y: DNSqlMoney): DNSqlMoney;
    ///<summary>The multiplicaion operator calculates the product of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  contains the product of the multiplication.</returns>
    {class} function Multiply(x: DNSqlMoney; y: DNSqlMoney): DNSqlMoney;
    ///<summary>The division operator divides the first <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameter by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  contains the results of the division.</returns>
    {class} function Divide(x: DNSqlMoney; y: DNSqlMoney): DNSqlMoney;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlMoney" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlMoney; y: DNSqlMoney): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlMoney; y: DNSqlMoney): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlMoney; y: DNSqlMoney): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlMoney; y: DNSqlMoney): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlMoney; y: DNSqlMoney): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  parameters to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlMoney; y: DNSqlMoney): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a currency value ranging from -2 63 (or -922,337,203,685,477.5808) to 2 63 -1 (or +922,337,203,685,477.5807) with an accuracy to a ten-thousandth of currency unit to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlMoney')]
  DNSqlMoney = interface(DDN.mscorlib.DNValueType)
  ['{9DE6EE1A-043D-37A7-A54E-A5541A181DEF}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: DDN.mscorlib.DNDecimal;

  { methods } 

    ///<summary>Converts the Value of this instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  as a <see cref="T:System.Decimal" />
    ///  structure.</summary>
    ///<returns>A <see cref="T:System.Decimal" />
    ///  structure whose value equals the <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  property of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure.</returns>
    function ToDecimal: DDN.mscorlib.DNDecimal;
    ///<summary>Converts the Value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to an <see cref="T:System.Int64" />
    ///  .</summary>
    ///<returns>A 64-bit integer whose value equals the integer part of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure.</returns>
    function ToInt64: Int64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to an <see cref="T:System.Int32" />
    ///  .</summary>
    ///<returns>A 32-bit integer whose value equals the integer part of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure.</returns>
    function ToInt32: Int32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to a <see cref="T:System.Double" />
    ///  .</summary>
    ///<returns>A double with a value equal to this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure.</returns>
    function ToDouble: Double;
    ///<summary>Converts this instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  to string.</summary>
    ///<returns>A string whose value is the string representation of the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure. If the value of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure is zero, the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  structure's value will be <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  .</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  . </returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure whose value is a string representing the value of this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlMoney): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlMoney.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns>Equals will return <see langword="true" />
    ///  if the object is an instance of <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Gets the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Returns a Boolean value that indicates whether this <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the monetary value of an instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure. This property is read-only.</summary>
    ///<returns>The monetary value of an instance of the <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  structure.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The property is set to null. </exception>
    property Value: DDN.mscorlib.DNDecimal read get_Value;
  end;

  TDNSqlMoney = class(TDNGenericImport<DNSqlMoneyClass, DNSqlMoney>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlSingleClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{37F2DDC7-3D28-5A2D-A6B9-B1261DE01D9B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure.</summary>
    ///  <param name="value">A floating point number which will be used as the <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  of the new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    {class} function init(value: Single): DNSqlSingle; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure using the supplied double parameter.</summary>
    ///  <param name="value">A double value which will be used as the <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  of the new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    {class} function init(value: Double): DNSqlSingle; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlSingle;
   function __fakeFieldGet_Zero: DNSqlSingle;
   function __fakeFieldGet_MinValue: DNSqlSingle;
   function __fakeFieldGet_MaxValue: DNSqlSingle;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure.</summary>
    {class} property Null: DNSqlSingle read __fakeFieldGet_Null;
    ///<summary>Represents the zero value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  class.</summary>
    {class} property Zero: DNSqlSingle read __fakeFieldGet_Zero;
    ///<summary>Represents the minimum value that can be assigned to <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  class.</summary>
    {class} property MinValue: DNSqlSingle read __fakeFieldGet_MinValue;
    ///<summary>Represents the maximum value that can be assigned to the <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  property of an instance of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  class.</summary>
    {class} property MaxValue: DNSqlSingle read __fakeFieldGet_MaxValue;

  { static methods } 

    ///<summary>Converts the specified <see cref="T:System.String" />
    ///  to a <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure.</summary>
    ///  <param name="s">The <see cref="T:System.String" />
    ///  to be parsed. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  equivalent to the value that is contained in the specified <see cref="T:System.String" />
    ///  .</returns>
    {class} function Parse(s: string): DNSqlSingle;
    ///<summary>Computes the sum of the two specified <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure that contains the sum of the two specified <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structures.</returns>
    {class} function Add(x: DNSqlSingle; y: DNSqlSingle): DNSqlSingle;
    ///<summary>Subtracts the second <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure from the first.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure that contains the results of the subtraction.</returns>
    {class} function Subtract(x: DNSqlSingle; y: DNSqlSingle): DNSqlSingle;
    ///<summary>Computes the product of the two specified <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure that contains the product of the multiplication.</returns>
    {class} function Multiply(x: DNSqlSingle; y: DNSqlSingle): DNSqlSingle;
    ///<summary>Divides the first <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure by the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see langword="SqlInt64" />
    ///  structure that contains the results of the division.</returns>
    {class} function Divide(x: DNSqlSingle; y: DNSqlSingle): DNSqlSingle;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  parameters to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlSingle" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlSingle; y: DNSqlSingle): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  parameters to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlSingle; y: DNSqlSingle): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  parameters to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlSingle; y: DNSqlSingle): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  operands to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlSingle; y: DNSqlSingle): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  parameters to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlSingle; y: DNSqlSingle): DNSqlBoolean;
    ///<summary>Performs a logical comparison of two <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structures to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlSingle; y: DNSqlSingle): DNSqlBoolean;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a floating point number within the range of -3.40E +38 through 3.40E +38 to be stored in or retrieved from a database.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlSingle')]
  DNSqlSingle = interface(DDN.mscorlib.DNValueType)
  ['{276F2119-1904-3B1B-8463-F19AF694D94A}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: Single;

  { methods } 

    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see langword="String" />
    ///  object representing the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure whose <see langword="Value" />
    ///  equals the <see langword="Value" />
    ///  of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. If the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure's Value is <see langword="true" />
    ///  , the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's <see langword="Value" />
    ///  will be 1. Otherwise, the <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  structure's <see langword="Value" />
    ///  will be 0.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlDouble " />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlInt16" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlDecimal" />
    ///  equal to the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  representing the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</returns>
    function ToSqlString: DNSqlString;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  instance to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DNSqlSingle): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlSingle.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns><see langword="true" />
    ///  if the object is an instance of <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  and the two are equal. Otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Gets the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if null. Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the value of this <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  structure. This property is read-only.</summary>
    ///<returns>A floating point value in the range -3.40E+38 through 3.40E+38.</returns>
    property Value: Single read get_Value;
  end;

  TDNSqlSingle = class(TDNGenericImport<DNSqlSingleClass, DNSqlSingle>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlStringClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{16539F8A-13D9-5E3B-AC40-2AC7238A19B8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  class.</summary>
    ///  <param name="lcid">Specifies the geographical locale and language for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="compareOptions">Specifies the compare options for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="data">The data array to store. </param>
    ///  <param name="index">The starting index within the array. </param>
    ///  <param name="count">The number of characters from index to copy. </param>
    ///  <param name="fUnicode"><see langword="true" />
    ///  if Unicode encoded. Otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(lcid: Int32; compareOptions: DNSqlCompareOptions; data: TArray<Byte>; index: Int32; count: Int32; fUnicode: Boolean): DNSqlString; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  class.</summary>
    ///  <param name="lcid">Specifies the geographical locale and language for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="compareOptions">Specifies the compare options for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="data">The data array to store. </param>
    ///  <param name="fUnicode"><see langword="true" />
    ///  if Unicode encoded. Otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(lcid: Int32; compareOptions: DNSqlCompareOptions; data: TArray<Byte>; fUnicode: Boolean): DNSqlString; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  class.</summary>
    ///  <param name="lcid">Specifies the geographical locale and language for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="compareOptions">Specifies the compare options for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="data">The data array to store. </param>
    ///  <param name="index">The starting index within the array. </param>
    ///  <param name="count">The number of characters from index to copy. </param>
    {class} function init(lcid: Int32; compareOptions: DNSqlCompareOptions; data: TArray<Byte>; index: Int32; count: Int32): DNSqlString; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure using the specified locale id, compare options, and data.</summary>
    ///  <param name="lcid">Specifies the geographical locale and language for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="compareOptions">Specifies the compare options for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="data">The data array to store. </param>
    {class} function init(lcid: Int32; compareOptions: DNSqlCompareOptions; data: TArray<Byte>): DNSqlString; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure using the specified string, locale id, and compare option values.</summary>
    ///  <param name="data">The string to store. </param>
    ///  <param name="lcid">Specifies the geographical locale and language for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///  <param name="compareOptions">Specifies the compare options for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    {class} function init(data: string; lcid: Int32; compareOptions: DNSqlCompareOptions): DNSqlString; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure using the specified string and locale id values.</summary>
    ///  <param name="data">The string to store. </param>
    ///  <param name="lcid">Specifies the geographical locale and language for the new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    {class} function init(data: string; lcid: Int32): DNSqlString; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure using the specified string.</summary>
    ///  <param name="data">The string to store. </param>
    {class} function init(data: string): DNSqlString; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_Null: DNSqlString;
   function __fakeFieldGet_IgnoreCase: Int32;
   function __fakeFieldGet_IgnoreWidth: Int32;
   function __fakeFieldGet_IgnoreNonSpace: Int32;
   function __fakeFieldGet_IgnoreKanaType: Int32;
   function __fakeFieldGet_BinarySort: Int32;
   function __fakeFieldGet_BinarySort2: Int32;

  { static fields } 

    ///<summary>Represents a <see cref="T:System.DBNull" />
    ///  that can be assigned to this instance of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</summary>
    {class} property Null: DNSqlString read __fakeFieldGet_Null;
    ///<summary>Specifies that <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  comparisons should ignore case.</summary>
    {class} property IgnoreCase: Int32 read __fakeFieldGet_IgnoreCase;
    ///<summary>Specifies that the string comparison must ignore the character width. </summary>
    {class} property IgnoreWidth: Int32 read __fakeFieldGet_IgnoreWidth;
    ///<summary>Specifies that the string comparison must ignore non-space combining characters, such as diacritics. </summary>
    {class} property IgnoreNonSpace: Int32 read __fakeFieldGet_IgnoreNonSpace;
    ///<summary>Specifies that the string comparison must ignore the Kana type. </summary>
    {class} property IgnoreKanaType: Int32 read __fakeFieldGet_IgnoreKanaType;
    ///<summary>Specifies that sorts should be based on a characters numeric value instead of its alphabetical value.</summary>
    {class} property BinarySort: Int32 read __fakeFieldGet_BinarySort;
    ///<summary>Specifies that sorts should be based on a character's numeric value instead of its alphabetical value.</summary>
    {class} property BinarySort2: Int32 read __fakeFieldGet_BinarySort2;

  { static methods } 

    ///<summary>Concatenates the two specified <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structures.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  that contains the newly concatenated value representing the contents of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  parameters.</returns>
    {class} function Concat(x: DNSqlString; y: DNSqlString): DNSqlString;
    ///<summary>Concatenates two specified <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  values to create a new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  that is the concatenated value of <paramref name="x" />
    ///  and <paramref name="y" />
    ///  .</returns>
    {class} function Add(x: DNSqlString; y: DNSqlString): DNSqlString;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  operands to determine whether they are equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if the two values are equal. Otherwise, <see langword="false" />
    ///  . If either instance is null, then the <see langword="SqlString" />
    ///  will be null.</returns>
    {class} function Equals(x: DNSqlString; y: DNSqlString): DNSqlBoolean; overload;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  operands to determine whether they are not equal.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the two instances are not equal or <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  if the two instances are equal. If either instance of <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function NotEquals(x: DNSqlString; y: DNSqlString): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  operands to determine whether the first is less than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThan(x: DNSqlString; y: DNSqlString): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  operands to determine whether the first is greater than the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThan(x: DNSqlString; y: DNSqlString): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  operands to determine whether the first is less than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is less than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function LessThanOrEqual(x: DNSqlString; y: DNSqlString): DNSqlBoolean;
    ///<summary>Performs a logical comparison of the two <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  operands to determine whether the first is greater than or equal to the second.</summary>
    ///  <param name="x">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///  <param name="y">A <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </param>
    ///<returns>A <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  that is <see cref="F:System.Data.SqlTypes.SqlBoolean.True" />
    ///  if the first instance is greater than or equal to the second instance. Otherwise, <see cref="F:System.Data.SqlTypes.SqlBoolean.False" />
    ///  . If either instance of <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  is null, the <see cref="P:System.Data.SqlTypes.SqlBoolean.Value" />
    ///  of the <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  will be <see cref="F:System.Data.SqlTypes.SqlBoolean.Null" />
    ///  .</returns>
    {class} function GreaterThanOrEqual(x: DNSqlString; y: DNSqlString): DNSqlBoolean;
    ///<summary>Gets the <see cref="T:System.Globalization.CompareOptions" />
    ///  enumeration equilvalent of the specified <see cref="T:System.Data.SqlTypes.SqlCompareOptions" />
    ///  value.</summary>
    ///  <param name="compareOptions">A <see cref="T:System.Data.SqlTypes.SqlCompareOptions" />
    ///  value that describes the comparison options for this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. </param>
    ///<returns>A <see langword="CompareOptions" />
    ///  value that corresponds to the <see langword="SqlCompareOptions" />
    ///  for this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</returns>
    {class} function CompareOptionsFromSqlCompareOptions(compareOptions: DNSqlCompareOptions): DDN.mscorlib.DNCompareOptions;
    ///<summary>Returns the XML Schema definition language (XSD) of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaSet">A <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>A <see langword="string" />
    ///  value that indicates the XSD of the specified <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    {class} function GetXsdType(schemaSet: DDN.System.Xml.DNXmlSchemaSet): DDN.System.Xml.DNXmlQualifiedName;

  end;

  ///<summary>Represents a variable-length stream of characters to be stored in or retrieved from the database. <see cref="T:System.Data.SqlTypes.SqlString" />
  ///  has a different underlying data structure from its corresponding .NET Framework <see cref="T:System.String" />
  ///  data type.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlString')]
  DNSqlString = interface(DDN.mscorlib.DNValueType)
  ['{304E7F9C-A851-379F-A730-C4555C05BF33}']
  { getters & setters } 

    function get_IsNull: Boolean;
    function get_Value: string;
    function get_LCID: Int32;
    function get_CultureInfo: DDN.mscorlib.DNCultureInfo;
    function get_CompareInfo: DDN.mscorlib.DNCompareInfo;
    function get_SqlCompareOptions: DNSqlCompareOptions;

  { methods } 

    ///<summary>Converts a <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  object to a <see cref="T:System.String" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  with the same value as this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</returns>
    function ToString: string;
    ///<summary>Gets an array of bytes, that contains the contents of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  in Unicode format.</summary>
    ///<returns>An byte array, that contains the contents of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  in Unicode format.</returns>
    function GetUnicodeBytes: TArray<Byte>;
    ///<summary>Gets an array of bytes, that contains the contents of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  in ANSI format.</summary>
    ///<returns>An byte array, that contains the contents of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  in ANSI format.</returns>
    function GetNonUnicodeBytes: TArray<Byte>;
    ///<summary>Creates a copy of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  object.</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  object in which all property values are the same as the original.</returns>
    function Clone: DNSqlString;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlBoolean" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="P:System.Data.SqlTypes.SqlString.Value" />
    ///  is non-zero; <see langword="false" />
    ///  if zero; otherwise Null.</returns>
    function ToSqlBoolean: DNSqlBoolean;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlByte" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlByte" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlByte.Value" />
    ///  equals the number represented by this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</returns>
    function ToSqlByte: DNSqlByte;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDateTime" />
    ///  .</summary>
    ///<returns>A new <see langword="SqlDateTime" />
    ///  structure that contains the date value represented by this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    function ToSqlDateTime: DNSqlDateTime;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDouble" />
    ///  that is equal to the numeric value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    function ToSqlDouble: DNSqlDouble;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  . </summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt16" />
    ///  that is equal to the numeric value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </returns>
    function ToSqlInt16: DNSqlInt16;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt32" />
    ///  that is equal to the numeric value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  . </returns>
    function ToSqlInt32: DNSqlInt32;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlInt64" />
    ///  that is equal to the numeric value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    function ToSqlInt64: DNSqlInt64;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlMoney" />
    ///  that is equal to the numeric value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    function ToSqlMoney: DNSqlMoney;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlDecimal" />
    ///  that contains the value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  .</returns>
    function ToSqlDecimal: DNSqlDecimal;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlSingle" />
    ///  that is equal to the numeric value of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  ..</returns>
    function ToSqlSingle: DNSqlSingle;
    ///<summary>Converts this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure to <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Data.SqlTypes.SqlGuid" />
    ///  structure whose <see cref="P:System.Data.SqlTypes.SqlGuid.Value" />
    ///  is the <see langword="Guid" />
    ///  represented by this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</returns>
    function ToSqlGuid: DNSqlGuid;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  object to the supplied <see cref="T:System.Object" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Object" />
    ///  to be compared. </param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return Value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic) </returns>
    function CompareTo(value: DDN.mscorlib.DNObject): Int32; overload;
    ///<summary>Compares this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  instance to the supplied <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  and returns an indication of their relative values.</summary>
    ///  <param name="value">The <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  to be compared.</param>
    ///<returns>A signed number that indicates the relative values of the instance and the object.Return value Condition Less than zero This instance is less than the object. Zero This instance is the same as the object. Greater than zero This instance is greater than the object -or- The object is a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </returns>
    function CompareTo(value: DNSqlString): Int32; overload;
    ///<summary>Compares the supplied object parameter to the <see cref="P:System.Data.SqlTypes.SqlString.Value" />
    ///  property of the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  object.</summary>
    ///  <param name="value">The object to be compared. </param>
    ///<returns>Equals will return <see langword="true" />
    ///  if the object is an instance of <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  and the two are equal; otherwise <see langword="false" />
    ///  .</returns>
    function Equals(value: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Gets the hash code for this instance.</summary>
    ///<returns>A 32-bit signed integer hash code.</returns>
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Indicates whether this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure is null.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="P:System.Data.SqlTypes.SqlString.Value" />
    ///  is <see cref="F:System.Data.SqlTypes.SqlString.Null" />
    ///  . Otherwise, <see langword="false" />
    ///  .</returns>
    property IsNull: Boolean read get_IsNull;
    ///<summary>Gets the string that is stored in this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure. This property is read-only.</summary>
    ///<returns>The string that is stored.</returns>
    ///<exception cref="T:System.Data.SqlTypes.SqlNullValueException">The value of the string is <see cref="F:System.Data.SqlTypes.SqlString.Null" />
    ///  . </exception>
    property Value: string read get_Value;
    ///<summary>Specifies the geographical locale and language for the <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</summary>
    ///<returns>The locale id for the string stored in the <see cref="P:System.Data.SqlTypes.SqlString.Value" />
    ///  property.</returns>
    property LCID: Int32 read get_LCID;
    ///<summary>Gets the <see cref="T:System.Globalization.CultureInfo" />
    ///  structure that represents information about the culture of this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.Globalization.CultureInfo" />
    ///  structure that describes information about the culture of this SqlString structure including the names of the culture, the writing system, and the calendar used, and also access to culture-specific objects that provide methods for common operations, such as formatting dates and sorting strings.</returns>
    property CultureInfo: DDN.mscorlib.DNCultureInfo read get_CultureInfo;
    ///<summary>Gets the <see cref="T:System.Globalization.CompareInfo" />
    ///  object that defines how string comparisons should be performed for this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</summary>
    ///<returns>A <see langword="CompareInfo" />
    ///  object that defines string comparison for this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structure.</returns>
    property CompareInfo: DDN.mscorlib.DNCompareInfo read get_CompareInfo;
    ///<summary>A combination of one or more of the <see cref="T:System.Data.SqlTypes.SqlCompareOptions" />
    ///  enumeration values that represent the way in which this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  should be compared to other <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structures.</summary>
    ///<returns>A value specifying how this <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  should be compared to other <see cref="T:System.Data.SqlTypes.SqlString" />
    ///  structures.</returns>
    property SqlCompareOptions: DNSqlCompareOptions read get_SqlCompareOptions;
  end;

  TDNSqlString = class(TDNGenericImport<DNSqlStringClass, DNSqlString>) end;

  //-------------namespace: System.Data----------------
  DNDataSetSchemaImporterExtensionClass = interface(DNObjectClass)
  ['{9B98207D-45B6-5354-A53F-3FD2DADAF8CE}']
  { constructors } 

    ///<summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    {class} function init: DNDataSetSchemaImporterExtension;

  end;

  ///<summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
  [DNTypeName('System.Data.DataSetSchemaImporterExtension')]
  DNDataSetSchemaImporterExtension = interface(DNObject)
  ['{09512958-649F-3854-81C0-DE4795F78BA5}']
  { methods } 

    ///<summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="schemaNamespace"><paramref name="schemaNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</returns>
    function ImportSchemaType(name: string; schemaNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>This member supports the .NET Framework infrastructure and is not intended to be used directly from your code.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDataSetSchemaImporterExtension = class(TDNGenericImport<DNDataSetSchemaImporterExtensionClass, DNDataSetSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNSqlTypesSchemaImporterExtensionHelperClass = interface(DNObjectClass)
  ['{772F90DC-D0E9-5CEA-8A42-CB6A96EE37D8}']
  { constructors } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name">The name as a string.</param>
    ///  <param name="targetNamespace">The target namespace.</param>
    ///  <param name="references">String array of references.</param>
    ///  <param name="namespaceImports">Array of CodeNamespaceImport objects.</param>
    ///  <param name="destinationType">The destination type as a string.</param>
    ///  <param name="direct">A Boolean for direct.</param>
    {class} function init(name: string; targetNamespace: string; references: TArray<string>; namespaceImports: TArray<DDN.System.DNCodeNamespaceImport>; destinationType: string; direct: Boolean): DNSqlTypesSchemaImporterExtensionHelper; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name">The name as a string.</param>
    ///  <param name="destinationType">The destination type as a string.</param>
    {class} function init(name: string; destinationType: string): DNSqlTypesSchemaImporterExtensionHelper; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name">The name as a string.</param>
    ///  <param name="destinationType">The destination type as a string.</param>
    ///  <param name="direct">A Boolean.</param>
    {class} function init(name: string; destinationType: string; direct: Boolean): DNSqlTypesSchemaImporterExtensionHelper; overload;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
  [DNTypeName('System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper')]
  DNSqlTypesSchemaImporterExtensionHelper = interface(DNObject)
  ['{E248171A-002A-3035-B308-FFB78E02542C}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSqlTypesSchemaImporterExtensionHelper = class(TDNGenericImport<DNSqlTypesSchemaImporterExtensionHelperClass, DNSqlTypesSchemaImporterExtensionHelper>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeBigIntSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{26BEA8BD-158C-53A9-B7EE-D060BD30C4D2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeBigIntSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeBigIntSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeBigIntSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeBigIntSchemaImporterExtension')]
  DNTypeBigIntSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{5A57403F-FBB5-345F-BF23-1C5EA5EC1213}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeBigIntSchemaImporterExtension = class(TDNGenericImport<DNTypeBigIntSchemaImporterExtensionClass, DNTypeBigIntSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeBinarySchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{FE1ED156-DC9B-52EA-B144-84DEE1AF5F7A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeBinarySchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeBinarySchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeBinarySchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeBinarySchemaImporterExtension')]
  DNTypeBinarySchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{0E34EF0C-E4B6-3941-9344-F22EDE85CB7B}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeBinarySchemaImporterExtension = class(TDNGenericImport<DNTypeBinarySchemaImporterExtensionClass, DNTypeBinarySchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeBitSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{15E6F105-2477-5349-BC3B-7BC2B0E47274}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeBitSchemaImporterExtension" />
    ///  class. </summary>
    {class} function init: DNTypeBitSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeBitSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeBitSchemaImporterExtension')]
  DNTypeBitSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{18E6AD5E-3E67-3FD2-99F7-EAD80E856B11}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeBitSchemaImporterExtension = class(TDNGenericImport<DNTypeBitSchemaImporterExtensionClass, DNTypeBitSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeCharSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{BE943EA8-D0E6-5EC8-B5AC-D97E3C20B633}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeCharSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeCharSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeCharSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeCharSchemaImporterExtension')]
  DNTypeCharSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{41798B65-28F3-3CB2-A8DF-36503C29D85F}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeCharSchemaImporterExtension = class(TDNGenericImport<DNTypeCharSchemaImporterExtensionClass, DNTypeCharSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeDateTimeSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{81236AE8-49B5-5B32-A1C0-133BA0BCD8E9}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeDateTimeSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeDateTimeSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeDateTimeSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeDateTimeSchemaImporterExtension')]
  DNTypeDateTimeSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{23535402-D07C-3B55-83EB-779096C82858}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeDateTimeSchemaImporterExtension = class(TDNGenericImport<DNTypeDateTimeSchemaImporterExtensionClass, DNTypeDateTimeSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeDecimalSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{5E4AA0CC-0783-5264-9BA3-8D71E3A45B13}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeDecimalSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeDecimalSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeDecimalSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeDecimalSchemaImporterExtension')]
  DNTypeDecimalSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{BE5D3EA5-6DE2-3CCD-8116-23D29C5386FA}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeDecimalSchemaImporterExtension = class(TDNGenericImport<DNTypeDecimalSchemaImporterExtensionClass, DNTypeDecimalSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeFloatSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{D5151541-292C-5FD9-804F-583363C9B0AD}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeFloatSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeFloatSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeFloatSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeFloatSchemaImporterExtension')]
  DNTypeFloatSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{C4D7C601-D1C2-3DC6-AE2C-29E4C782AE8D}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeFloatSchemaImporterExtension = class(TDNGenericImport<DNTypeFloatSchemaImporterExtensionClass, DNTypeFloatSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeIntSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{84287612-FDBC-561F-8281-AD8B4B81BE9E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeIntSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeIntSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeIntSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeIntSchemaImporterExtension')]
  DNTypeIntSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{95B2DA6A-6F7B-348D-8101-C3FDFB1BD15D}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeIntSchemaImporterExtension = class(TDNGenericImport<DNTypeIntSchemaImporterExtensionClass, DNTypeIntSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeMoneySchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{2A5F94A5-928C-55C9-9683-481828356671}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeMoneySchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeMoneySchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeMoneySchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
  [DNTypeName('System.Data.SqlTypes.TypeMoneySchemaImporterExtension')]
  DNTypeMoneySchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{F7AA49CD-DEC5-37B9-B1C9-0EB7CE366204}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeMoneySchemaImporterExtension = class(TDNGenericImport<DNTypeMoneySchemaImporterExtensionClass, DNTypeMoneySchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeNCharSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{C9A5B743-CF6D-5B32-86D7-AA88B7BE7282}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeNCharSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeNCharSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeNCharSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeNCharSchemaImporterExtension')]
  DNTypeNCharSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{F6134327-DE16-3E69-B9A3-891E39F7CA67}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeNCharSchemaImporterExtension = class(TDNGenericImport<DNTypeNCharSchemaImporterExtensionClass, DNTypeNCharSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeNTextSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{EB6B57AD-74AE-57CC-BFE3-6883AE29082E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeNTextSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeNTextSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeNTextSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeNTextSchemaImporterExtension')]
  DNTypeNTextSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{49F51A5F-F01A-3684-A8C9-1658E36F97A2}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeNTextSchemaImporterExtension = class(TDNGenericImport<DNTypeNTextSchemaImporterExtensionClass, DNTypeNTextSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeNumericSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{F7EB5407-6309-58EE-9705-D12DFC656577}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeNumericSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeNumericSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeNumericSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeNumericSchemaImporterExtension')]
  DNTypeNumericSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{31E614F6-BFA5-3265-A868-BBFC1105D235}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeNumericSchemaImporterExtension = class(TDNGenericImport<DNTypeNumericSchemaImporterExtensionClass, DNTypeNumericSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeNVarCharSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{FC1192F0-2512-5427-AC65-E3C0B2399207}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeNVarCharSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeNVarCharSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeNVarCharSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeNVarCharSchemaImporterExtension')]
  DNTypeNVarCharSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{0910F4A0-B56F-3570-98FA-14450A435273}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeNVarCharSchemaImporterExtension = class(TDNGenericImport<DNTypeNVarCharSchemaImporterExtensionClass, DNTypeNVarCharSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeRealSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{D573A8CF-3BDA-5E04-97CE-9C038240AB59}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeRealSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeRealSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeRealSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeRealSchemaImporterExtension')]
  DNTypeRealSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{9F3DECBE-49D6-3F91-BE6F-AA123454C482}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeRealSchemaImporterExtension = class(TDNGenericImport<DNTypeRealSchemaImporterExtensionClass, DNTypeRealSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeSmallDateTimeSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{7B3CA223-7412-54C1-8717-4E653716A485}']
  { constructors } 

    ///<summary>Initializes a new instance of the TypeSmallDateTimeSchemaImporterExtension class.</summary>
    {class} function init: DNTypeSmallDateTimeSchemaImporterExtension;

  end;

  ///<summary>The TypeSmallDateTimeSchemaImporterExtension class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeSmallDateTimeSchemaImporterExtension')]
  DNTypeSmallDateTimeSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{A004AEFC-5A6F-3B84-BC99-80DD80AC76D1}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeSmallDateTimeSchemaImporterExtension = class(TDNGenericImport<DNTypeSmallDateTimeSchemaImporterExtensionClass, DNTypeSmallDateTimeSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeSmallIntSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{708DDCC5-2477-5548-9E5B-7EBCF44F51D4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeSmallIntSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeSmallIntSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeSmallIntSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeSmallIntSchemaImporterExtension')]
  DNTypeSmallIntSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{7252A0B8-4B5E-3DA0-B7F2-A58347820406}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeSmallIntSchemaImporterExtension = class(TDNGenericImport<DNTypeSmallIntSchemaImporterExtensionClass, DNTypeSmallIntSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeSmallMoneySchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{915E709E-8CAF-5D5C-AA44-A1927030A130}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeSmallMoneySchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeSmallMoneySchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeSmallMoneySchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeSmallMoneySchemaImporterExtension')]
  DNTypeSmallMoneySchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{F1BBE8BB-B092-31A4-A430-7AAB3A5F2216}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeSmallMoneySchemaImporterExtension = class(TDNGenericImport<DNTypeSmallMoneySchemaImporterExtensionClass, DNTypeSmallMoneySchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeTextSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{06ABEA7C-275F-5351-9D48-165FFCC7AD07}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeTextSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeTextSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeTextSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeTextSchemaImporterExtension')]
  DNTypeTextSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{D54564DE-2B62-3498-A0AB-92261965FC56}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeTextSchemaImporterExtension = class(TDNGenericImport<DNTypeTextSchemaImporterExtensionClass, DNTypeTextSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeTinyIntSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{5CDC7732-C71F-5AC4-8AF9-7FDF5DFCA47A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeTinyIntSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeTinyIntSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeTinyIntSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeTinyIntSchemaImporterExtension')]
  DNTypeTinyIntSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{1AB7C3CF-702F-319A-8FE6-52AFD18E2D82}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeTinyIntSchemaImporterExtension = class(TDNGenericImport<DNTypeTinyIntSchemaImporterExtensionClass, DNTypeTinyIntSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeUniqueIdentifierSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{D0B2E25E-2F1D-55A8-A017-D220C48800CA}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeUniqueIdentifierSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeUniqueIdentifierSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeUniqueIdentifierSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeUniqueIdentifierSchemaImporterExtension')]
  DNTypeUniqueIdentifierSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{7B665635-1499-355C-88CD-F15BCADA9B05}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeUniqueIdentifierSchemaImporterExtension = class(TDNGenericImport<DNTypeUniqueIdentifierSchemaImporterExtensionClass, DNTypeUniqueIdentifierSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeVarBinarySchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{78787E14-D5C9-517C-AA73-C1CEE1F6003D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeVarBinarySchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeVarBinarySchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeVarBinarySchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeVarBinarySchemaImporterExtension')]
  DNTypeVarBinarySchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{273D2569-6B44-3406-A108-6B549002E767}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeVarBinarySchemaImporterExtension = class(TDNGenericImport<DNTypeVarBinarySchemaImporterExtensionClass, DNTypeVarBinarySchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeVarCharSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{F259F2D7-EB66-53CE-B122-5ED21BD0380F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeVarCharSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeVarCharSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeVarCharSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeVarCharSchemaImporterExtension')]
  DNTypeVarCharSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{A58311F8-456D-3371-BDA7-8DAE7C278BF7}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeVarCharSchemaImporterExtension = class(TDNGenericImport<DNTypeVarCharSchemaImporterExtensionClass, DNTypeVarCharSchemaImporterExtension>) end;

  //-------------namespace: System.Data.SqlTypes----------------
  DNTypeVarImageSchemaImporterExtensionClass = interface(DNSqlTypesSchemaImporterExtensionHelperClass)
  ['{AAC1F414-2EAE-5F05-B0AC-4902363C375E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Data.SqlTypes.TypeVarImageSchemaImporterExtension" />
    ///  class.</summary>
    {class} function init: DNTypeVarImageSchemaImporterExtension;

  end;

  ///<summary>The <see cref="T:System.Data.SqlTypes.TypeVarImageSchemaImporterExtension" />
  ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality. </summary>
  [DNTypeName('System.Data.SqlTypes.TypeVarImageSchemaImporterExtension')]
  DNTypeVarImageSchemaImporterExtension = interface(DNSqlTypesSchemaImporterExtensionHelper)
  ['{E9BBF708-3896-3482-9184-04DDCC7F6550}']
  { methods } 

    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="name"><paramref name="name" />
    ///</param>
    ///  <param name="xmlNamespace"><paramref name="xmlNamespace" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(name: string; xmlNamespace: string; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</summary>
    ///  <param name="type"><paramref name="type" />
    ///</param>
    ///  <param name="context"><paramref name="context" />
    ///</param>
    ///  <param name="schemas"><paramref name="schemas" />
    ///</param>
    ///  <param name="importer"><paramref name="importer" />
    ///</param>
    ///  <param name="compileUnit"><paramref name="compileUnit" />
    ///</param>
    ///  <param name="mainNamespace"><paramref name="mainNamespace" />
    ///</param>
    ///  <param name="options"><paramref name="options" />
    ///</param>
    ///  <param name="codeProvider"><paramref name="codeProvider" />
    ///</param>
    ///<returns>The <see cref="T:System.Data.SqlTypes.SqlTypesSchemaImporterExtensionHelper" />
    ///  class is not intended for use as a stand-alone component, but as a class from which other classes derive standard functionality.</returns>
    function ImportSchemaType(&type: DDN.System.Xml.DNXmlSchemaType; context: DDN.System.Xml.DNXmlSchemaObject; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    function ImportAnyElement(any: DDN.System.Xml.DNXmlSchemaAny; mixed: Boolean; schemas: DDN.System.Xml.DNXmlSchemas; importer: DDN.System.Xml.DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DDN.System.Xml.DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTypeVarImageSchemaImporterExtension = class(TDNGenericImport<DNTypeVarImageSchemaImporterExtensionClass, DNTypeVarImageSchemaImporterExtension>) end;

  //-------------namespace: System.Xml----------------
  DNXmlDataDocumentClass = interface(DNObjectClass)
  ['{F2F4E07B-104C-5753-BAC3-7255B3949AAC}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DDN.System.Xml.DNXmlResolver);
    procedure set_InnerText(value: string);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlDataDocument" />
    ///  class.</summary>
    {class} function init: DNXmlDataDocument; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlDataDocument" />
    ///  class with the specified <see cref="T:System.Data.DataSet" />
    ///  .</summary>
    ///  <param name="dataset">The <see langword="DataSet" />
    ///  to load into <see langword="XmlDataDocument" />
    ///  . </param>
    {class} function init(dataset: DNDataSet): DNXmlDataDocument; overload;

  { static propertys } 

    {class} property XmlResolver: DDN.System.Xml.DNXmlResolver write set_XmlResolver;
    {class} property InnerText: string write set_InnerText;
  end;

  ///<summary>Allows structured data to be stored, retrieved, and manipulated through a relational <see cref="T:System.Data.DataSet" />
  ///  . </summary>
  [DNTypeName('System.Xml.XmlDataDocument')]
  DNXmlDataDocument = interface(DNObject)
  ['{03C271EC-6EF3-3EB2-8C52-28C9AF77C24B}']
  { getters & setters } 

    function get_DataSet: DNDataSet;
    function get_NodeType: DDN.System.Xml.DNXmlNodeType;
    function get_ParentNode: DDN.System.Xml.DNXmlNode;
    function get_DocumentType: DDN.System.Xml.DNXmlDocumentType;
    function get_Implementation: DDN.System.Xml.DNXmlImplementation;
    function get_Name: string;
    function get_LocalName: string;
    function get_DocumentElement: DDN.System.Xml.DNXmlElement;
    function get_OwnerDocument: DDN.System.Xml.DNXmlDocument;
    function get_Schemas: DDN.System.Xml.DNXmlSchemaSet;
    procedure set_Schemas(value: DDN.System.Xml.DNXmlSchemaSet);
    procedure set_XmlResolver(value: DDN.System.Xml.DNXmlResolver);
    function get_NameTable: DDN.System.Xml.DNXmlNameTable;
    function get_PreserveWhitespace: Boolean;
    procedure set_PreserveWhitespace(value: Boolean);
    function get_IsReadOnly: Boolean;
    procedure set_InnerText(value: string);
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DDN.System.Xml.DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ChildNodes: DDN.System.Xml.DNXmlNodeList;
    function get_PreviousSibling: DDN.System.Xml.DNXmlNode;
    function get_NextSibling: DDN.System.Xml.DNXmlNode;
    function get_Attributes: DDN.System.Xml.DNXmlAttributeCollection;
    function get_FirstChild: DDN.System.Xml.DNXmlNode;
    function get_LastChild: DDN.System.Xml.DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_OuterXml: string;
    function get_Item(name: string): DDN.System.Xml.DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DDN.System.Xml.DNXmlElement; overload;
    function get_PreviousText: DDN.System.Xml.DNXmlNode;

  { events } 

    procedure add_NodeInserting(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure remove_NodeInserting(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure add_NodeInserted(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure remove_NodeInserted(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure add_NodeRemoving(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure remove_NodeRemoving(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure add_NodeRemoved(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure remove_NodeRemoved(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure add_NodeChanging(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure remove_NodeChanging(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure add_NodeChanged(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);
    procedure remove_NodeChanged(value: DDN.System.Xml.DNXmlNodeChangedEventHandler);

  { methods } 

    ///<summary>Creates an element with the specified <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  , <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  , and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="prefix">The prefix of the new element. If String.Empty or <see langword="null" />
    ///  , there is no prefix. </param>
    ///  <param name="localName">The local name of the new element. </param>
    ///  <param name="namespaceURI">The namespace Uniform Resource Identifier (URI) of the new element. If String.Empty or <see langword="null" />
    ///  , there is no namespaceURI. </param>
    ///<returns>A new <see cref="T:System.Xml.XmlElement" />
    ///  .</returns>
    function CreateElement(prefix: string; localName: string; namespaceURI: string): DDN.System.Xml.DNXmlElement; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlEntityReference" />
    ///  with the specified name.</summary>
    ///  <param name="name">The name of the entity reference.</param>
    ///<returns>An <see cref="T:System.Xml.XmlEntityReference" />
    ///  with the specified name.</returns>
    ///<exception cref="T:System.NotSupportedException">Calling this method.</exception>
    function CreateEntityReference(name: string): DDN.System.Xml.DNXmlEntityReference;
    ///<summary>Retrieves the <see cref="T:System.Data.DataRow" />
    ///  associated with the specified <see cref="T:System.Xml.XmlElement" />
    ///  .</summary>
    ///  <param name="e">The <see langword="XmlElement" />
    ///  whose associated <see langword="DataRow" />
    ///  you want to retrieve. </param>
    ///<returns>The <see langword="DataRow" />
    ///  containing a representation of the <see langword="XmlElement" />
    ///  ; <see langword="null" />
    ///  if there is no <see langword="DataRow" />
    ///  associated with the <see langword="XmlElement" />
    ///  .</returns>
    function GetRowFromElement(e: DDN.System.Xml.DNXmlElement): DNDataRow;
    ///<summary>Retrieves the <see cref="T:System.Xml.XmlElement" />
    ///  associated with the specified <see cref="T:System.Data.DataRow" />
    ///  .</summary>
    ///  <param name="r">The <see langword="DataRow" />
    ///  whose associated <see langword="XmlElement" />
    ///  you want to retrieve. </param>
    ///<returns>The <see langword="XmlElement" />
    ///  containing a representation of the specified <see langword="DataRow" />
    ///  .</returns>
    function GetElementFromRow(r: DNDataRow): DDN.System.Xml.DNXmlElement;
    ///<summary>Creates a duplicate of the current node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DDN.System.Xml.DNXmlNode;
    ///<summary>Loads the <see langword="XmlDataDocument" />
    ///  using the specified URL.</summary>
    ///  <param name="filename">The URL of the file containing the XML document to load. </param>
    procedure Load(filename: string); overload;
    ///<summary>Loads the <see langword="XmlDataDocument" />
    ///  from the specified stream.</summary>
    ///  <param name="inStream">The stream containing the XML document to load. </param>
    procedure Load(inStream: DDN.mscorlib.DNStream); overload;
    ///<summary>Loads the <see langword="XmlDataDocument" />
    ///  from the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="txtReader">The <see langword="TextReader" />
    ///  used to feed the XML data into the document. </param>
    procedure Load(txtReader: DDN.mscorlib.DNTextReader); overload;
    ///<summary>Loads the <see langword="XmlDataDocument" />
    ///  from the specified <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  containing the XML document to load.</param>
    ///<exception cref="T:System.NotSupportedException">The XML being loaded contains entity references, and the reader cannot resolve entities. </exception>
    procedure Load(reader: DDN.System.Xml.DNXmlReader); overload;
    ///<summary>Gets the <see cref="T:System.Xml.XmlElement" />
    ///  with the specified ID. This method is not supported by the <see cref="T:System.Xml.XmlDataDocument" />
    ///  class. Calling this method throws an exception.</summary>
    ///  <param name="elemId">The attribute ID to match.</param>
    ///<returns>An <see cref="T:System.Xml.XmlElement" />
    ///  with the specified ID.</returns>
    ///<exception cref="T:System.NotSupportedException">Calling this method.</exception>
    function GetElementById(elemId: string): DDN.System.Xml.DNXmlElement;
    ///<summary>Returns an <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all descendant elements that match the specified <see cref="P:System.Xml.XmlDocument.Name" />
    ///  .</summary>
    ///  <param name="name">The qualified name to match. It is matched against the <see cref="P:System.Xml.XmlDocument.Name" />
    ///  property of the matching node. The special value "*" matches all tags.</param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all matching nodes.</returns>
    function GetElementsByTagName(name: string): DDN.System.Xml.DNXmlNodeList; overload;
    function CreateAttribute(name: string): DDN.System.Xml.DNXmlAttribute; overload;
    function CreateCDataSection(data: string): DDN.System.Xml.DNXmlCDataSection;
    function CreateComment(data: string): DDN.System.Xml.DNXmlComment;
    function CreateDocumentType(name: string; publicId: string; systemId: string; internalSubset: string): DDN.System.Xml.DNXmlDocumentType;
    function CreateDocumentFragment: DDN.System.Xml.DNXmlDocumentFragment;
    function CreateElement(name: string): DDN.System.Xml.DNXmlElement; overload;
    function CreateProcessingInstruction(target: string; data: string): DDN.System.Xml.DNXmlProcessingInstruction;
    function CreateXmlDeclaration(version: string; encoding: string; standalone: string): DDN.System.Xml.DNXmlDeclaration;
    function CreateTextNode(text: string): DDN.System.Xml.DNXmlText;
    function CreateSignificantWhitespace(text: string): DDN.System.Xml.DNXmlSignificantWhitespace;
    function CreateNavigator: DDN.System.Xml.DNXPathNavigator;
    function CreateWhitespace(text: string): DDN.System.Xml.DNXmlWhitespace;
    function CreateAttribute(qualifiedName: string; namespaceURI: string): DDN.System.Xml.DNXmlAttribute; overload;
    function CreateElement(qualifiedName: string; namespaceURI: string): DDN.System.Xml.DNXmlElement; overload;
    function GetElementsByTagName(localName: string; namespaceURI: string): DDN.System.Xml.DNXmlNodeList; overload;
    function ImportNode(node: DDN.System.Xml.DNXmlNode; deep: Boolean): DDN.System.Xml.DNXmlNode;
    function CreateAttribute(prefix: string; localName: string; namespaceURI: string): DDN.System.Xml.DNXmlAttribute; overload;
    function CreateNode(nodeTypeString: string; name: string; namespaceURI: string): DDN.System.Xml.DNXmlNode; overload;
    function CreateNode(&type: DDN.System.Xml.DNXmlNodeType; name: string; namespaceURI: string): DDN.System.Xml.DNXmlNode; overload;
    function ReadNode(reader: DDN.System.Xml.DNXmlReader): DDN.System.Xml.DNXmlNode;
    procedure LoadXml(xml: string);
    procedure Save(filename: string); overload;
    procedure Save(outStream: DDN.mscorlib.DNStream); overload;
    procedure Save(writer: DDN.mscorlib.DNTextWriter); overload;
    procedure WriteTo(w: DDN.System.Xml.DNXmlWriter);
    procedure WriteContentTo(xw: DDN.System.Xml.DNXmlWriter);
    procedure Validate(validationEventHandler: DDN.System.Xml.DNValidationEventHandler); overload;
    function CreateNode(&type: DDN.System.Xml.DNXmlNodeType; prefix: string; name: string; namespaceURI: string): DDN.System.Xml.DNXmlNode; overload;
    procedure Save(w: DDN.System.Xml.DNXmlWriter); overload;
    procedure Validate(validationEventHandler: DDN.System.Xml.DNValidationEventHandler; nodeToValidate: DDN.System.Xml.DNXmlNode); overload;
    function SelectSingleNode(xpath: string): DDN.System.Xml.DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DDN.System.Xml.DNXmlNamespaceManager): DDN.System.Xml.DNXmlNode; overload;
    function SelectNodes(xpath: string): DDN.System.Xml.DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DDN.System.Xml.DNXmlNamespaceManager): DDN.System.Xml.DNXmlNodeList; overload;
    function InsertBefore(newChild: DDN.System.Xml.DNXmlNode; refChild: DDN.System.Xml.DNXmlNode): DDN.System.Xml.DNXmlNode;
    function InsertAfter(newChild: DDN.System.Xml.DNXmlNode; refChild: DDN.System.Xml.DNXmlNode): DDN.System.Xml.DNXmlNode;
    function ReplaceChild(newChild: DDN.System.Xml.DNXmlNode; oldChild: DDN.System.Xml.DNXmlNode): DDN.System.Xml.DNXmlNode;
    function RemoveChild(oldChild: DDN.System.Xml.DNXmlNode): DDN.System.Xml.DNXmlNode;
    function PrependChild(newChild: DDN.System.Xml.DNXmlNode): DDN.System.Xml.DNXmlNode;
    function AppendChild(newChild: DDN.System.Xml.DNXmlNode): DDN.System.Xml.DNXmlNode;
    procedure Normalize;
    function Clone: DDN.System.Xml.DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a <see cref="T:System.Data.DataSet" />
    ///  that provides a relational representation of the data in the <see langword="XmlDataDocument" />
    ///  .</summary>
    ///<returns>A <see langword="DataSet" />
    ///  that can be used to access the data in the <see langword="XmlDataDocument" />
    ///  using a relational model.</returns>
    property DataSet: DNDataSet read get_DataSet;
    property NodeType: DDN.System.Xml.DNXmlNodeType read get_NodeType;
    property ParentNode: DDN.System.Xml.DNXmlNode read get_ParentNode;
    property DocumentType: DDN.System.Xml.DNXmlDocumentType read get_DocumentType;
    property &Implementation: DDN.System.Xml.DNXmlImplementation read get_Implementation;
    property Name: string read get_Name;
    property LocalName: string read get_LocalName;
    property DocumentElement: DDN.System.Xml.DNXmlElement read get_DocumentElement;
    property OwnerDocument: DDN.System.Xml.DNXmlDocument read get_OwnerDocument;
    property Schemas: DDN.System.Xml.DNXmlSchemaSet read get_Schemas write set_Schemas;
    property XmlResolver: DDN.System.Xml.DNXmlResolver write set_XmlResolver;
    property NameTable: DDN.System.Xml.DNXmlNameTable read get_NameTable;
    property PreserveWhitespace: Boolean read get_PreserveWhitespace write set_PreserveWhitespace;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property InnerText: string write set_InnerText;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DDN.System.Xml.DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Value: string read get_Value write set_Value;
    property ChildNodes: DDN.System.Xml.DNXmlNodeList read get_ChildNodes;
    property PreviousSibling: DDN.System.Xml.DNXmlNode read get_PreviousSibling;
    property NextSibling: DDN.System.Xml.DNXmlNode read get_NextSibling;
    property Attributes: DDN.System.Xml.DNXmlAttributeCollection read get_Attributes;
    property FirstChild: DDN.System.Xml.DNXmlNode read get_FirstChild;
    property LastChild: DDN.System.Xml.DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property OuterXml: string read get_OuterXml;
    property Item[name: string]: DDN.System.Xml.DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DDN.System.Xml.DNXmlElement read get_Item; default;
    property PreviousText: DDN.System.Xml.DNXmlNode read get_PreviousText;
  end;

  TDNXmlDataDocument = class(TDNGenericImport<DNXmlDataDocumentClass, DNXmlDataDocument>) end;


implementation


initialization
  LoadAssemblyModule('System.Data.dll', True);

finalization

end.
