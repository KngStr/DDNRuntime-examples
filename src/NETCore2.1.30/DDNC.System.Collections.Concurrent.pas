//----------------------------------------------------------------------------
//  System.Collections.Concurrent.dll: System.Collections.Concurrent, Version=4.0.14.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
//----------------------------------------------------------------------------
//  The code is automatically generated by the GenCodeNET tool.
//----------------------------------------------------------------------------
//  .NET Core 2.1.30
//----------------------------------------------------------------------------
//  UnitName: DDNC.System.Collections.Concurrent
//  Author: ying32
//----------------------------------------------------------------------------

unit DDNC.System.Collections.Concurrent;

{$IFDEF FPC}
  {$mode delphi}//{$H+}
  {$modeswitch advancedrecords}
  {$modeswitch prefixedattributes} // Custom attributes featureï¼Œfpc3.2.2+
{$ENDIF}

interface

uses
  DDN.Runtime,
  DDNC.System.Private.CoreLib;

type

{ enums }

  //-------------namespace: System.Collections.Concurrent----------------
  [DNTypeName('System.Collections.Concurrent.EnumerablePartitionerOptions')]
  DNEnumerablePartitionerOptions = type Integer;
  DNEnumerablePartitionerOptionsHelper = record helper for DNEnumerablePartitionerOptions
  public const
    None = 0;
    NoBuffering = 1;
  end;




type


{ declares }

  DNIProducerConsumerCollection<T> = interface; // type: System.Collections.Concurrent.IProducerConsumerCollection`1, namespace: System.Collections.Concurrent
  DNBlockingCollection<T> = interface; // type: System.Collections.Concurrent.BlockingCollection`1, namespace: System.Collections.Concurrent
  DNConcurrentBag<T> = interface; // type: System.Collections.Concurrent.ConcurrentBag`1, namespace: System.Collections.Concurrent
  DNConcurrentDictionary<TKey, TValue> = interface; // type: System.Collections.Concurrent.ConcurrentDictionary`2, namespace: System.Collections.Concurrent
  DNConcurrentQueue<T> = interface; // type: System.Collections.Concurrent.ConcurrentQueue`1, namespace: System.Collections.Concurrent
  DNConcurrentStack<T> = interface; // type: System.Collections.Concurrent.ConcurrentStack`1, namespace: System.Collections.Concurrent
  DNPartitioner<TSource> = interface; // type: System.Collections.Concurrent.Partitioner`1, namespace: System.Collections.Concurrent
  DNOrderablePartitioner<TSource> = interface; // type: System.Collections.Concurrent.OrderablePartitioner`1, namespace: System.Collections.Concurrent
  DNPartitioner = interface; // type: System.Collections.Concurrent.Partitioner, namespace: System.Collections.Concurrent


{ objects }

  //-------------namespace: System.Collections.Concurrent----------------
  [DNTypeName('System.Collections.Concurrent.IProducerConsumerCollection`1')]
  DNIProducerConsumerCollection<T> = interface(DDNC.System.Private.CoreLib.DNIEnumerable<T>)
  ['{2B733F8C-2E75-3440-851D-877C316DA9EF}']
  { methods } 

    procedure CopyTo(&array: TArray<T>; index: Int32);
    function TryAdd(item: T): Boolean;
    function TryTake(out item: T): Boolean;
    function ToArray: TArray<T>;

  end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNBlockingCollectionClass<T> = interface(DNObjectClass)
  ['{7F074C9F-4B38-5DFD-AAE6-6B86FE736AF6}']
  { constructors } 

    {class} function init: DNBlockingCollection<T>; overload;
    {class} function init(boundedCapacity: Int32): DNBlockingCollection<T>; overload;
    {class} function init(collection: DNIProducerConsumerCollection<T>; boundedCapacity: Int32): DNBlockingCollection<T>; overload;
    {class} function init(collection: DNIProducerConsumerCollection<T>): DNBlockingCollection<T>; overload;

  { static methods } 

    {class} function AddToAny(collections: TArray<DNBlockingCollection<T>>; item: T): Int32; overload;
    {class} function AddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; millisecondsTimeout: Int32): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;
    {class} function TakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T): Int32; overload;
    {class} function TakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; millisecondsTimeout: Int32): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.BlockingCollection`1')]
  DNBlockingCollection<T> = interface(DDNC.System.Private.CoreLib.DNIEnumerable<T>)
  ['{1F68A8DF-3D6B-36C3-83AC-835F432C174A}']
  { getters & setters } 

    function get_BoundedCapacity: Int32;
    function get_IsAddingCompleted: Boolean;
    function get_IsCompleted: Boolean;
    function get_Count: Int32;

  { methods } 

    procedure Add(item: T); overload;
    procedure Add(item: T; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken); overload;
    function TryAdd(item: T): Boolean; overload;
    function TryAdd(item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Boolean; overload;
    function TryAdd(item: T; millisecondsTimeout: Int32): Boolean; overload;
    function TryAdd(item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Boolean; overload;
    function Take: T; overload;
    function Take(cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): T; overload;
    function TryTake(out item: T): Boolean; overload;
    function TryTake(out item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Boolean; overload;
    function TryTake(out item: T; millisecondsTimeout: Int32): Boolean; overload;
    function TryTake(out item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Boolean; overload;
    procedure CompleteAdding;
    procedure Dispose;
    function ToArray: TArray<T>;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    function GetConsumingEnumerable: DDNC.System.Private.CoreLib.DNIEnumerable<T>; overload;
    function GetConsumingEnumerable(cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): DDNC.System.Private.CoreLib.DNIEnumerable<T>; overload;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property BoundedCapacity: Int32 read get_BoundedCapacity;
    property IsAddingCompleted: Boolean read get_IsAddingCompleted;
    property IsCompleted: Boolean read get_IsCompleted;
    property Count: Int32 read get_Count;
  end;

  TDNBlockingCollection<T> = class(TDNGenericImport<DNBlockingCollectionClass<T>, DNBlockingCollection<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentBagClass<T> = interface(DNObjectClass)
  ['{61AC7559-5A44-5D38-8BBA-4C30EF0EE3FF}']
  { constructors } 

    {class} function init: DNConcurrentBag<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<T>): DNConcurrentBag<T>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentBag`1')]
  DNConcurrentBag<T> = interface(DNIProducerConsumerCollection<T>)
  ['{B58C6783-E9E4-38B6-9119-EF2BFC86E94C}']
  { getters & setters } 

    function get_Count: Int32;
    function get_IsEmpty: Boolean;

  { methods } 

    procedure Add(item: T);
    function TryTake(out result: T): Boolean;
    function TryPeek(out result: T): Boolean;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    function ToArray: TArray<T>;
    procedure Clear;
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<T>;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property Count: Int32 read get_Count;
    property IsEmpty: Boolean read get_IsEmpty;
  end;

  TDNConcurrentBag<T> = class(TDNGenericImport<DNConcurrentBagClass<T>, DNConcurrentBag<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentDictionaryClass<TKey, TValue> = interface(DNObjectClass)
  ['{0E5B9F4F-B0FC-5780-B420-DAA7DAAF4E71}']
  { constructors } 

    {class} function init: DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(concurrencyLevel: Int32; capacity: Int32): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>; comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(concurrencyLevel: Int32; collection: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>; comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(concurrencyLevel: Int32; capacity: Int32; comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentDictionary`2')]
  DNConcurrentDictionary<TKey, TValue> = interface(DDNC.System.Private.CoreLib.DNIDictionary<TKey, TValue>)
  ['{FC8D47BD-FF8E-38FD-8379-1BB6A3ED66CB}']
  { getters & setters } 

    function get_Count: Int32;
    function get_IsEmpty: Boolean;
    function get_Keys: DDNC.System.Private.CoreLib.DNICollection<TKey>;
    function get_Values: DDNC.System.Private.CoreLib.DNICollection<TValue>;

  { methods } 

    function TryAdd(key: TKey; value: TValue): Boolean;
    function ContainsKey(key: TKey): Boolean;
    function TryRemove(key: TKey; out value: TValue): Boolean;
    function TryGetValue(key: TKey; out value: TValue): Boolean;
    function TryUpdate(key: TKey; newValue: TValue; comparisonValue: TValue): Boolean;
    function ToArray: TArray<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>;
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>;
    function GetOrAdd(key: TKey; valueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue>): TValue; overload;
    function GetOrAdd(key: TKey; value: TValue): TValue; overload;
    function AddOrUpdate(key: TKey; addValueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue>; updateValueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue, TValue>): TValue; overload;
    function AddOrUpdate(key: TKey; addValue: TValue; updateValueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue, TValue>): TValue; overload;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property Count: Int32 read get_Count;
    property IsEmpty: Boolean read get_IsEmpty;
    property Keys: DDNC.System.Private.CoreLib.DNICollection<TKey> read get_Keys;
    property Values: DDNC.System.Private.CoreLib.DNICollection<TValue> read get_Values;
  end;

  TDNConcurrentDictionary<TKey, TValue> = class(TDNGenericImport<DNConcurrentDictionaryClass<TKey, TValue>, DNConcurrentDictionary<TKey, TValue>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentQueueClass<T> = interface(DNObjectClass)
  ['{AC0F0706-B857-526D-A764-2C90EC6C7CC2}']
  { constructors } 

    {class} function init: DNConcurrentQueue<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<T>): DNConcurrentQueue<T>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentQueue`1')]
  DNConcurrentQueue<T> = interface(DNIProducerConsumerCollection<T>)
  ['{4AF820D6-3004-3790-8C11-F9C6FC48A663}']
  { getters & setters } 

    function get_IsEmpty: Boolean;
    function get_Count: Int32;

  { methods } 

    function ToArray: TArray<T>;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<T>;
    procedure Enqueue(item: T);
    function TryDequeue(out result: T): Boolean;
    function TryPeek(out result: T): Boolean;
    procedure Clear;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property IsEmpty: Boolean read get_IsEmpty;
    property Count: Int32 read get_Count;
  end;

  TDNConcurrentQueue<T> = class(TDNGenericImport<DNConcurrentQueueClass<T>, DNConcurrentQueue<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentStackClass<T> = interface(DNObjectClass)
  ['{53D851E4-E630-5DEB-B024-6F0CA11BB478}']
  { constructors } 

    {class} function init: DNConcurrentStack<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<T>): DNConcurrentStack<T>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentStack`1')]
  DNConcurrentStack<T> = interface(DNIProducerConsumerCollection<T>)
  ['{9D73CCE7-DED8-3329-8D0B-54271E2BF5C8}']
  { getters & setters } 

    function get_IsEmpty: Boolean;
    function get_Count: Int32;

  { methods } 

    procedure Clear;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    procedure Push(item: T);
    procedure PushRange(items: TArray<T>); overload;
    procedure PushRange(items: TArray<T>; startIndex: Int32; count: Int32); overload;
    function TryPeek(out result: T): Boolean;
    function TryPop(out result: T): Boolean;
    function TryPopRange(items: TArray<T>): Int32; overload;
    function TryPopRange(items: TArray<T>; startIndex: Int32; count: Int32): Int32; overload;
    function ToArray: TArray<T>;
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<T>;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property IsEmpty: Boolean read get_IsEmpty;
    property Count: Int32 read get_Count;
  end;

  TDNConcurrentStack<T> = class(TDNGenericImport<DNConcurrentStackClass<T>, DNConcurrentStack<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNPartitionerClass<TSource> = interface(DDNC.System.Private.CoreLib.DNObjectClass)
  ['{69101805-020F-5C72-909B-6F464F20B30A}']
  end;

  [DNTypeName('System.Collections.Concurrent.Partitioner`1')]
  DNPartitioner<TSource> = interface(DDNC.System.Private.CoreLib.DNObject)
  ['{75959333-6738-3ECB-BCEB-5A7CF9B494B1}']
  { getters & setters } 

    function get_SupportsDynamicPartitions: Boolean;

  { methods } 

    function GetPartitions(partitionCount: Int32): DDNC.System.Private.CoreLib.DNIList<DDNC.System.Private.CoreLib.DNIEnumerator<TSource>>;
    function GetDynamicPartitions: DDNC.System.Private.CoreLib.DNIEnumerable<TSource>;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property SupportsDynamicPartitions: Boolean read get_SupportsDynamicPartitions;
  end;

  TDNPartitioner<TSource> = class(TDNGenericImport<DNPartitionerClass<TSource>, DNPartitioner<TSource>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNOrderablePartitionerClass<TSource> = interface(DNPartitionerClass<TSource>)
  ['{B0B57285-7CF2-5740-B063-C22B83AA26CF}']
  end;

  [DNTypeName('System.Collections.Concurrent.OrderablePartitioner`1')]
  DNOrderablePartitioner<TSource> = interface(DNPartitioner<TSource>)
  ['{18EA9EFB-D982-354F-AFB8-C9334559D826}']
  { getters & setters } 

    function get_KeysOrderedInEachPartition: Boolean;
    function get_KeysOrderedAcrossPartitions: Boolean;
    function get_KeysNormalized: Boolean;
    function get_SupportsDynamicPartitions: Boolean;

  { methods } 

    function GetOrderablePartitions(partitionCount: Int32): DDNC.System.Private.CoreLib.DNIList<DDNC.System.Private.CoreLib.DNIEnumerator<DDNC.System.Private.CoreLib.DNKeyValuePair<Int64, TSource>>>;
    function GetOrderableDynamicPartitions: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<Int64, TSource>>;
    function GetPartitions(partitionCount: Int32): DDNC.System.Private.CoreLib.DNIList<DDNC.System.Private.CoreLib.DNIEnumerator<TSource>>;
    function GetDynamicPartitions: DDNC.System.Private.CoreLib.DNIEnumerable<TSource>;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  { propertys } 

    property KeysOrderedInEachPartition: Boolean read get_KeysOrderedInEachPartition;
    property KeysOrderedAcrossPartitions: Boolean read get_KeysOrderedAcrossPartitions;
    property KeysNormalized: Boolean read get_KeysNormalized;
    property SupportsDynamicPartitions: Boolean read get_SupportsDynamicPartitions;
  end;

  TDNOrderablePartitioner<TSource> = class(TDNGenericImport<DNOrderablePartitionerClass<TSource>, DNOrderablePartitioner<TSource>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNPartitionerClass = interface(DDNC.System.Private.CoreLib.DNObjectClass)
  ['{F9951377-FD14-5BCA-8AE1-9D1505888867}']
  { static methods } 

    {class} function Create(fromInclusive: Int64; toExclusive: Int64): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int64, Int64>>; overload;
    {class} function Create(fromInclusive: Int64; toExclusive: Int64; rangeSize: Int64): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int64, Int64>>; overload;
    {class} function Create(fromInclusive: Int32; toExclusive: Int32): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int32, Int32>>; overload;
    {class} function Create(fromInclusive: Int32; toExclusive: Int32; rangeSize: Int32): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int32, Int32>>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.Partitioner')]
  DNPartitioner = interface(DDNC.System.Private.CoreLib.DNObject)
  ['{CFE6C1B1-E2CA-3451-B275-A3336262A702}']
  { methods } 

    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDNC.System.Private.CoreLib.DNType;

  end;

  TDNPartitioner = class(TDNGenericImport<DNPartitionerClass, DNPartitioner>) end;


implementation


initialization
  InternalTryLoadAssemblyModule('System.Collections.Concurrent, Version=4.0.14.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a');

finalization

end.
