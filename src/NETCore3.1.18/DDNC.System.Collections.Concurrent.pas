//----------------------------------------------------------------------------
//  System.Collections.Concurrent.dll: System.Collections.Concurrent, Version=4.0.15.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
//----------------------------------------------------------------------------
//  The code is automatically generated by the GenCodeNET tool.
//----------------------------------------------------------------------------
//  .NET Core 3.1.18
//----------------------------------------------------------------------------
//  UnitName: DDNC.System.Collections.Concurrent
//  Author: ying32
//----------------------------------------------------------------------------

unit DDNC.System.Collections.Concurrent;

{$IFDEF FPC}
  {$mode delphi}//{$H+}
  {$modeswitch advancedrecords}
  {$modeswitch prefixedattributes} // Custom attributes featureï¼Œfpc3.2.2+
{$ENDIF}

interface

uses
  DDN.Runtime,
  DDNC.System.Private.CoreLib;

type

{ enums }

  //-------------namespace: System.Collections.Concurrent----------------
  [DNTypeName('System.Collections.Concurrent.EnumerablePartitionerOptions')]
  DNEnumerablePartitionerOptions = type Integer;
  DNEnumerablePartitionerOptionsHelper = record helper for DNEnumerablePartitionerOptions
  public const
    None = 0;
    NoBuffering = 1;
  end;




type


{ declares }

  DNBlockingCollection<T> = interface; // type: System.Collections.Concurrent.BlockingCollection`1, namespace: System.Collections.Concurrent
  DNConcurrentBag<T> = interface; // type: System.Collections.Concurrent.ConcurrentBag`1, namespace: System.Collections.Concurrent
  DNConcurrentDictionary<TKey, TValue> = interface; // type: System.Collections.Concurrent.ConcurrentDictionary`2, namespace: System.Collections.Concurrent
  DNConcurrentStack<T> = interface; // type: System.Collections.Concurrent.ConcurrentStack`1, namespace: System.Collections.Concurrent
  DNPartitioner<TSource> = interface; // type: System.Collections.Concurrent.Partitioner`1, namespace: System.Collections.Concurrent
  DNOrderablePartitioner<TSource> = interface; // type: System.Collections.Concurrent.OrderablePartitioner`1, namespace: System.Collections.Concurrent
  DNPartitioner = interface; // type: System.Collections.Concurrent.Partitioner, namespace: System.Collections.Concurrent


{ objects }

  //-------------namespace: System.Collections.Concurrent----------------
  DNBlockingCollectionClass<T> = interface(DNObjectClass)
  ['{6DCCA7E3-4606-5754-8620-07A32DAB4C2F}']
  { constructors } 

    {class} function init: DNBlockingCollection<T>; overload;
    {class} function init(boundedCapacity: Int32): DNBlockingCollection<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIProducerConsumerCollection<T>; boundedCapacity: Int32): DNBlockingCollection<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIProducerConsumerCollection<T>): DNBlockingCollection<T>; overload;

  { static methods } 

    {class} function AddToAny(collections: TArray<DNBlockingCollection<T>>; item: T): Int32; overload;
    {class} function AddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; millisecondsTimeout: Int32): Int32; overload;
    {class} function TryAddToAny(collections: TArray<DNBlockingCollection<T>>; item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;
    {class} function TakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T): Int32; overload;
    {class} function TakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; millisecondsTimeout: Int32): Int32; overload;
    {class} function TryTakeFromAny(collections: TArray<DNBlockingCollection<T>>; out item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Int32; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.BlockingCollection`1')]
  DNBlockingCollection<T> = interface(DDNC.System.Private.CoreLib.DNIEnumerable<T>)
  ['{F148BF23-CF7B-3605-ADF8-901CF7C52F3E}']
  { getters & setters } 

    function get_BoundedCapacity: Int32;
    function get_IsAddingCompleted: Boolean;
    function get_IsCompleted: Boolean;
    function get_Count: Int32;

  { methods } 

    procedure Add(item: T); overload;
    procedure Add(item: T; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken); overload;
    function TryAdd(item: T): Boolean; overload;
    function TryAdd(item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Boolean; overload;
    function TryAdd(item: T; millisecondsTimeout: Int32): Boolean; overload;
    function TryAdd(item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Boolean; overload;
    function Take: T; overload;
    function Take(cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): T; overload;
    function TryTake(out item: T): Boolean; overload;
    function TryTake(out item: T; timeout: DDNC.System.Private.CoreLib.DNTimeSpan): Boolean; overload;
    function TryTake(out item: T; millisecondsTimeout: Int32): Boolean; overload;
    function TryTake(out item: T; millisecondsTimeout: Int32; cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): Boolean; overload;
    procedure CompleteAdding;
    procedure Dispose;
    function ToArray: TArray<T>;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    function GetConsumingEnumerable: DDNC.System.Private.CoreLib.DNIEnumerable<T>; overload;
    function GetConsumingEnumerable(cancellationToken: DDNC.System.Private.CoreLib.DNCancellationToken): DDNC.System.Private.CoreLib.DNIEnumerable<T>; overload;
    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  { propertys } 

    property BoundedCapacity: Int32 read get_BoundedCapacity;
    property IsAddingCompleted: Boolean read get_IsAddingCompleted;
    property IsCompleted: Boolean read get_IsCompleted;
    property Count: Int32 read get_Count;
  end;

  TDNBlockingCollection<T> = class(TDNGenericImport<DNBlockingCollectionClass<T>, DNBlockingCollection<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentBagClass<T> = interface(DNObjectClass)
  ['{80E8D278-9498-58C1-A07D-D383FED93862}']
  { constructors } 

    {class} function init: DNConcurrentBag<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<T>): DNConcurrentBag<T>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentBag`1')]
  DNConcurrentBag<T> = interface(DDNC.System.Private.CoreLib.DNIProducerConsumerCollection<T>)
  ['{CF3300E1-84B2-3EFF-B960-C0E6BD38457D}']
  { getters & setters } 

    function get_Count: Int32;
    function get_IsEmpty: Boolean;

  { methods } 

    procedure Add(item: T);
    function TryTake(out result: T): Boolean;
    function TryPeek(out result: T): Boolean;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    function ToArray: TArray<T>;
    procedure Clear;
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<T>;
    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  { propertys } 

    property Count: Int32 read get_Count;
    property IsEmpty: Boolean read get_IsEmpty;
  end;

  TDNConcurrentBag<T> = class(TDNGenericImport<DNConcurrentBagClass<T>, DNConcurrentBag<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentDictionaryClass<TKey, TValue> = interface(DNObjectClass)
  ['{E7783BA6-8CE6-5BFC-A9A3-5B23A9323E69}']
  { constructors } 

    {class} function init: DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(concurrencyLevel: Int32; capacity: Int32): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>; comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(concurrencyLevel: Int32; collection: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>; comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;
    {class} function init(concurrencyLevel: Int32; capacity: Int32; comparer: DDNC.System.Private.CoreLib.DNIEqualityComparer<TKey>): DNConcurrentDictionary<TKey, TValue>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentDictionary`2')]
  DNConcurrentDictionary<TKey, TValue> = interface(DDNC.System.Private.CoreLib.DNIDictionary<TKey, TValue>)
  ['{56315850-D213-30AF-B00E-E9076E76BCDD}']
  { getters & setters } 

    function get_Count: Int32;
    function get_IsEmpty: Boolean;
    function get_Keys: DDNC.System.Private.CoreLib.DNICollection<TKey>;
    function get_Values: DDNC.System.Private.CoreLib.DNICollection<TValue>;

  { methods } 

    function TryAdd(key: TKey; value: TValue): Boolean;
    function ContainsKey(key: TKey): Boolean;
    function TryRemove(key: TKey; out value: TValue): Boolean;
    function TryGetValue(key: TKey; out value: TValue): Boolean;
    function TryUpdate(key: TKey; newValue: TValue; comparisonValue: TValue): Boolean;
    function ToArray: TArray<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>;
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<DDNC.System.Private.CoreLib.DNKeyValuePair<TKey, TValue>>;
    function GetOrAdd(key: TKey; valueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue>): TValue; overload;
    function GetOrAdd(key: TKey; value: TValue): TValue; overload;
    function AddOrUpdate(key: TKey; addValueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue>; updateValueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue, TValue>): TValue; overload;
    function AddOrUpdate(key: TKey; addValue: TValue; updateValueFactory: DDNC.System.Private.CoreLib.DNFunc<TKey, TValue, TValue>): TValue; overload;
    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  { propertys } 

    property Count: Int32 read get_Count;
    property IsEmpty: Boolean read get_IsEmpty;
    property Keys: DDNC.System.Private.CoreLib.DNICollection<TKey> read get_Keys;
    property Values: DDNC.System.Private.CoreLib.DNICollection<TValue> read get_Values;
  end;

  TDNConcurrentDictionary<TKey, TValue> = class(TDNGenericImport<DNConcurrentDictionaryClass<TKey, TValue>, DNConcurrentDictionary<TKey, TValue>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNConcurrentStackClass<T> = interface(DNObjectClass)
  ['{31BB314C-495D-5BEF-BE60-BCBCAF845134}']
  { constructors } 

    {class} function init: DNConcurrentStack<T>; overload;
    {class} function init(collection: DDNC.System.Private.CoreLib.DNIEnumerable<T>): DNConcurrentStack<T>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.ConcurrentStack`1')]
  DNConcurrentStack<T> = interface(DDNC.System.Private.CoreLib.DNIProducerConsumerCollection<T>)
  ['{3EA3F359-DB3B-37E7-9AA3-D6F9FD147068}']
  { getters & setters } 

    function get_IsEmpty: Boolean;
    function get_Count: Int32;

  { methods } 

    procedure Clear;
    procedure CopyTo(&array: TArray<T>; index: Int32);
    procedure Push(item: T);
    procedure PushRange(items: TArray<T>); overload;
    procedure PushRange(items: TArray<T>; startIndex: Int32; count: Int32); overload;
    function TryPeek(out result: T): Boolean;
    function TryPop(out result: T): Boolean;
    function TryPopRange(items: TArray<T>): Int32; overload;
    function TryPopRange(items: TArray<T>; startIndex: Int32; count: Int32): Int32; overload;
    function ToArray: TArray<T>;
    function GetEnumerator: DDNC.System.Private.CoreLib.DNIEnumerator<T>;
    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  { propertys } 

    property IsEmpty: Boolean read get_IsEmpty;
    property Count: Int32 read get_Count;
  end;

  TDNConcurrentStack<T> = class(TDNGenericImport<DNConcurrentStackClass<T>, DNConcurrentStack<T>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNPartitionerClass<TSource> = interface(DDNC.System.Private.CoreLib.DNObjectClass)
  ['{48FE8078-5225-592A-A7D8-77B625783F54}']
  end;

  [DNTypeName('System.Collections.Concurrent.Partitioner`1')]
  DNPartitioner<TSource> = interface(DDNC.System.Private.CoreLib.DNObject)
  ['{2E7CFDB6-DD29-396C-B764-CB2719163576}']
  { getters & setters } 

    function get_SupportsDynamicPartitions: Boolean;

  { methods } 

    function GetPartitions(partitionCount: Int32): DDNC.System.Private.CoreLib.DNIList<DDNC.System.Private.CoreLib.DNIEnumerator<TSource>>;
    function GetDynamicPartitions: DDNC.System.Private.CoreLib.DNIEnumerable<TSource>;
    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  { propertys } 

    property SupportsDynamicPartitions: Boolean read get_SupportsDynamicPartitions;
  end;

  TDNPartitioner<TSource> = class(TDNGenericImport<DNPartitionerClass<TSource>, DNPartitioner<TSource>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNOrderablePartitionerClass<TSource> = interface(DNPartitionerClass<TSource>)
  ['{3EA47718-395D-56F0-AD09-8E8F29DC8DFE}']
  end;

  [DNTypeName('System.Collections.Concurrent.OrderablePartitioner`1')]
  DNOrderablePartitioner<TSource> = interface(DNPartitioner<TSource>)
  ['{B6B16009-61C1-312D-B6DD-AC690ACCEF86}']
  { getters & setters } 

    function get_KeysOrderedInEachPartition: Boolean;
    function get_KeysOrderedAcrossPartitions: Boolean;
    function get_KeysNormalized: Boolean;
    function get_SupportsDynamicPartitions: Boolean;

  { methods } 

    function GetOrderablePartitions(partitionCount: Int32): DDNC.System.Private.CoreLib.DNIList<DDNC.System.Private.CoreLib.DNIEnumerator<DDNC.System.Private.CoreLib.DNKeyValuePair<Int64, TSource>>>;
    function GetOrderableDynamicPartitions: DDNC.System.Private.CoreLib.DNIEnumerable<DDNC.System.Private.CoreLib.DNKeyValuePair<Int64, TSource>>;
    function GetPartitions(partitionCount: Int32): DDNC.System.Private.CoreLib.DNIList<DDNC.System.Private.CoreLib.DNIEnumerator<TSource>>;
    function GetDynamicPartitions: DDNC.System.Private.CoreLib.DNIEnumerable<TSource>;
    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  { propertys } 

    property KeysOrderedInEachPartition: Boolean read get_KeysOrderedInEachPartition;
    property KeysOrderedAcrossPartitions: Boolean read get_KeysOrderedAcrossPartitions;
    property KeysNormalized: Boolean read get_KeysNormalized;
    property SupportsDynamicPartitions: Boolean read get_SupportsDynamicPartitions;
  end;

  TDNOrderablePartitioner<TSource> = class(TDNGenericImport<DNOrderablePartitionerClass<TSource>, DNOrderablePartitioner<TSource>>) end;

  //-------------namespace: System.Collections.Concurrent----------------
  DNPartitionerClass = interface(DDNC.System.Private.CoreLib.DNObjectClass)
  ['{6DE46029-2ED4-55F3-A238-4E0B09817A29}']
  { static methods } 

    {class} function Create(fromInclusive: Int64; toExclusive: Int64): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int64, Int64>>; overload;
    {class} function Create(fromInclusive: Int64; toExclusive: Int64; rangeSize: Int64): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int64, Int64>>; overload;
    {class} function Create(fromInclusive: Int32; toExclusive: Int32): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int32, Int32>>; overload;
    {class} function Create(fromInclusive: Int32; toExclusive: Int32; rangeSize: Int32): DNOrderablePartitioner<DDNC.System.Private.CoreLib.DNTuple<Int32, Int32>>; overload;

  end;

  [DNTypeName('System.Collections.Concurrent.Partitioner')]
  DNPartitioner = interface(DDNC.System.Private.CoreLib.DNObject)
  ['{B94AD99E-C9BC-3187-9AB0-6235AC508104}']
  { methods } 

    function GetType: DDNC.System.Private.CoreLib.DNType;
    function ToString: string;
    function Equals(obj: DDNC.System.Private.CoreLib.DNObject): Boolean;
    function GetHashCode: Int32;

  end;

  TDNPartitioner = class(TDNGenericImport<DNPartitionerClass, DNPartitioner>) end;


implementation


initialization
  LoadAssemblyModule('System.Collections.Concurrent, Version=4.0.15.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a');

finalization

end.
