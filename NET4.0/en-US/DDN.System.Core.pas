//----------------------------------------------------------------------------
//  System.Core.dll: System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
//----------------------------------------------------------------------------
//  The code is automatically generated by the GenCodeNET tool.
//----------------------------------------------------------------------------
//  .NET Framework: 4.0
//----------------------------------------------------------------------------
//  UnitName: DDN.System.Core
//  Author: ying32
//----------------------------------------------------------------------------

unit DDN.System.Core;

{$IFDEF FPC}
  {$mode delphi}//{$H+}
  {$modeswitch advancedrecords}
  {$modeswitch prefixedattributes} // Custom attributes featureï¼Œfpc3.2.2+
{$ENDIF}

interface

uses
  DDN.Runtime,
  DDN.mscorlib,
  DDN.System;

type

{ enums }

  //-------------namespace: System.Diagnostics.Eventing----------------
  ///<summary>Defines the possible states of the last write operation.</summary>
  [DNTypeName('System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode')]
  DNEventProvider_WriteEventErrorCode = type Integer;
  DNEventProvider_WriteEventErrorCodeHelper = record helper for DNEventProvider_WriteEventErrorCode
  public const
    ///<summary>The write was successful.</summary>
    NoError = 0;
    ///<summary>The session ran out of free buffers to write to. This can occur during high event rates because the disk subsystem is overloaded or the number of buffers is too small. Rather than blocking until more buffers become available, the event is dropped. Consider increasing the number and size of the buffers for the session, or reducing the number of events written or the size of the events.</summary>
    NoFreeBuffers = 1;
    ///<summary>The event is larger than the session buffer size; events cannot span buffers.</summary>
    EventTooBig = 2;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines the default access permissions for the event log. The Application and System values indicate that the log shares the access control list (ACL) with the appropriate Windows log (the Application or System event logs) and share the Event Tracing for Windows (ETW) session with other logs of the same isolation. All channels with Custom isolation use a private ETW session.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogIsolation')]
  DNEventLogIsolation = type Integer;
  DNEventLogIsolationHelper = record helper for DNEventLogIsolation
  public const
    ///<summary>The log shares the access control list with the Application event log and shares the ETW session with other logs that have Application isolation.</summary>
    Application = 0;
    ///<summary>The log shares the access control list with the System event log and shares the ETW session with other logs that have System isolation.</summary>
    System = 1;
    ///<summary>The event log is a custom event log that uses its own private ETW session.</summary>
    Custom = 2;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Determines the behavior for the event log service handles an event log when the log reaches its maximum allowed size (when the event log is full).</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogMode')]
  DNEventLogMode = type Integer;
  DNEventLogModeHelper = record helper for DNEventLogMode
  public const
    ///<summary>New events continue to be stored when the log file is full. Each new incoming event replaces the oldest event in the log.</summary>
    Circular = 0;
    ///<summary>Archive the log when full, do not overwrite events. The log is automatically archived when necessary. No events are overwritten. </summary>
    AutoBackup = 1;
    ///<summary>Do not overwrite events. Clear the log manually rather than automatically.</summary>
    Retain = 2;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines the type of events that are logged in an event log. Each log can only contain one type of event.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogType')]
  DNEventLogType = type Integer;
  DNEventLogTypeHelper = record helper for DNEventLogType
  public const
    ///<summary>These events are primarily for end users, administrators, and support. The events that are found in the Administrative type logs indicate a problem and a well-defined solution that an administrator can act on. An example of an administrative event is an event that occurs when an application fails to connect to a printer. </summary>
    Administrative = 0;
    ///<summary>Events in an operational type event log are used for analyzing and diagnosing a problem or occurrence. They can be used to trigger tools or tasks based on the problem or occurrence. An example of an operational event is an event that occurs when a printer is added or removed from a system.</summary>
    Operational = 1;
    ///<summary>Events in an analytic event log are published in high volume. They describe program operation and indicate problems that cannot be handled by user intervention.</summary>
    Analytical = 2;
    ///<summary>Events in a debug type event log are used solely by developers to diagnose a problem for debugging.</summary>
    Debug = 3;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Specifies that a string contains a name of an event log or the file system path to an event log file.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.PathType')]
  DNPathType = type Integer;
  DNPathTypeHelper = record helper for DNPathType
  public const
    ///<summary>A path parameter contains the name of the event log.</summary>
    LogName = 1;
    ///<summary>A path parameter contains the file system path to an event log file.</summary>
    FilePath = 2;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines values for the type of authentication used during a Remote Procedure Call (RPC) login to a server. This login occurs when you create a <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
  ///  object that specifies a connection to a remote computer.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.SessionAuthentication')]
  DNSessionAuthentication = type Integer;
  DNSessionAuthenticationHelper = record helper for DNSessionAuthentication
  public const
    ///<summary>Use the default authentication method during RPC login. The default authentication is equivalent to Negotiate.</summary>
    Default_ = 0;
    ///<summary>Use the Negotiate authentication method during RPC login. This allows the client application to select the most appropriate authentication method (NTLM or Kerberos) for the situation. </summary>
    Negotiate = 1;
    ///<summary>Use Kerberos authentication during RPC login. </summary>
    Kerberos = 2;
    ///<summary>Use Windows NT LAN Manager (NTLM) authentication during RPC login.</summary>
    Ntlm = 3;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines the standard keywords that are attached to events by the event provider. For more information about keywords, see <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" />
  ///  .</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.StandardEventKeywords')]
  DNStandardEventKeywords = type Integer;
  DNStandardEventKeywordsHelper = record helper for DNStandardEventKeywords
  public const
    ///<summary>This value indicates that no filtering on keyword is performed when the event is published.</summary>
    None = 0;
    ///<summary>Attached to all response time events. </summary>
    ResponseTime = 281474976710656;
    ///<summary>Attached to all Windows Diagnostic Infrastructure (WDI) context events.</summary>
    WdiContext = 562949953421312;
    ///<summary>Attached to all Windows Diagnostic Infrastructure (WDI) diagnostic events.</summary>
    WdiDiagnostic = 1125899906842624;
    ///<summary>Attached to all Service Quality Mechanism (SQM) events.</summary>
    Sqm = 2251799813685248;
    ///<summary>Attached to transfer events where the related Activity ID (Correlation ID) is a computed value and is not guaranteed to be unique (not a real GUID).</summary>
    CorrelationHint = 4503599627370496;
    ///<summary>Attached to all failed security audit events. This keyword should only be used for events in the Security log.</summary>
    AuditFailure = 4503599627370496;
    ///<summary>Attached to all successful security audit events. This keyword should only be used for events in the Security log.</summary>
    AuditSuccess = 9007199254740992;
    ///<summary>Attached to transfer events where the related Activity ID (Correlation ID) is a computed value and is not guaranteed to be unique (not a real GUID).</summary>
    CorrelationHint2 = 18014398509481984;
    ///<summary>Attached to events which are raised using the RaiseEvent function.</summary>
    EventLogClassic = 36028797018963968;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines the standard event levels that are used in the Event Log service. The level defines the severity of the event. Custom event levels can be defined beyond these standard levels. For more information about levels, see <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" />
  ///  .</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.StandardEventLevel')]
  DNStandardEventLevel = type Integer;
  DNStandardEventLevelHelper = record helper for DNStandardEventLevel
  public const
    ///<summary>This value indicates that not filtering on the level is done during the event publishing.</summary>
    LogAlways = 0;
    ///<summary>This level corresponds to critical errors, which is a serious error that has caused a major failure. </summary>
    Critical = 1;
    ///<summary>This level corresponds to normal errors that signify a problem. </summary>
    Error = 2;
    ///<summary>This level corresponds to warning events. For example, an event that gets published because a disk is nearing full capacity is a warning event.</summary>
    Warning = 3;
    ///<summary>This level corresponds to informational events or messages that are not errors. These events can help trace the progress or state of an application.</summary>
    Informational = 4;
    ///<summary>This level corresponds to lengthy events or messages. </summary>
    Verbose = 5;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines the standard opcodes that are attached to events by the event provider. For more information about opcodes, see <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" />
  ///  .</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.StandardEventOpcode')]
  DNStandardEventOpcode = type Integer;
  DNStandardEventOpcodeHelper = record helper for DNStandardEventOpcode
  public const
    ///<summary>An event with this opcode is an informational event.</summary>
    Info = 0;
    ///<summary>An event with this opcode is published when an application starts a new transaction or activity. This can be embedded into another transaction or activity when multiple events with the Start opcode follow each other without an event with a Stop opcode.</summary>
    Start = 1;
    ///<summary>An event with this opcode is published when an activity or a transaction in an application ends. The event corresponds to the last unpaired event with a Start opcode.</summary>
    Stop = 2;
    ///<summary>An event with this opcode is a trace collection start event.</summary>
    DataCollectionStart = 3;
    ///<summary>An event with this opcode is a trace collection stop event.</summary>
    DataCollectionStop = 4;
    ///<summary>An event with this opcode is an extension event.</summary>
    Extension = 5;
    ///<summary>An event with this opcode is published after an activity in an application replies to an event.</summary>
    Reply = 6;
    ///<summary>An event with this opcode is published after an activity in an application resumes from a suspended state. The event should follow an event with the Suspend opcode.</summary>
    Resume = 7;
    ///<summary>An event with this opcode is published when an activity in an application is suspended. </summary>
    Suspend = 8;
    ///<summary>An event with this opcode is published when one activity in an application transfers data or system resources to another activity. </summary>
    Send = 9;
    ///<summary>An event with this opcode is published when one activity in an application receives data.</summary>
    Receive = 240;
  end;


  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  ///<summary>Defines the standard tasks that are attached to events by the event provider. For more information about tasks, see <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" />
  ///  .</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.StandardEventTask')]
  DNStandardEventTask = type Integer;
  DNStandardEventTaskHelper = record helper for DNStandardEventTask
  public const
    ///<summary>No task is used to identify a portion of an application that publishes an event.</summary>
    None = 0;
  end;


  //-------------namespace: System.Diagnostics.PerformanceData----------------
  ///<summary>Specifies whether the counter set allows multiple instances such as processes and physical disks, or a single instance such as memory.</summary>
  [DNTypeName('System.Diagnostics.PerformanceData.CounterSetInstanceType')]
  DNCounterSetInstanceType = type Integer;
  DNCounterSetInstanceTypeHelper = record helper for DNCounterSetInstanceType
  public const
    ///<summary>The counter set contains single instance counters, for example, a counter that measures physical memory.</summary>
    Single = 0;
    ///<summary>The counter set contains multiple instance counters, for example, a counter that measures the average disk I/O for a process.</summary>
    Multiple = 2;
    ///<summary>The counter set contains single instance counters whose aggregate value is obtained from one or more sources. For example, a counter in this type of counter set might obtain the number of reads from each of the three hard disks on the computer and sum their values.</summary>
    GlobalAggregate = 4;
    ///<summary>The counter set contains multiple instance counters whose aggregate value is obtained from all instances of the counter. For example, a counter in this type of counter set might obtain the total thread execution time for all threads in a multithreaded application and sum their values.</summary>
    MultipleAggregate = 6;
    ///<summary>This type is similar to <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.GlobalAggregate" />
    ///  except that this counter set type stores all counter values for the lifetime of the consumer application (the counter value is cached beyond the lifetime of the counter). For example, if one of the hard disks in the global aggregate example were to become unavailable, the total bytes read by that disk would still be available and used to calculate the aggregate value.</summary>
    GlobalAggregateWithHistory = 11;
    ///<summary>This type is similar to <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.MultipleAggregate" />
    ///  , except that instead of aggregating all instance data to one aggregated (_Total) instance, it will aggregate counter data from instances of the same name. For example, if multiple provider processes contained instances named IExplore, <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.Multiple" />
    ///  and <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.MultipleAggregate" />
    ///  CounterSet will show multiple IExplore instances (IExplore, IExplore#1, IExplore#2, and so on); however, a <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.InstanceAggregate" />
    ///  instance type will publish only one IExplore instance with aggregated counter data from all instances named IExplore.</summary>
    InstanceAggregate = 22;
  end;


  //-------------namespace: System.Diagnostics.PerformanceData----------------
  ///<summary>Defines the possible types of counters. Each counter is assigned a counter type. The counter type determines how the counter data is calculated, averaged, and displayed.</summary>
  [DNTypeName('System.Diagnostics.PerformanceData.CounterType')]
  DNCounterType = type Integer;
  DNCounterTypeHelper = record helper for DNCounterType
  public const
    ///<summary>This counter type shows the most recently observed value, in hexadecimal format. It does not display an average. (See the PERF_COUNTER_RAWCOUNT_HEX counter type in the deployment kit.)</summary>
    RawDataHex32 = 0;
    ///<summary>This counter type shows the last observed value, in hexadecimal format. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawDataHex32" />
    ///  counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_RAWCOUNT_HEX counter type in the deployment kit.)</summary>
    RawDataHex64 = 256;
    ///<summary>This counter type shows the last observed value only. It does not display an average. (See the PERF_COUNTER_RAWCOUNT counter type in the deployment kit.)</summary>
    RawData32 = 65536;
    ///<summary>This counter type shows the last observed value only, not an average. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawData32" />
    ///  counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_RAWCOUNT counter type in the deployment kit.)</summary>
    RawData64 = 65792;
    ///<summary>This counter type shows the change in the measured attribute between the two most recent sample intervals. (See the PERF_COUNTER_DELTA counter type in the deployment kit.)</summary>
    Delta32 = 4195328;
    ///<summary>This counter type shows the change in the measured attribute between the two most recent sample intervals. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.Delta32" />
    ///  counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_DELTA counter type in the deployment kit.)</summary>
    Delta64 = 4195584;
    ///<summary>This counter type shows the average number of operations completed in one second. It measures time in units of ticks of the system performance timer. The variable F represents the number of ticks that occur in one second. The value of F is factored into the equation so that the result is displayed in seconds. (See the PERF_SAMPLE_COUNTER counter type in the deployment kit.)</summary>
    SampleCounter = 4260864;
    ///<summary>This counter type is designed to monitor the average length of a queue to a resource over time. It shows the difference between the queue lengths observed during the last two sample intervals divided by the duration of the interval. (See the PERF_COUNTER_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
    QueueLength = 4523008;
    ///<summary>This counter type monitors the average length of a queue to a resource over time. Counters of this type display the difference between the queue lengths observed during the last two sample intervals, divided by the duration of the interval. This counter type is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.QueueLength" />
    ///  counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
    LargeQueueLength = 4523264;
    ///<summary>This counter type measures the queue-length space-time product using a 100-nanosecond time base. (See the PERF_COUNTER_100NS_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
    QueueLength100Ns = 5571840;
    ///<summary>This counter type measures the queue-length space-time product using an object-specific time base. (See the PERF_COUNTER_OBJ_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
    QueueLengthObjectTime = 6620416;
    ///<summary>This counter type shows the average number of operations completed during each second of the sample interval. Counters of this type measure time in ticks of the system clock. (See the PERF_COUNTER_COUNTER counter type in the deployment kit.)</summary>
    RateOfCountPerSecond32 = 272696320;
    ///<summary>This counter type shows the average number of operations completed during each second of the sample interval. Counters of this type measure time in ticks of the system clock. This counter type is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RateOfCountPerSecond32" />
    ///  type, but it uses larger fields to accommodate larger values. (See the PERF_COUNTER_BULK_COUNT counter type in the deployment kit.)</summary>
    RateOfCountPerSecond64 = 272696576;
    ///<summary>This counter type shows the ratio of a subset to its set as a percentage. For example, it compares the number of bytes in use on a disk to the total number of bytes on the disk. Counters of this type display the current percentage only, not an average over time. (See the PERF_RAW_FRACTION counter type in the deployment kit.)</summary>
    RawFraction32 = 537003008;
    ///<summary>This counter type shows the ratio of a subset to its set as a percentage. For example, it compares the number of bytes in use on a disk to the total number of bytes on the disk. Counters of this type display the current percentage only, not an average over time. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawFraction32" />
    ///  counter type, except that it uses larger fields to accommodate larger values.</summary>
    RawFraction64 = 537003264;
    ///<summary>This counter type shows the average time that a component was active as a percentage of the total sample time. (See the PERF_COUNTER_TIMER counter type in the deployment kit.)</summary>
    PercentageActive = 541132032;
    ///<summary>This counter type shows a value that consists of two counter values: the count of the elapsed time of the event being monitored, and the frequency from the system performance timer. This counter type differs from other counter timers in that the clock tick value accompanies the counter value, eliminating any possible difference due to latency from the function call. Precision counter types are used when standard system timers are not precise enough for accurate readings. (See the PERF_PRECISION_TIMER counter type in the deployment kit.)</summary>
    PrecisionSystemTimer = 541525248;
    ///<summary>This counter type shows the active time of a component as a percentage of the total elapsed time of the sample interval. It measures time in units of 100 nanoseconds. Counters of this type are designed to measure the activity of one component at a time. (See the PERF_100NSEC_TIMER counter type in the deployment kit.)</summary>
    PercentageActive100Ns = 542180608;
    ///<summary>This counter type shows a value that consists of two counter values: the count of the elapsed time of the event being monitored, and the "clock" time from a private timer in the same units. It measures time in 100Â nanosecond units. This counter type differs from other counter timers in that the clock tick value accompanies the counter value eliminating any possible difference due to latency from the function call. Precision counter types are used when standard system timers are not precise enough for accurate readings. (See the PERF_PRECISION_100NS_TIMER counter type in the deployment kit.)</summary>
    PrecisionTimer100Ns = 542573824;
    ///<summary>This 64-bit counter type is a timer that displays in object-specific units. (See the PERF_OBJ_TIME_TIMER counter type in the deployment kit.)</summary>
    ObjectSpecificTimer = 543229184;
    ///<summary>This counter type shows a value that consists of two counter values: the count of the elapsed time of the event being monitored, and the frequency specified in the PerfFreq field of the object header. This counter type differs from other counter timers in that the clock tick value accompanies the counter value so as to eliminate any possible difference due to latency from the function call. Precision counter types are used when standard system timers are not precise enough for accurate readings. (See the PERF_PRECISION_OBJECT_TIMER counter type in the deployment kit.)</summary>
    PrecisionObjectSpecificTimer = 543622400;
    ///<summary>This counter type shows the average ratio of hits to all operations during the last two sample intervals. (See the PERF_SAMPLE_FRACTION counter type in the deployment kit.)</summary>
    SampleFraction = 549585920;
    ///<summary>This is an inverse counter type. Inverse counters measure the time that a component is not active and derive the active time from that measurement. Counters of this type display the average percentage of active time observed during sample interval. The value of these counters is calculated by monitoring the percentage of time that the service was inactive and then subtracting that value from 100 percent. This counter type is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.PercentageNotActive100Ns" />
    ///  counter type, except that it measures time in units of ticks of the system performance timer, rather than in 100 nanosecond units. (See the PERF_COUNTER_TIMER_INV counter type in the deployment kit.)</summary>
    PercentageNotActive = 557909248;
    ///<summary>This counter type shows the average percentage of active time observed during the sample interval. This is an inverse counter. Inverse counters are calculated by monitoring the percentage of time that the service was inactive and then subtracting that value from 100 percent. (See the PERF_100NSEC_TIMER_INV counter type in the deployment kit.)</summary>
    PercentageNotActive100Ns = 558957824;
    ///<summary>This counter type is a multitimer. Multitimers collect data from more than one instance of a component, such as a processor or disk. Counters of this type display the active time of one or more components as a percentage of the total time of the sample interval. Because the numerator records the active time of components operating simultaneously, the resulting percentage can exceed 100 percent. This counter type differs from <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageActive100Ns" />
    ///  in that it measures time in units of ticks of the system performance timer, rather than in 100 nanosecond units. (See the PERF_COUNTER_MULTI_TIMER counter type in the deployment kit.)</summary>
    MultiTimerPercentageActive = 574686464;
    ///<summary>This counter type shows the active time of one or more components as a percentage of the total time of the sample interval. It measures time in 100Â nanosecond units. This counter type is a multitimer. Multitimers are designed to monitor more than one instance of a component, such as a processor or disk. (See the PERF_100NSEC_MULTI_TIMER counter type in the deployment kit.)</summary>
    MultiTimerPercentageActive100Ns = 575735040;
    ///<summary>This counter type shows the active time of one or more components as a percentage of the total time of the sample interval. This counter type is an inverse multitimer. Multitimers monitor more than one instance of a component, such as a processor or disk. Inverse counters measure the time that a component is not active and derive the active time from that measurement. This counter differs from <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageNotActive100Ns" />
    ///  in that it measures time in units of ticks of the system performance timer, rather than in 100 nanosecond units. (See the PERF_COUNTER_MULTI_TIMER_INV counter type in the deployment kit.)</summary>
    MultiTimerPercentageNotActive = 591463680;
    ///<summary>This counter type shows the active time of one or more components as a percentage of the total time of the sample interval. Counters of this type measure time in 100 nanosecond units. This counter type is an inverse multitimer. Multitimers are designed to monitor more than one instance of a component, such as a processor or disk. Inverse counters measure the time that a component is not active and derive its active time from the measurement of inactive time. (See the PERF_100NSEC_MULTI_TIMER_INV counter type in the deployment kit.)</summary>
    MultiTimerPercentageNotActive100Ns = 592512256;
    ///<summary>This counter type measures the average time it takes to complete a process or operation. Counters of this type display a ratio of the total elapsed time of the sample interval to the number of processes or operations completed during that time. This counter type measures time in ticks of the system clock. (See the PERF_AVERAGE_TIMER counter type in the deployment kit.)</summary>
    AverageTimer32 = 805438464;
    ///<summary>This counter type shows the total time between when the component or process started and the time when this value is calculated. (See the PERF_ELAPSED_TIME counter type in the deployment kit.)</summary>
    ElapsedTime = 807666944;
    ///<summary>This counter type shows how many items are processed, on average, during an operation. Counters of this type display a ratio of the items processed (such as bytes sent) to the number of operations completed. The ratio is calculated by comparing the number of items processed during the last interval to the number of operations completed during the last interval. (See the PERF_AVERAGE_BULK counter type in the deployment kit.)</summary>
    AverageCount64 = 1073874176;
    ///<summary>This counter stores the number of sampling interrupts taken and is used as a denominator in the sampling fraction. This type supports the <see cref="F:System.Diagnostics.PerformanceData.CounterType.SampleFraction" />
    ///  counter type.</summary>
    SampleBase = 1073939457;
    ///<summary>This counter is used as the base data (denominator) in the computation of time or count averages for the <see cref="F:System.Diagnostics.PerformanceData.CounterType.AverageCount64" />
    ///  and <see cref="F:System.Diagnostics.PerformanceData.CounterType.AverageTimer32" />
    ///  counter types. This counter type collects the last observed value only. (See the PERF_AVERAGE_BASE counter type in the deployment kit.)</summary>
    AverageBase = 1073939458;
    ///<summary>This counter type collects the last observed value only. The value is used as the denominator of a counter that presents a general arithmetic fraction. This type supports the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawFraction32" />
    ///  counter type. (See the PERF_RAW_BASE counter type in the deployment kit.)</summary>
    RawBase32 = 1073939459;
    ///<summary>This counter type collects the last observed value. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawBase32" />
    ///  counter type except that it uses larger fields to accommodate larger values. This type supports the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawFraction64" />
    ///  counter type. (See the PERF_LARGE_RAW_BASE counter type in the deployment kit.)</summary>
    RawBase64 = 1073939712;
    ///<summary>Indicates the number of items sampled. It is used as the denominator in the calculations to get an average among the items sampled when taking timings of multiple, but similar, items. This type supports the following counter types: <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageActive" />
    ///  , <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageNotActive" />
    ///  , <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageActive100Ns" />
    ///  , and <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageNotActive100Ns" />
    ///  .</summary>
    MultiTimerBase = 1107494144;
  end;


  //-------------namespace: System.Diagnostics----------------
  ///<summary>Specifies the file structure that will be used for the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
  ///  log.</summary>
  [DNTypeName('System.Diagnostics.TraceLogRetentionOption')]
  DNTraceLogRetentionOption = type Integer;
  DNTraceLogRetentionOptionHelper = record helper for DNTraceLogRetentionOption
  public const
    ///<summary>An unlimited number of sequential files, each with a maximum file size that is determined by the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" />
    ///  property. There is no logical bound to the number or size of the files, but it is limited by the physical constraints imposed by the computer.</summary>
    UnlimitedSequentialFiles = 0;
    ///<summary>A finite number of sequential files, each with a maximum file size. When the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" />
    ///  property value is reached, writing starts in a new file with an incremented integer suffix. When the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumNumberOfFiles" />
    ///  property value is reached, the first file is cleared and overwritten. Files are then incrementally overwritten in a circular manner.</summary>
    LimitedCircularFiles = 1;
    ///<summary>One file with no maximum file size restriction.</summary>
    SingleFileUnboundedSize = 2;
    ///<summary>A finite number of sequential files, each with a maximum file size. When the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" />
    ///  property value is reached, writing starts in a new file with an incremented integer suffix.</summary>
    LimitedSequentialFiles = 3;
    ///<summary>One file with a maximum file size that is determined by the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" />
    ///  property.</summary>
    SingleFileBoundedSize = 4;
  end;


  //-------------namespace: System.IO----------------
  ///<summary>Specifies whether the underlying handle is inheritable by child processes.</summary>
  [DNTypeName('System.IO.HandleInheritability')]
  DNHandleInheritability = type Integer;
  DNHandleInheritabilityHelper = record helper for DNHandleInheritability
  public const
    ///<summary>Specifies that the handle is not inheritable by child processes.</summary>
    None = 0;
    ///<summary>Specifies that the handle is inheritable by child processes.</summary>
    Inheritable = 1;
  end;


  //-------------namespace: System.IO.MemoryMappedFiles----------------
  ///<summary>Specifies access capabilities and restrictions for a memory-mapped file or view. </summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedFileAccess')]
  DNMemoryMappedFileAccess = type Integer;
  DNMemoryMappedFileAccessHelper = record helper for DNMemoryMappedFileAccess
  public const
    ///<summary>Read and write access to the file.</summary>
    ReadWrite = 0;
    ///<summary>Read-only access to the file.</summary>
    Read = 1;
    ///<summary>Write-only access to file.</summary>
    Write = 2;
    ///<summary>Read and write access to the file, with the restriction that any write operations will not be seen by other processes. </summary>
    CopyOnWrite = 3;
    ///<summary>Read access to the file that can store and run executable code.</summary>
    ReadExecute = 4;
    ///<summary>Read and write access to the file that can can store and run executable code.</summary>
    ReadWriteExecute = 5;
  end;


  //-------------namespace: System.IO.MemoryMappedFiles----------------
  ///<summary>Provides memory allocation options for memory-mapped files.</summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedFileOptions')]
  DNMemoryMappedFileOptions = type Integer;
  DNMemoryMappedFileOptionsHelper = record helper for DNMemoryMappedFileOptions
  public const
    ///<summary>No memory allocation options are applied.</summary>
    None = 0;
    ///<summary>Memory allocation is delayed until a view is created with either the <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
    ///  or <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
    ///  method.</summary>
    DelayAllocatePages = 67108864;
  end;


  //-------------namespace: System.IO.MemoryMappedFiles----------------
  ///<summary>Specifies access rights to a memory-mapped file that is not associated with a file on disk.</summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedFileRights')]
  DNMemoryMappedFileRights = type Integer;
  DNMemoryMappedFileRightsHelper = record helper for DNMemoryMappedFileRights
  public const
    ///<summary>The right to read and write to a file with the restriction that write operations will not be seen by other processes.</summary>
    CopyOnWrite = 1;
    ///<summary>The right to add data to a file or remove data from a file.</summary>
    Write = 2;
    ///<summary>The right to open and copy a file as read-only.</summary>
    Read = 4;
    ///<summary>The right to open and copy a file, and the right to add data to a file or remove data from a file.</summary>
    ReadWrite = 6;
    ///<summary>The right to run an application file.</summary>
    Execute = 8;
    ///<summary>The right to open and copy a folder or file as read-only, and to run application files. This right includes the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileRights.Read" />
    ///  right and the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileRights.Execute" />
    ///  right.</summary>
    ReadExecute = 12;
    ///<summary>The right to open and copy a file, the right to add data to a file or remove data from a file, and the right to run an application file.</summary>
    ReadWriteExecute = 14;
    ///<summary>The right to delete a file.</summary>
    Delete = 65536;
    ///<summary>The right to open and copy access and audit rules from a file. This does not include the right to read data, file system attributes, or extended file system attributes.</summary>
    ReadPermissions = 131072;
    ///<summary>The right to change the security and audit rules associated with a file.</summary>
    ChangePermissions = 262144;
    ///<summary>The right to change the owner of a file.</summary>
    TakeOwnership = 524288;
    ///<summary>The right to exert full control over a file, and to modify access control and audit rules. This value represents the right to do anything with a file and is the combination of all rights in this enumeration.</summary>
    FullControl = 983055;
    ///<summary>The right to get or set permissions on a file.</summary>
    AccessSystemSecurity = 16777216;
  end;


  //-------------namespace: System.IO.Pipes----------------
  ///<summary>Defines the access rights to use when you create access and audit rules.</summary>
  [DNTypeName('System.IO.Pipes.PipeAccessRights')]
  DNPipeAccessRights = type Integer;
  DNPipeAccessRightsHelper = record helper for DNPipeAccessRights
  public const
    ///<summary>Specifies the right to read data from the pipe. This does not include the right to read file system attributes, extended file system attributes, or access and audit rules.</summary>
    ReadData = 1;
    ///<summary>Specifies the right to write data to a pipe. This does not include the right to write file system attributes or extended file system attributes.</summary>
    WriteData = 2;
    ///<summary>Specifies the right to create a new pipe. Setting this right also sets the <see cref="F:System.IO.Pipes.PipeAccessRights.Synchronize" />
    ///  right.</summary>
    CreateNewInstance = 4;
    ///<summary>Specifies the right to read extended file system attributes from a pipe. This does not include the right to read data, file system attributes, or access and audit rules.</summary>
    ReadExtendedAttributes = 8;
    ///<summary>Specifies the right to write extended file system attributes to a pipe. This does not include the right to write file attributes or data.</summary>
    WriteExtendedAttributes = 16;
    ///<summary>Specifies the right to read file system attributes from a pipe. This does not include the right to read data, extended file system attributes, or access and audit rules.</summary>
    ReadAttributes = 128;
    ///<summary>Specifies the right to write file system attributes to a pipe. This does not include the right to write data or extended file system attributes.</summary>
    WriteAttributes = 256;
    ///<summary>Specifies the right to write to the pipe. This right includes the <see cref="F:System.IO.Pipes.PipeAccessRights.WriteAttributes" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.WriteData" />
    ///  , and <see cref="F:System.IO.Pipes.PipeAccessRights.WriteExtendedAttributes" />
    ///  rights.</summary>
    Write = 274;
    ///<summary>Specifies the right to delete a pipe.</summary>
    Delete = 65536;
    ///<summary>Specifies the right to read access and audit rules from the pipe. This does not include the right to read data, file system attributes, or extended file system attributes.</summary>
    ReadPermissions = 131072;
    ///<summary>Specifies the right to read from the pipe. This right includes the <see cref="F:System.IO.Pipes.PipeAccessRights.ReadAttributes" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.ReadData" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.ReadExtendedAttributes" />
    ///  , and <see cref="F:System.IO.Pipes.PipeAccessRights.ReadPermissions" />
    ///  rights.</summary>
    Read = 131209;
    ///<summary>Specifies the right to read and write from the pipe. This right includes the <see cref="F:System.IO.Pipes.PipeAccessRights.ReadAttributes" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.ReadData" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.ReadExtendedAttributes" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.ReadPermissions" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.WriteAttributes" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.WriteData" />
    ///  , and <see cref="F:System.IO.Pipes.PipeAccessRights.WriteExtendedAttributes" />
    ///  rights.</summary>
    ReadWrite = 131483;
    ///<summary>Specifies the right to change the security and audit rules that are associated with a pipe.</summary>
    ChangePermissions = 262144;
    ///<summary>Specifies the right to change the owner of a pipe. Note that owners of a pipe have full access to that resource.</summary>
    TakeOwnership = 524288;
    ///<summary>Specifies whether the application can wait for a pipe handle to synchronize with the completion of an I/O operation.</summary>
    Synchronize = 1048576;
    ///<summary>Specifies the right to exert full control over a pipe, and to modify access control and audit rules. This value represents the combination of all rights in this enumeration.</summary>
    FullControl = 2032031;
    ///<summary>Specifies the right to make changes to the system access control list (SACL).</summary>
    AccessSystemSecurity = 16777216;
  end;


  //-------------namespace: System.IO.Pipes----------------
  ///<summary>Specifies the direction of the pipe.</summary>
  [DNTypeName('System.IO.Pipes.PipeDirection')]
  DNPipeDirection = type Integer;
  DNPipeDirectionHelper = record helper for DNPipeDirection
  public const
    ///<summary>Specifies that the pipe direction is in.</summary>
    In_ = 1;
    ///<summary>Specifies that the pipe direction is out.</summary>
    Out_ = 2;
    ///<summary>Specifies that the pipe direction is two-way.</summary>
    InOut = 3;
  end;


  //-------------namespace: System.IO.Pipes----------------
  ///<summary>Provides options for creating a <see cref="T:System.IO.Pipes.PipeStream" />
  ///  object. This enumeration has a <see cref="T:System.FlagsAttribute" />
  ///  attribute that allows a bitwise combination of its member values.</summary>
  [DNTypeName('System.IO.Pipes.PipeOptions')]
  DNPipeOptions = type Integer;
  DNPipeOptionsHelper = record helper for DNPipeOptions
  public const
    ///<summary>Indicates that there are no additional parameters.</summary>
    None = 0;
    ///<summary>Indicates that the pipe can be used for asynchronous reading and writing.</summary>
    Asynchronous = 1073741824;
    ///<summary>Indicates that the system should write through any intermediate cache and go directly to the pipe.</summary>
    WriteThrough = -2147483648;
  end;


  //-------------namespace: System.IO.Pipes----------------
  ///<summary>Specifies the transmission mode of the pipe.</summary>
  [DNTypeName('System.IO.Pipes.PipeTransmissionMode')]
  DNPipeTransmissionMode = type Integer;
  DNPipeTransmissionModeHelper = record helper for DNPipeTransmissionMode
  public const
    ///<summary>Indicates that data in the pipe is transmitted and read as a stream of bytes.</summary>
    Byte = 0;
    ///<summary>Indicates that data in the pipe is transmitted and read as a stream of messages.</summary>
    Message = 1;
  end;


  //-------------namespace: System.Linq.Expressions----------------
  ///<summary>Describes the node types for the nodes of an expression tree.</summary>
  [DNTypeName('System.Linq.Expressions.ExpressionType')]
  DNExpressionType = type Integer;
  DNExpressionTypeHelper = record helper for DNExpressionType
  public const
    ///<summary>An addition operation, such as a + b, without overflow checking, for numeric operands.</summary>
    Add = 0;
    ///<summary>An addition operation, such as (a + b), with overflow checking, for numeric operands.</summary>
    AddChecked = 1;
    ///<summary>A bitwise or logical <see langword="AND" />
    ///  operation, such as (a &amp; b) in C# and (a And b) in Visual Basic.</summary>
    And_ = 2;
    ///<summary>A conditional <see langword="AND" />
    ///  operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />
    ///  . It corresponds to (a &amp;&amp; b) in C# and (a AndAlso b) in Visual Basic.</summary>
    AndAlso = 3;
    ///<summary>An operation that obtains the length of a one-dimensional array, such as array.Length.</summary>
    ArrayLength = 4;
    ///<summary>An indexing operation in a one-dimensional array, such as array[index] in C# or array(index) in Visual Basic.</summary>
    ArrayIndex = 5;
    ///<summary>A method call, such as in the obj.sampleMethod() expression.</summary>
    Call = 6;
    ///<summary>A node that represents a null coalescing operation, such as (a ?? b) in C# or If(a, b) in Visual Basic.</summary>
    Coalesce = 7;
    ///<summary>A conditional operation, such as a &gt; b ? a : b in C# or If(a &gt; b, a, b) in Visual Basic.</summary>
    Conditional = 8;
    ///<summary>A constant value.</summary>
    Constant = 9;
    ///<summary>A cast or conversion operation, such as (SampleType)obj in C#or CType(obj, SampleType) in Visual Basic. For a numeric conversion, if the converted value is too large for the destination type, no exception is thrown.</summary>
    Convert = 10;
    ///<summary>A cast or conversion operation, such as (SampleType)obj in C#or CType(obj, SampleType) in Visual Basic. For a numeric conversion, if the converted value does not fit the destination type, an exception is thrown.</summary>
    ConvertChecked = 11;
    ///<summary>A division operation, such as (a / b), for numeric operands.</summary>
    Divide = 12;
    ///<summary>A node that represents an equality comparison, such as (a == b) in C# or (a = b) in Visual Basic.</summary>
    Equal = 13;
    ///<summary>A bitwise or logical <see langword="XOR" />
    ///  operation, such as (a ^ b) in C# or (a Xor b) in Visual Basic.</summary>
    ExclusiveOr = 14;
    ///<summary>A "greater than" comparison, such as (a &gt; b).</summary>
    GreaterThan = 15;
    ///<summary>A "greater than or equal to" comparison, such as (a &gt;= b).</summary>
    GreaterThanOrEqual = 16;
    ///<summary>An operation that invokes a delegate or lambda expression, such as sampleDelegate.Invoke().</summary>
    Invoke = 17;
    ///<summary>A lambda expression, such as a =&gt; a + a in C# or Function(a) a + a in Visual Basic.</summary>
    Lambda = 18;
    ///<summary>A bitwise left-shift operation, such as (a &lt;&lt; b).</summary>
    LeftShift = 19;
    ///<summary>A "less than" comparison, such as (a &lt; b).</summary>
    LessThan = 20;
    ///<summary>A "less than or equal to" comparison, such as (a &lt;= b).</summary>
    LessThanOrEqual = 21;
    ///<summary>An operation that creates a new <see cref="T:System.Collections.IEnumerable" />
    ///  object and initializes it from a list of elements, such as new List&lt;SampleType&gt;(){ a, b, c } in C# or Dim sampleList = { a, b, c } in Visual Basic.</summary>
    ListInit = 22;
    ///<summary>An operation that reads from a field or property, such as obj.SampleProperty.</summary>
    MemberAccess = 23;
    ///<summary>An operation that creates a new object and initializes one or more of its members, such as new Point { X = 1, Y = 2 } in C# or New Point With {.X = 1, .Y = 2} in Visual Basic.</summary>
    MemberInit = 24;
    ///<summary>An arithmetic remainder operation, such as (a % b) in C# or (a Mod b) in Visual Basic.</summary>
    Modulo = 25;
    ///<summary>A multiplication operation, such as (a * b), without overflow checking, for numeric operands.</summary>
    Multiply = 26;
    ///<summary>An multiplication operation, such as (a * b), that has overflow checking, for numeric operands.</summary>
    MultiplyChecked = 27;
    ///<summary>An arithmetic negation operation, such as (-a). The object a should not be modified in place.</summary>
    Negate = 28;
    ///<summary>A unary plus operation, such as (+a). The result of a predefined unary plus operation is the value of the operand, but user-defined implementations might have unusual results.</summary>
    UnaryPlus = 29;
    ///<summary>An arithmetic negation operation, such as (-a), that has overflow checking. The object a should not be modified in place.</summary>
    NegateChecked = 30;
    ///<summary>An operation that calls a constructor to create a new object, such as new SampleType().</summary>
    New = 31;
    ///<summary>An operation that creates a new one-dimensional array and initializes it from a list of elements, such as new SampleType[]{a, b, c} in C# or New SampleType(){a, b, c} in Visual Basic.</summary>
    NewArrayInit = 32;
    ///<summary>An operation that creates a new array, in which the bounds for each dimension are specified, such as new SampleType[dim1, dim2] in C# or New SampleType(dim1, dim2) in Visual Basic.</summary>
    NewArrayBounds = 33;
    ///<summary>A bitwise complement or logical negation operation. In C#, it is equivalent to (~a) for integral types and to (!a) for Boolean values. In Visual Basic, it is equivalent to (Not a). The object a should not be modified in place.</summary>
    Not_ = 34;
    ///<summary>An inequality comparison, such as (a != b) in C# or (a &lt;&gt; b) in Visual Basic.</summary>
    NotEqual = 35;
    ///<summary>A bitwise or logical <see langword="OR" />
    ///  operation, such as (a | b) in C# or (a Or b) in Visual Basic.</summary>
    Or_ = 36;
    ///<summary>A short-circuiting conditional <see langword="OR" />
    ///  operation, such as (a || b) in C# or (a OrElse b) in Visual Basic.</summary>
    OrElse = 37;
    ///<summary>A reference to a parameter or variable that is defined in the context of the expression. For more information, see <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  .</summary>
    Parameter = 38;
    ///<summary>A mathematical operation that raises a number to a power, such as (a ^ b) in Visual Basic.</summary>
    Power = 39;
    ///<summary>An expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />
    ///  . A <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />
    ///  node can contain references to parameters that are defined in the context of the expression it represents.</summary>
    Quote = 40;
    ///<summary>A bitwise right-shift operation, such as (a &gt;&gt; b).</summary>
    RightShift = 41;
    ///<summary>A subtraction operation, such as (a - b), without overflow checking, for numeric operands.</summary>
    Subtract = 42;
    ///<summary>An arithmetic subtraction operation, such as (a - b), that has overflow checking, for numeric operands.</summary>
    SubtractChecked = 43;
    ///<summary>An explicit reference or boxing conversion in which <see langword="null" />
    ///  is supplied if the conversion fails, such as (obj as SampleType) in C# or TryCast(obj, SampleType) in Visual Basic.</summary>
    TypeAs = 44;
    ///<summary>A type test, such as obj is SampleType in C# or TypeOf obj is SampleType in Visual Basic.</summary>
    TypeIs = 45;
    ///<summary>An assignment operation, such as (a = b).</summary>
    Assign = 46;
    ///<summary>A block of expressions.</summary>
    Block = 47;
    ///<summary>Debugging information.</summary>
    DebugInfo = 48;
    ///<summary>A unary decrement operation, such as (a - 1) in C# and Visual Basic. The object a should not be modified in place.</summary>
    Decrement = 49;
    ///<summary>A dynamic operation.</summary>
    Dynamic_ = 50;
    ///<summary>A default value.</summary>
    Default_ = 51;
    ///<summary>An extension expression.</summary>
    Extension = 52;
    ///<summary>A "go to" expression, such as goto Label in C# or GoTo Label in Visual Basic.</summary>
    Goto_ = 53;
    ///<summary>A unary increment operation, such as (a + 1) in C# and Visual Basic. The object a should not be modified in place.</summary>
    Increment = 54;
    ///<summary>An index operation or an operation that accesses a property that takes arguments. </summary>
    Index = 55;
    ///<summary>A label.</summary>
    Label_ = 56;
    ///<summary>A list of run-time variables. For more information, see <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />
    ///  .</summary>
    RuntimeVariables = 57;
    ///<summary>A loop, such as for or while.</summary>
    Loop = 58;
    ///<summary>A switch operation, such as <see langword="switch" />
    ///  in C# or <see langword="Select Case" />
    ///  in Visual Basic.</summary>
    Switch = 59;
    ///<summary>An operation that throws an exception, such as throw new Exception().</summary>
    Throw = 60;
    ///<summary>A <see langword="try-catch" />
    ///  expression.</summary>
    Try_ = 61;
    ///<summary>An unbox value type operation, such as <see langword="unbox" />
    ///  and <see langword="unbox.any" />
    ///  instructions in MSIL. </summary>
    Unbox = 62;
    ///<summary>An addition compound assignment operation, such as (a += b), without overflow checking, for numeric operands.</summary>
    AddAssign = 63;
    ///<summary>A bitwise or logical <see langword="AND" />
    ///  compound assignment operation, such as (a &amp;= b) in C#.</summary>
    AndAssign = 64;
    ///<summary>An division compound assignment operation, such as (a /= b), for numeric operands.</summary>
    DivideAssign = 65;
    ///<summary>A bitwise or logical <see langword="XOR" />
    ///  compound assignment operation, such as (a ^= b) in C#.</summary>
    ExclusiveOrAssign = 66;
    ///<summary>A bitwise left-shift compound assignment, such as (a &lt;&lt;= b).</summary>
    LeftShiftAssign = 67;
    ///<summary>An arithmetic remainder compound assignment operation, such as (a %= b) in C#.</summary>
    ModuloAssign = 68;
    ///<summary>A multiplication compound assignment operation, such as (a *= b), without overflow checking, for numeric operands.</summary>
    MultiplyAssign = 69;
    ///<summary>A bitwise or logical <see langword="OR" />
    ///  compound assignment, such as (a |= b) in C#.</summary>
    OrAssign = 70;
    ///<summary>A compound assignment operation that raises a number to a power, such as (a ^= b) in Visual Basic.</summary>
    PowerAssign = 71;
    ///<summary>A bitwise right-shift compound assignment operation, such as (a &gt;&gt;= b).</summary>
    RightShiftAssign = 72;
    ///<summary>A subtraction compound assignment operation, such as (a -= b), without overflow checking, for numeric operands.</summary>
    SubtractAssign = 73;
    ///<summary>An addition compound assignment operation, such as (a += b), with overflow checking, for numeric operands.</summary>
    AddAssignChecked = 74;
    ///<summary>A multiplication compound assignment operation, such as (a *= b), that has overflow checking, for numeric operands.</summary>
    MultiplyAssignChecked = 75;
    ///<summary>A subtraction compound assignment operation, such as (a -= b), that has overflow checking, for numeric operands.</summary>
    SubtractAssignChecked = 76;
    ///<summary>A unary prefix increment, such as (++a). The object a should be modified in place.</summary>
    PreIncrementAssign = 77;
    ///<summary>A unary prefix decrement, such as (--a). The object a should be modified in place.</summary>
    PreDecrementAssign = 78;
    ///<summary>A unary postfix increment, such as (a++). The object a should be modified in place.</summary>
    PostIncrementAssign = 79;
    ///<summary>A unary postfix decrement, such as (a--). The object a should be modified in place.</summary>
    PostDecrementAssign = 80;
    ///<summary>An exact type test.</summary>
    TypeEqual = 81;
    ///<summary>A ones complement operation, such as (~a) in C#.</summary>
    OnesComplement = 82;
    ///<summary>A <see langword="true" />
    ///  condition value.</summary>
    IsTrue = 83;
    ///<summary>A <see langword="false" />
    ///  condition value.</summary>
    IsFalse = 84;
  end;


  //-------------namespace: System.Linq.Expressions----------------
  ///<summary>Specifies what kind of jump this <see cref="T:System.Linq.Expressions.GotoExpression" />
  ///  represents.</summary>
  [DNTypeName('System.Linq.Expressions.GotoExpressionKind')]
  DNGotoExpressionKind = type Integer;
  DNGotoExpressionKindHelper = record helper for DNGotoExpressionKind
  public const
    ///<summary>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  that represents a jump to some location.</summary>
    Goto_ = 0;
    ///<summary>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  that represents a return statement.</summary>
    Return = 1;
    ///<summary>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  that represents a break statement.</summary>
    Break = 2;
    ///<summary>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  that represents a continue statement.</summary>
    Continue_ = 3;
  end;


  //-------------namespace: System.Linq.Expressions----------------
  ///<summary>Describes the binding types that are used in <see cref="T:System.Linq.Expressions.MemberInitExpression" />
  ///  objects.</summary>
  [DNTypeName('System.Linq.Expressions.MemberBindingType')]
  DNMemberBindingType = type Integer;
  DNMemberBindingTypeHelper = record helper for DNMemberBindingType
  public const
    ///<summary>A binding that represents initializing a member with the value of an expression.</summary>
    Assignment = 0;
    ///<summary>A binding that represents recursively initializing members of a member.</summary>
    MemberBinding = 1;
    ///<summary>A binding that represents initializing a member of type <see cref="T:System.Collections.IList" />
    ///  or <see cref="T:System.Collections.Generic.ICollection`1" />
    ///  from a list of elements.</summary>
    ListBinding = 2;
  end;


  //-------------namespace: System.Linq----------------
  ///<summary>The query execution mode is a hint that specifies how the system should handle performance trade-offs when parallelizing queries.</summary>
  [DNTypeName('System.Linq.ParallelExecutionMode')]
  DNParallelExecutionMode = type Integer;
  DNParallelExecutionModeHelper = record helper for DNParallelExecutionMode
  public const
    ///<summary>This is the default setting. PLINQ will examine the query's structure and will only parallelize the query if will likely result in speedup. If the query structure indicates that speedup is not likely to be obtained, then PLINQ will execute the query as an ordinary LINQ to Objects query.</summary>
    Default_ = 0;
    ///<summary>Parallelize the entire query, even if that means using high-overhead algorithms. Use this flag in cases where you know that parallel execution of the query will result in speedup, but PLINQ in the Default mode would execute it as sequential.</summary>
    ForceParallelism = 1;
  end;


  //-------------namespace: System.Linq----------------
  ///<summary>Specifies the preferred type of output merge to use in a query. In other words, it indicates how PLINQ should merge the results from the various partitions back into a single result sequence. This is a hint only, and may not be respected by the system when parallelizing all queries.</summary>
  [DNTypeName('System.Linq.ParallelMergeOptions')]
  DNParallelMergeOptions = type Integer;
  DNParallelMergeOptionsHelper = record helper for DNParallelMergeOptions
  public const
    ///<summary>Use the default merge type, which is AutoBuffered.</summary>
    Default_ = 0;
    ///<summary>Use a merge without output buffers. As soon as result elements have been computed, make that element available to the consumer of the query.</summary>
    NotBuffered = 1;
    ///<summary>Use a merge with output buffers of a size chosen by the system. Results will accumulate into an output buffer before they are available to the consumer of the query.</summary>
    AutoBuffered = 2;
    ///<summary>Use a merge with full output buffers. The system will accumulate all of the results before making any of them available to the consumer of the query.</summary>
    FullyBuffered = 3;
  end;


  //-------------namespace: System.Management.Instrumentation----------------
  ///<summary>Represents the possible commit behaviors of a read/write property. It is used as the value of a parameter of the <see cref="T:System.Management.Instrumentation.ManagementConfigurationAttribute" />
  ///  attribute.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementConfigurationType')]
  DNManagementConfigurationType = type Integer;
  DNManagementConfigurationTypeHelper = record helper for DNManagementConfigurationType
  public const
    ///<summary>Set values take effect only when Commit is called.</summary>
    Apply = 0;
    ///<summary>Set values are applied immediately.</summary>
    OnCommit = 1;
  end;


  //-------------namespace: System.Management.Instrumentation----------------
  ///<summary>Defines values that specify the hosting model for the provider.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementHostingModel')]
  DNManagementHostingModel = type Integer;
  DNManagementHostingModelHelper = record helper for DNManagementHostingModel
  public const
    ///<summary>Activates the provider as a decoupled provider.</summary>
    Decoupled = 0;
    ///<summary>Activates the provider in the provider host process that is running under the NetworkService account.</summary>
    NetworkService = 1;
    ///<summary>Activates the provider in the provider host process that is running under the LocalService account.</summary>
    LocalService = 2;
    ///<summary>Activates the provider in the provider host process that is running under the LocalSystem account.</summary>
    LocalSystem = 3;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies the key export policies for a key. </summary>
  [DNTypeName('System.Security.Cryptography.CngExportPolicies')]
  DNCngExportPolicies = type Integer;
  DNCngExportPoliciesHelper = record helper for DNCngExportPolicies
  public const
    ///<summary>No export policies are established. Key export is allowed without restriction.</summary>
    None = 0;
    ///<summary>The private key can be exported multiple times.</summary>
    AllowExport = 1;
    ///<summary>The private key can be exported multiple times as plaintext.</summary>
    AllowPlaintextExport = 2;
    ///<summary>The private key can be exported one time for archiving purposes.</summary>
    AllowArchiving = 4;
    ///<summary>The private key can be exported one time as plaintext.</summary>
    AllowPlaintextArchiving = 8;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies options used for key creation.</summary>
  [DNTypeName('System.Security.Cryptography.CngKeyCreationOptions')]
  DNCngKeyCreationOptions = type Integer;
  DNCngKeyCreationOptionsHelper = record helper for DNCngKeyCreationOptions
  public const
    ///<summary>No key creation options are used.</summary>
    None = 0;
    ///<summary>A machine-wide key is created.</summary>
    MachineKey = 32;
    ///<summary>The existing key is overwritten during key creation.</summary>
    OverwriteExistingKey = 128;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies options for opening key handles.</summary>
  [DNTypeName('System.Security.Cryptography.CngKeyHandleOpenOptions')]
  DNCngKeyHandleOpenOptions = type Integer;
  DNCngKeyHandleOpenOptionsHelper = record helper for DNCngKeyHandleOpenOptions
  public const
    ///<summary>The key handle being opened does not specify an ephemeral key.</summary>
    None = 0;
    ///<summary>The key handle being opened specifies an ephemeral key.</summary>
    EphemeralKey = 1;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies options for opening a key.</summary>
  [DNTypeName('System.Security.Cryptography.CngKeyOpenOptions')]
  DNCngKeyOpenOptions = type Integer;
  DNCngKeyOpenOptionsHelper = record helper for DNCngKeyOpenOptions
  public const
    ///<summary>No key open options are specified.</summary>
    None = 0;
    ///<summary>If the <see cref="F:System.Security.Cryptography.CngKeyOpenOptions.MachineKey" />
    ///  value is not specified, a user key is opened instead.</summary>
    UserKey = 0;
    ///<summary>A machine-wide key is opened.</summary>
    MachineKey = 32;
    ///<summary>UI prompting is suppressed.</summary>
    Silent = 64;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies the cryptographic operations that a Cryptography Next Generation (CNG) key may be used with. </summary>
  [DNTypeName('System.Security.Cryptography.CngKeyUsages')]
  DNCngKeyUsages = type Integer;
  DNCngKeyUsagesHelper = record helper for DNCngKeyUsages
  public const
    ///<summary>No usage values are assigned to the key.</summary>
    None = 0;
    ///<summary>The key can be used for encryption and decryption.</summary>
    Decryption = 1;
    ///<summary>The key can be used for signing and verification.</summary>
    Signing = 2;
    ///<summary>The key can be used for secret agreement generation and key exchange.</summary>
    KeyAgreement = 4;
    ///<summary>The key can be used for all purposes.</summary>
    AllUsages = 16777215;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies Cryptography Next Generation (CNG) key property options.</summary>
  [DNTypeName('System.Security.Cryptography.CngPropertyOptions')]
  DNCngPropertyOptions = type Integer;
  DNCngPropertyOptionsHelper = record helper for DNCngPropertyOptions
  public const
    ///<summary>The referenced property has no options.</summary>
    None = 0;
    ///<summary>The property is not specified by CNG. Use this option to avoid future name conflicts with CNG properties.</summary>
    CustomProperty = 1073741824;
    ///<summary>The property should be persisted.</summary>
    Persist = -2147483648;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies the protection level for the key in user interface (UI) prompting scenarios.</summary>
  [DNTypeName('System.Security.Cryptography.CngUIProtectionLevels')]
  DNCngUIProtectionLevels = type Integer;
  DNCngUIProtectionLevelsHelper = record helper for DNCngUIProtectionLevels
  public const
    ///<summary>No UI prompt is displayed when the key is accessed.</summary>
    None = 0;
    ///<summary>A UI prompt is displayed the first time the key is accessed in a process.</summary>
    ProtectKey = 1;
    ///<summary>A UI prompt is displayed every time the key is accessed.</summary>
    ForceHighProtection = 2;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Indicates how to interpret the data contained in an <see cref="T:System.Security.Cryptography.ECCurve" />
  ///  object.</summary>
  [DNTypeName('System.Security.Cryptography.ECCurve+ECCurveType')]
  DNECCurve_ECCurveType = type Integer;
  DNECCurve_ECCurveTypeHelper = record helper for DNECCurve_ECCurveType
  public const
    ///<summary>No curve data is interpreted. The caller is assumed to know what the curve is.</summary>
    Implicit = 0;
    ///<summary>The curve parameters represent a prime curve with the formula y^2 = x^3 + A*x + B in the prime field P.</summary>
    PrimeShortWeierstrass = 1;
    ///<summary>The curve parameters represent a prime curve with the formula A*x^2 + y^2 = 1 + B*x^2*y^2 in the prime field P.</summary>
    PrimeTwistedEdwards = 2;
    ///<summary>The curve parameters represent a prime curve with the formula B*y^2 = x^3 + A*x^2 + x.</summary>
    PrimeMontgomery = 3;
    ///<summary>The curve parameters represent a characteristic 2 curve.</summary>
    Characteristic2 = 4;
    ///<summary>The curve parameters represent a named curve.</summary>
    Named = 5;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies the key derivation function that the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
  ///  class will use to convert secret agreements into key material.</summary>
  [DNTypeName('System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction')]
  DNECDiffieHellmanKeyDerivationFunction = type Integer;
  DNECDiffieHellmanKeyDerivationFunctionHelper = record helper for DNECDiffieHellmanKeyDerivationFunction
  public const
    ///<summary>A hash algorithm is used to generate key material. The <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" />
    ///  property specifies the name of the algorithm to use. If the algorithm name is not specified, <see cref="T:System.Security.Cryptography.SHA256" />
    ///  is used as the default algorithm. </summary>
    Hash = 0;
    ///<summary>A Hash-based Message Authentication Code (HMAC) algorithm is used to generate key material. The <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" />
    ///  property specifies the key to use. Either this property must be set or the <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" />
    ///  property must be set to <see langword="true" />
    ///  ; otherwise, a <see cref="T:System.Security.Cryptography.CryptographicException" />
    ///  is thrown when you use <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />
    ///  . If both properties are set, the secret agreement is used as the HMAC key. </summary>
    Hmac = 1;
    ///<summary>The Transport Layer Security (TLS) protocol is used to generate key material. The <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />
    ///  and <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />
    ///  properties must be set; otherwise, a <see cref="T:System.Security.Cryptography.CryptographicException" />
    ///  is thrown when you use <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />
    ///  . </summary>
    Tls = 2;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Defines XML serialization formats for elliptic curve keys.</summary>
  [DNTypeName('System.Security.Cryptography.ECKeyXmlFormat')]
  DNECKeyXmlFormat = type Integer;
  DNECKeyXmlFormatHelper = record helper for DNECKeyXmlFormat
  public const
    ///<summary>An XML serialization format described in RFC 4050, "Using the Elliptic Curve Signature Algorithm (ECDSA) for XML Digital Signatures."</summary>
    Rfc4050 = 0;
  end;


  //-------------namespace: System.Security.Cryptography----------------
  ///<summary>Specifies most of the result codes for signature verification. </summary>
  [DNTypeName('System.Security.Cryptography.SignatureVerificationResult')]
  DNSignatureVerificationResult = type Integer;
  DNSignatureVerificationResultHelper = record helper for DNSignatureVerificationResult
  public const
    ///<summary>The certificate verification result is valid.</summary>
    Valid = 0;
    ///<summary>The identity of the assembly specified in the /asm:assembly/asm:assemblyIdentity node of the manifest does not match the identity of the assembly in the Authenticode signature in the /asm:assembly/ds:signature/ds:KeyInfo/msrel:RelData/r:license/r:grant/as:ManifestInformation/as:assemblyIdentity node.</summary>
    AssemblyIdentityMismatch = 1;
    ///<summary>The strong name signature does not verify in the <see cref="T:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation" />
    ///  object.Â Because the strong name signature wraps the Authenticode signature, someone could replace the Authenticode signature with a signature of their choosing. To prevent this, this error code is returned if the strong name does not verify because substituting a part of the strong name signature will invalidate it.</summary>
    ContainingSignatureInvalid = 2;
    ///<summary>The public key token from the manifest identity in the /asm:assembly/asm:AssemblyIdentity node does not match the public key token of the key that is used to sign the manifest.</summary>
    PublicKeyTokenMismatch = 3;
    ///<summary>The publisher name from /asm:assembly/asmv2:publisherIdentity does not match the subject name of the signing certificate, or the issuer key hash from the same publisherIdentity node does not match the key hash of the signing certificate.</summary>
    PublisherMismatch = 4;
    ///<summary>A system-level error occurred while verifying trust.</summary>
    SystemError = -2146869247;
    ///<summary>The certificate for the signer of the message is invalid or not found.</summary>
    InvalidSignerCertificate = -2146869246;
    ///<summary>One of the counter signatures is invalid.</summary>
    InvalidCountersignature = -2146869245;
    ///<summary>The signature of the certificate cannot be verified.</summary>
    InvalidCertificateSignature = -2146869244;
    ///<summary>The time stamp signature or certificate could not be verified or is malformed.</summary>
    InvalidTimestamp = -2146869243;
    ///<summary>The digital signature of the object did not verify.</summary>
    BadDigest = -2146869232;
    ///<summary>The basic constraint extension of a certificate has not been observed.</summary>
    BasicConstraintsNotObserved = -2146869223;
    ///<summary>The certificate has an unknown trust provider.</summary>
    UnknownTrustProvider = -2146762751;
    ///<summary>The certificate has an unknown verification action.</summary>
    UnknownVerificationAction = -2146762750;
    ///<summary>The signature format is invalid.</summary>
    BadSignatureFormat = -2146762749;
    ///<summary>The certificate is not trusted explicitly.</summary>
    CertificateNotExplicitlyTrusted = -2146762748;
    ///<summary>The signature is missing.</summary>
    MissingSignature = -2146762496;
    ///<summary>The certificate has expired.</summary>
    CertificateExpired = -2146762495;
    ///<summary>A certificate was issued after the issuing certificate has expired.</summary>
    InvalidTimePeriodNesting = -2146762494;
    ///<summary>The certificate has an invalid role.</summary>
    InvalidCertificateRole = -2146762493;
    ///<summary>A path length constraint in the certification chain has been violated.</summary>
    PathLengthConstraintViolated = -2146762492;
    ///<summary>A certificate contains an unknown extension that is marked critical.</summary>
    UnknownCriticalExtension = -2146762491;
    ///<summary>The certificate cannot be used for signing and verification.</summary>
    CertificateUsageNotAllowed = -2146762490;
    ///<summary>A parent of a given certificate did not issue that child certificate.</summary>
    IssuerChainingError = -2146762489;
    ///<summary>The certificate is missing or has an empty value for an important field, such as a subject or issuer name.</summary>
    CertificateMalformed = -2146762488;
    ///<summary>The root certificate is not trusted.</summary>
    UntrustedRootCertificate = -2146762487;
    ///<summary>The chain could not be built.</summary>
    CouldNotBuildChain = -2146762486;
    ///<summary>There is a general trust failure with the certificate.</summary>
    GenericTrustFailure = -2146762485;
    ///<summary>The certificate has been revoked.</summary>
    CertificateRevoked = -2146762484;
    ///<summary>The test root certificate is not trusted.</summary>
    UntrustedTestRootCertificate = -2146762483;
    ///<summary>The revocation check failed.</summary>
    RevocationCheckFailure = -2146762482;
    ///<summary>The certificate has an invalid usage.</summary>
    InvalidCertificateUsage = -2146762480;
    ///<summary>The certificate was explicitly marked as not trusted by the user.</summary>
    CertificateExplicitlyDistrusted = -2146762479;
    ///<summary>The certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider.</summary>
    UntrustedCertificationAuthority = -2146762478;
    ///<summary>The certificate has an invalid policy.</summary>
    InvalidCertificatePolicy = -2146762477;
    ///<summary>The certificate has an invalid name. The name is either not included in the permitted list or is explicitly excluded.</summary>
    InvalidCertificateName = -2146762476;
  end;


  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  ///<summary>Identifies the level of trustworthiness that is assigned to the signature for a manifest.</summary>
  [DNTypeName('System.Security.Cryptography.X509Certificates.TrustStatus')]
  DNTrustStatus = type Integer;
  DNTrustStatusHelper = record helper for DNTrustStatus
  public const
    ///<summary>The signature was created by an explicitly distrusted publisher.</summary>
    Untrusted = 0;
    ///<summary>The identity is not known and the signature is invalid. Because there is no verified signature, an identity cannot be determined.</summary>
    UnknownIdentity = 1;
    ///<summary>The identity is known and the signature is valid. A valid Authenticode signature provides an identity.</summary>
    KnownIdentity = 2;
    ///<summary>The signature is valid and was created by an explicitly trusted publisher.</summary>
    Trusted = 3;
  end;


  //-------------namespace: System.Security----------------
  ///<summary>Represents the type of manifest that the signature information applies to.</summary>
  [DNTypeName('System.Security.ManifestKinds')]
  DNManifestKinds = type Integer;
  DNManifestKindsHelper = record helper for DNManifestKinds
  public const
    ///<summary>The manifest is of no particular type. </summary>
    None = 0;
    ///<summary>The manifest is for deployment only.</summary>
    Deployment = 1;
    ///<summary>The manifest is for an application. </summary>
    Application = 2;
    ///<summary>The manifest is for deployment and application. The is the default value for verifying signatures. </summary>
    ApplicationAndDeployment = 3;
  end;


  //-------------namespace: System.Threading----------------
  ///<summary>Specifies whether a lock can be entered multiple times by the same thread.</summary>
  [DNTypeName('System.Threading.LockRecursionPolicy')]
  DNLockRecursionPolicy = type Integer;
  DNLockRecursionPolicyHelper = record helper for DNLockRecursionPolicy
  public const
    ///<summary>If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect. </summary>
    NoRecursion = 0;
    ///<summary>A thread can enter a lock recursively. Some classes may restrict this capability. </summary>
    SupportsRecursion = 1;
  end;




type


{ declares }

  DNIGrouping<TKey, TElement> = interface; // type: System.Linq.IGrouping`2, namespace: System.Linq
  DNILookup<TKey, TElement> = interface; // type: System.Linq.ILookup`2, namespace: System.Linq
  DNIOrderedEnumerable<TElement> = interface; // type: System.Linq.IOrderedEnumerable`1, namespace: System.Linq
  DNIQueryable<T> = interface; // type: System.Linq.IQueryable`1, namespace: System.Linq
  DNIOrderedQueryable<T> = interface; // type: System.Linq.IOrderedQueryable`1, namespace: System.Linq
  DNIQueryable = interface; // type: System.Linq.IQueryable, namespace: System.Linq
  DNIOrderedQueryable = interface; // type: System.Linq.IOrderedQueryable, namespace: System.Linq
  DNIDynamicMetaObjectProvider = interface; // type: System.Dynamic.IDynamicMetaObjectProvider, namespace: System.Dynamic
  DNIInvokeOnGetBinder = interface; // type: System.Dynamic.IInvokeOnGetBinder, namespace: System.Dynamic
  DNIArgumentProvider = interface; // type: System.Linq.Expressions.IArgumentProvider, namespace: System.Linq.Expressions
  DNIDynamicExpression = interface; // type: System.Linq.Expressions.IDynamicExpression, namespace: System.Linq.Expressions
  DNIQueryProvider = interface; // type: System.Linq.IQueryProvider, namespace: System.Linq
  DNIRuntimeVariables = interface; // type: System.Runtime.CompilerServices.IRuntimeVariables, namespace: System.Runtime.CompilerServices
  DNIStrongBox = interface; // type: System.Runtime.CompilerServices.IStrongBox, namespace: System.Runtime.CompilerServices
  DNManagementEntityAttribute = interface; // type: System.Management.Instrumentation.ManagementEntityAttribute, namespace: System.Management.Instrumentation
  DNManagementMemberAttribute = interface; // type: System.Management.Instrumentation.ManagementMemberAttribute, namespace: System.Management.Instrumentation
  DNManagementCommitAttribute = interface; // type: System.Management.Instrumentation.ManagementCommitAttribute, namespace: System.Management.Instrumentation
  DNManagementConfigurationAttribute = interface; // type: System.Management.Instrumentation.ManagementConfigurationAttribute, namespace: System.Management.Instrumentation
  DNManagementKeyAttribute = interface; // type: System.Management.Instrumentation.ManagementKeyAttribute, namespace: System.Management.Instrumentation
  DNManagementNewInstanceAttribute = interface; // type: System.Management.Instrumentation.ManagementNewInstanceAttribute, namespace: System.Management.Instrumentation
  DNManagementBindAttribute = interface; // type: System.Management.Instrumentation.ManagementBindAttribute, namespace: System.Management.Instrumentation
  DNManagementCreateAttribute = interface; // type: System.Management.Instrumentation.ManagementCreateAttribute, namespace: System.Management.Instrumentation
  DNManagementEnumeratorAttribute = interface; // type: System.Management.Instrumentation.ManagementEnumeratorAttribute, namespace: System.Management.Instrumentation
  DNManagementProbeAttribute = interface; // type: System.Management.Instrumentation.ManagementProbeAttribute, namespace: System.Management.Instrumentation
  DNManagementRemoveAttribute = interface; // type: System.Management.Instrumentation.ManagementRemoveAttribute, namespace: System.Management.Instrumentation
  DNManagementTaskAttribute = interface; // type: System.Management.Instrumentation.ManagementTaskAttribute, namespace: System.Management.Instrumentation
  DNManagementNameAttribute = interface; // type: System.Management.Instrumentation.ManagementNameAttribute, namespace: System.Management.Instrumentation
  DNManagementReferenceAttribute = interface; // type: System.Management.Instrumentation.ManagementReferenceAttribute, namespace: System.Management.Instrumentation
  DNWmiConfigurationAttribute = interface; // type: System.Management.Instrumentation.WmiConfigurationAttribute, namespace: System.Management.Instrumentation
  DNDynamicAttribute = interface; // type: System.Runtime.CompilerServices.DynamicAttribute, namespace: System.Runtime.CompilerServices
  DNHashSet<T> = interface; // type: System.Collections.Generic.HashSet`1, namespace: System.Collections.Generic
  DNCngPropertyCollection = interface; // type: System.Security.Cryptography.CngPropertyCollection, namespace: System.Security.Cryptography
  DNManifestSignatureInformationCollection = interface; // type: System.Security.Cryptography.ManifestSignatureInformationCollection, namespace: System.Security.Cryptography
  DNEventProvider = interface; // type: System.Diagnostics.Eventing.EventProvider, namespace: System.Diagnostics.Eventing
  DNEventBookmark = interface; // type: System.Diagnostics.Eventing.Reader.EventBookmark, namespace: System.Diagnostics.Eventing.Reader
  DNEventKeyword = interface; // type: System.Diagnostics.Eventing.Reader.EventKeyword, namespace: System.Diagnostics.Eventing.Reader
  DNEventLevel = interface; // type: System.Diagnostics.Eventing.Reader.EventLevel, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogConfiguration = interface; // type: System.Diagnostics.Eventing.Reader.EventLogConfiguration, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogInformation = interface; // type: System.Diagnostics.Eventing.Reader.EventLogInformation, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogLink = interface; // type: System.Diagnostics.Eventing.Reader.EventLogLink, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogPropertySelector = interface; // type: System.Diagnostics.Eventing.Reader.EventLogPropertySelector, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogQuery = interface; // type: System.Diagnostics.Eventing.Reader.EventLogQuery, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogReader = interface; // type: System.Diagnostics.Eventing.Reader.EventLogReader, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogSession = interface; // type: System.Diagnostics.Eventing.Reader.EventLogSession, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogStatus = interface; // type: System.Diagnostics.Eventing.Reader.EventLogStatus, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogWatcher = interface; // type: System.Diagnostics.Eventing.Reader.EventLogWatcher, namespace: System.Diagnostics.Eventing.Reader
  DNEventMetadata = interface; // type: System.Diagnostics.Eventing.Reader.EventMetadata, namespace: System.Diagnostics.Eventing.Reader
  DNEventOpcode = interface; // type: System.Diagnostics.Eventing.Reader.EventOpcode, namespace: System.Diagnostics.Eventing.Reader
  DNEventProperty = interface; // type: System.Diagnostics.Eventing.Reader.EventProperty, namespace: System.Diagnostics.Eventing.Reader
  DNEventRecord = interface; // type: System.Diagnostics.Eventing.Reader.EventRecord, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogRecord = interface; // type: System.Diagnostics.Eventing.Reader.EventLogRecord, namespace: System.Diagnostics.Eventing.Reader
  DNEventTask = interface; // type: System.Diagnostics.Eventing.Reader.EventTask, namespace: System.Diagnostics.Eventing.Reader
  DNProviderMetadata = interface; // type: System.Diagnostics.Eventing.Reader.ProviderMetadata, namespace: System.Diagnostics.Eventing.Reader
  DNCounterData = interface; // type: System.Diagnostics.PerformanceData.CounterData, namespace: System.Diagnostics.PerformanceData
  DNCounterSet = interface; // type: System.Diagnostics.PerformanceData.CounterSet, namespace: System.Diagnostics.PerformanceData
  DNCounterSetInstance = interface; // type: System.Diagnostics.PerformanceData.CounterSetInstance, namespace: System.Diagnostics.PerformanceData
  DNCounterSetInstanceCounterDataSet = interface; // type: System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet, namespace: System.Diagnostics.PerformanceData
  DNUnescapedXmlDiagnosticData = interface; // type: System.Diagnostics.UnescapedXmlDiagnosticData, namespace: System.Diagnostics
  DNBindingRestrictions = interface; // type: System.Dynamic.BindingRestrictions, namespace: System.Dynamic
  DNCallInfo = interface; // type: System.Dynamic.CallInfo, namespace: System.Dynamic
  DNDynamicMetaObject = interface; // type: System.Dynamic.DynamicMetaObject, namespace: System.Dynamic
  DNDynamicObject = interface; // type: System.Dynamic.DynamicObject, namespace: System.Dynamic
  DNExpandoObject = interface; // type: System.Dynamic.ExpandoObject, namespace: System.Dynamic
  DNEventRecordWrittenEventArgs = interface; // type: System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogException = interface; // type: System.Diagnostics.Eventing.Reader.EventLogException, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogInvalidDataException = interface; // type: System.Diagnostics.Eventing.Reader.EventLogInvalidDataException, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogNotFoundException = interface; // type: System.Diagnostics.Eventing.Reader.EventLogNotFoundException, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogProviderDisabledException = interface; // type: System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException, namespace: System.Diagnostics.Eventing.Reader
  DNEventLogReadingException = interface; // type: System.Diagnostics.Eventing.Reader.EventLogReadingException, namespace: System.Diagnostics.Eventing.Reader
  DNInstrumentationBaseException = interface; // type: System.Management.Instrumentation.InstrumentationBaseException, namespace: System.Management.Instrumentation
  DNInstrumentationException = interface; // type: System.Management.Instrumentation.InstrumentationException, namespace: System.Management.Instrumentation
  DNInstanceNotFoundException = interface; // type: System.Management.Instrumentation.InstanceNotFoundException, namespace: System.Management.Instrumentation
  DNMemoryMappedFile = interface; // type: System.IO.MemoryMappedFiles.MemoryMappedFile, namespace: System.IO.MemoryMappedFiles
  DNMemoryMappedViewAccessor = interface; // type: System.IO.MemoryMappedFiles.MemoryMappedViewAccessor, namespace: System.IO.MemoryMappedFiles
  DNEnumerable = interface; // type: System.Linq.Enumerable, namespace: System.Linq
  DNEnumerableExecutor = interface; // type: System.Linq.EnumerableExecutor, namespace: System.Linq
  DNEnumerableExecutor<T> = interface; // type: System.Linq.EnumerableExecutor`1, namespace: System.Linq
  DNEnumerableQuery = interface; // type: System.Linq.EnumerableQuery, namespace: System.Linq
  DNEnumerableQuery<T> = interface; // type: System.Linq.EnumerableQuery`1, namespace: System.Linq
  DNCatchBlock = interface; // type: System.Linq.Expressions.CatchBlock, namespace: System.Linq.Expressions
  DNElementInit = interface; // type: System.Linq.Expressions.ElementInit, namespace: System.Linq.Expressions
  DNExpression = interface; // type: System.Linq.Expressions.Expression, namespace: System.Linq.Expressions
  DNBinaryExpression = interface; // type: System.Linq.Expressions.BinaryExpression, namespace: System.Linq.Expressions
  DNBlockExpression = interface; // type: System.Linq.Expressions.BlockExpression, namespace: System.Linq.Expressions
  DNConditionalExpression = interface; // type: System.Linq.Expressions.ConditionalExpression, namespace: System.Linq.Expressions
  DNConstantExpression = interface; // type: System.Linq.Expressions.ConstantExpression, namespace: System.Linq.Expressions
  DNDebugInfoExpression = interface; // type: System.Linq.Expressions.DebugInfoExpression, namespace: System.Linq.Expressions
  DNDefaultExpression = interface; // type: System.Linq.Expressions.DefaultExpression, namespace: System.Linq.Expressions
  DNDynamicExpression = interface; // type: System.Linq.Expressions.DynamicExpression, namespace: System.Linq.Expressions
  DNGotoExpression = interface; // type: System.Linq.Expressions.GotoExpression, namespace: System.Linq.Expressions
  DNIndexExpression = interface; // type: System.Linq.Expressions.IndexExpression, namespace: System.Linq.Expressions
  DNInvocationExpression = interface; // type: System.Linq.Expressions.InvocationExpression, namespace: System.Linq.Expressions
  DNLabelExpression = interface; // type: System.Linq.Expressions.LabelExpression, namespace: System.Linq.Expressions
  DNLambdaExpression = interface; // type: System.Linq.Expressions.LambdaExpression, namespace: System.Linq.Expressions
  DNExpression<TDelegate> = interface; // type: System.Linq.Expressions.Expression`1, namespace: System.Linq.Expressions
  DNListInitExpression = interface; // type: System.Linq.Expressions.ListInitExpression, namespace: System.Linq.Expressions
  DNLoopExpression = interface; // type: System.Linq.Expressions.LoopExpression, namespace: System.Linq.Expressions
  DNMemberExpression = interface; // type: System.Linq.Expressions.MemberExpression, namespace: System.Linq.Expressions
  DNMemberInitExpression = interface; // type: System.Linq.Expressions.MemberInitExpression, namespace: System.Linq.Expressions
  DNMethodCallExpression = interface; // type: System.Linq.Expressions.MethodCallExpression, namespace: System.Linq.Expressions
  DNNewArrayExpression = interface; // type: System.Linq.Expressions.NewArrayExpression, namespace: System.Linq.Expressions
  DNNewExpression = interface; // type: System.Linq.Expressions.NewExpression, namespace: System.Linq.Expressions
  DNParameterExpression = interface; // type: System.Linq.Expressions.ParameterExpression, namespace: System.Linq.Expressions
  DNRuntimeVariablesExpression = interface; // type: System.Linq.Expressions.RuntimeVariablesExpression, namespace: System.Linq.Expressions
  DNSwitchExpression = interface; // type: System.Linq.Expressions.SwitchExpression, namespace: System.Linq.Expressions
  DNTryExpression = interface; // type: System.Linq.Expressions.TryExpression, namespace: System.Linq.Expressions
  DNTypeBinaryExpression = interface; // type: System.Linq.Expressions.TypeBinaryExpression, namespace: System.Linq.Expressions
  DNUnaryExpression = interface; // type: System.Linq.Expressions.UnaryExpression, namespace: System.Linq.Expressions
  DNExpressionVisitor = interface; // type: System.Linq.Expressions.ExpressionVisitor, namespace: System.Linq.Expressions
  DNDynamicExpressionVisitor = interface; // type: System.Linq.Expressions.DynamicExpressionVisitor, namespace: System.Linq.Expressions
  DNLabelTarget = interface; // type: System.Linq.Expressions.LabelTarget, namespace: System.Linq.Expressions
  DNMemberBinding = interface; // type: System.Linq.Expressions.MemberBinding, namespace: System.Linq.Expressions
  DNMemberAssignment = interface; // type: System.Linq.Expressions.MemberAssignment, namespace: System.Linq.Expressions
  DNMemberListBinding = interface; // type: System.Linq.Expressions.MemberListBinding, namespace: System.Linq.Expressions
  DNMemberMemberBinding = interface; // type: System.Linq.Expressions.MemberMemberBinding, namespace: System.Linq.Expressions
  DNSwitchCase = interface; // type: System.Linq.Expressions.SwitchCase, namespace: System.Linq.Expressions
  DNSymbolDocumentInfo = interface; // type: System.Linq.Expressions.SymbolDocumentInfo, namespace: System.Linq.Expressions
  DNLookup<TKey, TElement> = interface; // type: System.Linq.Lookup`2, namespace: System.Linq
  DNParallelEnumerable = interface; // type: System.Linq.ParallelEnumerable, namespace: System.Linq
  DNParallelQuery = interface; // type: System.Linq.ParallelQuery, namespace: System.Linq
  DNParallelQuery<TSource> = interface; // type: System.Linq.ParallelQuery`1, namespace: System.Linq
  DNOrderedParallelQuery<TSource> = interface; // type: System.Linq.OrderedParallelQuery`1, namespace: System.Linq
  DNQueryable = interface; // type: System.Linq.Queryable, namespace: System.Linq
  DNEventProviderTraceListener = interface; // type: System.Diagnostics.Eventing.EventProviderTraceListener, namespace: System.Diagnostics.Eventing
  DNEventSchemaTraceListener = interface; // type: System.Diagnostics.EventSchemaTraceListener, namespace: System.Diagnostics
  DNPipeStream = interface; // type: System.IO.Pipes.PipeStream, namespace: System.IO.Pipes
  DNAnonymousPipeClientStream = interface; // type: System.IO.Pipes.AnonymousPipeClientStream, namespace: System.IO.Pipes
  DNAnonymousPipeServerStream = interface; // type: System.IO.Pipes.AnonymousPipeServerStream, namespace: System.IO.Pipes
  DNNamedPipeClientStream = interface; // type: System.IO.Pipes.NamedPipeClientStream, namespace: System.IO.Pipes
  DNNamedPipeServerStream = interface; // type: System.IO.Pipes.NamedPipeServerStream, namespace: System.IO.Pipes
  DNMemoryMappedViewStream = interface; // type: System.IO.MemoryMappedFiles.MemoryMappedViewStream, namespace: System.IO.MemoryMappedFiles
  DNComAwareEventInfo = interface; // type: System.Runtime.InteropServices.ComAwareEventInfo, namespace: System.Runtime.InteropServices
  DNCallSite = interface; // type: System.Runtime.CompilerServices.CallSite, namespace: System.Runtime.CompilerServices
  DNCallSite<T> = interface; // type: System.Runtime.CompilerServices.CallSite`1, namespace: System.Runtime.CompilerServices
  DNCallSiteBinder = interface; // type: System.Runtime.CompilerServices.CallSiteBinder, namespace: System.Runtime.CompilerServices
  DNDynamicMetaObjectBinder = interface; // type: System.Dynamic.DynamicMetaObjectBinder, namespace: System.Dynamic
  DNBinaryOperationBinder = interface; // type: System.Dynamic.BinaryOperationBinder, namespace: System.Dynamic
  DNConvertBinder = interface; // type: System.Dynamic.ConvertBinder, namespace: System.Dynamic
  DNCreateInstanceBinder = interface; // type: System.Dynamic.CreateInstanceBinder, namespace: System.Dynamic
  DNDeleteIndexBinder = interface; // type: System.Dynamic.DeleteIndexBinder, namespace: System.Dynamic
  DNDeleteMemberBinder = interface; // type: System.Dynamic.DeleteMemberBinder, namespace: System.Dynamic
  DNGetIndexBinder = interface; // type: System.Dynamic.GetIndexBinder, namespace: System.Dynamic
  DNGetMemberBinder = interface; // type: System.Dynamic.GetMemberBinder, namespace: System.Dynamic
  DNInvokeBinder = interface; // type: System.Dynamic.InvokeBinder, namespace: System.Dynamic
  DNInvokeMemberBinder = interface; // type: System.Dynamic.InvokeMemberBinder, namespace: System.Dynamic
  DNSetIndexBinder = interface; // type: System.Dynamic.SetIndexBinder, namespace: System.Dynamic
  DNSetMemberBinder = interface; // type: System.Dynamic.SetMemberBinder, namespace: System.Dynamic
  DNUnaryOperationBinder = interface; // type: System.Dynamic.UnaryOperationBinder, namespace: System.Dynamic
  DNCallSiteHelpers = interface; // type: System.Runtime.CompilerServices.CallSiteHelpers, namespace: System.Runtime.CompilerServices
  DNCallSiteOps = interface; // type: System.Runtime.CompilerServices.CallSiteOps, namespace: System.Runtime.CompilerServices
  DNClosure = interface; // type: System.Runtime.CompilerServices.Closure, namespace: System.Runtime.CompilerServices
  DNDebugInfoGenerator = interface; // type: System.Runtime.CompilerServices.DebugInfoGenerator, namespace: System.Runtime.CompilerServices
  DNExecutionScope = interface; // type: System.Runtime.CompilerServices.ExecutionScope, namespace: System.Runtime.CompilerServices
  DNReadOnlyCollectionBuilder<T> = interface; // type: System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1, namespace: System.Runtime.CompilerServices
  DNRuleCache<T> = interface; // type: System.Runtime.CompilerServices.RuleCache`1, namespace: System.Runtime.CompilerServices
  DNRuntimeOps = interface; // type: System.Runtime.CompilerServices.RuntimeOps, namespace: System.Runtime.CompilerServices
  DNStrongBox<T> = interface; // type: System.Runtime.CompilerServices.StrongBox`1, namespace: System.Runtime.CompilerServices
  DNSafeMemoryMappedFileHandle = interface; // type: Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle, namespace: Microsoft.Win32.SafeHandles
  DNSafeNCryptHandle = interface; // type: Microsoft.Win32.SafeHandles.SafeNCryptHandle, namespace: Microsoft.Win32.SafeHandles
  DNSafeNCryptKeyHandle = interface; // type: Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle, namespace: Microsoft.Win32.SafeHandles
  DNSafeNCryptProviderHandle = interface; // type: Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle, namespace: Microsoft.Win32.SafeHandles
  DNSafeNCryptSecretHandle = interface; // type: Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle, namespace: Microsoft.Win32.SafeHandles
  DNSafePipeHandle = interface; // type: Microsoft.Win32.SafeHandles.SafePipeHandle, namespace: Microsoft.Win32.SafeHandles
  DNSafeMemoryMappedViewHandle = interface; // type: Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle, namespace: Microsoft.Win32.SafeHandles
  DNPipeAccessRule = interface; // type: System.IO.Pipes.PipeAccessRule, namespace: System.IO.Pipes
  DNPipeAuditRule = interface; // type: System.IO.Pipes.PipeAuditRule, namespace: System.IO.Pipes
  DNPipeSecurity = interface; // type: System.IO.Pipes.PipeSecurity, namespace: System.IO.Pipes
  DNMemoryMappedFileSecurity = interface; // type: System.IO.MemoryMappedFiles.MemoryMappedFileSecurity, namespace: System.IO.MemoryMappedFiles
  DNDSACng = interface; // type: System.Security.Cryptography.DSACng, namespace: System.Security.Cryptography
  DNECDiffieHellman = interface; // type: System.Security.Cryptography.ECDiffieHellman, namespace: System.Security.Cryptography
  DNECDiffieHellmanCng = interface; // type: System.Security.Cryptography.ECDiffieHellmanCng, namespace: System.Security.Cryptography
  DNECDsa = interface; // type: System.Security.Cryptography.ECDsa, namespace: System.Security.Cryptography
  DNECDsaCng = interface; // type: System.Security.Cryptography.ECDsaCng, namespace: System.Security.Cryptography
  DNRSACng = interface; // type: System.Security.Cryptography.RSACng, namespace: System.Security.Cryptography
  DNCngAlgorithm = interface; // type: System.Security.Cryptography.CngAlgorithm, namespace: System.Security.Cryptography
  DNCngAlgorithmGroup = interface; // type: System.Security.Cryptography.CngAlgorithmGroup, namespace: System.Security.Cryptography
  DNCngKey = interface; // type: System.Security.Cryptography.CngKey, namespace: System.Security.Cryptography
  DNCngKeyBlobFormat = interface; // type: System.Security.Cryptography.CngKeyBlobFormat, namespace: System.Security.Cryptography
  DNCngKeyCreationParameters = interface; // type: System.Security.Cryptography.CngKeyCreationParameters, namespace: System.Security.Cryptography
  DNCngProvider = interface; // type: System.Security.Cryptography.CngProvider, namespace: System.Security.Cryptography
  DNCngUIPolicy = interface; // type: System.Security.Cryptography.CngUIPolicy, namespace: System.Security.Cryptography
  DNECCurve_NamedCurves = interface; // type: System.Security.Cryptography.ECCurve+NamedCurves, namespace: System.Security.Cryptography
  DNECDiffieHellmanPublicKey = interface; // type: System.Security.Cryptography.ECDiffieHellmanPublicKey, namespace: System.Security.Cryptography
  DNECDiffieHellmanCngPublicKey = interface; // type: System.Security.Cryptography.ECDiffieHellmanCngPublicKey, namespace: System.Security.Cryptography
  DNMD5Cng = interface; // type: System.Security.Cryptography.MD5Cng, namespace: System.Security.Cryptography
  DNSHA1Cng = interface; // type: System.Security.Cryptography.SHA1Cng, namespace: System.Security.Cryptography
  DNSHA256Cng = interface; // type: System.Security.Cryptography.SHA256Cng, namespace: System.Security.Cryptography
  DNSHA256CryptoServiceProvider = interface; // type: System.Security.Cryptography.SHA256CryptoServiceProvider, namespace: System.Security.Cryptography
  DNSHA384Cng = interface; // type: System.Security.Cryptography.SHA384Cng, namespace: System.Security.Cryptography
  DNSHA384CryptoServiceProvider = interface; // type: System.Security.Cryptography.SHA384CryptoServiceProvider, namespace: System.Security.Cryptography
  DNSHA512Cng = interface; // type: System.Security.Cryptography.SHA512Cng, namespace: System.Security.Cryptography
  DNSHA512CryptoServiceProvider = interface; // type: System.Security.Cryptography.SHA512CryptoServiceProvider, namespace: System.Security.Cryptography
  DNIncrementalHash = interface; // type: System.Security.Cryptography.IncrementalHash, namespace: System.Security.Cryptography
  DNManifestSignatureInformation = interface; // type: System.Security.Cryptography.ManifestSignatureInformation, namespace: System.Security.Cryptography
  DNStrongNameSignatureInformation = interface; // type: System.Security.Cryptography.StrongNameSignatureInformation, namespace: System.Security.Cryptography
  DNAesCng = interface; // type: System.Security.Cryptography.AesCng, namespace: System.Security.Cryptography
  DNAesCryptoServiceProvider = interface; // type: System.Security.Cryptography.AesCryptoServiceProvider, namespace: System.Security.Cryptography
  DNAesManaged = interface; // type: System.Security.Cryptography.AesManaged, namespace: System.Security.Cryptography
  DNTripleDESCng = interface; // type: System.Security.Cryptography.TripleDESCng, namespace: System.Security.Cryptography
  DNAuthenticodeSignatureInformation = interface; // type: System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation, namespace: System.Security.Cryptography.X509Certificates
  DNCertificateRequest = interface; // type: System.Security.Cryptography.X509Certificates.CertificateRequest, namespace: System.Security.Cryptography.X509Certificates
  DNDSACertificateExtensions = interface; // type: System.Security.Cryptography.X509Certificates.DSACertificateExtensions, namespace: System.Security.Cryptography.X509Certificates
  DNECDsaCertificateExtensions = interface; // type: System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions, namespace: System.Security.Cryptography.X509Certificates
  DNRSACertificateExtensions = interface; // type: System.Security.Cryptography.X509Certificates.RSACertificateExtensions, namespace: System.Security.Cryptography.X509Certificates
  DNSubjectAlternativeNameBuilder = interface; // type: System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder, namespace: System.Security.Cryptography.X509Certificates
  DNTimestampInformation = interface; // type: System.Security.Cryptography.X509Certificates.TimestampInformation, namespace: System.Security.Cryptography.X509Certificates
  DNX509SignatureGenerator = interface; // type: System.Security.Cryptography.X509Certificates.X509SignatureGenerator, namespace: System.Security.Cryptography.X509Certificates
  DNReaderWriterLockSlim = interface; // type: System.Threading.ReaderWriterLockSlim, namespace: System.Threading
  DNTaskExtensions = interface; // type: System.Threading.Tasks.TaskExtensions, namespace: System.Threading.Tasks
  DNHashSet_Enumerator<T> = interface; // type: System.Collections.Generic.HashSet`1+Enumerator, namespace: System.Collections.Generic
  DNEventDescriptor = interface; // type: System.Diagnostics.Eventing.EventDescriptor, namespace: System.Diagnostics.Eventing
  DNCngProperty = interface; // type: System.Security.Cryptography.CngProperty, namespace: System.Security.Cryptography
  DNECCurve = interface; // type: System.Security.Cryptography.ECCurve, namespace: System.Security.Cryptography
  DNECParameters = interface; // type: System.Security.Cryptography.ECParameters, namespace: System.Security.Cryptography
  DNECPoint = interface; // type: System.Security.Cryptography.ECPoint, namespace: System.Security.Cryptography

{ delegates }

  ///<summary>Encapsulates a method that has 10 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`10')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10) of object;

  ///<summary>Encapsulates a method that has 11 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`11')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11) of object;

  ///<summary>Encapsulates a method that has 12 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`12')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12) of object;

  ///<summary>Encapsulates a method that has 13 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`13')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13) of object;

  ///<summary>Encapsulates a method that has 14 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`14')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13; arg14: T14) of object;

  ///<summary>Encapsulates a method that has 15 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///     </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`15')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13; arg14: T14; arg15: T15) of object;

  ///<summary>Encapsulates a method that has 16 parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`16')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13; arg14: T14; arg15: T15; arg16: T16) of object;

  ///<summary>Encapsulates a method that has nine parameters and does not return a value.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam>
  [DNTypeName('System.Action`9')]
  DNAction<T1, T2, T3, T4, T5, T6, T7, T8, T9> = procedure(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9) of object;

  ///<summary>Encapsulates a method that has nine parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`10')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9): TResult of object;

  ///<summary>Encapsulates a method that has 10 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`11')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10): TResult of object;

  ///<summary>Encapsulates a method that has 11 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`12')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11): TResult of object;

  ///<summary>Encapsulates a method that has 12 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`13')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12): TResult of object;

  ///<summary>Encapsulates a method that has 13 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`14')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13): TResult of object;

  ///<summary>Encapsulates a method that has 14 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`15')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13; arg14: T14): TResult of object;

  ///<summary>Encapsulates a method that has 15 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`16')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13; arg14: T14; arg15: T15): TResult of object;

  ///<summary>Encapsulates a method that has 16 parameters and returns a value of the type specified by the <paramref name="TResult" />
  ///  parameter.</summary>
  ///  <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
  ///  <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
  ///  ///    <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates
  ///    </typeparam><typeparam name="TResult">The type of the return value of the method that this delegate encapsulates
  ///    </typeparam><returns>The return value of the method that this delegate encapsulates
  ///    </returns>
  [DNTypeName('System.Func`17')]
  DNFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> = function(arg1: T1; arg2: T2; arg3: T3; arg4: T4; arg5: T5; arg6: T6; arg7: T7; arg8: T8; arg9: T9; arg10: T10; arg11: T11; arg12: T12; arg13: T13; arg14: T14; arg15: T15; arg16: T16): TResult of object;

  ///<summary>Represents the method to call as the client.</summary>
  [DNTypeName('System.IO.Pipes.PipeStreamImpersonationWorker')]
  DNPipeStreamImpersonationWorker = procedure of object;




{ objects }

  //-------------namespace: System.Linq----------------
  ///<summary>Represents a collection of objects that have a common key.</summary>
  ///<typeparam name="TKey">The type of the key of the <see cref="T:System.Linq.IGrouping`2" />
  ///  .</typeparam><typeparam name="TElement">The type of the values in the <see cref="T:System.Linq.IGrouping`2" />
  ///  .</typeparam>
  [DNTypeName('System.Linq.IGrouping`2')]
  DNIGrouping<TKey, TElement> = interface(DDN.mscorlib.DNIEnumerable<TElement>)
  ['{9CCECD6C-7922-345E-A182-6626F99CC460}']
  { getters & setters } 

    function get_Key: TKey;

  { propertys } 

    ///<summary>Gets the key of the <see cref="T:System.Linq.IGrouping`2" />
    ///  .</summary>
    ///<returns>The key of the <see cref="T:System.Linq.IGrouping`2" />
    ///  .</returns>
    property Key: TKey read get_Key;
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Defines an indexer, size property, and Boolean search method for data structures that map keys to <see cref="T:System.Collections.Generic.IEnumerable`1" />
  ///  sequences of values.</summary>
  ///<typeparam name="TKey">The type of the keys in the <see cref="T:System.Linq.ILookup`2" />
  ///  .</typeparam><typeparam name="TElement">The type of the elements in the <see cref="T:System.Collections.Generic.IEnumerable`1" />
  ///  sequences that make up the values in the <see cref="T:System.Linq.ILookup`2" />
  ///  .</typeparam>
  [DNTypeName('System.Linq.ILookup`2')]
  DNILookup<TKey, TElement> = interface(DDN.mscorlib.DNIEnumerable<DNIGrouping<TKey, TElement>>)
  ['{6B51090C-E837-3318-A840-0B5D95886587}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(key: TKey): DDN.mscorlib.DNIEnumerable<TElement>;

  { methods } 

    function &Contains(key: TKey): Boolean;

  { propertys } 

    ///<summary>Gets the number of key/value collection pairs in the <see cref="T:System.Linq.ILookup`2" />
    ///  .</summary>
    ///<returns>The number of key/value collection pairs in the <see cref="T:System.Linq.ILookup`2" />
    ///  .</returns>
    property Count: Int32 read get_Count;
    property Item[key: TKey]: DDN.mscorlib.DNIEnumerable<TElement> read get_Item; default;
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Represents a sorted sequence.</summary>
  ///<typeparam name="TElement">The type of the elements of the sequence.</typeparam>
  [DNTypeName('System.Linq.IOrderedEnumerable`1')]
  DNIOrderedEnumerable<TElement> = interface(DDN.mscorlib.DNIEnumerable<TElement>)
  ['{6EEB1E7D-F438-329E-BD25-428DAB0608A7}']
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Provides functionality to evaluate queries against a specific data source wherein the type of the data is known.</summary>
  ///<typeparam name="T">The type of the data in the data source.</typeparam>
  [DNTypeName('System.Linq.IQueryable`1')]
  DNIQueryable<T> = interface(DDN.mscorlib.DNIEnumerable<T>)
  ['{E2C91F76-C000-32D6-B5A1-1BB9AA1B5660}']
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Represents the result of a sorting operation.</summary>
  ///<typeparam name="T">The type of the content of the data source.</typeparam>
  [DNTypeName('System.Linq.IOrderedQueryable`1')]
  DNIOrderedQueryable<T> = interface(DNIQueryable<T>)
  ['{0FD6D6C3-C6F1-39DA-B3F5-1363BAEA7D94}']
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified.</summary>
  [DNTypeName('System.Linq.IQueryable')]
  DNIQueryable = interface(DDN.mscorlib.DNIEnumerable)
  ['{84F6F43C-A9A7-3658-91B4-B41B15CAEFF2}']
  { getters & setters } 

    function get_Expression: DNExpression;
    function get_ElementType: DDN.mscorlib.DNType;
    function get_Provider: DNIQueryProvider;

  { propertys } 

    ///<summary>Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that is associated with this instance of <see cref="T:System.Linq.IQueryable" />
    ///  .</returns>
    property Expression: DNExpression read get_Expression;
    ///<summary>Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable" />
    ///  is executed.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.</returns>
    property ElementType: DDN.mscorlib.DNType read get_ElementType;
    ///<summary>Gets the query provider that is associated with this data source.</summary>
    ///<returns>The <see cref="T:System.Linq.IQueryProvider" />
    ///  that is associated with this data source.</returns>
    property Provider: DNIQueryProvider read get_Provider;
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Represents the result of a sorting operation.</summary>
  [DNTypeName('System.Linq.IOrderedQueryable')]
  DNIOrderedQueryable = interface(DNIQueryable)
  ['{E5303F81-6FE2-37CC-893F-1BF7E067D44F}']
  end;

  //-------------namespace: System.Dynamic----------------
  ///<summary>Represents a dynamic object, that can have its operations bound at runtime.</summary>
  [DNTypeName('System.Dynamic.IDynamicMetaObjectProvider')]
  DNIDynamicMetaObjectProvider = interface(DDN.mscorlib.DNObject)
  ['{B86A98CC-DCC0-3205-8777-7911A07DAAAF}']
  { methods } 

    ///<summary>Returns the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  responsible for binding operations performed on this object.</summary>
    ///  <param name="parameter">The expression tree representation of the runtime value.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  to bind this object.</returns>
    function GetMetaObject(parameter: DNExpression): DNDynamicMetaObject;

  end;

  //-------------namespace: System.Dynamic----------------
  ///<summary>Represents information about a dynamic get member operation that indicates if the get member should invoke properties when they perform the get operation.</summary>
  [DNTypeName('System.Dynamic.IInvokeOnGetBinder')]
  DNIInvokeOnGetBinder = interface(DDN.mscorlib.DNObject)
  ['{ED40980B-63E1-325C-BC22-93E284CA8CD3}']
  { getters & setters } 

    function get_InvokeOnGet: Boolean;

  { propertys } 

    ///<summary>Gets the value indicating if this get member operation should invoke properties when they perform the get operation. The default value when this interface is not present is true.</summary>
    ///<returns>True if this get member operation should invoke properties when they perform the get operation; otherwise false.</returns>
    property InvokeOnGet: Boolean read get_InvokeOnGet;
  end;

  //-------------namespace: System.Linq.Expressions----------------
  ///  ///    <summary>Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression)
  ///      You should not use this API
  ///      It is only public due to DLL refactoring and exists only for internal performance optimizations
  ///    This enables two optimizations which reduce the size of expression trees
  ///      The first enables the tree nodes to hold onto an IList&lt;T&gt; instead of a ReadOnlyCollection
  ///      IList&lt;T&gt; saves the cost of allocating the ReadOnlyCollection for each node
  ///      The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4)
  ///      Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node
  ///    The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections
  ///      The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array
  ///    For the array case, the collection is typed to IList&lt;T&gt; instead of ReadOnlyCollection&lt;T&gt;
  ///      When the node is initially constructed it is an array
  ///      When the compiler accesses the members it uses this interface
  ///      Accessing array elements promotes the array to a ReadOnlyCollection
  ///    For the object case we store the first argument in a field typed to object
  ///      When the node is initially constructed, the field holds the Expression
  ///      The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression
  ///    ReturnObject to return the object that handles the Expression or ReadOnlyCollection case
  ///      When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection
  ///    It is important that the Expressions consistently return the same ReadOnlyCollection
  ///      Otherwise, the re-writer tree walker will break
  ///      It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node
  ///      Currently users can rely on object identity to tell if the node has changed
  ///      Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API
  ///    </summary>
  [DNTypeName('System.Linq.Expressions.IArgumentProvider')]
  DNIArgumentProvider = interface(DDN.mscorlib.DNObject)
  ['{6D1D0B80-3581-33F4-9261-6A4D710EDB5F}']
  { getters & setters } 

    function get_ArgumentCount: Int32;

  { methods } 

    ///<summary>Returns the argument at index, throwing if index is out of bounds.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
    ///  <param name="index">The index of the argument.</param>
    ///<returns>The argument at index, throwing if index is out of bounds as <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function GetArgument(index: Int32): DNExpression;

  { propertys } 

    ///<summary>Returns the number of arguments to the expression tree node.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
    ///<returns>The number of arguments to the expression tree node as <see cref="T:System.Int32" />
    ///  .</returns>
    property ArgumentCount: Int32 read get_ArgumentCount;
  end;

  //-------------namespace: System.Linq.Expressions----------------
  ///<summary>Provides an internal interface for accessing the arguments of DynamicExpression tree nodes as well as CallSite and Rewriting functionality.  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.</summary>
  [DNTypeName('System.Linq.Expressions.IDynamicExpression')]
  DNIDynamicExpression = interface(DNIArgumentProvider)
  ['{F2DF1DD2-D434-34A4-A72E-401019651DEC}']
  { getters & setters } 

    function get_DelegateType: DDN.mscorlib.DNType;

  { methods } 

    ///<summary>Rewrites this node replacing the dynamic expressionâ€™s arguments with the provided values.  The number of args needs to match the number of the current expression.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.  This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.</summary>
    ///  <param name="args">The arguments used to replace this node.</param>
    ///<returns>The rewritten node, but if no changes were made, then returns the same node.</returns>
    function Rewrite(args: TArray<DNExpression>): DNExpression;
    ///<summary>Optionally creates the CallSite and returns the CallSite for the DynamicExpressionâ€™s polymorphic inline cache.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
    ///<returns>The CallSite for the DynamicExpressionâ€™s polymorphic inline cache.</returns>
    function CreateCallSite: DDN.mscorlib.DNObject;

  { propertys } 

    ///<summary>Gets the delegate type used by the CallSite, which is the type of the rules used in the dynamic expressionâ€™s polymorhphic inline cache. </summary>
    ///<returns>The delegate type used by the CallSite.</returns>
    property DelegateType: DDN.mscorlib.DNType read get_DelegateType;
  end;

  //-------------namespace: System.Linq----------------
  ///<summary>Defines methods to create and execute queries that are described by an <see cref="T:System.Linq.IQueryable" />
  ///  object.</summary>
  [DNTypeName('System.Linq.IQueryProvider')]
  DNIQueryProvider = interface(DDN.mscorlib.DNObject)
  ['{B9608E43-658E-3B98-9448-8F93B7D6E50C}']
  { methods } 

    ///<summary>Constructs an <see cref="T:System.Linq.IQueryable" />
    ///  object that can evaluate the query represented by a specified expression tree.</summary>
    ///  <param name="expression">An expression tree that represents a LINQ query.</param>
    ///<returns>An <see cref="T:System.Linq.IQueryable" />
    ///  that can evaluate the query represented by the specified expression tree.</returns>
    function CreateQuery(expression: DNExpression): DNIQueryable;
    ///<summary>Executes the query represented by a specified expression tree.</summary>
    ///  <param name="expression">An expression tree that represents a LINQ query.</param>
    ///<returns>The value that results from executing the specified query.</returns>
    function Execute(expression: DNExpression): DDN.mscorlib.DNObject;

  end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  ///<summary>Represents the values of run-time variables.</summary>
  [DNTypeName('System.Runtime.CompilerServices.IRuntimeVariables')]
  DNIRuntimeVariables = interface(DDN.mscorlib.DNObject)
  ['{D2E28B60-F4E4-3614-8D43-5DAEEDB31E8E}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(index: Int32): DDN.mscorlib.DNObject;
    procedure set_Item(index: Int32; value: DDN.mscorlib.DNObject);

  { propertys } 

    ///<summary>Gets a count of the run-time variables.</summary>
    ///<returns>The number of run-time variables.</returns>
    property Count: Int32 read get_Count;
    property Item[index: Int32]: DDN.mscorlib.DNObject read get_Item write set_Item; default;
  end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  ///<summary>Defines a property for accessing the value that an object references.</summary>
  [DNTypeName('System.Runtime.CompilerServices.IStrongBox')]
  DNIStrongBox = interface(DDN.mscorlib.DNObject)
  ['{53080814-DA86-3D64-AA57-5B4C3EF730E5}']
  { getters & setters } 

    function get_Value: DDN.mscorlib.DNObject;
    procedure set_Value(value: DDN.mscorlib.DNObject);

  { propertys } 

    ///<summary>Gets or sets the value that an object references.</summary>
    ///<returns>The value that the object references.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value write set_Value;
  end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementEntityAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{B8D086AB-9B12-523D-A352-64D38E56DAE1}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEntityAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementEntityAttribute;

  end;

  ///<summary>The ManagementEntity attribute indicates that a class provides management information exposed through a WMI provider.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementEntityAttribute')]
  DNManagementEntityAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{53823D1D-B9B6-3076-94D8-8519297E9583}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_External: Boolean;
    procedure set_External(value: Boolean);
    function get_Singleton: Boolean;
    procedure set_Singleton(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the WMI class.</summary>
    ///<returns>A string that contains the name of the WMI class.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets a value that specifies whether the class represents a WMI class in a provider implemented external to the current assembly.</summary>
    ///<returns>A boolean value that is true if the class represents an external WMI class and false otherwise.</returns>
    property &External: Boolean read get_External write set_External;
    ///<summary>Specifies whether the associated class represents a singleton WMI class.</summary>
    ///<returns>A boolean value that is true if the class represents a singleton WMI class and false otherwise.</returns>
    property Singleton: Boolean read get_Singleton write set_Singleton;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementEntityAttribute = class(TDNGenericImport<DNManagementEntityAttributeClass, DNManagementEntityAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementMemberAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{59755F57-A148-5977-8840-004082C3337A}']
  end;

  ///<summary>This class is used by the WMI.NET Provider Extensions framework. It is the base class for all the management attributes that can be applied to members.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementMemberAttribute')]
  DNManagementMemberAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{541D72AD-B73A-38E0-B512-EF13FA98B26A}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementMemberAttribute = class(TDNGenericImport<DNManagementMemberAttributeClass, DNManagementMemberAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementCommitAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{B8D91077-046F-56D9-AAAB-F02B31E58203}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementCommitAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementCommitAttribute;

  end;

  ///<summary>The ManagementCommit attribute marks a method that is called when it is necessary to update a set of read-write properties in one, atomic operation.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementCommitAttribute')]
  DNManagementCommitAttribute = interface(DNManagementMemberAttribute)
  ['{B7ABE03A-04AB-3493-9620-ADD9DABADD51}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementCommitAttribute = class(TDNGenericImport<DNManagementCommitAttributeClass, DNManagementCommitAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementConfigurationAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{47FD3ABA-8079-5593-8727-642E27719355}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementConfigurationAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementConfigurationAttribute;

  end;

  ///<summary>The ManagementConfiguration attribute indicates that a property or field represents a read-write WMI property.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementConfigurationAttribute')]
  DNManagementConfigurationAttribute = interface(DNManagementMemberAttribute)
  ['{C9B58203-A921-36F8-A54B-3CAB0F089187}']
  { getters & setters } 

    function get_Mode: DNManagementConfigurationType;
    procedure set_Mode(value: DNManagementConfigurationType);
    function get_Schema: DDN.mscorlib.DNType;
    procedure set_Schema(value: DDN.mscorlib.DNType);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the mode of the property, which specifies whether changes to it are applied as soon as possible or when a commit method is called.</summary>
    ///<returns>Returns a <see cref="T:System.Management.Instrumentation.ManagementConfigurationType" />
    ///  that indicates whether the WMI property uses <see cref="F:System.Management.Instrumentation.ManagementConfigurationType.Apply" />
    ///  or <see cref="F:System.Management.Instrumentation.ManagementConfigurationType.OnCommit" />
    ///  mode.</returns>
    property Mode: DNManagementConfigurationType read get_Mode write set_Mode;
    ///<summary>Gets or sets a value that defines the type of output that the property that is marked with the ManagementConfiguration attribute will return.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  value representing the type of output that the property marked with the ManagementConfiguration attribute will return.</returns>
    property Schema: DDN.mscorlib.DNType read get_Schema write set_Schema;
    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementConfigurationAttribute = class(TDNGenericImport<DNManagementConfigurationAttributeClass, DNManagementConfigurationAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementKeyAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{2B6CC536-36E9-5F3D-AF2F-D59D1A1E0075}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementKeyAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementKeyAttribute;

  end;

  ///<summary>The ManagementKey attribute identifies the key properties of a WMI class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementKeyAttribute')]
  DNManagementKeyAttribute = interface(DNManagementMemberAttribute)
  ['{5CDB732B-452E-3422-A754-D76D70448B53}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementKeyAttribute = class(TDNGenericImport<DNManagementKeyAttributeClass, DNManagementKeyAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementNewInstanceAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{90F18510-C781-5FE3-81FD-C2A07D6ACC87}']
  end;

  ///<summary>The base class for management attributes that have only run-time functionality and no schema representation. The management attribute classes ManagementBindAttribute, ManagementCreateAttribute and ManagementEnumeratorAttribute are all derived from this class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementNewInstanceAttribute')]
  DNManagementNewInstanceAttribute = interface(DNManagementMemberAttribute)
  ['{8076768E-AF9A-3247-9486-36583F155826}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementNewInstanceAttribute = class(TDNGenericImport<DNManagementNewInstanceAttributeClass, DNManagementNewInstanceAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementBindAttributeClass = interface(DNManagementNewInstanceAttributeClass)
  ['{5F162B06-5FAF-5E39-9A77-5E92663FF720}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementBindAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementBindAttribute;

  end;

  ///<summary>The ManagementBind attribute indicates that a method is used to return the instance of a WMI class associated with a specific key value.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementBindAttribute')]
  DNManagementBindAttribute = interface(DNManagementNewInstanceAttribute)
  ['{BB2DBF33-A3FD-3167-AE87-9767ADBD1641}']
  { getters & setters } 

    function get_Schema: DDN.mscorlib.DNType;
    procedure set_Schema(value: DDN.mscorlib.DNType);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that defines the type of output that the method that is marked with the ManagementEnumerator attribute will output.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  value that indicates the type of output that the method marked with the <see cref="ManagementBind" />
    ///  attribute will output.</returns>
    property Schema: DDN.mscorlib.DNType read get_Schema write set_Schema;
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementBindAttribute = class(TDNGenericImport<DNManagementBindAttributeClass, DNManagementBindAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementCreateAttributeClass = interface(DNManagementNewInstanceAttributeClass)
  ['{D48D267A-B894-5FFB-B851-D0CCD265994F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementCreateAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementCreateAttribute;

  end;

  ///<summary>The ManagementCreateAttribute is used to indicate that a method creates a new instance of a managed entity.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementCreateAttribute')]
  DNManagementCreateAttribute = interface(DNManagementNewInstanceAttribute)
  ['{73F8A513-C17A-3F82-AD39-F54E59BDC29F}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementCreateAttribute = class(TDNGenericImport<DNManagementCreateAttributeClass, DNManagementCreateAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementEnumeratorAttributeClass = interface(DNManagementNewInstanceAttributeClass)
  ['{A347E947-EBA6-560D-9708-DF12AD0EAB06}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEnumeratorAttribute" />
    ///  class.</summary>
    {class} function init: DNManagementEnumeratorAttribute;

  end;

  ///<summary>The ManagementEnumerator attribute marks a method that returns all the instances of a WMI class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementEnumeratorAttribute')]
  DNManagementEnumeratorAttribute = interface(DNManagementNewInstanceAttribute)
  ['{35E186C4-6DF8-3C6F-8616-CBFE37BA9FE7}']
  { getters & setters } 

    function get_Schema: DDN.mscorlib.DNType;
    procedure set_Schema(value: DDN.mscorlib.DNType);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that defines the type of output that the method that is marked with the ManagementEnumerator attribute will output.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  value that indicates the type of output that the method marked with the <see cref="ManagementEnumerator" />
    ///  attribute will output.</returns>
    property Schema: DDN.mscorlib.DNType read get_Schema write set_Schema;
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementEnumeratorAttribute = class(TDNGenericImport<DNManagementEnumeratorAttributeClass, DNManagementEnumeratorAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementProbeAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{38F5AE86-B09D-5FB4-A943-5A3F3154CAC8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementProbeAttribute" />
    ///  class. This is the default constructor for the class.</summary>
    {class} function init: DNManagementProbeAttribute;

  end;

  ///<summary>The ManagementProbe attribute indicates that a property or field represents a read-only WMI property.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementProbeAttribute')]
  DNManagementProbeAttribute = interface(DNManagementMemberAttribute)
  ['{E4A957F4-8DE2-3250-A26E-ECE78E4102F3}']
  { getters & setters } 

    function get_Schema: DDN.mscorlib.DNType;
    procedure set_Schema(value: DDN.mscorlib.DNType);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that defines the type of output that the property that is marked with the ManagementProbe attribute will output.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  value that indicates the type of output that the property that is marked with the ManagementProbe attribute will output.</returns>
    property Schema: DDN.mscorlib.DNType read get_Schema write set_Schema;
    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementProbeAttribute = class(TDNGenericImport<DNManagementProbeAttributeClass, DNManagementProbeAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementRemoveAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{72ADFF59-862B-556B-9C7B-E62D256BE900}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementRemoveAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementRemoveAttribute;

  end;

  ///<summary>The ManagementRemoveAttribute is used to indicate that a method cleans up an instance of a managed entity.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementRemoveAttribute')]
  DNManagementRemoveAttribute = interface(DNManagementMemberAttribute)
  ['{844E4DBB-F830-3531-AE85-3BE9B5482F16}']
  { getters & setters } 

    function get_Schema: DDN.mscorlib.DNType;
    procedure set_Schema(value: DDN.mscorlib.DNType);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that defines the type of output that the object that is marked with the ManagementRemove attribute will output.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  value that indicates the type of output that the object marked with the Remove attribute will output.</returns>
    property Schema: DDN.mscorlib.DNType read get_Schema write set_Schema;
    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementRemoveAttribute = class(TDNGenericImport<DNManagementRemoveAttributeClass, DNManagementRemoveAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementTaskAttributeClass = interface(DNManagementMemberAttributeClass)
  ['{98BB1A4E-4B7E-540D-8AAD-CFB24D799521}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementTaskAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementTaskAttribute;

  end;

  ///<summary>The ManagementTask attribute indicates that the target method implements a WMI method.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementTaskAttribute')]
  DNManagementTaskAttribute = interface(DNManagementMemberAttribute)
  ['{0BBF46BB-50BA-362E-B2CA-07299AD6636B}']
  { getters & setters } 

    function get_Schema: DDN.mscorlib.DNType;
    procedure set_Schema(value: DDN.mscorlib.DNType);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that defines the type of output that the method that is marked with the ManagementTask attribute will output.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  value that indicates the type of output that the method that is marked with the ManagementTask attribute will output.</returns>
    property Schema: DDN.mscorlib.DNType read get_Schema write set_Schema;
    ///<summary>Gets or sets the name of the management attribute.</summary>
    ///<returns>Returns a string which is the name of the management attribute.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementTaskAttribute = class(TDNGenericImport<DNManagementTaskAttributeClass, DNManagementTaskAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementNameAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{4D97168D-71C7-59BB-B7C4-1F897DB29557}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementNameAttribute" />
    ///  class that specifies a value for the <see cref="P:System.Management.ManagementNameAttribute.Name" />
    ///  property of the class.</summary>
    ///  <param name="name">The user-friendly name for the object.</param>
    {class} function init(name: string): DNManagementNameAttribute;

  end;

  ///<summary>The ManagementName attribute is used to override names exposed through a WMI class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementNameAttribute')]
  DNManagementNameAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{CC5D0CBD-863A-3CFD-97BF-E647B0F8A364}']
  { getters & setters } 

    function get_Name: string;
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the user-friendly name for an object. The object can be a method parameter or properties marked with the ManagementProbe, ManagementKey, or ManagementConfiguration attributes.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value that indicates the user friendly name for an object.</returns>
    property Name: string read get_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementNameAttribute = class(TDNGenericImport<DNManagementNameAttributeClass, DNManagementNameAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNManagementReferenceAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{F87D6FC2-FAD2-505F-BF22-D1937C134A83}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.ManagementReferenceAttribute" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNManagementReferenceAttribute;

  end;

  ///<summary>The ManagementReferenceAttribute marks a class member, property or method parameter as a reference to another management object or class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.ManagementReferenceAttribute')]
  DNManagementReferenceAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{3A6AF516-8364-331F-B48A-EBD46FC4FBFE}']
  { getters & setters } 

    function get_Type: string;
    procedure set_Type(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the referenced type.</summary>
    ///<returns>A string containing the name of the referenced type.</returns>
    property &Type: string read get_Type write set_Type;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNManagementReferenceAttribute = class(TDNGenericImport<DNManagementReferenceAttributeClass, DNManagementReferenceAttribute>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNWmiConfigurationAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{68A425D3-CBA3-5AD6-9FA4-6FA9A37794A0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.WmiConfigurationAttribute" />
    ///  class that specifies the WMI namespace in which the WMI provider will expose classes.</summary>
    ///  <param name="scope">The WMI namespace in which the provider will expose classes. For example, "root\MyProviderNamespace".</param>
    {class} function init(scope: string): DNWmiConfigurationAttribute;

  end;

  ///<summary>The WmiConfiguration attribute indicates that an assembly contains code that implements a WMI provider by using the WMI.NET Provider Extensions model. The attribute accepts parameters that establish the high-level configuration of the implemented WMI provider. Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.WmiConfigurationAttribute')]
  DNWmiConfigurationAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{80563157-8A58-3AB9-9F89-83209A273D90}']
  { getters & setters } 

    function get_SecurityRestriction: string;
    procedure set_SecurityRestriction(value: string);
    function get_NamespaceSecurity: string;
    procedure set_NamespaceSecurity(value: string);
    function get_IdentifyLevel: Boolean;
    procedure set_IdentifyLevel(value: Boolean);
    function get_HostingModel: DNManagementHostingModel;
    procedure set_HostingModel(value: DNManagementHostingModel);
    function get_HostingGroup: string;
    procedure set_HostingGroup(value: string);
    function get_Scope: string;
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a security descriptor for the WMI provider. For more information, see the SecurityDescriptor property information in the "__Win32Provider" topic in the MSDN online library at http://www.msdn.com. </summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value that contains the security descriptor for the WMI provider.</returns>
    property SecurityRestriction: string read get_SecurityRestriction write set_SecurityRestriction;
    ///<summary>Gets or sets a Security Descriptor Definition Language (SDDL) string that specifies the security descriptor on the namespace in which the provider exposes management objects.</summary>
    ///<returns>An SDDL string that represents the security descriptor on the namespace in which the provider exposes management objects.</returns>
    property NamespaceSecurity: string read get_NamespaceSecurity write set_NamespaceSecurity;
    ///<summary>Gets or sets a value that specifies whether the WMI provider can impersonate its callers. If the value is false, the provider cannot impersonate, and if the value is true, the provider can impersonate.</summary>
    ///<returns>A Boolean value that indicates whether a provider can or cannot impersonate its callers. If the value is false, the provider cannot impersonate, and if the value is true, the provider can impersonate.</returns>
    property IdentifyLevel: Boolean read get_IdentifyLevel write set_IdentifyLevel;
    ///<summary>Gets or sets the hosting model for the WMI provider.</summary>
    ///<returns>A <see cref="T:System.Management.Instrumentation.ManagementHostingModel" />
    ///  value that indicates the hosting model of the WMI provider.</returns>
    property HostingModel: DNManagementHostingModel read get_HostingModel write set_HostingModel;
    ///<summary>Gets or sets the hosting group for the WMI provider.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value that indicates the hosting group for the WMI provider.</returns>
    property HostingGroup: string read get_HostingGroup write set_HostingGroup;
    ///<summary>Gets or sets the WMI namespace in which the WMI provider exposes classes.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  value that indicates the namespace in which the WMI provider exposes classes.</returns>
    property Scope: string read get_Scope;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNWmiConfigurationAttribute = class(TDNGenericImport<DNWmiConfigurationAttributeClass, DNWmiConfigurationAttribute>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNDynamicAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{1A8F6EA3-A351-5A4C-94BE-2633A5B44677}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />
    ///  class.</summary>
    {class} function init: DNDynamicAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" />
    ///  class.</summary>
    ///  <param name="transformFlags">Specifies, in a prefix traversal of a type's construction, which <see cref="T:System.Object" />
    ///  occurrences are meant to be treated as a dynamically dispatched type.</param>
    {class} function init(transformFlags: TArray<Boolean>): DNDynamicAttribute; overload;

  end;

  ///<summary>Indicates that the use of <see cref="T:System.Object" />
  ///  on a member is meant to be treated as a dynamically dispatched type.</summary>
  [DNTypeName('System.Runtime.CompilerServices.DynamicAttribute')]
  DNDynamicAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{F36032CB-ED1F-3C03-9481-AD3F370F33B6}']
  { getters & setters } 

    function get_TransformFlags: DDN.mscorlib.DNIList<Boolean>;
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Specifies, in a prefix traversal of a type's construction, which <see cref="T:System.Object" />
    ///  occurrences are meant to be treated as a dynamically dispatched type.</summary>
    ///<returns>The list of <see cref="T:System.Object" />
    ///  occurrences that are meant to be treated as a dynamically dispatched type.</returns>
    property TransformFlags: DDN.mscorlib.DNIList<Boolean> read get_TransformFlags;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNDynamicAttribute = class(TDNGenericImport<DNDynamicAttributeClass, DNDynamicAttribute>) end;

  //-------------namespace: System.Collections.Generic----------------
  DNHashSetClass<T> = interface(DNObjectClass)
  ['{8B38CB70-C951-554A-BE2D-CE908C0A65D5}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  class that is empty and uses the default equality comparer for the set type.</summary>
    {class} function init: DNHashSet<T>; overload;
    {class} function init(capacity: Int32): DNHashSet<T>; overload;
    {class} function init(comparer: DDN.mscorlib.DNIEqualityComparer<T>): DNHashSet<T>; overload;
    {class} function init(collection: DDN.mscorlib.DNIEnumerable<T>): DNHashSet<T>; overload;
    {class} function init(collection: DDN.mscorlib.DNIEnumerable<T>; comparer: DDN.mscorlib.DNIEqualityComparer<T>): DNHashSet<T>; overload;
    {class} function init(capacity: Int32; comparer: DDN.mscorlib.DNIEqualityComparer<T>): DNHashSet<T>; overload;

  { static methods } 

    ///<summary>Returns an <see cref="T:System.Collections.IEqualityComparer" />
    ///  object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</summary>
    ///<returns>An <see cref="T:System.Collections.IEqualityComparer" />
    ///  object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</returns>
    {class} function CreateSetComparer: DDN.mscorlib.DNIEqualityComparer<DNHashSet<T>>;

  end;

  ///<summary>Represents a set of values.To browse the .NET Framework source code for this type, see the Reference Source.</summary>
  ///<typeparam name="T">The type of elements in the hash set.</typeparam>
  [DNTypeName('System.Collections.Generic.HashSet`1')]
  DNHashSet<T> = interface(DDN.mscorlib.DNICollection<T>)
  ['{3160CAC9-56AB-3595-8B2F-EBB706278EEF}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Comparer: DDN.mscorlib.DNIEqualityComparer<T>;

  { methods } 

    function &Contains(item: T): Boolean;
    procedure CopyTo(&array: TArray<T>; arrayIndex: Int32); overload;
    ///<summary>Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" />
    ///  object for the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</returns>
    function GetEnumerator: DNHashSet_Enumerator<T>;
    procedure UnionWith(other: DDN.mscorlib.DNIEnumerable<T>);
    procedure CopyTo(&array: TArray<T>); overload;
    procedure CopyTo(&array: TArray<T>; arrayIndex: Int32; count: Int32); overload;
    ///<summary>Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</summary>
    procedure TrimExcess;
    ///<summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" />
    ///  interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</summary>
    ///  <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</param>
    ///  <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="info" />
    ///  is <see langword="null" />
    ///  .</exception>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    ///<summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" />
    ///  interface and raises the deserialization event when the deserialization is complete.</summary>
    ///  <param name="sender">The source of the deserialization event.</param>
    ///<exception cref="T:System.Runtime.Serialization.SerializationException">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  object is invalid.</exception>
    procedure OnDeserialization(sender: DDN.mscorlib.DNObject);
    function TryGetValue(equalValue: T; out actualValue: T): Boolean;
    procedure IntersectWith(other: DDN.mscorlib.DNIEnumerable<T>);
    procedure ExceptWith(other: DDN.mscorlib.DNIEnumerable<T>);
    procedure SymmetricExceptWith(other: DDN.mscorlib.DNIEnumerable<T>);
    function IsSubsetOf(other: DDN.mscorlib.DNIEnumerable<T>): Boolean;
    function IsProperSubsetOf(other: DDN.mscorlib.DNIEnumerable<T>): Boolean;
    function IsSupersetOf(other: DDN.mscorlib.DNIEnumerable<T>): Boolean;
    function IsProperSupersetOf(other: DDN.mscorlib.DNIEnumerable<T>): Boolean;
    function Overlaps(other: DDN.mscorlib.DNIEnumerable<T>): Boolean;
    function SetEquals(other: DDN.mscorlib.DNIEnumerable<T>): Boolean;
    function RemoveWhere(match: DDN.mscorlib.DNPredicate<T>): Int32;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of elements that are contained in a set.</summary>
    ///<returns>The number of elements that are contained in the set.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" />
    ///  object that is used to determine equality for the values in the set.</summary>
    ///<returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1" />
    ///  object that is used to determine equality for the values in the set.</returns>
    property Comparer: DDN.mscorlib.DNIEqualityComparer<T> read get_Comparer;
  end;

  TDNHashSet<T> = class(TDNGenericImport<DNHashSetClass<T>, DNHashSet<T>>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngPropertyCollectionClass = interface(DDN.mscorlib.DNCollectionClass<DNCngProperty>)
  ['{AF936CFE-89D2-5C69-ABD9-21FFB145A2D2}']
  { constructors } 

    ///<summary>Initializes a new <see cref="T:System.Security.Cryptography.CngPropertyCollection" />
    ///  object.</summary>
    {class} function init: DNCngPropertyCollection;

  end;

  ///<summary>Provides a strongly typed collection of Cryptography Next Generation (CNG) properties.</summary>
  [DNTypeName('System.Security.Cryptography.CngPropertyCollection')]
  DNCngPropertyCollection = interface(DDN.mscorlib.DNCollection<DNCngProperty>)
  ['{9C7A6B6C-BCCD-32D0-B423-71F1B9DFDD61}']
  { getters & setters } 

    function get_Count: Int32;

  { methods } 

    procedure CopyTo(&array: TArray<DNCngProperty>; index: Int32);
    function &Contains(item: DNCngProperty): Boolean;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator<DNCngProperty>;
    function IndexOf(item: DNCngProperty): Int32;
    procedure Insert(index: Int32; item: DNCngProperty);
    procedure RemoveAt(index: Int32);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Count: Int32 read get_Count;
  end;

  TDNCngPropertyCollection = class(TDNGenericImport<DNCngPropertyCollectionClass, DNCngPropertyCollection>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNManifestSignatureInformationCollectionClass = interface(DDN.mscorlib.DNReadOnlyCollectionClass<DNManifestSignatureInformation>)
  ['{208DB70B-AC9E-5B40-B212-B0CB1E5751E8}']
  end;

  ///<summary>Represents a read-only collection of <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" />
  ///  objects.Â  </summary>
  [DNTypeName('System.Security.Cryptography.ManifestSignatureInformationCollection')]
  DNManifestSignatureInformationCollection = interface(DDN.mscorlib.DNReadOnlyCollection<DNManifestSignatureInformation>)
  ['{5A2850E9-7246-3A11-A348-8462B4BB27FB}']
  { getters & setters } 

    function get_Count: Int32;

  { methods } 

    function &Contains(value: DNManifestSignatureInformation): Boolean;
    procedure CopyTo(&array: TArray<DNManifestSignatureInformation>; index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator<DNManifestSignatureInformation>;
    function IndexOf(value: DNManifestSignatureInformation): Int32;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Count: Int32 read get_Count;
  end;

  TDNManifestSignatureInformationCollection = class(TDNGenericImport<DNManifestSignatureInformationCollectionClass, DNManifestSignatureInformationCollection>) end;

  //-------------namespace: System.Diagnostics.Eventing----------------
  DNEventProviderClass = interface(DNObjectClass)
  ['{52A96496-DC6F-5787-82E7-132A601C54B6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProvider" />
    ///  class.</summary>
    ///  <param name="providerGuid">Guid that uniquely identifies the provider.</param>
    ///<exception cref="T:System.InsufficientMemoryException">There is not enough memory to complete the operation.</exception><exception cref="T:System.PlatformNotSupportedException">The classes in the <see cref="N:System.Diagnostics.Eventing" />
    ///  namespace work only on Windows Vista.</exception><exception cref="T:System.ArgumentException">The <paramref name="providerGuid" />
    ///  parameter cannot be null.</exception><exception cref="T:System.ComponentModel.Win32Exception">An error returned by the ETW subsystem. </exception>
    {class} function init(providerGuid: DDN.mscorlib.DNGuid): DNEventProvider;

  { static methods } 

    ///<summary>Gets the last error associated with an event write failure.</summary>
    ///<returns>Use the value to determine the cause of an event write failure.</returns>
    {class} function GetLastWriteEventError: DNEventProvider_WriteEventErrorCode;
    {class} procedure SetActivityId(out id: DDN.mscorlib.DNGuid);
    ///<summary>Creates a unique activity identifier for the provider.</summary>
    ///<returns>A unique Guid that you use when calling the <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
    ///  method to set the activity identifier for the provider.</returns>
    {class} function CreateActivityId: DDN.mscorlib.DNGuid;

  end;

  ///<summary>Use this class to write events.</summary>
  [DNTypeName('System.Diagnostics.Eventing.EventProvider')]
  DNEventProvider = interface(DDN.mscorlib.DNIDisposable)
  ['{9934463F-339F-3087-AD9D-198169B01C5B}']
  { methods } 

    ///<summary>Releases the resources used by this <see cref="T:System.Diagnostics.Eventing.EventProvider" />
    ///  object.</summary>
    procedure Dispose;
    ///<summary>Removes the provider's registration from the ETW subsystem and releases all unmanaged resources.</summary>
    ///<exception cref="T:System.ComponentModel.Win32Exception">An error returned by the ETW subsystem. </exception>
    procedure Close;
    ///<summary>Determines whether any session enabled the provider, regardless of the level and keyword values used to enable the provider.</summary>
    ///<returns>Is <see langword="true" />
    ///  if the provider is enabled to any session; otherwise, <see langword="false" />
    ///  .</returns>
    function IsEnabled: Boolean; overload;
    ///<summary>Determines whether any session is requesting the specified event from the provider.</summary>
    ///  <param name="level">Level of detail included in the event.</param>
    ///  <param name="keywords">Bit mask that specifies the event category. This mask should be the same keyword mask that is defined in the manifest for the event.</param>
    ///<returns>Is <see langword="true" />
    ///  if any session is requesting the specified event; otherwise, <see langword="false" />
    ///  .</returns>
    function IsEnabled(level: Byte; keywords: Int64): Boolean; overload;
    ///<summary>Writes an event that contains a string as its data if the level and keyword value match the events requested by the session.</summary>
    ///  <param name="eventMessage">String to write as the event data.</param>
    ///  <param name="eventLevel">Level of detail included in the event. If the provider uses a manifest to define the event, set this value to the same level defined in the manifest.</param>
    ///  <param name="eventKeywords">Bit mask that specifies the event category. If the provider uses a manifest to define the event, set this value to the same keyword mask defined in the manifest.</param>
    ///<returns>Is <see langword="true" />
    ///  if the event is written; otherwise, <see langword="false" />
    ///  . If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
    ///  method to determine the cause of the failure.</returns>
    ///<exception cref="T:System.ArgumentException">If <paramref name="eventMessage" />
    ///  is <see langword="null" />
    ///  .</exception>
    function WriteMessageEvent(eventMessage: string; eventLevel: Byte; eventKeywords: Int64): Boolean; overload;
    ///<summary>Writes an event that contains a string as its data.</summary>
    ///  <param name="eventMessage">String to write as the event data.</param>
    ///<returns>Is <see langword="true" />
    ///  if the event is written; otherwise, <see langword="false" />
    ///  . If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
    ///  method to determine the cause of the failure.</returns>
    ///<exception cref="T:System.ArgumentException">If <paramref name="eventMessage" />
    ///  is <see langword="null" />
    ///  .</exception>
    function WriteMessageEvent(eventMessage: string): Boolean; overload;
    function WriteEvent(out eventDescriptor: DNEventDescriptor; eventPayload: TArray<DDN.mscorlib.DNObject>): Boolean; overload;
    function WriteEvent(out eventDescriptor: DNEventDescriptor; data: string): Boolean; overload;
    function WriteTransferEvent(out eventDescriptor: DNEventDescriptor; relatedActivityId: DDN.mscorlib.DNGuid; eventPayload: TArray<DDN.mscorlib.DNObject>): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEventProvider = class(TDNGenericImport<DNEventProviderClass, DNEventProvider>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventBookmarkClass = interface(DNObjectClass)
  ['{39002AEE-596A-5072-A5C9-C5223D4DF7F5}']
  end;

  ///<summary>Represents a placeholder (bookmark) within an event stream. You can use the placeholder to mark a position and return to this position in a stream of events. An instance of this object can be obtained from an <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />
  ///  object, in which case it corresponds to the position of that event record.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventBookmark')]
  DNEventBookmark = interface(DDN.mscorlib.DNISerializable)
  ['{3898E01B-7819-3A8A-9BCA-03F4E8CEADEB}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEventBookmark = class(TDNGenericImport<DNEventBookmarkClass, DNEventBookmark>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventKeywordClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6F266642-F04C-5C87-823F-B8FE8C2DBE7F}']
  end;

  ///<summary>Represents a keyword for an event. Keywords are defined in an event provider and are used to group the event with other similar events (based on the usage of the events).</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventKeyword')]
  DNEventKeyword = interface(DDN.mscorlib.DNObject)
  ['{371D98BB-FAB8-36C5-A58E-C0EFA52BA550}']
  { getters & setters } 

    function get_Name: string;
    function get_Value: Int64;
    function get_DisplayName: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the non-localized name of the keyword.</summary>
    ///<returns>Returns a string that contains the non-localized name of this keyword.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the numeric value associated with the keyword.</summary>
    ///<returns>Returns a <see langword="long" />
    ///  value.</returns>
    property Value: Int64 read get_Value;
    ///<summary>Gets the localized name of the keyword.</summary>
    ///<returns>Returns a string that contains a localized name for this keyword.</returns>
    property DisplayName: string read get_DisplayName;
  end;

  TDNEventKeyword = class(TDNGenericImport<DNEventKeywordClass, DNEventKeyword>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLevelClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D31EE6C8-2755-501D-809E-5126F3B108AA}']
  end;

  ///<summary>Contains an event level that is defined in an event provider. The level signifies the severity of the event.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLevel')]
  DNEventLevel = interface(DDN.mscorlib.DNObject)
  ['{3F7F447B-B55B-305D-A1E4-EB9A9840F592}']
  { getters & setters } 

    function get_Name: string;
    function get_Value: Int32;
    function get_DisplayName: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the non-localized name of the event level.</summary>
    ///<returns>Returns a string that contains the non-localized name of the event level.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the numeric value of the event level.</summary>
    ///<returns>Returns an integer value.</returns>
    property Value: Int32 read get_Value;
    ///<summary>Gets the localized name for the event level. The name describes what severity level of events this level is used for.</summary>
    ///<returns>Returns a string that contains the localized name for the event level.</returns>
    property DisplayName: string read get_DisplayName;
  end;

  TDNEventLevel = class(TDNGenericImport<DNEventLevelClass, DNEventLevel>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogConfigurationClass = interface(DNObjectClass)
  ['{A940016F-8202-52A2-B940-B3F8C3CFB0C0}']
  { constructors } 

    ///<summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogConfiguration" />
    ///  object by specifying the local event log for which to get information and configuration settings. </summary>
    ///  <param name="logName">The name of the local event log for which to get information and configuration settings.</param>
    {class} function init(logName: string): DNEventLogConfiguration; overload;
    ///<summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogConfiguration" />
    ///  object by specifying the name of the log for which to get information and configuration settings. The log can be on the local computer or a remote computer, based on the event log session specified.</summary>
    ///  <param name="logName">The name of the event log for which to get information and configuration settings.</param>
    ///  <param name="session">The event log session used to determine the event log service that the specified log belongs to. The session is either connected to the event log service on the local computer or a remote computer.</param>
    {class} function init(logName: string; session: DNEventLogSession): DNEventLogConfiguration; overload;

  end;

  ///<summary>Contains static information and configuration settings for an event log. Many of the configurations settings were defined by the event provider that created the log.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogConfiguration')]
  DNEventLogConfiguration = interface(DDN.mscorlib.DNIDisposable)
  ['{757E9EE3-FA81-37D6-A4B9-92DA6996789F}']
  { getters & setters } 

    function get_LogName: string;
    function get_LogType: DNEventLogType;
    function get_LogIsolation: DNEventLogIsolation;
    function get_IsEnabled: Boolean;
    procedure set_IsEnabled(value: Boolean);
    function get_IsClassicLog: Boolean;
    function get_SecurityDescriptor: string;
    procedure set_SecurityDescriptor(value: string);
    function get_LogFilePath: string;
    procedure set_LogFilePath(value: string);
    function get_MaximumSizeInBytes: Int64;
    procedure set_MaximumSizeInBytes(value: Int64);
    function get_LogMode: DNEventLogMode;
    procedure set_LogMode(value: DNEventLogMode);
    function get_OwningProviderName: string;
    function get_ProviderNames: DDN.mscorlib.DNIEnumerable<string>;
    function get_ProviderLevel: DDN.mscorlib.DNNullable<Int32>;
    procedure set_ProviderLevel(value: DDN.mscorlib.DNNullable<Int32>);
    function get_ProviderKeywords: DDN.mscorlib.DNNullable<Int64>;
    procedure set_ProviderKeywords(value: DDN.mscorlib.DNNullable<Int64>);
    function get_ProviderBufferSize: DDN.mscorlib.DNNullable<Int32>;
    function get_ProviderMinimumNumberOfBuffers: DDN.mscorlib.DNNullable<Int32>;
    function get_ProviderMaximumNumberOfBuffers: DDN.mscorlib.DNNullable<Int32>;
    function get_ProviderLatency: DDN.mscorlib.DNNullable<Int32>;
    function get_ProviderControlGuid: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;

  { methods } 

    ///<summary>Saves the configuration settings that </summary>
    procedure SaveChanges;
    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the event log.</summary>
    ///<returns>Returns a string that contains the name of the event log.</returns>
    property LogName: string read get_LogName;
    ///<summary>Gets an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogType" />
    ///  value that determines the type of the event log.</summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogType" />
    ///  value.</returns>
    property LogType: DNEventLogType read get_LogType;
    ///<summary>Gets an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogIsolation" />
    ///  value that specifies whether the event log is an application, system, or custom event log. </summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogIsolation" />
    ///  value.</returns>
    property LogIsolation: DNEventLogIsolation read get_LogIsolation;
    ///<summary>Gets or sets a Boolean value that determines whether the event log is enabled or disabled. An enabled log is one in which events can be logged, and a disabled log is one in which events cannot be logged.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the log is enabled, and returns <see langword="false" />
    ///  if the log is disabled.</returns>
    property IsEnabled: Boolean read get_IsEnabled write set_IsEnabled;
    ///<summary>Gets the flag that indicates if the event log is a classic event log. A classic event log is one that has its events defined in a .mc file instead of a manifest (.xml file) used by the event provider.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the event log is a classic log, and returns <see langword="false" />
    ///  if the event log is not a classic log.</returns>
    property IsClassicLog: Boolean read get_IsClassicLog;
    ///<summary>Gets or sets the security descriptor of the event log. The security descriptor defines the users and groups of users that can read and write to the event log.</summary>
    ///<returns>Returns a string that contains the security descriptor for the event log.</returns>
    property SecurityDescriptor: string read get_SecurityDescriptor write set_SecurityDescriptor;
    ///<summary>Gets or sets the file directory path to the location of the file where the events are stored for the log.</summary>
    ///<returns>Returns a string that contains the path to the event log file.</returns>
    property LogFilePath: string read get_LogFilePath write set_LogFilePath;
    ///<summary>Gets or sets the maximum size, in bytes, that the event log file is allowed to be. When the file reaches this maximum size, it is considered full.</summary>
    ///<returns>Returns a long value that represents the maximum size, in bytes, that the event log file is allowed to be.</returns>
    property MaximumSizeInBytes: Int64 read get_MaximumSizeInBytes write set_MaximumSizeInBytes;
    ///<summary>Gets or sets an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogMode" />
    ///  value that determines how events are handled when the event log becomes full.</summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogMode" />
    ///  value.</returns>
    property LogMode: DNEventLogMode read get_LogMode write set_LogMode;
    ///<summary>Gets the name of the event provider that created this event log.</summary>
    ///<returns>Returns a string that contains the name of the event provider that created this event log.</returns>
    property OwningProviderName: string read get_OwningProviderName;
    ///<summary>Gets an enumerable collection of the names of all the event providers that can publish events to this event log.</summary>
    ///<returns>Returns an enumerable collection of strings that contain the event provider names.</returns>
    property ProviderNames: DDN.mscorlib.DNIEnumerable<string> read get_ProviderNames;
    ///<summary>Gets or sets the maximum event level (which defines the severity of the event) that is allowed to be logged in the event log. This value is defined by the event provider.</summary>
    ///<returns>Returns an integer value that can be null if the maximum event level was not defined in the event provider.</returns>
    property ProviderLevel: DDN.mscorlib.DNNullable<Int32> read get_ProviderLevel write set_ProviderLevel;
    ///<summary>Gets or sets keyword mask used by the event provider.</summary>
    ///<returns>Returns a long value that can be null if the event provider did not define any keywords.</returns>
    property ProviderKeywords: DDN.mscorlib.DNNullable<Int64> read get_ProviderKeywords write set_ProviderKeywords;
    ///<summary>Gets the size of the buffer that the event provider uses for publishing events to the log.</summary>
    ///<returns>Returns an integer value that can be null.</returns>
    property ProviderBufferSize: DDN.mscorlib.DNNullable<Int32> read get_ProviderBufferSize;
    ///<summary>Gets the minimum number of buffers used by the event provider to publish events to the event log.</summary>
    ///<returns>Returns an integer value that is the minimum number of buffers used by the event provider to publish events to the event log. This value can be null.</returns>
    property ProviderMinimumNumberOfBuffers: DDN.mscorlib.DNNullable<Int32> read get_ProviderMinimumNumberOfBuffers;
    ///<summary>Gets the maximum number of buffers used by the event provider to publish events to the event log.</summary>
    ///<returns>Returns an integer value that is the maximum number of buffers used by the event provider to publish events to the event log. This value can be null.</returns>
    property ProviderMaximumNumberOfBuffers: DDN.mscorlib.DNNullable<Int32> read get_ProviderMaximumNumberOfBuffers;
    ///<summary>Gets the maximum latency time used by the event provider when publishing events to the log.</summary>
    ///<returns>Returns an integer value that can be null if no latency time was specified by the event provider.</returns>
    property ProviderLatency: DDN.mscorlib.DNNullable<Int32> read get_ProviderLatency;
    ///<summary>Gets the control globally unique identifier (GUID) for the event log if the log is a debug log. If this log is not a debug log, this value will be null. </summary>
    ///<returns>Returns a GUID value or null.</returns>
    property ProviderControlGuid: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_ProviderControlGuid;
  end;

  TDNEventLogConfiguration = class(TDNGenericImport<DNEventLogConfigurationClass, DNEventLogConfiguration>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogInformationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{51596AD5-E55C-50FE-B5E0-160F79AFA2EF}']
  end;

  ///<summary>Allows you to access the run-time properties of active event logs and event log files. These properties include the number of events in the log, the size of the log, a value that determines whether the log is full, and the last time the log was written to or accessed.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogInformation')]
  DNEventLogInformation = interface(DDN.mscorlib.DNObject)
  ['{C90F1181-30C8-38E5-9EC4-E3788587A4ED}']
  { getters & setters } 

    function get_CreationTime: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime>;
    function get_LastAccessTime: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime>;
    function get_LastWriteTime: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime>;
    function get_FileSize: DDN.mscorlib.DNNullable<Int64>;
    function get_Attributes: DDN.mscorlib.DNNullable<Int32>;
    function get_RecordCount: DDN.mscorlib.DNNullable<Int64>;
    function get_OldestRecordNumber: DDN.mscorlib.DNNullable<Int64>;
    function get_IsLogFull: DDN.mscorlib.DNNullable<Boolean>;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the time that the log file associated with the event log was created.</summary>
    ///<returns>Returns a <see cref="T:System.DateTime" />
    ///  object. This value can be null.</returns>
    property CreationTime: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime> read get_CreationTime;
    ///<summary>Gets the last time the log file associated with the event log was accessed.</summary>
    ///<returns>Returns a <see cref="T:System.DateTime" />
    ///  object. This value can be null.</returns>
    property LastAccessTime: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime> read get_LastAccessTime;
    ///<summary>Gets the last time data was written to the log file associated with the event log.</summary>
    ///<returns>Returns a <see cref="T:System.DateTime" />
    ///  object. This value can be null.</returns>
    property LastWriteTime: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime> read get_LastWriteTime;
    ///<summary>Gets the size of the file, in bytes, associated with the event log.</summary>
    ///<returns>Returns a long value.</returns>
    property FileSize: DDN.mscorlib.DNNullable<Int64> read get_FileSize;
    ///<summary>Gets the file attributes of the log file associated with the log.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Attributes: DDN.mscorlib.DNNullable<Int32> read get_Attributes;
    ///<summary>Gets the number of event records in the event log.</summary>
    ///<returns>Returns a long value that represents the number of event records in the event log. This value can be null.</returns>
    property RecordCount: DDN.mscorlib.DNNullable<Int64> read get_RecordCount;
    ///<summary>Gets the number of the oldest event record in the event log.</summary>
    ///<returns>Returns a long value that represents the number of the oldest event record in the event log. This value can be null.</returns>
    property OldestRecordNumber: DDN.mscorlib.DNNullable<Int64> read get_OldestRecordNumber;
    ///<summary>Gets a Boolean value that determines whether the log file has reached its maximum size (the log is full).</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the log is full, and returns <see langword="false" />
    ///  if the log is not full.</returns>
    property IsLogFull: DDN.mscorlib.DNNullable<Boolean> read get_IsLogFull;
  end;

  TDNEventLogInformation = class(TDNGenericImport<DNEventLogInformationClass, DNEventLogInformation>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogLinkClass = interface(DDN.mscorlib.DNObjectClass)
  ['{38E4F3DA-8620-5652-9011-F1338A7C0520}']
  end;

  ///<summary>Represents a link between an event provider and an event log that the provider publishes events into. This object cannot be instantiated.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogLink')]
  DNEventLogLink = interface(DDN.mscorlib.DNObject)
  ['{FD4CD649-8864-3E93-A0E6-284E537B1625}']
  { getters & setters } 

    function get_LogName: string;
    function get_IsImported: Boolean;
    function get_DisplayName: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the non-localized name of the event log associated with this object.</summary>
    ///<returns>Returns a string that contains the non-localized name of the event log associated with this object.</returns>
    property LogName: string read get_LogName;
    ///<summary>Gets a Boolean value that determines whether the event log is imported, rather than defined in the event provider. An imported event log is defined in a different provider.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the event log is imported by the event provider, and returns <see langword="false" />
    ///  if the event log is not imported by the event provider.</returns>
    property IsImported: Boolean read get_IsImported;
    ///<summary>Gets the localized name of the event log.</summary>
    ///<returns>Returns a string that contains the localized name of the event log.</returns>
    property DisplayName: string read get_DisplayName;
  end;

  TDNEventLogLink = class(TDNGenericImport<DNEventLogLinkClass, DNEventLogLink>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogPropertySelectorClass = interface(DNObjectClass)
  ['{BCCF9178-6F87-5F3A-95B1-A1E763CD03F0}']
  { constructors } 

    {class} function init(propertyQueries: DDN.mscorlib.DNIEnumerable<string>): DNEventLogPropertySelector;

  end;

  ///<summary>Contains an array of strings that represent XPath queries for elements in the XML representation of an event, which is based on the Event Schema. The queries in this object are used to extract values from the event.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogPropertySelector')]
  DNEventLogPropertySelector = interface(DDN.mscorlib.DNIDisposable)
  ['{2D01384E-A1DB-3E28-A8A3-8CBF27382A39}']
  { methods } 

    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEventLogPropertySelector = class(TDNGenericImport<DNEventLogPropertySelectorClass, DNEventLogPropertySelector>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogQueryClass = interface(DDN.mscorlib.DNObjectClass)
  ['{BD8EFA8B-A362-56CB-831C-935FF649BEFD}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogQuery" />
    ///  class by specifying the target of the query. The target can be an active event log or a log file.</summary>
    ///  <param name="path">The name of the event log to query, or the path to the event log file to query.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    {class} function init(path: string; pathType: DNPathType): DNEventLogQuery; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogQuery" />
    ///  class by specifying the target of the query and the event query. The target can be an active event log or a log file.</summary>
    ///  <param name="path">The name of the event log to query, or the path to the event log file to query.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    ///  <param name="query">The event query used to retrieve events that match the query conditions.</param>
    {class} function init(path: string; pathType: DNPathType; query: string): DNEventLogQuery; overload;

  end;

  ///<summary>Represents a query for events in an event log and the settings that define how the query is executed and on what computer the query is executed on.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogQuery')]
  DNEventLogQuery = interface(DDN.mscorlib.DNObject)
  ['{4A584020-F65A-3E95-86A7-EA767D7651EF}']
  { getters & setters } 

    function get_Session: DNEventLogSession;
    procedure set_Session(value: DNEventLogSession);
    function get_TolerateQueryErrors: Boolean;
    procedure set_TolerateQueryErrors(value: Boolean);
    function get_ReverseDirection: Boolean;
    procedure set_ReverseDirection(value: Boolean);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the session that access the Event Log service on the local computer or a remote computer. This object can be set to access a remote event log by creating a <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
    ///  object or an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" />
    ///  object with this <see cref="T:System.Diagnostics.Eventing.Reader.EventLogQuery" />
    ///  object.</summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
    ///  object.</returns>
    property Session: DNEventLogSession read get_Session write set_Session;
    ///<summary>Gets or sets a Boolean value that determines whether this query will continue to retrieve events when the query has an error.</summary>
    ///<returns><see langword="true" />
    ///  indicates that the query will continue to retrieve events even if the query fails for some logs, and <see langword="false" />
    ///  indicates that this query will not continue to retrieve events when the query fails.</returns>
    property TolerateQueryErrors: Boolean read get_TolerateQueryErrors write set_TolerateQueryErrors;
    ///<summary>Gets or sets the Boolean value that determines whether to read events from the newest event in an event log to the oldest event in the log.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if events are read from the newest event in the log to the oldest event, and returns <see langword="false" />
    ///  if events are read from the oldest event in the log to the newest event.</returns>
    property ReverseDirection: Boolean read get_ReverseDirection write set_ReverseDirection;
  end;

  TDNEventLogQuery = class(TDNGenericImport<DNEventLogQueryClass, DNEventLogQuery>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogReaderClass = interface(DNObjectClass)
  ['{E4F6B822-D8B5-5C77-9DD3-290B5041CB30}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
    ///  class by specifying an active event log to retrieve events from.</summary>
    ///  <param name="path">The name of the event log to retrieve events from.</param>
    {class} function init(path: string): DNEventLogReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
    ///  class by specifying the name of an event log to retrieve events from or the path to a log file to retrieve events from.</summary>
    ///  <param name="path">The name of the event log to retrieve events from, or the path to the event log file to retrieve events from.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    {class} function init(path: string; pathType: DNPathType): DNEventLogReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
    ///  class by specifying an event query.</summary>
    ///  <param name="eventQuery">The event query used to retrieve events.</param>
    {class} function init(eventQuery: DNEventLogQuery): DNEventLogReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
    ///  class by specifying an event query and a bookmark that is used as starting position for the query.</summary>
    ///  <param name="eventQuery">The event query used to retrieve events.</param>
    ///  <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events logged after the bookmark event will be returned by the query.</param>
    {class} function init(eventQuery: DNEventLogQuery; bookmark: DNEventBookmark): DNEventLogReader; overload;

  end;

  ///<summary>Enables you to read events from an event log based on an event query. The events that are read by this object are returned as <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />
  ///  objects.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogReader')]
  DNEventLogReader = interface(DDN.mscorlib.DNIDisposable)
  ['{E6AD8EF9-89FE-3054-A2FC-C268C003E5AF}']
  { getters & setters } 

    function get_BatchSize: Int32;
    procedure set_BatchSize(value: Int32);
    function get_LogStatus: DDN.mscorlib.DNIList<DNEventLogStatus>;

  { methods } 

    ///<summary>Reads the next event that is returned from the event query in this object.</summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />
    ///  object.</returns>
    function ReadEvent: DNEventRecord; overload;
    ///<summary>Reads the next event that is returned from the event query in this object.</summary>
    ///  <param name="timeout">The maximum time to allow the read operation to run before canceling the operation.</param>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />
    ///  object.</returns>
    function ReadEvent(timeout: DDN.mscorlib.DNTimeSpan): DNEventRecord; overload;
    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    ///<summary>Changes the position in the event stream where the next event that is read will come from by specifying a bookmark event. No events logged before the bookmark event will be retrieved.</summary>
    ///  <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
    procedure Seek(bookmark: DNEventBookmark); overload;
    ///<summary>Changes the position in the event stream where the next event that is read will come from by specifying a bookmark event and an offset number of events from the bookmark. No events logged before the bookmark plus the offset will be retrieved.</summary>
    ///  <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
    ///  <param name="offset">The offset number of events to change the position of the bookmark.</param>
    procedure Seek(bookmark: DNEventBookmark; offset: Int64); overload;
    ///<summary>Changes the position in the event stream where the next event that is read will come from by specifying a starting position and an offset from the starting position. No events logged before the starting position plus the offset will be retrieved.</summary>
    ///  <param name="origin">A value from the <see cref="T:System.IO.SeekOrigin" />
    ///  enumeration defines where in the stream of events to start querying for events.</param>
    ///  <param name="offset">The offset number of events to add to the origin.</param>
    procedure Seek(origin: DDN.mscorlib.DNSeekOrigin; offset: Int64); overload;
    ///<summary>Cancels the current query operation.</summary>
    procedure CancelReading;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the number of events retrieved from the stream of events on every read operation.</summary>
    ///<returns>Returns an integer value.</returns>
    property BatchSize: Int32 read get_BatchSize write set_BatchSize;
    ///<summary>Gets the status of each event log or log file associated with the event query in this object.</summary>
    ///<returns>Returns a list of <see cref="T:System.Diagnostics.Eventing.Reader.EventLogStatus" />
    ///  objects that each contain status information about an event log associated with the event query in this object.</returns>
    property LogStatus: DDN.mscorlib.DNIList<DNEventLogStatus> read get_LogStatus;
  end;

  TDNEventLogReader = class(TDNGenericImport<DNEventLogReaderClass, DNEventLogReader>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogSessionClass = interface(DNObjectClass)
  ['{8F82BBE7-5026-5E3D-9AF6-FBD5EDF8772E}']
  { static getter & setter } 

    {class} function get_GlobalSession: DNEventLogSession;

  { constructors } 

    ///<summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
    ///  object, establishes a connection with the local Event Log service.</summary>
    {class} function init: DNEventLogSession; overload;
    ///<summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
    ///  object, and establishes a connection with the Event Log service on the specified computer. The credentials (user name and password) of the user who calls the method is used for the credentials to access the remote computer.</summary>
    ///  <param name="server">The name of the computer on which to connect to the Event Log service.</param>
    {class} function init(server: string): DNEventLogSession; overload;
    ///<summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
    ///  object, and establishes a connection with the Event Log service on the specified computer. The specified credentials (user name and password) are used for the credentials to access the remote computer.</summary>
    ///  <param name="server">The name of the computer on which to connect to the Event Log service.</param>
    ///  <param name="domain">The domain of the specified user.</param>
    ///  <param name="user">The user name used to connect to the remote computer.</param>
    ///  <param name="password">The password used to connect to the remote computer.</param>
    ///  <param name="logOnType">The type of connection to use for the connection to the remote computer.</param>
    {class} function init(server: string; domain: string; user: string; password: DDN.mscorlib.DNSecureString; logOnType: DNSessionAuthentication): DNEventLogSession; overload;

  { static propertys } 

    ///<summary>Gets a static predefined session object that is connected to the Event Log service on the local computer.</summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
    ///  object that is a predefined session object that is connected to the Event Log service on the local computer.</returns>
    {class} property GlobalSession: DNEventLogSession read get_GlobalSession;
  end;

  ///<summary>Used to access the Event Log service on the local computer or a remote computer so you can manage and gather information about the event logs and event providers on the computer.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogSession')]
  DNEventLogSession = interface(DDN.mscorlib.DNIDisposable)
  ['{3C24798A-F126-32DD-8BE7-9F13FC43C203}']
  { methods } 

    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    ///<summary>Cancels any operations (such as reading an event log or subscribing to an event log) that are currently active for the Event Log service that this session object is connected to.</summary>
    procedure CancelCurrentOperations;
    ///<summary>Gets an object that contains runtime information for the specified event log.</summary>
    ///  <param name="logName">The name of the event log to get information about, or the path to the event log file to get information about.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInformation" />
    ///  object that contains information about the specified log.</returns>
    function GetLogInformation(logName: string; pathType: DNPathType): DNEventLogInformation;
    ///<summary>Exports events into an external log file. The events are stored without the event messages.</summary>
    ///  <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    ///  <param name="query">The query used to select the events to export.  Only the events returned from the query will be exported.</param>
    ///  <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
    procedure ExportLog(path: string; pathType: DNPathType; query: string; targetFilePath: string); overload;
    ///<summary>Exports events into an external log file. A flag can be set to indicate that the method will continue exporting events even if the specified query fails for some logs. The events are stored without the event messages.</summary>
    ///  <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    ///  <param name="query">The query used to select the events to export. Only the events returned from the query will be exported.</param>
    ///  <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
    ///  <param name="tolerateQueryErrors"><see langword="true" />
    ///  indicates that the method will continue exporting events even if the specified query fails for some logs, and <see langword="false" />
    ///  indicates that this method will not continue to export events when the specified query fails.</param>
    procedure ExportLog(path: string; pathType: DNPathType; query: string; targetFilePath: string; tolerateQueryErrors: Boolean); overload;
    ///<summary>Exports events and their messages into an external log file.</summary>
    ///  <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    ///  <param name="query">The query used to select the events to export.  Only the events returned from the query will be exported.</param>
    ///  <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
    procedure ExportLogAndMessages(path: string; pathType: DNPathType; query: string; targetFilePath: string); overload;
    ///<summary>Exports events and their messages into an external log file. A flag can be set to indicate that the method will continue exporting events even if the specified query fails for some logs. The event messages are exported in the specified language.</summary>
    ///  <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
    ///  <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
    ///  <param name="query">The query used to select the events to export.  Only the events returned from the query will be exported.</param>
    ///  <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
    ///  <param name="tolerateQueryErrors"><see langword="true" />
    ///  indicates that the method will continue exporting events even if the specified query fails for some logs, and <see langword="false" />
    ///  indicates that this method will not continue to export events when the specified query fails.</param>
    ///  <param name="targetCultureInfo">The culture that specifies which language that the exported event messages will be in.</param>
    procedure ExportLogAndMessages(path: string; pathType: DNPathType; query: string; targetFilePath: string; tolerateQueryErrors: Boolean; targetCultureInfo: DDN.mscorlib.DNCultureInfo); overload;
    ///<summary>Clears events from the specified event log.</summary>
    ///  <param name="logName">The name of the event log to clear all the events from.</param>
    procedure ClearLog(logName: string); overload;
    ///<summary>Clears events from the specified event log, and saves the cleared events to the specified file.</summary>
    ///  <param name="logName">The name of the event log to clear all the events from.</param>
    ///  <param name="backupPath">The path to the file in which the cleared events will be saved. The file should end in .evtx.</param>
    procedure ClearLog(logName: string; backupPath: string); overload;
    ///<summary>Gets an enumerable collection of all the event provider names that are registered with the Event Log service. An event provider is an application that publishes events to an event log.</summary>
    ///<returns>Returns an enumerable collection of strings that contain the event provider names.</returns>
    function GetProviderNames: DDN.mscorlib.DNIEnumerable<string>;
    ///<summary>Gets an enumerable collection of all the event log names that are registered with the Event Log service.</summary>
    ///<returns>Returns an enumerable collection of strings that contain the event log names.</returns>
    function GetLogNames: DDN.mscorlib.DNIEnumerable<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEventLogSession = class(TDNGenericImport<DNEventLogSessionClass, DNEventLogSession>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogStatusClass = interface(DDN.mscorlib.DNObjectClass)
  ['{B4DA3F1B-6354-5E9E-8086-85752C5A9D76}']
  end;

  ///<summary>Contains the status code or error code for a specific event log. This status can be used to determine if the event log is available for an operation.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogStatus')]
  DNEventLogStatus = interface(DDN.mscorlib.DNObject)
  ['{88451979-703B-3DF0-90AD-5415C3585A5D}']
  { getters & setters } 

    function get_LogName: string;
    function get_StatusCode: Int32;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the event log for which the status code is obtained.</summary>
    ///<returns>Returns a string that contains the name of the event log for which the status code is obtained.</returns>
    property LogName: string read get_LogName;
    ///<summary>Gets the status code or error code for the event log. This status or error is the result of a read or subscription operation on the event log.</summary>
    ///<returns>Returns an integer value.</returns>
    property StatusCode: Int32 read get_StatusCode;
  end;

  TDNEventLogStatus = class(TDNGenericImport<DNEventLogStatusClass, DNEventLogStatus>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogWatcherClass = interface(DNObjectClass)
  ['{3A05D279-C451-5811-996D-15F67A823DF8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" />
    ///  class by specifying the name or path to an event log.</summary>
    ///  <param name="path">The path or name of the event log monitor for events. If any event is logged in this event log, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" />
    ///  event is raised.</param>
    {class} function init(path: string): DNEventLogWatcher; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" />
    ///  class by specifying an event query.</summary>
    ///  <param name="eventQuery">Specifies a query for the event subscription. When an event is logged that matches the criteria expressed in the query, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" />
    ///  event is raised. </param>
    {class} function init(eventQuery: DNEventLogQuery): DNEventLogWatcher; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" />
    ///  class by specifying an event query and a bookmark that is used as starting position for the query.</summary>
    ///  <param name="eventQuery">Specifies a query for the event subscription. When an event is logged that matches the criteria expressed in the query, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" />
    ///  event is raised.</param>
    ///  <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
    {class} function init(eventQuery: DNEventLogQuery; bookmark: DNEventBookmark): DNEventLogWatcher; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" />
    ///  class by specifying an event query, a bookmark that is used as starting position for the query, and a Boolean value that determines whether to read the events that already exist in the event log.</summary>
    ///  <param name="eventQuery">Specifies a query for the event subscription. When an event is logged that matches the criteria expressed in the query, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" />
    ///  event is raised.</param>
    ///  <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
    ///  <param name="readExistingEvents">A Boolean value that determines whether to read the events that already exist in the event log. If this value is <see langword="true" />
    ///  , then the existing events are read and if this value is <see langword="false" />
    ///  , then the existing events are not read.</param>
    {class} function init(eventQuery: DNEventLogQuery; bookmark: DNEventBookmark; readExistingEvents: Boolean): DNEventLogWatcher; overload;

  end;

  ///<summary>Allows you to subscribe to incoming events. Each time a desired event is published to an event log, the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" />
  ///  event is raised, and the method that handles this event will be executed. </summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogWatcher')]
  DNEventLogWatcher = interface(DDN.mscorlib.DNIDisposable)
  ['{840AAF0A-18CB-3E84-BFF9-35027204183B}']
  { getters & setters } 

    function get_Enabled: Boolean;
    procedure set_Enabled(value: Boolean);

  { events } 

    procedure add_EventRecordWritten(value: DDN.mscorlib.DNEventHandler<DNEventRecordWrittenEventArgs>);
    procedure remove_EventRecordWritten(value: DDN.mscorlib.DNEventHandler<DNEventRecordWrittenEventArgs>);

  { methods } 

    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Determines whether this object starts delivering events to the event delegate.</summary>
    ///<returns>Returns <see langword="true" />
    ///  when this object can deliver events to the event delegate, and returns <see langword="false" />
    ///  when this object has stopped delivery.</returns>
    property Enabled: Boolean read get_Enabled write set_Enabled;
  end;

  TDNEventLogWatcher = class(TDNGenericImport<DNEventLogWatcherClass, DNEventLogWatcher>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventMetadataClass = interface(DDN.mscorlib.DNObjectClass)
  ['{21C585C0-4952-5EF3-A535-C3C7BAD37275}']
  end;

  ///<summary>Contains the metadata (properties and settings) for an event that is defined in an event provider. </summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventMetadata')]
  DNEventMetadata = interface(DDN.mscorlib.DNObject)
  ['{CCB3CDCA-6F23-3A21-93B3-DDF1168F0BEE}']
  { getters & setters } 

    function get_Id: Int64;
    function get_Version: Byte;
    function get_LogLink: DNEventLogLink;
    function get_Level: DNEventLevel;
    function get_Opcode: DNEventOpcode;
    function get_Task: DNEventTask;
    function get_Keywords: DDN.mscorlib.DNIEnumerable<DNEventKeyword>;
    function get_Template: string;
    function get_Description: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the identifier of the event that is defined in the event provider.</summary>
    ///<returns>Returns a <see langword="long" />
    ///  value that is the event identifier.</returns>
    property Id: Int64 read get_Id;
    ///<summary>Gets the version of the event that qualifies the event identifier.</summary>
    ///<returns>Returns a byte value.</returns>
    property Version: Byte read get_Version;
    ///<summary>Gets a link to the event log that receives this event when the provider publishes this event.</summary>
    ///<returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventLogLink" />
    ///  object.</returns>
    property LogLink: DNEventLogLink read get_LogLink;
    ///<summary>Gets the level associated with the event that is defined in the event provider. The level defines the severity of the event.</summary>
    ///<returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" />
    ///  object.</returns>
    property Level: DNEventLevel read get_Level;
    ///<summary>Gets the opcode associated with this event that is defined by an event provider. The opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event.</summary>
    ///<returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" />
    ///  object.</returns>
    property Opcode: DNEventOpcode read get_Opcode;
    ///<summary>Gets the task associated with the event. A task identifies a portion of an application or a component that publishes an event. </summary>
    ///<returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" />
    ///  object.</returns>
    property Task: DNEventTask read get_Task;
    ///<summary>Gets the keywords associated with the event that is defined in the even provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" />
    ///  objects.</returns>
    property Keywords: DDN.mscorlib.DNIEnumerable<DNEventKeyword> read get_Keywords;
    ///<summary>Gets the template string for the event. Templates are used to describe data that is used by a provider when an event is published. Templates optionally specify XML that provides the structure of an event. The XML allows values that the event publisher provides to be inserted during the rendering of an event.</summary>
    ///<returns>Returns a string that contains the template for the event.</returns>
    property Template: string read get_Template;
    ///<summary>Gets the description template associated with the event using the current thread locale for the description language.</summary>
    ///<returns>Returns a string that contains the description template associated with the event.</returns>
    property Description: string read get_Description;
  end;

  TDNEventMetadata = class(TDNGenericImport<DNEventMetadataClass, DNEventMetadata>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventOpcodeClass = interface(DDN.mscorlib.DNObjectClass)
  ['{7C75009D-6A5E-5A1E-A6AA-7348DA829EB9}']
  end;

  ///<summary>Contains an event opcode that is defined in an event provider. An opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventOpcode')]
  DNEventOpcode = interface(DDN.mscorlib.DNObject)
  ['{2CB6009E-42C8-3ABB-BE5F-5BC2878C566F}']
  { getters & setters } 

    function get_Name: string;
    function get_Value: Int32;
    function get_DisplayName: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the non-localized name for an event opcode.</summary>
    ///<returns>Returns a string that contains the non-localized name for an event opcode.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the numeric value associated with the event opcode.</summary>
    ///<returns>Returns an integer value.</returns>
    property Value: Int32 read get_Value;
    ///<summary>Gets the localized name for an event opcode.</summary>
    ///<returns>Returns a string that contains the localized name for an event opcode.</returns>
    property DisplayName: string read get_DisplayName;
  end;

  TDNEventOpcode = class(TDNGenericImport<DNEventOpcodeClass, DNEventOpcode>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventPropertyClass = interface(DDN.mscorlib.DNObjectClass)
  ['{5A2AAA9A-2722-5C54-B65F-1C3A60DFAE60}']
  end;

  ///<summary>Contains the value of an event property that is specified by the event provider when the event is published.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventProperty')]
  DNEventProperty = interface(DDN.mscorlib.DNObject)
  ['{4186473A-2A29-3A1C-B8D1-AC00A4785166}']
  { getters & setters } 

    function get_Value: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the value of the event property that is specified by the event provider when the event is published.</summary>
    ///<returns>Returns an object.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value;
  end;

  TDNEventProperty = class(TDNGenericImport<DNEventPropertyClass, DNEventProperty>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventRecordClass = interface(DNObjectClass)
  ['{217D5B4B-BCD4-52DB-BA8E-D334EB4D7851}']
  end;

  ///<summary>Defines the properties of an event instance for an event that is received from an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
  ///  object. The event properties provide information about the event such as the name of the computer where the event was logged and the time the event was created. This class is an abstract class. The <see cref="T:System.Diagnostics.Eventing.Reader.EventLogRecord" />
  ///  class implements this class.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventRecord')]
  DNEventRecord = interface(DDN.mscorlib.DNIDisposable)
  ['{E73161FA-BE10-3479-A361-836D561BCBD3}']
  { getters & setters } 

    function get_Id: Int32;
    function get_Version: DDN.mscorlib.DNNullable<Byte>;
    function get_Level: DDN.mscorlib.DNNullable<Byte>;
    function get_Task: DDN.mscorlib.DNNullable<Int32>;
    function get_Opcode: DDN.mscorlib.DNNullable<Int16>;
    function get_Keywords: DDN.mscorlib.DNNullable<Int64>;
    function get_RecordId: DDN.mscorlib.DNNullable<Int64>;
    function get_ProviderName: string;
    function get_ProviderId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;
    function get_LogName: string;
    function get_ProcessId: DDN.mscorlib.DNNullable<Int32>;
    function get_ThreadId: DDN.mscorlib.DNNullable<Int32>;
    function get_MachineName: string;
    function get_UserId: DDN.mscorlib.DNSecurityIdentifier;
    function get_TimeCreated: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime>;
    function get_ActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;
    function get_RelatedActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;
    function get_Qualifiers: DDN.mscorlib.DNNullable<Int32>;
    function get_LevelDisplayName: string;
    function get_OpcodeDisplayName: string;
    function get_TaskDisplayName: string;
    function get_KeywordsDisplayNames: DDN.mscorlib.DNIEnumerable<string>;
    function get_Bookmark: DNEventBookmark;
    function get_Properties: DDN.mscorlib.DNIList<DNEventProperty>;

  { methods } 

    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    ///<summary>Gets the event message in the current locale.</summary>
    ///<returns>Returns a string that contains the event message in the current locale.</returns>
    function FormatDescription: string; overload;
    function FormatDescription(values: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNObject>): string; overload;
    ///<summary>Gets the XML representation of the event. All of the event properties are represented in the event XML. The XML conforms to the event schema.</summary>
    ///<returns>Returns a string that contains the XML representation of the event.</returns>
    function ToXml: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the identifier for this event. All events with this identifier value represent the same type of event.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Id: Int32 read get_Id;
    ///<summary>Gets the version number for the event.</summary>
    ///<returns>Returns a byte value. This value can be null.</returns>
    property Version: DDN.mscorlib.DNNullable<Byte> read get_Version;
    ///<summary>Gets the level of the event. The level signifies the severity of the event. For the name of the level, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.LevelDisplayName" />
    ///  property.</summary>
    ///<returns>Returns a byte value. This value can be null.</returns>
    property Level: DDN.mscorlib.DNNullable<Byte> read get_Level;
    ///<summary>Gets a task identifier for a portion of an application or a component that publishes an event. A task is a 16-bit value with 16 top values reserved. This type allows any value between 0x0000 and 0xffef to be used. To obtain the task name, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.TaskDisplayName" />
    ///  property.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Task: DDN.mscorlib.DNNullable<Int32> read get_Task;
    ///<summary>Gets the opcode of the event. The opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event. For the name of the opcode, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.OpcodeDisplayName" />
    ///  property.</summary>
    ///<returns>Returns a short value. This value can be null.</returns>
    property Opcode: DDN.mscorlib.DNNullable<Int16> read get_Opcode;
    ///<summary>Gets the keyword mask of the event. Get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.KeywordsDisplayNames" />
    ///  property to get the name of the keywords used in this mask.</summary>
    ///<returns>Returns a long value. This value can be null.</returns>
    property Keywords: DDN.mscorlib.DNNullable<Int64> read get_Keywords;
    ///<summary>Gets the event record identifier of the event in the log.</summary>
    ///<returns>Returns a long value. This value can be null.</returns>
    property RecordId: DDN.mscorlib.DNNullable<Int64> read get_RecordId;
    ///<summary>Gets the name of the event provider that published this event.</summary>
    ///<returns>Returns a string that contains the name of the event provider that published this event.</returns>
    property ProviderName: string read get_ProviderName;
    ///<summary>Gets the globally unique identifier (GUID) of the event provider that published this event.</summary>
    ///<returns>Returns a GUID value. This value can be null.</returns>
    property ProviderId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_ProviderId;
    ///<summary>Gets the name of the event log where this event is logged.</summary>
    ///<returns>Returns a string that contains a name of the event log that contains this event.</returns>
    property LogName: string read get_LogName;
    ///<summary>Gets the process identifier for the event provider that logged this event.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property ProcessId: DDN.mscorlib.DNNullable<Int32> read get_ProcessId;
    ///<summary>Gets the thread identifier for the thread that the event provider is running in.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property ThreadId: DDN.mscorlib.DNNullable<Int32> read get_ThreadId;
    ///<summary>Gets the name of the computer on which this event was logged.</summary>
    ///<returns>Returns a string that contains the name of the computer on which this event was logged.</returns>
    property MachineName: string read get_MachineName;
    ///<summary>Gets the security descriptor of the user whose context is used to publish the event.</summary>
    ///<returns>Returns a <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  value.</returns>
    property UserId: DDN.mscorlib.DNSecurityIdentifier read get_UserId;
    ///<summary>Gets the time, in <see cref="T:System.DateTime" />
    ///  format, that the event was created.</summary>
    ///<returns>Returns a <see cref="T:System.DateTime" />
    ///  value. The value can be null.</returns>
    property TimeCreated: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime> read get_TimeCreated;
    ///<summary>Gets the globally unique identifier (GUID) for the activity in process for which the event is involved. This allows consumers to group related activities.</summary>
    ///<returns>Returns a GUID value.</returns>
    property ActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_ActivityId;
    ///<summary>Gets a globally unique identifier (GUID) for a related activity in a process for which an event is involved.</summary>
    ///<returns>Returns a GUID value. This value can be null.</returns>
    property RelatedActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_RelatedActivityId;
    ///<summary>Gets qualifier numbers that are used for event identification.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Qualifiers: DDN.mscorlib.DNNullable<Int32> read get_Qualifiers;
    ///<summary>Gets the display name of the level for this event.</summary>
    ///<returns>Returns a string that contains the display name of the level for this event.</returns>
    property LevelDisplayName: string read get_LevelDisplayName;
    ///<summary>Gets the display name of the opcode for this event.</summary>
    ///<returns>Returns a string that contains the display name of the opcode for this event.</returns>
    property OpcodeDisplayName: string read get_OpcodeDisplayName;
    ///<summary>Gets the display name of the task for the event.</summary>
    ///<returns>Returns a string that contains the display name of the task for the event.</returns>
    property TaskDisplayName: string read get_TaskDisplayName;
    ///<summary>Gets the display names of the keywords used in the keyword mask for this event. </summary>
    ///<returns>Returns an enumerable collection of strings that contain the display names of the keywords used in the keyword mask for this event.</returns>
    property KeywordsDisplayNames: DDN.mscorlib.DNIEnumerable<string> read get_KeywordsDisplayNames;
    ///<summary>Gets a placeholder (bookmark) that corresponds to this event. This can be used as a placeholder in a stream of events.</summary>
    ///<returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" />
    ///  object.</returns>
    property Bookmark: DNEventBookmark read get_Bookmark;
    ///<summary>Gets the user-supplied properties of the event.</summary>
    ///<returns>Returns a list of <see cref="T:System.Diagnostics.Eventing.Reader.EventProperty" />
    ///  objects.</returns>
    property Properties: DDN.mscorlib.DNIList<DNEventProperty> read get_Properties;
  end;

  TDNEventRecord = class(TDNGenericImport<DNEventRecordClass, DNEventRecord>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogRecordClass = interface(DNEventRecordClass)
  ['{7262A67E-8E87-5ABB-BCF0-3146A49890DF}']
  end;

  ///<summary>Contains the properties of an event instance for an event that is received from an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
  ///  object. The event properties provide information about the event such as the name of the computer where the event was logged and the time that the event was created.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogRecord')]
  DNEventLogRecord = interface(DNEventRecord)
  ['{8BDD331B-2C91-34BF-9741-79F8947F4BFB}']
  { getters & setters } 

    function get_Id: Int32;
    function get_Version: DDN.mscorlib.DNNullable<Byte>;
    function get_Qualifiers: DDN.mscorlib.DNNullable<Int32>;
    function get_Level: DDN.mscorlib.DNNullable<Byte>;
    function get_Task: DDN.mscorlib.DNNullable<Int32>;
    function get_Opcode: DDN.mscorlib.DNNullable<Int16>;
    function get_Keywords: DDN.mscorlib.DNNullable<Int64>;
    function get_RecordId: DDN.mscorlib.DNNullable<Int64>;
    function get_ProviderName: string;
    function get_ProviderId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;
    function get_LogName: string;
    function get_ProcessId: DDN.mscorlib.DNNullable<Int32>;
    function get_ThreadId: DDN.mscorlib.DNNullable<Int32>;
    function get_MachineName: string;
    function get_UserId: DDN.mscorlib.DNSecurityIdentifier;
    function get_TimeCreated: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime>;
    function get_ActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;
    function get_RelatedActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid>;
    function get_ContainerLog: string;
    function get_MatchedQueryIds: DDN.mscorlib.DNIEnumerable<Int32>;
    function get_Bookmark: DNEventBookmark;
    function get_LevelDisplayName: string;
    function get_OpcodeDisplayName: string;
    function get_TaskDisplayName: string;
    function get_KeywordsDisplayNames: DDN.mscorlib.DNIEnumerable<string>;
    function get_Properties: DDN.mscorlib.DNIList<DNEventProperty>;

  { methods } 

    ///<summary>Gets the event message in the current locale.</summary>
    ///<returns>Returns a string that contains the event message in the current locale.</returns>
    function FormatDescription: string; overload;
    ///<summary>Gets the enumeration of the values of the user-supplied event properties, or the results of XPath-based data if the event has XML representation.</summary>
    ///  <param name="propertySelector">Selects the property values to return.</param>
    ///<returns>Returns a list of objects.</returns>
    function GetPropertyValues(propertySelector: DNEventLogPropertySelector): DDN.mscorlib.DNIList<DDN.mscorlib.DNObject>;
    ///<summary>Gets the XML representation of the event. All of the event properties are represented in the event's XML. The XML conforms to the event schema.</summary>
    ///<returns>Returns a string that contains the XML representation of the event.</returns>
    function ToXml: string;
    function FormatDescription(values: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNObject>): string; overload;
    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the identifier for this event. All events with this identifier value represent the same type of event.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Id: Int32 read get_Id;
    ///<summary>Gets the version number for the event.</summary>
    ///<returns>Returns a byte value. This value can be null.</returns>
    property Version: DDN.mscorlib.DNNullable<Byte> read get_Version;
    ///<summary>Gets qualifier numbers that are used for event identification.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Qualifiers: DDN.mscorlib.DNNullable<Int32> read get_Qualifiers;
    ///<summary>Gets the level of the event. The level signifies the severity of the event. For the name of the level, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.LevelDisplayName" />
    ///  property.</summary>
    ///<returns>Returns a byte value. This value can be null.</returns>
    property Level: DDN.mscorlib.DNNullable<Byte> read get_Level;
    ///<summary>Gets a task identifier for a portion of an application or a component that publishes an event. A task is a 16-bit value with 16 top values reserved. This type allows any value between 0x0000 and 0xffef to be used. For the name of the task, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.TaskDisplayName" />
    ///  property.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property Task: DDN.mscorlib.DNNullable<Int32> read get_Task;
    ///<summary>Gets the opcode of the event. The opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event. For the name of the opcode, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.OpcodeDisplayName" />
    ///  property.</summary>
    ///<returns>Returns a short value. This value can be null.</returns>
    property Opcode: DDN.mscorlib.DNNullable<Int16> read get_Opcode;
    ///<summary>Gets the keyword mask of the event. Get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.KeywordsDisplayNames" />
    ///  property to get the name of the keywords used in this mask.</summary>
    ///<returns>Returns a long value. This value can be null.</returns>
    property Keywords: DDN.mscorlib.DNNullable<Int64> read get_Keywords;
    ///<summary>Gets the event record identifier of the event in the log.</summary>
    ///<returns>Returns a long value. This value can be null.</returns>
    property RecordId: DDN.mscorlib.DNNullable<Int64> read get_RecordId;
    ///<summary>Gets the name of the event provider that published this event.</summary>
    ///<returns>Returns a string that contains the name of the event provider that published this event.</returns>
    property ProviderName: string read get_ProviderName;
    ///<summary>Gets the globally unique identifier (GUID) of the event provider that published this event.</summary>
    ///<returns>Returns a GUID value. This value can be null.</returns>
    property ProviderId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_ProviderId;
    ///<summary>Gets the name of the event log where this event is logged.</summary>
    ///<returns>Returns a string that contains a name of the event log that contains this event.</returns>
    property LogName: string read get_LogName;
    ///<summary>Gets the process identifier for the event provider that logged this event.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property ProcessId: DDN.mscorlib.DNNullable<Int32> read get_ProcessId;
    ///<summary>Gets the thread identifier for the thread that the event provider is running in.</summary>
    ///<returns>Returns an integer value. This value can be null.</returns>
    property ThreadId: DDN.mscorlib.DNNullable<Int32> read get_ThreadId;
    ///<summary>Gets the name of the computer on which this event was logged.</summary>
    ///<returns>Returns a string that contains the name of the computer on which this event was logged.</returns>
    property MachineName: string read get_MachineName;
    ///<summary>Gets the security descriptor of the user whose context is used to publish the event.</summary>
    ///<returns>Returns a <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  value.</returns>
    property UserId: DDN.mscorlib.DNSecurityIdentifier read get_UserId;
    ///<summary>Gets the time, in <see cref="T:System.DateTime" />
    ///  format, that the event was created.</summary>
    ///<returns>Returns a <see cref="T:System.DateTime" />
    ///  value. The value can be null.</returns>
    property TimeCreated: DDN.mscorlib.DNNullable<DDN.mscorlib.DNDateTime> read get_TimeCreated;
    ///<summary>Gets the globally unique identifier (GUID) for the activity in process for which the event is involved. This allows consumers to group related activities.</summary>
    ///<returns>Returns a GUID value.</returns>
    property ActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_ActivityId;
    ///<summary>Gets a globally unique identifier (GUID) for a related activity in a process for which an event is involved.</summary>
    ///<returns>Returns a GUID value. This value can be null.</returns>
    property RelatedActivityId: DDN.mscorlib.DNNullable<DDN.mscorlib.DNGuid> read get_RelatedActivityId;
    ///<summary>Gets the name of the event log or the event log file in which the event is stored.</summary>
    ///<returns>Returns a string that contains the name of the event log or the event log file in which the event is stored.</returns>
    property ContainerLog: string read get_ContainerLog;
    ///<summary>Gets a list of query identifiers that this event matches. This event matches a query if the query would return this event.</summary>
    ///<returns>Returns an enumerable collection of integer values.</returns>
    property MatchedQueryIds: DDN.mscorlib.DNIEnumerable<Int32> read get_MatchedQueryIds;
    ///<summary>Gets a placeholder (bookmark) that corresponds to this event. This can be used as a placeholder in a stream of events.</summary>
    ///<returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" />
    ///  object.</returns>
    property Bookmark: DNEventBookmark read get_Bookmark;
    ///<summary>Gets the display name of the level for this event.</summary>
    ///<returns>Returns a string that contains the display name of the level for this event.</returns>
    property LevelDisplayName: string read get_LevelDisplayName;
    ///<summary>Gets the display name of the opcode for this event.</summary>
    ///<returns>Returns a string that contains the display name of the opcode for this event.</returns>
    property OpcodeDisplayName: string read get_OpcodeDisplayName;
    ///<summary>Gets the display name of the task for the event.</summary>
    ///<returns>Returns a string that contains the display name of the task for the event.</returns>
    property TaskDisplayName: string read get_TaskDisplayName;
    ///<summary>Gets the display names of the keywords used in the keyword mask for this event.</summary>
    ///<returns>Returns an enumerable collection of strings that contain the display names of the keywords used in the keyword mask for this event.</returns>
    property KeywordsDisplayNames: DDN.mscorlib.DNIEnumerable<string> read get_KeywordsDisplayNames;
    ///<summary>Gets the user-supplied properties of the event.</summary>
    ///<returns>Returns a list of <see cref="T:System.Diagnostics.Eventing.Reader.EventProperty" />
    ///  objects.</returns>
    property Properties: DDN.mscorlib.DNIList<DNEventProperty> read get_Properties;
  end;

  TDNEventLogRecord = class(TDNGenericImport<DNEventLogRecordClass, DNEventLogRecord>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventTaskClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F21A0E3F-BE10-57E3-B092-5C4DA4A1DDE7}']
  end;

  ///<summary>Contains an event task that is defined in an event provider. The task identifies a portion of an application or a component that publishes an event. A task is a 16-bit value with 16 top values reserved.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventTask')]
  DNEventTask = interface(DDN.mscorlib.DNObject)
  ['{5A496A36-9B9E-36DC-8D3E-94EA24CB7B32}']
  { getters & setters } 

    function get_Name: string;
    function get_Value: Int32;
    function get_DisplayName: string;
    function get_EventGuid: DDN.mscorlib.DNGuid;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the non-localized name of the event task.</summary>
    ///<returns>Returns a string that contains the non-localized name of the event task.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the numeric value associated with the task.</summary>
    ///<returns>Returns an integer value.</returns>
    property Value: Int32 read get_Value;
    ///<summary>Gets the localized name for the event task.</summary>
    ///<returns>Returns a string that contains the localized name for the event task.</returns>
    property DisplayName: string read get_DisplayName;
    ///<summary>Gets the event globally unique identifier (GUID) associated with the task. </summary>
    ///<returns>Returns a GUID value.</returns>
    property EventGuid: DDN.mscorlib.DNGuid read get_EventGuid;
  end;

  TDNEventTask = class(TDNGenericImport<DNEventTaskClass, DNEventTask>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNProviderMetadataClass = interface(DNObjectClass)
  ['{72DC5594-2E19-5649-BC22-80DB812B851C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.ProviderMetadata" />
    ///  class by specifying the name of the provider that you want to retrieve information about.</summary>
    ///  <param name="providerName">The name of the event provider that you want to retrieve information about.</param>
    {class} function init(providerName: string): DNProviderMetadata; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.ProviderMetadata" />
    ///  class by specifying the name of the provider that you want to retrieve information about, the event log service that the provider is registered with, and the language that you want to return the information in.</summary>
    ///  <param name="providerName">The name of the event provider that you want to retrieve information about.</param>
    ///  <param name="session">The <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" />
    ///  object that specifies whether to get the provider information from a provider on the local computer or a provider on a remote computer.</param>
    ///  <param name="targetCultureInfo">The culture that specifies the language that the information should be returned in.</param>
    {class} function init(providerName: string; session: DNEventLogSession; targetCultureInfo: DDN.mscorlib.DNCultureInfo): DNProviderMetadata; overload;

  end;

  ///<summary>Contains static information about an event provider, such as the name and id of the provider, and the collection of events defined in the provider.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.ProviderMetadata')]
  DNProviderMetadata = interface(DDN.mscorlib.DNIDisposable)
  ['{16D04670-7CD4-3BDB-974A-5138AB990FDB}']
  { getters & setters } 

    function get_Name: string;
    function get_Id: DDN.mscorlib.DNGuid;
    function get_MessageFilePath: string;
    function get_ResourceFilePath: string;
    function get_ParameterFilePath: string;
    function get_HelpLink: DDN.System.DNUri;
    function get_DisplayName: string;
    function get_LogLinks: DDN.mscorlib.DNIList<DNEventLogLink>;
    function get_Levels: DDN.mscorlib.DNIList<DNEventLevel>;
    function get_Opcodes: DDN.mscorlib.DNIList<DNEventOpcode>;
    function get_Keywords: DDN.mscorlib.DNIList<DNEventKeyword>;
    function get_Tasks: DDN.mscorlib.DNIList<DNEventTask>;
    function get_Events: DDN.mscorlib.DNIEnumerable<DNEventMetadata>;

  { methods } 

    ///<summary>Releases all the resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the unique name of the event provider.</summary>
    ///<returns>Returns a string that contains the unique name of the event provider.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the globally unique identifier (GUID) for the event provider.</summary>
    ///<returns>Returns the GUID value for the event provider.</returns>
    property Id: DDN.mscorlib.DNGuid read get_Id;
    ///<summary>Gets the path of the file that contains the message table resource that has the strings associated with the provider metadata.</summary>
    ///<returns>Returns a string that contains the path of the provider message file.</returns>
    property MessageFilePath: string read get_MessageFilePath;
    ///<summary>Gets the path to the file that contains the metadata associated with the provider.</summary>
    ///<returns>Returns a string that contains the path to the file that contains the metadata associated with the provider.</returns>
    property ResourceFilePath: string read get_ResourceFilePath;
    ///<summary>Gets the path of the file that contains the message table resource that has the strings used for parameter substitutions in event descriptions.</summary>
    ///<returns>Returns a string that contains the path of the file that contains the message table resource that has the strings used for parameter substitutions in event descriptions.</returns>
    property ParameterFilePath: string read get_ParameterFilePath;
    ///<summary>Gets the base of the URL used to form help requests for the events in this event provider.</summary>
    ///<returns>Returns a <see cref="T:System.Uri" />
    ///  value.</returns>
    property HelpLink: DDN.System.DNUri read get_HelpLink;
    ///<summary>Gets the localized name of the event provider.</summary>
    ///<returns>Returns a string that contains the localized name of the event provider.</returns>
    property DisplayName: string read get_DisplayName;
    ///<summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLogLink" />
    ///  objects, each of which represent a link to an event log that is used by the event provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLogLink" />
    ///  objects.</returns>
    property LogLinks: DDN.mscorlib.DNIList<DNEventLogLink> read get_LogLinks;
    ///<summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" />
    ///  objects, each of which represent a level that is defined in the event provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" />
    ///  objects.</returns>
    property Levels: DDN.mscorlib.DNIList<DNEventLevel> read get_Levels;
    ///<summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" />
    ///  objects, each of which represent an opcode that is defined in the event provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" />
    ///  objects.</returns>
    property Opcodes: DDN.mscorlib.DNIList<DNEventOpcode> read get_Opcodes;
    ///<summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" />
    ///  objects, each of which represent an event keyword that is defined in the event provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" />
    ///  objects.</returns>
    property Keywords: DDN.mscorlib.DNIList<DNEventKeyword> read get_Keywords;
    ///<summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" />
    ///  objects, each of which represent a task that is defined in the event provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" />
    ///  objects.</returns>
    property Tasks: DDN.mscorlib.DNIList<DNEventTask> read get_Tasks;
    ///<summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventMetadata" />
    ///  objects, each of which represents an event that is defined in the provider.</summary>
    ///<returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventMetadata" />
    ///  objects.</returns>
    property Events: DDN.mscorlib.DNIEnumerable<DNEventMetadata> read get_Events;
  end;

  TDNProviderMetadata = class(TDNGenericImport<DNProviderMetadataClass, DNProviderMetadata>) end;

  //-------------namespace: System.Diagnostics.PerformanceData----------------
  DNCounterDataClass = interface(DDN.mscorlib.DNObjectClass)
  ['{7C95220B-A686-51E9-9827-94199ECC98D3}']
  end;

  ///<summary>Contains the raw data for a counter.</summary>
  [DNTypeName('System.Diagnostics.PerformanceData.CounterData')]
  DNCounterData = interface(DDN.mscorlib.DNObject)
  ['{F74B9394-8089-3D3B-AB4A-AF794331F21D}']
  { getters & setters } 

    function get_Value: Int64;
    procedure set_Value(value: Int64);
    function get_RawValue: Int64;
    procedure set_RawValue(value: Int64);

  { methods } 

    ///<summary>Increments the counter value by 1.</summary>
    procedure Increment;
    ///<summary>Decrements the counter value by 1.</summary>
    procedure Decrement;
    ///<summary>Increments the counter value by the specified amount.</summary>
    ///  <param name="value">The amount by which to increment the counter value. The increment value can be positive or negative.</param>
    procedure IncrementBy(value: Int64);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Sets or gets the counter data.</summary>
    ///<returns>The counter data.</returns>
    property Value: Int64 read get_Value write set_Value;
    ///<summary>Sets or gets the raw counter data.</summary>
    ///<returns>The raw counter data.</returns>
    property RawValue: Int64 read get_RawValue write set_RawValue;
  end;

  TDNCounterData = class(TDNGenericImport<DNCounterDataClass, DNCounterData>) end;

  //-------------namespace: System.Diagnostics.PerformanceData----------------
  DNCounterSetClass = interface(DNObjectClass)
  ['{273F1485-BB67-5480-AF98-7A009FE19698}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.PerformanceData.CounterSet" />
    ///  class.</summary>
    ///  <param name="providerGuid">Guid that uniquely identifies the provider of the counter data. Use the Guid specified in the manifest.</param>
    ///  <param name="counterSetGuid">Guid that uniquely identifies the counter set for a provider. Use the Guid specified in the manifest.</param>
    ///  <param name="instanceType">Identifies the type of the counter set, for example, whether the counter set is a single or multiple instance counter set.</param>
    ///<exception cref="T:System.InsufficientMemoryException">Not enough memory is available to complete the operation.</exception><exception cref="T:System.PlatformNotSupportedException">Not supported prior to Windows Vista.</exception><exception cref="T:System.ArgumentException">One of the parameters is NULL or not valid.</exception><exception cref="T:System.ComponentModel.Win32Exception">An underlying Win32 function call failed.</exception>
    {class} function init(providerGuid: DDN.mscorlib.DNGuid; counterSetGuid: DDN.mscorlib.DNGuid; instanceType: DNCounterSetInstanceType): DNCounterSet;

  end;

  ///<summary>Defines a set of logical counters.</summary>
  [DNTypeName('System.Diagnostics.PerformanceData.CounterSet')]
  DNCounterSet = interface(DDN.mscorlib.DNIDisposable)
  ['{73B42C75-1907-366C-9259-245A4BD8A56B}']
  { methods } 

    ///<summary>Releases all unmanaged resources used by this object.</summary>
    procedure Dispose;
    ///<summary>Adds a counter to the counter set by using the specified counter identifier and type.</summary>
    ///  <param name="counterId">Identifies the counter. Use the same value that you used in the manifest to define the counter.</param>
    ///  <param name="counterType">Identifies the counter type. The counter type determines how the counter data is calculated, averaged, and displayed. </param>
    ///<exception cref="T:System.ArgumentException">The counter identifier already exists in the set or is negative, or the counter type is NULL or not valid.</exception><exception cref="T:System.InvalidOperationException">You cannot add counters to the counter set after creating an instance of the counter set.</exception>
    procedure AddCounter(counterId: Int32; counterType: DNCounterType); overload;
    ///<summary>Adds a counter to the counter set by using the specified counter identifier and type and a display name for the counter.</summary>
    ///  <param name="counterId">Identifies the counter. Use the same value that you used in the manifest to define the counter.</param>
    ///  <param name="counterType">Identifies the counter type. The counter type determines how the counter data is calculated, averaged, and displayed. </param>
    ///  <param name="counterName">Name of the counter. You can use this name to index the counter in the counter set instance. (See <see cref="P:System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet.Item(System.String)" />
    ///  .)</param>
    ///<exception cref="T:System.ArgumentException">The counter identifier already exists in the set or is negative, or the counter type is NULL or not valid.</exception><exception cref="T:System.InvalidOperationException">You cannot add counters to the counter set after creating an instance of the counter set.</exception>
    procedure AddCounter(counterId: Int32; counterType: DNCounterType; counterName: string); overload;
    ///<summary>Creates an instance of the counter set.</summary>
    ///  <param name="instanceName">Name of the instance. The name must be unique.</param>
    ///<returns>An instance of the counter set which will contain the counter data.</returns>
    ///<exception cref="T:System.ArgumentException">The instance name is NULL.</exception><exception cref="T:System.InvalidOperationException">You must add counters to the counter set before creating an instance of the counter set.</exception>
    function CreateCounterSetInstance(instanceName: string): DNCounterSetInstance;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNCounterSet = class(TDNGenericImport<DNCounterSetClass, DNCounterSet>) end;

  //-------------namespace: System.Diagnostics.PerformanceData----------------
  DNCounterSetInstanceClass = interface(DNObjectClass)
  ['{75C73B49-808F-581A-B055-54AA1798C29B}']
  end;

  ///<summary>Creates an instance of the logical counters defined in the <see cref="T:System.Diagnostics.PerformanceData.CounterSet" />
  ///  class.</summary>
  [DNTypeName('System.Diagnostics.PerformanceData.CounterSetInstance')]
  DNCounterSetInstance = interface(DDN.mscorlib.DNIDisposable)
  ['{5FB5D727-F6A7-3154-89C3-39B3605A219C}']
  { getters & setters } 

    function get_Counters: DNCounterSetInstanceCounterDataSet;

  { methods } 

    ///<summary>Releases all unmanaged resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Retrieves the collection of counter data for the counter set instance.</summary>
    ///<returns>A collection of the counter data contained in the counter set instance.</returns>
    property Counters: DNCounterSetInstanceCounterDataSet read get_Counters;
  end;

  TDNCounterSetInstance = class(TDNGenericImport<DNCounterSetInstanceClass, DNCounterSetInstance>) end;

  //-------------namespace: System.Diagnostics.PerformanceData----------------
  DNCounterSetInstanceCounterDataSetClass = interface(DNObjectClass)
  ['{371D2D97-58E1-5593-8678-B99AC249AC1D}']
  end;

  ///<summary>Contains the collection of counter values.</summary>
  [DNTypeName('System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet')]
  DNCounterSetInstanceCounterDataSet = interface(DDN.mscorlib.DNIDisposable)
  ['{8CFAD6F2-7C85-36F3-9161-DD97C2AF6AAF}']
  { getters & setters } 

    function get_Item(counterId: Int32): DNCounterData; overload;
    function get_Item(counterName: string): DNCounterData; overload;

  { methods } 

    ///<summary>Releases all unmanaged resources used by this object.</summary>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[counterId: Int32]: DNCounterData read get_Item; default;
    property Item[counterName: string]: DNCounterData read get_Item; default;
  end;

  TDNCounterSetInstanceCounterDataSet = class(TDNGenericImport<DNCounterSetInstanceCounterDataSetClass, DNCounterSetInstanceCounterDataSet>) end;

  //-------------namespace: System.Diagnostics----------------
  DNUnescapedXmlDiagnosticDataClass = interface(DDN.mscorlib.DNObjectClass)
  ['{BBFD733D-40D4-5289-A503-5B8366440C6A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.UnescapedXmlDiagnosticData" />
    ///  class by using the specified XML data string.</summary>
    ///  <param name="xmlPayload">The XML data to be logged in the <see langword="UserData" />
    ///  node of the event schema.  </param>
    {class} function init(xmlPayload: string): DNUnescapedXmlDiagnosticData;

  end;

  ///<summary>Provides unescaped XML data for the logging of user-provided trace data.</summary>
  [DNTypeName('System.Diagnostics.UnescapedXmlDiagnosticData')]
  DNUnescapedXmlDiagnosticData = interface(DDN.mscorlib.DNObject)
  ['{0FF9AB07-001B-33D8-9352-25ED7238B895}']
  { getters & setters } 

    function get_UnescapedXml: string;
    procedure set_UnescapedXml(value: string);

  { methods } 

    ///<summary>Returns a string representation of the <see cref="T:System.Diagnostics.UnescapedXmlDiagnosticData" />
    ///  object.</summary>
    ///<returns>A string representation of the <see cref="T:System.Diagnostics.UnescapedXmlDiagnosticData" />
    ///  object. If the object is <see langword="null" />
    ///  , this method returns an empty string.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets the unescaped XML data string.</summary>
    ///<returns>An unescaped XML string.</returns>
    property UnescapedXml: string read get_UnescapedXml write set_UnescapedXml;
  end;

  TDNUnescapedXmlDiagnosticData = class(TDNGenericImport<DNUnescapedXmlDiagnosticDataClass, DNUnescapedXmlDiagnosticData>) end;

  //-------------namespace: System.Dynamic----------------
  DNBindingRestrictionsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{BD600AAD-CFDF-54FF-8254-461FC32A3C5A}']
  { static fields getter & setter } 

   function __fakeFieldGet_Empty: DNBindingRestrictions;

  { static fields } 

    ///<summary>Represents an empty set of binding restrictions. This field is read only.</summary>
    {class} property Empty: DNBindingRestrictions read __fakeFieldGet_Empty;

  { static methods } 

    ///<summary>Creates the binding restriction that check the expression for runtime type identity.</summary>
    ///  <param name="expression">The expression to test.</param>
    ///  <param name="type">The exact type to test.</param>
    ///<returns>The new binding restrictions.</returns>
    {class} function GetTypeRestriction(expression: DNExpression; &type: DDN.mscorlib.DNType): DNBindingRestrictions;
    ///<summary>Creates the binding restriction that checks the expression for object instance identity.</summary>
    ///  <param name="expression">The expression to test.</param>
    ///  <param name="instance">The exact object instance to test.</param>
    ///<returns>The new binding restrictions.</returns>
    {class} function GetInstanceRestriction(expression: DNExpression; instance: DDN.mscorlib.DNObject): DNBindingRestrictions;
    ///<summary>Creates the binding restriction that checks the expression for arbitrary immutable properties.</summary>
    ///  <param name="expression">The expression representing the restrictions.</param>
    ///<returns>The new binding restrictions.</returns>
    {class} function GetExpressionRestriction(expression: DNExpression): DNBindingRestrictions;
    {class} function Combine(contributingObjects: DDN.mscorlib.DNIList<DNDynamicMetaObject>): DNBindingRestrictions;

  end;

  ///<summary>Represents a set of binding restrictions on the <see cref="T:System.Dynamic.DynamicMetaObject" />
  ///  under which the dynamic binding is valid.</summary>
  [DNTypeName('System.Dynamic.BindingRestrictions')]
  DNBindingRestrictions = interface(DDN.mscorlib.DNObject)
  ['{FB6E11CE-F3B8-3BEC-AE30-9135F618C3A4}']
  { methods } 

    ///<summary>Merges the set of binding restrictions with the current binding restrictions.</summary>
    ///  <param name="restrictions">The set of restrictions with which to merge the current binding restrictions.</param>
    ///<returns>The new set of binding restrictions.</returns>
    function Merge(restrictions: DNBindingRestrictions): DNBindingRestrictions;
    ///<summary>Creates the <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the binding restrictions.</summary>
    ///<returns>The expression tree representing the restrictions.</returns>
    function ToExpression: DNExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNBindingRestrictions = class(TDNGenericImport<DNBindingRestrictionsClass, DNBindingRestrictions>) end;

  //-------------namespace: System.Dynamic----------------
  DNCallInfoClass = interface(DDN.mscorlib.DNObjectClass)
  ['{80DF0ECB-4EE5-57E9-B196-D0D3DA6EBE68}']
  { constructors } 

    ///<summary>Creates a new PositionalArgumentInfo.</summary>
    ///  <param name="argCount">The number of arguments.</param>
    ///  <param name="argNames">The argument names.</param>
    {class} function init(argCount: Int32; argNames: TArray<string>): DNCallInfo; overload;
    {class} function init(argCount: Int32; argNames: DDN.mscorlib.DNIEnumerable<string>): DNCallInfo; overload;

  end;

  ///<summary>Describes arguments in the dynamic binding process.</summary>
  [DNTypeName('System.Dynamic.CallInfo')]
  DNCallInfo = interface(DDN.mscorlib.DNObject)
  ['{9FE8E955-3B50-3853-9698-AE3CA9D0B2D9}']
  { getters & setters } 

    function get_ArgumentCount: Int32;
    function get_ArgumentNames: DDN.mscorlib.DNReadOnlyCollection<string>;

  { methods } 

    ///<summary>Serves as a hash function for the current <see cref="T:System.Dynamic.CallInfo" />
    ///  .</summary>
    ///<returns>A hash code for the current <see cref="T:System.Dynamic.CallInfo" />
    ///  .</returns>
    function GetHashCode: Int32;
    ///<summary>Determines whether the specified CallInfo instance is considered equal to the current.</summary>
    ///  <param name="obj">The instance of <see cref="T:System.Dynamic.CallInfo" />
    ///  to compare with the current instance.</param>
    ///<returns>true if the specified instance is equal to the current one otherwise, false.</returns>
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The number of arguments.</summary>
    ///<returns>The number of arguments.</returns>
    property ArgumentCount: Int32 read get_ArgumentCount;
    ///<summary>The argument names.</summary>
    ///<returns>The read-only collection of argument names.</returns>
    property ArgumentNames: DDN.mscorlib.DNReadOnlyCollection<string> read get_ArgumentNames;
  end;

  TDNCallInfo = class(TDNGenericImport<DNCallInfoClass, DNCallInfo>) end;

  //-------------namespace: System.Dynamic----------------
  DNDynamicMetaObjectClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6F4E3A75-55E7-505A-B140-2023A687853A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  class.</summary>
    ///  <param name="expression">The expression representing this <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  during the dynamic binding process.</param>
    ///  <param name="restrictions">The set of binding restrictions under which the binding is valid.</param>
    {class} function init(expression: DNExpression; restrictions: DNBindingRestrictions): DNDynamicMetaObject; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  class.</summary>
    ///  <param name="expression">The expression representing this <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  during the dynamic binding process.</param>
    ///  <param name="restrictions">The set of binding restrictions under which the binding is valid.</param>
    ///  <param name="value">The runtime value represented by the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  .</param>
    {class} function init(expression: DNExpression; restrictions: DNBindingRestrictions; value: DDN.mscorlib.DNObject): DNDynamicMetaObject; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_EmptyMetaObjects: TArray<DNDynamicMetaObject>;

  { static fields } 

    ///<summary>Represents an empty array of type <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  . This field is read only.</summary>
    {class} property EmptyMetaObjects: TArray<DNDynamicMetaObject> read __fakeFieldGet_EmptyMetaObjects;

  { static methods } 

    ///<summary>Creates a meta-object for the specified object.</summary>
    ///  <param name="value">The object to get a meta-object for.</param>
    ///  <param name="expression">The expression representing this <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  during the dynamic binding process.</param>
    ///<returns>If the given object implements <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" />
    ///  and is not a remote object from outside the current AppDomain, returns the object's specific meta-object returned by <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />
    ///  . Otherwise a plain new meta-object with no restrictions is created and returned.</returns>
    {class} function Create(value: DDN.mscorlib.DNObject; expression: DNExpression): DNDynamicMetaObject;

  end;

  ///<summary>Represents the dynamic binding and a binding logic of an object participating in the dynamic binding.</summary>
  [DNTypeName('System.Dynamic.DynamicMetaObject')]
  DNDynamicMetaObject = interface(DDN.mscorlib.DNObject)
  ['{7C5EC2F6-5CA9-34BC-B4E0-C857AA5BE3D7}']
  { getters & setters } 

    function get_Expression: DNExpression;
    function get_Restrictions: DNBindingRestrictions;
    function get_Value: DDN.mscorlib.DNObject;
    function get_HasValue: Boolean;
    function get_RuntimeType: DDN.mscorlib.DNType;
    function get_LimitType: DDN.mscorlib.DNType;

  { methods } 

    ///<summary>Performs the binding of the dynamic conversion operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.ConvertBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindConvert(binder: DNConvertBinder): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic get member operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.GetMemberBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindGetMember(binder: DNGetMemberBinder): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic set member operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.SetMemberBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="value">The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the value for the set member operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindSetMember(binder: DNSetMemberBinder; value: DNDynamicMetaObject): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic delete member operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.DeleteMemberBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindDeleteMember(binder: DNDeleteMemberBinder): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic get index operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.GetIndexBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="indexes">An array of <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  instances - indexes for the get index operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindGetIndex(binder: DNGetIndexBinder; indexes: TArray<DNDynamicMetaObject>): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic set index operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.SetIndexBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="indexes">An array of <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  instances - indexes for the set index operation.</param>
    ///  <param name="value">The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the value for the set index operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindSetIndex(binder: DNSetIndexBinder; indexes: TArray<DNDynamicMetaObject>; value: DNDynamicMetaObject): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic delete index operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.DeleteIndexBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="indexes">An array of <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  instances - indexes for the delete index operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindDeleteIndex(binder: DNDeleteIndexBinder; indexes: TArray<DNDynamicMetaObject>): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic invoke member operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.InvokeMemberBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  instances - arguments to the invoke member operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindInvokeMember(binder: DNInvokeMemberBinder; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic invoke operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.InvokeBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  instances - arguments to the invoke operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindInvoke(binder: DNInvokeBinder; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic create instance operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.CreateInstanceBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  instances - arguments to the create instance operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindCreateInstance(binder: DNCreateInstanceBinder; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic unary operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.UnaryOperationBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindUnaryOperation(binder: DNUnaryOperationBinder): DNDynamicMetaObject;
    ///<summary>Performs the binding of the dynamic binary operation.</summary>
    ///  <param name="binder">An instance of the <see cref="T:System.Dynamic.BinaryOperationBinder" />
    ///  that represents the details of the dynamic operation.</param>
    ///  <param name="arg">An instance of the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the right hand side of the binary operation.</param>
    ///<returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function BindBinaryOperation(binder: DNBinaryOperationBinder; arg: DNDynamicMetaObject): DNDynamicMetaObject;
    ///<summary>Returns the enumeration of all dynamic member names.</summary>
    ///<returns>The list of dynamic member names.</returns>
    function GetDynamicMemberNames: DDN.mscorlib.DNIEnumerable<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The expression representing the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  during the dynamic binding process.</summary>
    ///<returns>The expression representing the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  during the dynamic binding process.</returns>
    property Expression: DNExpression read get_Expression;
    ///<summary>The set of binding restrictions under which the binding is valid.</summary>
    ///<returns>The set of binding restrictions.</returns>
    property Restrictions: DNBindingRestrictions read get_Restrictions;
    ///<summary>The runtime value represented by this <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  .</summary>
    ///<returns>The runtime value represented by this <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  .</returns>
    property Value: DDN.mscorlib.DNObject read get_Value;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  has the runtime value.</summary>
    ///<returns>True if the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  has the runtime value, otherwise false.</returns>
    property HasValue: Boolean read get_HasValue;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  of the runtime value or null if the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  has no value associated with it.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  of the runtime value or null.</returns>
    property RuntimeType: DDN.mscorlib.DNType read get_RuntimeType;
    ///<summary>Gets the limit type of the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  .</summary>
    ///<returns><see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" />
    ///  if runtime value is available, a type of the <see cref="P:System.Dynamic.DynamicMetaObject.Expression" />
    ///  otherwise.</returns>
    property LimitType: DDN.mscorlib.DNType read get_LimitType;
  end;

  TDNDynamicMetaObject = class(TDNGenericImport<DNDynamicMetaObjectClass, DNDynamicMetaObject>) end;

  //-------------namespace: System.Dynamic----------------
  DNDynamicObjectClass = interface(DNObjectClass)
  ['{E1BBE545-B356-5E8C-83E9-4B2715F4F039}']
  end;

  ///<summary>Provides a base class for specifying dynamic behavior at run time. This class must be inherited from; you cannot instantiate it directly.</summary>
  [DNTypeName('System.Dynamic.DynamicObject')]
  DNDynamicObject = interface(DNIDynamicMetaObjectProvider)
  ['{204F3E34-E149-3EAB-8FE7-10348AA2C02E}']
  { methods } 

    function TryGetMember(binder: DNGetMemberBinder; out result: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Provides the implementation for operations that set member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" />
    ///  class can override this method to specify dynamic behavior for operations such as setting a value for a property.</summary>
    ///  <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member to which the value is being assigned. For example, for the statement sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" />
    ///  class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
    ///  <param name="value">The value to set to the member. For example, for sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" />
    ///  class, the <paramref name="value" />
    ///  is "Test".</param>
    ///<returns><see langword="true" />
    ///  if the operation is successful; otherwise, <see langword="false" />
    ///  . If this method returns <see langword="false" />
    ///  , the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
    function TrySetMember(binder: DNSetMemberBinder; value: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.</summary>
    ///  <param name="binder">Provides information about the deletion.</param>
    ///<returns><see langword="true" />
    ///  if the operation is successful; otherwise, <see langword="false" />
    ///  . If this method returns <see langword="false" />
    ///  , the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
    function TryDeleteMember(binder: DNDeleteMemberBinder): Boolean;
    function TryInvokeMember(binder: DNInvokeMemberBinder; args: TArray<DDN.mscorlib.DNObject>; out result: DDN.mscorlib.DNObject): Boolean;
    function TryConvert(binder: DNConvertBinder; out result: DDN.mscorlib.DNObject): Boolean;
    function TryCreateInstance(binder: DNCreateInstanceBinder; args: TArray<DDN.mscorlib.DNObject>; out result: DDN.mscorlib.DNObject): Boolean;
    function TryInvoke(binder: DNInvokeBinder; args: TArray<DDN.mscorlib.DNObject>; out result: DDN.mscorlib.DNObject): Boolean;
    function TryBinaryOperation(binder: DNBinaryOperationBinder; arg: DDN.mscorlib.DNObject; out result: DDN.mscorlib.DNObject): Boolean;
    function TryUnaryOperation(binder: DNUnaryOperationBinder; out result: DDN.mscorlib.DNObject): Boolean;
    function TryGetIndex(binder: DNGetIndexBinder; indexes: TArray<DDN.mscorlib.DNObject>; out result: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Provides the implementation for operations that set a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" />
    ///  class can override this method to specify dynamic behavior for operations that access objects by a specified index.</summary>
    ///  <param name="binder">Provides information about the operation. </param>
    ///  <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" />
    ///  class, <paramref name="indexes[0]" />
    ///  is equal to 3.</param>
    ///  <param name="value">The value to set to the object that has the specified index. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" />
    ///  class, <paramref name="value" />
    ///  is equal to 10.</param>
    ///<returns><see langword="true" />
    ///  if the operation is successful; otherwise, <see langword="false" />
    ///  . If this method returns <see langword="false" />
    ///  , the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.</returns>
    function TrySetIndex(binder: DNSetIndexBinder; indexes: TArray<DDN.mscorlib.DNObject>; value: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Provides the implementation for operations that delete an object by index. This method is not intended for use in C# or Visual Basic.</summary>
    ///  <param name="binder">Provides information about the deletion.</param>
    ///  <param name="indexes">The indexes to be deleted.</param>
    ///<returns><see langword="true" />
    ///  if the operation is successful; otherwise, <see langword="false" />
    ///  . If this method returns <see langword="false" />
    ///  , the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
    function TryDeleteIndex(binder: DNDeleteIndexBinder; indexes: TArray<DDN.mscorlib.DNObject>): Boolean;
    ///<summary>Provides a <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  that dispatches to the dynamic virtual methods. The object can be encapsulated inside another <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  to provide custom behavior for individual actions. This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.</summary>
    ///  <param name="parameter">The expression that represents <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  to dispatch to the dynamic virtual methods.</param>
    ///<returns>An object of the <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  type.</returns>
    function GetMetaObject(parameter: DNExpression): DNDynamicMetaObject;
    ///<summary>Returns the enumeration of all dynamic member names. </summary>
    ///<returns>A sequence that contains dynamic member names.</returns>
    function GetDynamicMemberNames: DDN.mscorlib.DNIEnumerable<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDynamicObject = class(TDNGenericImport<DNDynamicObjectClass, DNDynamicObject>) end;

  //-------------namespace: System.Dynamic----------------
  DNExpandoObjectClass = interface(DNObjectClass)
  ['{060D7A36-212B-52B2-915E-05118EE1CA79}']
  { constructors } 

    ///<summary>Initializes a new <see langword="ExpandoObject" />
    ///  that does not have members.</summary>
    {class} function init: DNExpandoObject;

  end;

  ///<summary>Represents an object whose members can be dynamically added and removed at run time.</summary>
  [DNTypeName('System.Dynamic.ExpandoObject')]
  DNExpandoObject = interface(DNIDynamicMetaObjectProvider)
  ['{840EBDA4-C790-33E3-9805-EA653C9DEC12}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNExpandoObject = class(TDNGenericImport<DNExpandoObjectClass, DNExpandoObject>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventRecordWrittenEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{AC5F40B0-12E8-5834-9338-D46A0FA79D5E}']
  end;

  ///<summary>When the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" />
  ///  event is raised, an instance of this object is passed to the delegate method that handles the event. This object contains the event that was published to the event log or the exception that occurred when the event subscription failed. </summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventRecordWrittenEventArgs')]
  DNEventRecordWrittenEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{EC061C98-D7AF-3D6D-BDEA-F7D1B8426E56}']
  { getters & setters } 

    function get_EventRecord: DNEventRecord;
    function get_EventException: DDN.mscorlib.DNException;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the event record that is published to the event log. This event matches the criteria from the query specified in the event subscription.</summary>
    ///<returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />
    ///  object.</returns>
    property EventRecord: DNEventRecord read get_EventRecord;
    ///<summary>Gets the exception that occurred when the event subscription failed. The exception has a description of why the subscription failed.</summary>
    ///<returns>Returns an <see cref="T:System.Exception" />
    ///  object.</returns>
    property EventException: DDN.mscorlib.DNException read get_EventException;
  end;

  TDNEventRecordWrittenEventArgs = class(TDNGenericImport<DNEventRecordWrittenEventArgsClass, DNEventRecordWrittenEventArgs>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogExceptionClass = interface(DDN.mscorlib.DNExceptionClass)
  ['{B44D9323-8D54-517A-B776-7C173E8AD041}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" />
    ///  class.</summary>
    {class} function init: DNEventLogException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" />
    ///  class by specifying the error message that describes the current exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    {class} function init(message: string): DNEventLogException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" />
    ///  class with an error message and inner exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNEventLogException; overload;

  end;

  ///<summary>Represents the base class for all the exceptions that are thrown when an error occurs while reading event log related information. </summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogException')]
  DNEventLogException = interface(DDN.mscorlib.DNException)
  ['{AE52C84A-5E93-3AF3-90AA-82E22C8507C1}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Sets the SerializationInfo object with information about the exception.</summary>
    ///  <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that holds the serialized object data about the exception thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object that contains contextual information about the source or destination.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the error message that describes the current exception.</summary>
    ///<returns>Returns a string that contains the error message that describes the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNEventLogException = class(TDNGenericImport<DNEventLogExceptionClass, DNEventLogException>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogInvalidDataExceptionClass = interface(DNEventLogExceptionClass)
  ['{D73102E7-8021-5A7C-8302-B94C34BC70E7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" />
    ///  class.</summary>
    {class} function init: DNEventLogInvalidDataException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" />
    ///  class by specifying the error message that describes the current exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    {class} function init(message: string): DNEventLogInvalidDataException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" />
    ///  class with an error message and inner exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNEventLogInvalidDataException; overload;

  end;

  ///<summary>Represents the exception thrown when an event provider publishes invalid data in an event.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogInvalidDataException')]
  DNEventLogInvalidDataException = interface(DNEventLogException)
  ['{72072B91-C071-353B-9689-14F3F90E8224}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Sets the SerializationInfo object with information about the exception.</summary>
    ///  <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that holds the serialized object data about the exception thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object that contains contextual information about the source or destination.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the error message that describes the current exception.</summary>
    ///<returns>Returns a string that contains the error message that describes the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNEventLogInvalidDataException = class(TDNGenericImport<DNEventLogInvalidDataExceptionClass, DNEventLogInvalidDataException>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogNotFoundExceptionClass = interface(DNEventLogExceptionClass)
  ['{9BEA56B2-13FC-5FB2-89FA-595E265DF079}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" />
    ///  class.</summary>
    {class} function init: DNEventLogNotFoundException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" />
    ///  class by specifying the error message that describes the current exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    {class} function init(message: string): DNEventLogNotFoundException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" />
    ///  class with an error message and inner exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNEventLogNotFoundException; overload;

  end;

  ///<summary>Represents the exception that is thrown when a requested event log (usually specified by the name of the event log or the path to the event log file) does not exist.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogNotFoundException')]
  DNEventLogNotFoundException = interface(DNEventLogException)
  ['{7467A27C-8DDC-3F25-AFA5-7F91CAB51CFF}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Sets the SerializationInfo object with information about the exception.</summary>
    ///  <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that holds the serialized object data about the exception thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object that contains contextual information about the source or destination.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the error message that describes the current exception.</summary>
    ///<returns>Returns a string that contains the error message that describes the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNEventLogNotFoundException = class(TDNGenericImport<DNEventLogNotFoundExceptionClass, DNEventLogNotFoundException>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogProviderDisabledExceptionClass = interface(DNEventLogExceptionClass)
  ['{27E19F6B-629F-5FEE-8BCD-01E93C0357C1}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" />
    ///  class.</summary>
    {class} function init: DNEventLogProviderDisabledException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" />
    ///  class by specifying the error message that describes the current exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    {class} function init(message: string): DNEventLogProviderDisabledException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" />
    ///  class with an error message and inner exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNEventLogProviderDisabledException; overload;

  end;

  ///<summary>Represents the exception that is thrown when a specified event provider name references a disabled event provider. A disabled event provider cannot publish events.</summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException')]
  DNEventLogProviderDisabledException = interface(DNEventLogException)
  ['{FFE913DB-FB84-339C-8BFD-096F34AFFB0D}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Sets the SerializationInfo object with information about the exception.</summary>
    ///  <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that holds the serialized object data about the exception thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object that contains contextual information about the source or destination.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the error message that describes the current exception.</summary>
    ///<returns>Returns a string that contains the error message that describes the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNEventLogProviderDisabledException = class(TDNGenericImport<DNEventLogProviderDisabledExceptionClass, DNEventLogProviderDisabledException>) end;

  //-------------namespace: System.Diagnostics.Eventing.Reader----------------
  DNEventLogReadingExceptionClass = interface(DNEventLogExceptionClass)
  ['{86C40441-D2C1-55FC-B851-1E9F5682BF3E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" />
    ///  class.</summary>
    {class} function init: DNEventLogReadingException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" />
    ///  class by specifying the error message that describes the current exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    {class} function init(message: string): DNEventLogReadingException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" />
    ///  class with an error message and inner exception.</summary>
    ///  <param name="message">The error message that describes the current exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNEventLogReadingException; overload;

  end;

  ///<summary>Represents an exception that is thrown when an error occurred while reading, querying, or subscribing to the events in an event log. </summary>
  [DNTypeName('System.Diagnostics.Eventing.Reader.EventLogReadingException')]
  DNEventLogReadingException = interface(DNEventLogException)
  ['{FDCAE3B5-2174-3EA5-A6B7-4CB283AE4D6A}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Sets the SerializationInfo object with information about the exception.</summary>
    ///  <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object that holds the serialized object data about the exception thrown.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object that contains contextual information about the source or destination.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the error message that describes the current exception.</summary>
    ///<returns>Returns a string that contains the error message that describes the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNEventLogReadingException = class(TDNGenericImport<DNEventLogReadingExceptionClass, DNEventLogReadingException>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNInstrumentationBaseExceptionClass = interface(DDN.mscorlib.DNExceptionClass)
  ['{21A5C93D-94CB-5354-BBA5-E8D722F8501F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" />
    ///  . class. This is the default constructor.</summary>
    {class} function init: DNInstrumentationBaseException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" />
    ///  class with a message that describes the exception.</summary>
    ///  <param name="message">Message that describes the exception.</param>
    {class} function init(message: string): DNInstrumentationBaseException; overload;
    ///<summary>Initializes a new <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" />
    ///  class with the specified string and exception.</summary>
    ///  <param name="message">Message that describes the exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNInstrumentationBaseException; overload;

  end;

  ///<summary>Represents the base provider-related exception.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.InstrumentationBaseException')]
  DNInstrumentationBaseException = interface(DDN.mscorlib.DNException)
  ['{A0C56843-F520-3B7D-81C4-AAACB5877558}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInstrumentationBaseException = class(TDNGenericImport<DNInstrumentationBaseExceptionClass, DNInstrumentationBaseException>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNInstrumentationExceptionClass = interface(DNInstrumentationBaseExceptionClass)
  ['{16A0D172-5D42-541C-AB04-7F5AD1A8FDD6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationException" />
    ///  class. This is the default constructor.</summary>
    {class} function init: DNInstrumentationException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationException" />
    ///  class with a message that describes the exception.</summary>
    ///  <param name="message">Message that describes the exception.</param>
    {class} function init(message: string): DNInstrumentationException; overload;
    ///<summary>Initializes a new <see cref="T:System.Management.Instrumentation.InstrumentationException" />
    ///  class with the System.Exception that caused the current exception.</summary>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(innerException: DDN.mscorlib.DNException): DNInstrumentationException; overload;
    ///<summary>Initializes a new <see cref="T:System.Management.Instrumentation.InstrumentationException" />
    ///  class with the specified string and exception.</summary>
    ///  <param name="message">Message that describes the exception.</param>
    ///  <param name="innerException">The Exception instance that caused the current exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNInstrumentationException; overload;

  end;

  ///<summary>Represents a provider-related exception.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.InstrumentationException')]
  DNInstrumentationException = interface(DNInstrumentationBaseException)
  ['{DD8BCCD3-7DEF-3E01-934C-179EB6122E5D}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInstrumentationException = class(TDNGenericImport<DNInstrumentationExceptionClass, DNInstrumentationException>) end;

  //-------------namespace: System.Management.Instrumentation----------------
  DNInstanceNotFoundExceptionClass = interface(DNInstrumentationExceptionClass)
  ['{BF77AB9C-4021-5A69-B147-8F8E4DE4C1DF}']
  { constructors } 

    ///<summary>Initializes a new instance of the InstanceNotFoundException class.</summary>
    {class} function init: DNInstanceNotFoundException; overload;
    ///<summary>Initializes a new instance of the InstanceNotFoundException class with its message string set to message.</summary>
    ///  <param name="message">A string that contains the error message that explains the reason for the exception.</param>
    {class} function init(message: string): DNInstanceNotFoundException; overload;
    ///<summary>Initializes a new instance of the InstanceNotFoundException class with the specified error message and the inner exception.</summary>
    ///  <param name="message">A string that contains the error message that explains the reason for the exception.</param>
    ///  <param name="innerException">The Exception that caused the current exception to be thrown.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNInstanceNotFoundException; overload;

  end;

  ///<summary>The exception thrown to indicate that no instances are returned by a provider.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
  [DNTypeName('System.Management.Instrumentation.InstanceNotFoundException')]
  DNInstanceNotFoundException = interface(DNInstrumentationException)
  ['{6EA1817C-23A9-39C4-9DBC-8E0A2F3F8B79}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNInstanceNotFoundException = class(TDNGenericImport<DNInstanceNotFoundExceptionClass, DNInstanceNotFoundException>) end;

  //-------------namespace: System.IO.MemoryMappedFiles----------------
  DNMemoryMappedFileClass = interface(DNObjectClass)
  ['{1F981C0C-2294-5D16-8F25-07285133B2EC}']
  { static methods } 

    ///<summary>Opens an existing memory-mapped file that has the specified name in system memory.</summary>
    ///  <param name="mapName">The name of the memory-mapped file to open.</param>
    ///<returns>A memory-mapped file that has the specified name. </returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.IO.FileNotFoundException">The file specified for <paramref name="mapName" />
    ///  does not exist.</exception>
    {class} function OpenExisting(mapName: string): DNMemoryMappedFile; overload;
    ///<summary>Opens an existing memory-mapped file that has the specified name and access rights in system memory.</summary>
    ///  <param name="mapName">The name of the memory-mapped file to open.</param>
    ///  <param name="desiredAccessRights">One of the enumeration values that specifies the access rights to apply to the memory-mapped file.</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
    ///  enumeration value.</exception><exception cref="T:System.IO.FileNotFoundException">The file specified for <paramref name="mapName" />
    ///  does not exist.</exception>
    {class} function OpenExisting(mapName: string; desiredAccessRights: DNMemoryMappedFileRights): DNMemoryMappedFile; overload;
    ///<summary>Opens an existing memory-mapped file that has the specified name, access rights, and inheritability in system memory.</summary>
    ///  <param name="mapName">The name of the memory-mapped file to open.</param>
    ///  <param name="desiredAccessRights">One of the enumeration values that specifies the access rights to apply to the memory-mapped file.</param>
    ///  <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="desiredAccessRights" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  enumeration value.</exception><exception cref="T:System.UnauthorizedAccessException">The requested access is invalid for the memory-mapped file.</exception><exception cref="T:System.IO.FileNotFoundException">The file specified for <paramref name="mapName" />
    ///  does not exist.</exception>
    {class} function OpenExisting(mapName: string; desiredAccessRights: DNMemoryMappedFileRights; inheritability: DNHandleInheritability): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file from a file on disk.</summary>
    ///  <param name="path">The path to file to map.</param>
    ///<returns>A memory-mapped file.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="path" />
    ///  is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" />
    ///  method. -or-
    ///  <paramref name="path" />
    ///  refers to an invalid device. </exception><exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.IO.IOException">An I/O error occurred.</exception><exception cref="T:System.IO.PathTooLongException"><paramref name="path" />
    ///  exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
    {class} function CreateFromFile(path: string): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified access mode from a file on disk. </summary>
    ///  <param name="path">The path to file to map.</param>
    ///  <param name="mode">Access mode; must be <see cref="F:System.IO.FileMode.Open" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified access mode.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="path" />
    ///  is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" />
    ///  method. -or-
    ///  <paramref name="path" />
    ///  refers to an invalid device.-or-
    ///  <paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.Append" />
    ///  .</exception><exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.IO.IOException"><paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.Create" />
    ///  , <see cref="F:System.IO.FileMode.CreateNew" />
    ///  , or <see cref="F:System.IO.FileMode.Truncate" />
    ///  .-or-
    ///  <paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.OpenOrCreate" />
    ///  and the file on disk does not exist.-or-An I/O error occurred.</exception><exception cref="T:System.IO.PathTooLongException"><paramref name="path" />
    ///  exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters. </exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
    {class} function CreateFromFile(path: string; mode: DDN.mscorlib.DNFileMode): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified access mode and name from a file on disk.</summary>
    ///  <param name="path">The path to the file to map.</param>
    ///  <param name="mode">Access mode; must be <see cref="F:System.IO.FileMode.Open" />
    ///  .</param>
    ///  <param name="mapName">A name to assign to the memory-mapped file. </param>
    ///<returns>A memory-mapped file that has the specified name and access mode.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="path" />
    ///  is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" />
    ///  method. -or-
    ///  <paramref name="path" />
    ///  refers to an invalid device.-or-
    ///  <paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.Append" />
    ///  .</exception><exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  or <paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.IO.IOException"><paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.Create" />
    ///  , <see cref="F:System.IO.FileMode.CreateNew" />
    ///  , or <see cref="F:System.IO.FileMode.Truncate" />
    ///  .-or-
    ///  <paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.OpenOrCreate" />
    ///  and the file on disk does not exist.-or-An I/O error occurred.</exception><exception cref="T:System.IO.PathTooLongException"><paramref name="path" />
    ///  exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
    {class} function CreateFromFile(path: string; mode: DDN.mscorlib.DNFileMode; mapName: string): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified access mode, name, and capacity from a file on disk.</summary>
    ///  <param name="path">The path to the file to map.</param>
    ///  <param name="mode">Access mode; can be any of the <see cref="T:System.IO.FileMode" />
    ///  enumeration values except <see cref="F:System.IO.FileMode.Append" />
    ///  .</param>
    ///  <param name="mapName">A name to assign to the memory-mapped file. </param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="path" />
    ///  is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" />
    ///  method. -or-
    ///  <paramref name="path" />
    ///  refers to an invalid device.-or-
    ///  <paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.Append" />
    ///  .</exception><exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  or <paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is greater than the size of the logical address space.-or-
    ///  <paramref name="capacity" />
    ///  is less than zero.-or-
    ///  <paramref name="capacity" />
    ///  is less than the file size (but not zero).-or-
    ///  <paramref name="capacity" />
    ///  is zero, and the size of the file on disk is also zero.</exception><exception cref="T:System.IO.IOException">An I/O error occurred.</exception><exception cref="T:System.IO.PathTooLongException"><paramref name="path" />
    ///  exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
    {class} function CreateFromFile(path: string; mode: DDN.mscorlib.DNFileMode; mapName: string; capacity: Int64): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified access mode, name, capacity, and access type from a file on disk.</summary>
    ///  <param name="path">The path to the file to map.</param>
    ///  <param name="mode">Access mode; can be any of the <see cref="T:System.IO.FileMode" />
    ///  enumeration values except <see cref="F:System.IO.FileMode.Append" />
    ///  .</param>
    ///  <param name="mapName">A name to assign to the memory-mapped file. </param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="access" />
    ///  is not an allowed value.-or-
    ///  <paramref name="path" />
    ///  specifies an empty file.-or-
    ///  <paramref name="access" />
    ///  is specified as <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" />
    ///  and capacity is greater than the size of the file indicated by <paramref name="path" />
    ///  .-or-
    ///  <paramref name="mode" />
    ///  is <see cref="F:System.IO.FileMode.Append" />
    ///  .</exception><exception cref="T:System.ArgumentNullException"><paramref name="path" />
    ///  or <paramref name="mapName" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is greater than the size of the logical address space.-or-
    ///  <paramref name="capacity" />
    ///  is less than zero.-or-
    ///  <paramref name="capacity" />
    ///  is less than the file size (but not zero).-or-
    ///  <paramref name="capacity" />
    ///  is zero, and the size of the file on disk is also zero.-or-
    ///  <paramref name="access" />
    ///  is not a defined <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  value.-or-The size of the file indicated by <paramref name="path" />
    ///  is greater than <paramref name="capacity" />
    ///  .</exception><exception cref="T:System.IO.IOException">-or-An I/O error occurred.</exception><exception cref="T:System.IO.PathTooLongException"><paramref name="path" />
    ///  exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
    {class} function CreateFromFile(path: string; mode: DDN.mscorlib.DNFileMode; mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file from an existing file with the specified access mode, name, inheritability, and capacity.</summary>
    ///  <param name="fileStream">The file stream of the existing file.</param>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of <paramref name="filestream" />
    ///  .</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. This parameter canâ€™t be set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  . </param>
    ///  <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///  <param name="leaveOpen">A value that indicates whether to close the source file stream when the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
    ///  is disposed. </param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  or an empty string.-or-
    ///  <paramref name="capacity" />
    ///  and the length of the file are zero.-or-
    ///  <paramref name="access" />
    ///  is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value, which is not allowed.-or-
    ///  <paramref name="access" />
    ///  is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" />
    ///  and <paramref name="capacity" />
    ///  is larger than the length of <see langword="filestream" />
    ///  .</exception><exception cref="T:System.ArgumentNullException"><paramref name="fileStream" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is less than zero.-or-
    ///  <paramref name="capacity" />
    ///  is less than the file size.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  enumeration value.</exception>
    {class} function CreateFromFile(fileStream: DDN.mscorlib.DNFileStream; mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess; inheritability: DNHandleInheritability; leaveOpen: Boolean): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified name, capacity, access type, security permissions, inheritability, and disposal requirement from a file on disk. </summary>
    ///  <param name="fileStream">The <paramref name="fileStream" />
    ///  to the file to map.</param>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. This parameter canâ€™t be set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  . </param>
    ///  <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///  <param name="leaveOpen"><see langword="true" />
    ///  to not dispose <paramref name="fileStream" />
    ///  after the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
    ///  is closed; <see langword="false" />
    ///  to dispose <paramref name="fileStream" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="capacity" />
    ///  and the length of the file are zero.-or-
    ///  <paramref name="access" />
    ///  is set to the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" />
    ///  or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value, which is not allowed.</exception><exception cref="T:System.ArgumentNullException"><paramref name="fileStream" />
    ///  or <paramref name="mapname" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is less than zero.-or-
    ///  <paramref name="capacity" />
    ///  is less than the file size.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  enumeration value.</exception><exception cref="T:System.ObjectDisposedException"><paramref name="fileStream" />
    ///  was closed.</exception><exception cref="T:System.UnauthorizedAccessException"><paramref name="access" />
    ///  is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  when <paramref name="fileStream" />
    ///  's access is set to <see cref="F:System.IO.FileAccess.Read" />
    ///  or <see cref="F:System.IO.FileAccess.Write" />
    ///  . </exception><exception cref="T:System.IO.IOException"><paramref name="mapName" />
    ///  already exists.</exception>
    {class} function CreateFromFile(fileStream: DDN.mscorlib.DNFileStream; mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess; memoryMappedFileSecurity: DNMemoryMappedFileSecurity; inheritability: DNHandleInheritability; leaveOpen: Boolean): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified capacity in system memory. </summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///<returns>A memory-mapped file that has the specified name and capacity.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string. </exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is less than or equal to zero.</exception>
    {class} function CreateNew(mapName: string; capacity: Int64): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified capacity and access type in system memory. </summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  . </param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="access" />
    ///  is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value. </exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is less than or equal to zero.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.</exception>
    {class} function CreateNew(mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified name, capacity, access type, memory allocation options and inheritability.</summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  .</param>
    ///  <param name="options">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</param>
    ///  <param name="inheritability">A value that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="access" />
    ///  is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value. </exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is less than or equal to zero.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  value.</exception>
    {class} function CreateNew(mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess; options: DNMemoryMappedFileOptions; inheritability: DNHandleInheritability): DNMemoryMappedFile; overload;
    ///<summary>Creates a memory-mapped file that has the specified capacity, access type, memory allocation, security permissions, and inheritability in system memory.</summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  . </param>
    ///  <param name="options">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</param>
    ///  <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="access" />
    ///  is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is less than or equal to zero.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  enumeration value.</exception>
    {class} function CreateNew(mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess; options: DNMemoryMappedFileOptions; memoryMappedFileSecurity: DNMemoryMappedFileSecurity; inheritability: DNHandleInheritability): DNMemoryMappedFile; overload;
    ///<summary>Creates or opens a memory-mapped file that has the specified capacity in system memory.</summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///<returns>A memory-mapped file that has the specified name and size.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is greater than the size of the logical address space.-or-
    ///  <paramref name="capacity" />
    ///  is less than or equal to zero.</exception>
    {class} function CreateOrOpen(mapName: string; capacity: Int64): DNMemoryMappedFile; overload;
    ///<summary>Creates or opens a memory-mapped file that has the specified capacity and access type in system memory. </summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  . </param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="access" />
    ///  is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is greater than the size of the logical address space.-or-
    ///  <paramref name="capacity" />
    ///  is less than or equal to zero.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.</exception><exception cref="T:System.UnauthorizedAccessException">The operating system denied the specified access to the file; for example, access is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  , but the file or directory is read-only. </exception>
    {class} function CreateOrOpen(mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess): DNMemoryMappedFile; overload;
    ///<summary>Creates a new empty memory mapped file or opens an existing memory mapped file if one exists with the same name. If opening an existing file, the capacity, options, and memory arguments will be ignored. </summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  . </param>
    ///  <param name="options">A bitwise combination of values that indicate the memory allocation options to apply to the file.</param>
    ///  <param name="inheritability">A value that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string.-or-
    ///  <paramref name="access" />
    ///  is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is greater than the size of the logical address space.-or-
    ///  <paramref name="capacity" />
    ///  is less than or equal to zero.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  enumeration value.</exception><exception cref="T:System.UnauthorizedAccessException">The operating system denied the specified access to the file; for example, access is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  , but the file or directory is read-only. </exception>
    {class} function CreateOrOpen(mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess; options: DNMemoryMappedFileOptions; inheritability: DNHandleInheritability): DNMemoryMappedFile; overload;
    ///<summary>Creates or opens a memory-mapped file that has the specified capacity, access type, memory allocation, security permissions, and inheritability in system memory.</summary>
    ///  <param name="mapName">A name to assign to the memory-mapped file.</param>
    ///  <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  . </param>
    ///  <param name="options">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</param>
    ///  <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />
    ///  .</param>
    ///<returns>A memory-mapped file that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="mapName" />
    ///  is an empty string. -or-
    ///  <paramref name="access" />
    ///  is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  enumeration value.</exception><exception cref="T:System.ArgumentNullException"><paramref name="mapName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />
    ///  is greater than the size of the logical address space.-or-
    ///  <paramref name="capacity" />
    ///  is less than or equal to zero.-or-
    ///  <paramref name="access" />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  enumeration value.</exception><exception cref="T:System.UnauthorizedAccessException">The operating system denied the specified <paramref name="access" />
    ///  to the file; for example, <paramref name="access" />
    ///  is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  , but the file or directory is read-only. </exception>
    {class} function CreateOrOpen(mapName: string; capacity: Int64; access: DNMemoryMappedFileAccess; options: DNMemoryMappedFileOptions; memoryMappedFileSecurity: DNMemoryMappedFileSecurity; inheritability: DNHandleInheritability): DNMemoryMappedFile; overload;

  end;

  ///<summary>Represents a memory-mapped file. </summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedFile')]
  DNMemoryMappedFile = interface(DDN.mscorlib.DNIDisposable)
  ['{0942D30F-2F26-3DD6-92A2-D3EDDA4F2ED4}']
  { getters & setters } 

    function get_SafeMemoryMappedFileHandle: DNSafeMemoryMappedFileHandle;

  { methods } 

    ///<summary>Creates a stream that maps to a view of the memory-mapped file.  </summary>
    ///<returns>A stream of memory.</returns>
    ///<exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception>
    function CreateViewStream: DNMemoryMappedViewStream; overload;
    ///<summary>Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset and size.</summary>
    ///  <param name="offset">The byte at which to start the view.</param>
    ///  <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" />
    ///  and ends approximately at the end of the memory-mapped file.</param>
    ///<returns>A stream of memory that has the specified offset and size.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  or <paramref name="size" />
    ///  is a negative value.-or-
    ///  <paramref name="size" />
    ///  is greater than the logical address space.</exception><exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception><exception cref="T:System.IO.IOException"><paramref name="size" />
    ///  is greater than the total virtual memory.</exception>
    function CreateViewStream(offset: Int64; size: Int64): DNMemoryMappedViewStream; overload;
    ///<summary>Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset, size, and access type.</summary>
    ///  <param name="offset">The byte at which to start the view.</param>
    ///  <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" />
    ///  and ends approximately at the end of the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  .</param>
    ///<returns>A stream of memory that has the specified characteristics.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  or <paramref name="size" />
    ///  is a negative value.-or-
    ///  <paramref name="size" />
    ///  is greater than the logical address space.-or-
    ///  <paramref name="access " />
    ///  is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
    ///  enumeration value.</exception><exception cref="T:System.UnauthorizedAccessException"><paramref name="access" />
    ///  is invalid for the memory-mapped file.</exception><exception cref="T:System.IO.IOException"><paramref name="size" />
    ///  is greater than the total virtual memory.-or-
    ///  <paramref name="access" />
    ///  is invalid for the memory-mapped file.</exception>
    function CreateViewStream(offset: Int64; size: Int64; access: DNMemoryMappedFileAccess): DNMemoryMappedViewStream; overload;
    ///<summary>Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />
    ///  that maps to a view of the memory-mapped file.</summary>
    ///<returns>A randomly accessible block of memory.</returns>
    ///<exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception>
    function CreateViewAccessor: DNMemoryMappedViewAccessor; overload;
    ///<summary>Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />
    ///  that maps to a view of the memory-mapped file, and that has the specified offset and size.</summary>
    ///  <param name="offset">The byte at which to start the view.</param>
    ///  <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" />
    ///  and ends approximately at the end of the memory-mapped file.</param>
    ///<returns>A randomly accessible block of memory.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  or <paramref name="size" />
    ///  is a negative value.-or-
    ///  <paramref name="size" />
    ///  is greater than the logical address space.</exception><exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception><exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
    function CreateViewAccessor(offset: Int64; size: Int64): DNMemoryMappedViewAccessor; overload;
    ///<summary>Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" />
    ///  that maps to a view of the memory-mapped file, and that has the specified offset, size, and access restrictions.</summary>
    ///  <param name="offset">The byte at which to start the view.</param>
    ///  <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" />
    ///  and ends approximately at the end of the memory-mapped file.</param>
    ///  <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />
    ///  .</param>
    ///<returns>A randomly accessible block of memory.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  or <paramref name="size" />
    ///  is a negative value.-or-
    ///  <paramref name="size" />
    ///  is greater than the logical address space.</exception><exception cref="T:System.UnauthorizedAccessException"><paramref name="access" />
    ///  is invalid for the memory-mapped file.</exception><exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
    function CreateViewAccessor(offset: Int64; size: Int64; access: DNMemoryMappedFileAccess): DNMemoryMappedViewAccessor; overload;
    ///<summary>Releases all resources used by the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
    ///  . </summary>
    procedure Dispose;
    ///<summary>Gets the access control to the memory-mapped file resource.</summary>
    ///<returns>The permissions that can be granted for file access and operations on memory-mapped files.</returns>
    ///<exception cref="T:System.InvalidOperationException">An underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">An underlying call to set security information failed.</exception><exception cref="T:System.ObjectDisposedException">The memory-mapped file is closed.</exception><exception cref="T:System.PlatformNotSupportedException">The current platform is Windows 98 or earlier.</exception><exception cref="T:System.UnauthorizedAccessException">An underlying call to set security information failed.-or-The memory-mapped file was opened as <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />
    ///  only.</exception>
    function GetAccessControl: DNMemoryMappedFileSecurity;
    ///<summary>Sets the access control to the memory-mapped file resource.</summary>
    ///  <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="memoryMappedFileSecurity" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">An underlying call to set security information failed.</exception><exception cref="T:System.UnauthorizedAccessException">An underlying call to set security information failed.</exception>
    procedure SetAccessControl(memoryMappedFileSecurity: DNMemoryMappedFileSecurity);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the file handle of a memory-mapped file.</summary>
    ///<returns>The handle to the memory-mapped file.</returns>
    property SafeMemoryMappedFileHandle: DNSafeMemoryMappedFileHandle read get_SafeMemoryMappedFileHandle;
  end;

  TDNMemoryMappedFile = class(TDNGenericImport<DNMemoryMappedFileClass, DNMemoryMappedFile>) end;

  //-------------namespace: System.IO.MemoryMappedFiles----------------
  DNMemoryMappedViewAccessorClass = interface(DDN.mscorlib.DNUnmanagedMemoryAccessorClass)
  ['{188FE65B-F987-5B0D-873C-F4BC557B89F1}']
  end;

  ///<summary>Represents a randomly accessed view of a memory-mapped file.</summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedViewAccessor')]
  DNMemoryMappedViewAccessor = interface(DDN.mscorlib.DNUnmanagedMemoryAccessor)
  ['{FAFB1B2C-8AF6-3882-861B-A38B3302FCF1}']
  { getters & setters } 

    function get_SafeMemoryMappedViewHandle: DNSafeMemoryMappedViewHandle;
    function get_PointerOffset: Int64;
    function get_Capacity: Int64;
    function get_CanRead: Boolean;
    function get_CanWrite: Boolean;

  { methods } 

    ///<summary>Clears all buffers for this view and causes any buffered data to be written to the underlying file.</summary>
    ///<exception cref="T:System.ObjectDisposedException">Methods were called after the accessor was closed.</exception>
    procedure Flush;
    procedure Dispose;
    function ReadBoolean(position: Int64): Boolean;
    function ReadByte(position: Int64): Byte;
    function ReadDecimal(position: Int64): DDN.mscorlib.DNDecimal;
    procedure Write(position: Int64; value: Boolean); overload;
    procedure Write(position: Int64; value: Byte); overload;
    procedure Write(position: Int64; value: DDN.mscorlib.DNDecimal); overload;
    function ReadChar(position: Int64): Char;
    function ReadInt16(position: Int64): Int16;
    function ReadInt32(position: Int64): Int32;
    function ReadInt64(position: Int64): Int64;
    function ReadSingle(position: Int64): Single;
    function ReadDouble(position: Int64): Double;
    function ReadSByte(position: Int64): SByte;
    function ReadUInt16(position: Int64): UInt16;
    function ReadUInt32(position: Int64): UInt32;
    function ReadUInt64(position: Int64): UInt64;
    procedure Write(position: Int64; value: Char); overload;
    procedure Write(position: Int64; value: Int16); overload;
    procedure Write(position: Int64; value: Int32); overload;
    procedure Write(position: Int64; value: Int64); overload;
    procedure Write(position: Int64; value: Single); overload;
    procedure Write(position: Int64; value: Double); overload;
    procedure Write(position: Int64; value: SByte); overload;
    procedure Write(position: Int64; value: UInt16); overload;
    procedure Write(position: Int64; value: UInt32); overload;
    procedure Write(position: Int64; value: UInt64); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a handle to the view of a memory-mapped file.</summary>
    ///<returns>A wrapper for the operating system's handle to the view of the file. </returns>
    property SafeMemoryMappedViewHandle: DNSafeMemoryMappedViewHandle read get_SafeMemoryMappedViewHandle;
    ///<summary>[Supported in the .NET Framework 4.5.1 and later versions] Gets the number of bytes by which the starting position of this view is offset from the beginning of the memory-mapped file. </summary>
    ///<returns>The number of bytes between the starting position of this view and the beginning of the memory-mapped file. </returns>
    ///<exception cref="T:System.InvalidOperationException">The object from which this instance was created is <see langword="null" />
    ///  . </exception>
    property PointerOffset: Int64 read get_PointerOffset;
    property Capacity: Int64 read get_Capacity;
    property CanRead: Boolean read get_CanRead;
    property CanWrite: Boolean read get_CanWrite;
  end;

  TDNMemoryMappedViewAccessor = class(TDNGenericImport<DNMemoryMappedViewAccessorClass, DNMemoryMappedViewAccessor>) end;

  //-------------namespace: System.Linq----------------
  DNEnumerableClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F1D19C7D-BD35-5372-B8D8-EB0AFFF57645}']
  { static methods } 

    ///<summary>Generates a sequence of integral numbers within a specified range.</summary>
    ///  <param name="start">The value of the first integer in the sequence.</param>
    ///  <param name="count">The number of sequential integers to generate.</param>
    ///<returns>An IEnumerable&lt;Int32&gt; in C# or IEnumerable(Of Int32) in Visual Basic that contains a range of sequential integral numbers.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />
    ///  is less than 0.-or-
    ///  <paramref name="start" />
    ///  + <paramref name="count" />
    ///  -1 is larger than <see cref="F:System.Int32.MaxValue" />
    ///  .</exception>
    {class} function Range(start: Int32; count: Int32): DDN.mscorlib.DNIEnumerable<Int32>;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<Int32>): Int32; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<Int64>): Int64; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<Single>): Single; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<Double>): Double; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<Int32>): Int32; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<Int64>): Int64; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<Single>): Single; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<Double>): Double; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<Int32>): Int32; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<Int64>): Int64; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<Double>): Double; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<Single>): Single; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<Int32>): Double; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<Int64>): Double; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<Single>): Single; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<Double>): Double; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Sum(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Min(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Max(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;

  end;

  ///<summary>Provides a set of <see langword="static" />
  ///  (<see langword="Shared" />
  ///  in Visual Basic) methods for querying objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1" />
  ///  .</summary>
  [DNTypeName('System.Linq.Enumerable')]
  DNEnumerable = interface(DDN.mscorlib.DNObject)
  ['{06F3D115-ED03-3D5F-B08B-8A15E18B855D}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEnumerable = class(TDNGenericImport<DNEnumerableClass, DNEnumerable>) end;

  //-------------namespace: System.Linq----------------
  DNEnumerableExecutorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{48A14358-A67F-56E5-AFE4-72F88C69B969}']
  end;

  ///<summary>Represents an expression tree and provides functionality to execute the expression tree after rewriting it.</summary>
  [DNTypeName('System.Linq.EnumerableExecutor')]
  DNEnumerableExecutor = interface(DDN.mscorlib.DNObject)
  ['{8F0D57B6-ED42-3D3F-A379-C471B23C4226}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEnumerableExecutor = class(TDNGenericImport<DNEnumerableExecutorClass, DNEnumerableExecutor>) end;

  //-------------namespace: System.Linq----------------
  DNEnumerableExecutorClass<T> = interface(DNEnumerableExecutorClass)
  ['{BFA54836-7473-5188-AC34-6700181F627A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableExecutor`1" />
    ///  class.</summary>
    ///  <param name="expression">An expression tree to associate with the new instance.</param>
    {class} function init(expression: DNExpression): DNEnumerableExecutor<T>;

  end;

  ///<summary>Represents an expression tree and provides functionality to execute the expression tree after rewriting it.</summary>
  ///<typeparam name="T">The data type of the value that results from executing the expression tree.</typeparam>
  [DNTypeName('System.Linq.EnumerableExecutor`1')]
  DNEnumerableExecutor<T> = interface(DNEnumerableExecutor)
  ['{686CA1B2-44E5-3C28-8377-4C28F45569BF}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEnumerableExecutor<T> = class(TDNGenericImport<DNEnumerableExecutorClass<T>, DNEnumerableExecutor<T>>) end;

  //-------------namespace: System.Linq----------------
  DNEnumerableQueryClass = interface(DDN.mscorlib.DNObjectClass)
  ['{DBA98CC1-B28B-5165-B65F-1E958C24EDB7}']
  end;

  ///<summary>Represents an <see cref="T:System.Collections.IEnumerable" />
  ///  as an <see cref="T:System.Linq.EnumerableQuery" />
  ///  data source. </summary>
  [DNTypeName('System.Linq.EnumerableQuery')]
  DNEnumerableQuery = interface(DDN.mscorlib.DNObject)
  ['{4C4C01EF-B143-3C92-8CEB-1B0674F7D0C8}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNEnumerableQuery = class(TDNGenericImport<DNEnumerableQueryClass, DNEnumerableQuery>) end;

  //-------------namespace: System.Linq----------------
  DNEnumerableQueryClass<T> = interface(DNEnumerableQueryClass)
  ['{93B11976-DB76-5A4B-AF17-75A36F686726}']
  { constructors } 

    {class} function init(enumerable: DDN.mscorlib.DNIEnumerable<T>): DNEnumerableQuery<T>; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableQuery`1" />
    ///  class and associates the instance with an expression tree.</summary>
    ///  <param name="expression">An expression tree to associate with the new instance.</param>
    {class} function init(expression: DNExpression): DNEnumerableQuery<T>; overload;

  end;

  ///<summary>Represents an <see cref="T:System.Collections.Generic.IEnumerable`1" />
  ///  collection as an <see cref="T:System.Linq.IQueryable`1" />
  ///  data source.</summary>
  ///<typeparam name="T">The type of the data in the collection.</typeparam>
  [DNTypeName('System.Linq.EnumerableQuery`1')]
  DNEnumerableQuery<T> = interface(DNEnumerableQuery)
  ['{1E96291A-8D60-322C-B030-794757583063}']
  { methods } 

    ///<summary>Returns a textual representation of the enumerable collection or, if it is null, of the expression tree that is associated with this instance.</summary>
    ///<returns>A textual representation of the enumerable collection or, if it is null, of the expression tree that is associated with this instance.</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  end;

  TDNEnumerableQuery<T> = class(TDNGenericImport<DNEnumerableQueryClass<T>, DNEnumerableQuery<T>>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNCatchBlockClass = interface(DDN.mscorlib.DNObjectClass)
  ['{82F694E3-D0BB-57EF-8298-83B63E214F5B}']
  end;

  ///<summary>Represents a catch statement in a try block.</summary>
  [DNTypeName('System.Linq.Expressions.CatchBlock')]
  DNCatchBlock = interface(DDN.mscorlib.DNObject)
  ['{FC67E70C-F8B5-3A77-8CD8-A289136AEF93}']
  { getters & setters } 

    function get_Variable: DNParameterExpression;
    function get_Test: DDN.mscorlib.DNType;
    function get_Body: DNExpression;
    function get_Filter: DNExpression;

  { methods } 

    ///<summary>Returns a <see cref="T:System.String" />
    ///  that represents the current <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that represents the current <see cref="T:System.Object" />
    ///  .</returns>
    function ToString: string;
    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="variable">The <see cref="P:System.Linq.Expressions.CatchBlock.Variable" />
    ///  property of the result.</param>
    ///  <param name="filter">The <see cref="P:System.Linq.Expressions.CatchBlock.Filter" />
    ///  property of the result.</param>
    ///  <param name="body">The <see cref="P:System.Linq.Expressions.CatchBlock.Body" />
    ///  property of the result.</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(variable: DNParameterExpression; filter: DNExpression; body: DNExpression): DNCatchBlock;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a reference to the <see cref="T:System.Exception" />
    ///  object caught by this handler.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  object representing a reference to the <see cref="T:System.Exception" />
    ///  object caught by this handler.</returns>
    property Variable: DNParameterExpression read get_Variable;
    ///<summary>Gets the type of <see cref="T:System.Exception" />
    ///  this handler catches.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the type of <see cref="T:System.Exception" />
    ///  this handler catches.</returns>
    property Test: DDN.mscorlib.DNType read get_Test;
    ///<summary>Gets the body of the catch block.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object representing the catch body.</returns>
    property Body: DNExpression read get_Body;
    ///<summary>Gets the body of the <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  filter.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object representing the body of the <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  filter.</returns>
    property Filter: DNExpression read get_Filter;
  end;

  TDNCatchBlock = class(TDNGenericImport<DNCatchBlockClass, DNCatchBlock>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNElementInitClass = interface(DNObjectClass)
  ['{E9AE3CB1-9152-5890-A5A0-5BAC809079B4}']
  end;

  ///<summary>Represents an initializer for a single element of an <see cref="T:System.Collections.IEnumerable" />
  ///  collection.</summary>
  [DNTypeName('System.Linq.Expressions.ElementInit')]
  DNElementInit = interface(DNIArgumentProvider)
  ['{45F6112D-6439-3067-BDB9-DA62367EFBC0}']
  { getters & setters } 

    function get_AddMethod: DDN.mscorlib.DNMethodInfo;
    function get_Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;

  { methods } 

    ///<summary>Returns a textual representation of an <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  object.</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  object.</returns>
    function ToString: string;
    function Update(arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNElementInit;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the instance method that is used to add an element to an <see cref="T:System.Collections.IEnumerable" />
    ///  collection.</summary>
    ///<returns>A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents an instance method that adds an element to a collection.</returns>
    property AddMethod: DDN.mscorlib.DNMethodInfo read get_AddMethod;
    ///<summary>Gets the collection of arguments that are passed to a method that adds an element to an <see cref="T:System.Collections.IEnumerable" />
    ///  collection.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that represent the arguments for a method that adds an element to a collection.</returns>
    property Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Arguments;
  end;

  TDNElementInit = class(TDNGenericImport<DNElementInitClass, DNElementInit>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNExpressionClass = interface(DDN.mscorlib.DNObjectClass)
  ['{AB5693C1-11DD-5538-880B-F4BDF42BA0B1}']
  { static methods } 

    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  , given the left and right operands, by calling an appropriate factory method.</summary>
    ///  <param name="binaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that specifies the type of binary operation.</param>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the left operand.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the right operand.</param>
    ///<returns>The <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that results from calling the appropriate factory method.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="binaryType" />
    ///  does not correspond to a binary expression node.</exception><exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function MakeBinary(binaryType: DNExpressionType; left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  , given the left operand, right operand and implementing method, by calling the appropriate factory method.</summary>
    ///  <param name="binaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that specifies the type of binary operation.</param>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the left operand.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the right operand.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that specifies the implementing method.</param>
    ///<returns>The <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that results from calling the appropriate factory method.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="binaryType" />
    ///  does not correspond to a binary expression node.</exception><exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function MakeBinary(binaryType: DNExpressionType; left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  , given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</summary>
    ///  <param name="binaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that specifies the type of binary operation.</param>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the left operand.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the right operand.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that specifies the implementing method.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  that represents a type conversion function. This parameter is used only if <paramref name="binaryType" />
    ///  is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />
    ///  or compound assignment..</param>
    ///<returns>The <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that results from calling the appropriate factory method.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="binaryType" />
    ///  does not correspond to a binary expression node.</exception><exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function MakeBinary(binaryType: DNExpressionType; left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an equality comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The equality operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Equal(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an inequality comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The inequality operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function NotEqual(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "greater than" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The "greater than" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function GreaterThan(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "less than" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The "less than" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function LessThan(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "greater than or equal" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The "greater than or equal" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function GreaterThanOrEqual(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a " less than or equal" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The "less than or equal" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function LessThanOrEqual(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a conditional <see langword="AND" />
    ///  operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />
    ///  .</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The bitwise <see langword="AND" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.-or-
    ///  <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type are not the same Boolean type.</exception>
    {class} function AndAlso(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a conditional <see langword="OR" />
    ///  operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />
    ///  .</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The bitwise <see langword="OR" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.-or-
    ///  <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type are not the same Boolean type.</exception>
    {class} function OrElse(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a coalescing operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of <paramref name="left" />
    ///  does not represent a reference type or a nullable value type.</exception><exception cref="T:System.ArgumentException"><paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type are not convertible to each other.</exception>
    {class} function Coalesce(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic addition operation that does not have overflow checking.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The addition operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Add(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an addition assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function AddAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an addition assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function AddAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an addition assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function AddAssignChecked(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an addition assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function AddAssignChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic addition operation that has overflow checking.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The addition operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function AddChecked(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic subtraction operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The subtraction operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Subtract(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a subtraction assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function SubtractAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a subtraction assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function SubtractAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a subtraction assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function SubtractAssignChecked(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a subtraction assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function SubtractAssignChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic subtraction operation that has overflow checking.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The subtraction operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function SubtractChecked(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic division operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The division operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Divide(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a division assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function DivideAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a division assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function DivideAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic remainder operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The modulus operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Modulo(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a remainder assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function ModuloAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a remainder assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function ModuloAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic multiplication operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The multiplication operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Multiply(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a multiplication assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function MultiplyAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a multiplication assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function MultiplyAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a multiplication assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function MultiplyAssignChecked(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a multiplication assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function MultiplyAssignChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic multiplication operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The multiplication operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function MultiplyChecked(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise left-shift operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The left-shift operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function LeftShift(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise left-shift assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function LeftShiftAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise left-shift assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function LeftShiftAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise right-shift operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The right-shift operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function RightShift(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise right-shift assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function RightShiftAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise right-shift assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function RightShiftAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise <see langword="AND" />
    ///  operation.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The bitwise <see langword="AND" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function &And(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise AND assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function AndAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise AND assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function AndAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise <see langword="OR" />
    ///  operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The bitwise <see langword="OR" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function &Or(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise OR assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function OrAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise OR assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function OrAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise <see langword="XOR" />
    ///  operation, using op_ExclusiveOr for user-defined types.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see langword="XOR" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function ExclusiveOr(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise XOR assignment operation, using op_ExclusiveOr for user-defined types.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function ExclusiveOrAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise XOR assignment operation, using op_ExclusiveOr for user-defined types.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function ExclusiveOrAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents raising a number to a power.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The exponentiation operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.-or-
    ///  <paramref name="left" />
    ///  .Type and/or <paramref name="right" />
    ///  .Type are not <see cref="T:System.Double" />
    ///  .</exception>
    {class} function Power(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents raising an expression to a power and assigning the result back to the expression.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function PowerAssign(left: DNExpression; right: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents raising an expression to a power and assigning the result back to the expression.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function PowerAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    {class} function Block(expressions: DDN.mscorlib.DNIEnumerable<DNExpression>): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  that contains the given expressions, has no variables and has specific result type.</summary>
    ///  <param name="type">The result type of the block.</param>
    ///  <param name="expressions">The expressions in the block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  .</returns>
    {class} function Block(&type: DDN.mscorlib.DNType; expressions: TArray<DNExpression>): DNBlockExpression; overload;
    {class} function Block(&type: DDN.mscorlib.DNType; expressions: DDN.mscorlib.DNIEnumerable<DNExpression>): DNBlockExpression; overload;
    {class} function Block(variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>; expressions: TArray<DNExpression>): DNBlockExpression; overload;
    {class} function Block(&type: DDN.mscorlib.DNType; variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>; expressions: TArray<DNExpression>): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  representing a catch statement.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  of <see cref="T:System.Exception" />
    ///  this <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  will handle.</param>
    ///  <param name="body">The body of the catch statement.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  .</returns>
    {class} function Catch(&type: DDN.mscorlib.DNType; body: DNExpression): DNCatchBlock; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  representing a catch statement with a reference to the caught <see cref="T:System.Exception" />
    ///  object for use in the handler body.</summary>
    ///  <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  representing a reference to the <see cref="T:System.Exception" />
    ///  object caught by this handler.</param>
    ///  <param name="body">The body of the catch statement.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  .</returns>
    {class} function Catch(variable: DNParameterExpression; body: DNExpression): DNCatchBlock; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  representing a catch statement with an <see cref="T:System.Exception" />
    ///  filter but no reference to the caught <see cref="T:System.Exception" />
    ///  object.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  of <see cref="T:System.Exception" />
    ///  this <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  will handle.</param>
    ///  <param name="body">The body of the catch statement.</param>
    ///  <param name="filter">The body of the <see cref="T:System.Exception" />
    ///  filter.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  .</returns>
    {class} function Catch(&type: DDN.mscorlib.DNType; body: DNExpression; filter: DNExpression): DNCatchBlock; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  representing a catch statement with an <see cref="T:System.Exception" />
    ///  filter and a reference to the caught <see cref="T:System.Exception" />
    ///  object.</summary>
    ///  <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  representing a reference to the <see cref="T:System.Exception" />
    ///  object caught by this handler.</param>
    ///  <param name="body">The body of the catch statement.</param>
    ///  <param name="filter">The body of the <see cref="T:System.Exception" />
    ///  filter.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  .</returns>
    {class} function Catch(variable: DNParameterExpression; body: DNExpression; filter: DNExpression): DNCatchBlock; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that represents a conditional block with an <see langword="if" />
    ///  statement.</summary>
    ///  <param name="test">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  property equal to.</param>
    ///  <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />
    ///  and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  , <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  , properties set to the specified values. The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  returned by this method is <see cref="T:System.Void" />
    ///  .</returns>
    {class} function IfThen(test: DNExpression; ifTrue: DNExpression): DNConditionalExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that represents a conditional block with <see langword="if" />
    ///  and <see langword="else" />
    ///  statements.</summary>
    ///  <param name="test">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  property equal to.</param>
    ///  <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  property equal to.</param>
    ///  <param name="ifFalse">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />
    ///  and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  , <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  , and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  properties set to the specified values. The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  returned by this method is <see cref="T:System.Void" />
    ///  .</returns>
    {class} function IfThenElse(test: DNExpression; ifTrue: DNExpression; ifFalse: DNExpression): DNConditionalExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />
    ///  property set to the specified value.</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />
    ///  and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />
    ///  property set to the specified value.</returns>
    {class} function Constant(value: DDN.mscorlib.DNObject): DNConstantExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />
    ///  and <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  properties set to the specified values.</summary>
    ///  <param name="value">An <see cref="T:System.Object" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" />
    ///  and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" />
    ///  and <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="value" />
    ///  is not <see langword="null" />
    ///  and <paramref name="type" />
    ///  is not assignable from the dynamic type of <paramref name="value" />
    ///  .</exception>
    {class} function Constant(value: DDN.mscorlib.DNObject; &type: DDN.mscorlib.DNType): DNConstantExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  with the specified span.</summary>
    ///  <param name="document">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that represents the source file.</param>
    ///  <param name="startLine">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  . Must be greater than 0.</param>
    ///  <param name="startColumn">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  . Must be greater than 0.</param>
    ///  <param name="endLine">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  . Must be greater or equal than the start line.</param>
    ///  <param name="endColumn">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  . If the end line is the same as the start line, it must be greater or equal than the start column. In any case, must be greater than 0.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  .</returns>
    {class} function DebugInfo(document: DNSymbolDocumentInfo; startLine: Int32; startColumn: Int32; endLine: Int32; endColumn: Int32): DNDebugInfoExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  for clearing a sequence point.</summary>
    ///  <param name="document">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that represents the source file.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  for clearning a sequence point.</returns>
    {class} function ClearDebugInfo(document: DNSymbolDocumentInfo): DNDebugInfoExpression;
    ///<summary>Creates an empty expression that has <see cref="T:System.Void" />
    ///  type.</summary>
    ///<returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" />
    ///  and the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <see cref="T:System.Void" />
    ///  .</returns>
    {class} function Empty: DNDefaultExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to the specified type.</summary>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" />
    ///  and the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to the specified type.</returns>
    {class} function &Default(&type: DDN.mscorlib.DNType): DNDefaultExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arguments">The arguments to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arguments: TArray<DNExpression>): DNDynamicExpression; overload;
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and one argument.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and two arguments.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression; arg1: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and three arguments.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and four arguments.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///  <param name="arg3">The fourth argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arguments">The arguments to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arguments: TArray<DNExpression>): DNDynamicExpression; overload;
    ///<summary>Creates an <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  , given an array of values as the second argument.</summary>
    ///  <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />
    ///  property equal to.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />
    ///  property equal to.</param>
    ///<returns>An <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" />
    ///  and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="addMethod" />
    ///  or <paramref name="arguments" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The method that addMethod represents is not named "Add" (case insensitive).-or-The method that addMethod represents is not an instance method.-or-arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of one or more elements of <paramref name="arguments" />
    ///  is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" />
    ///  represents.</exception>
    {class} function ElementInit(addMethod: DDN.mscorlib.DNMethodInfo; arguments: TArray<DNExpression>): DNElementInit; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a break statement.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and a null value to be passed to the target label upon jumping.</returns>
    {class} function Break(target: DNLabelTarget): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a break statement. The value passed to the label upon jumping can be specified.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function Break(target: DNLabelTarget; value: DNExpression): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a break statement with the specified type.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  .</returns>
    {class} function Break(target: DNLabelTarget; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a break statement with the specified type. The value passed to the label upon jumping can be specified.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function Break(target: DNLabelTarget; value: DNExpression; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a continue statement.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and a null value to be passed to the target label upon jumping.</returns>
    {class} function &Continue(target: DNLabelTarget): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a continue statement with the specified type.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and a null value to be passed to the target label upon jumping.</returns>
    {class} function &Continue(target: DNLabelTarget; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a return statement.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and a null value to be passed to the target label upon jumping.</returns>
    {class} function Return(target: DNLabelTarget): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a return statement with the specified type.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and a null value to be passed to the target label upon jumping.</returns>
    {class} function Return(target: DNLabelTarget; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a return statement. The value passed to the label upon jumping can be specified.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function Return(target: DNLabelTarget; value: DNExpression): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a return statement with the specified type. The value passed to the label upon jumping can be specified.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function Return(target: DNLabelTarget; value: DNExpression; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a "go to" statement.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to the specified value, and a null value to be passed to the target label upon jumping.</returns>
    {class} function &Goto(target: DNLabelTarget): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a "go to" statement with the specified type.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and a null value to be passed to the target label upon jumping.</returns>
    {class} function &Goto(target: DNLabelTarget; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a "go to" statement. The value passed to the label upon jumping can be specified.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function &Goto(target: DNLabelTarget; value: DNExpression): DNGotoExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a "go to" statement with the specified type. The value passed to the label upon jumping can be specified.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function &Goto(target: DNLabelTarget; value: DNExpression; &type: DDN.mscorlib.DNType): DNGotoExpression; overload;
    {class} function MakeIndex(instance: DNExpression; indexer: DDN.mscorlib.DNPropertyInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNIndexExpression;
    ///<summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" />
    ///  to access an array.</summary>
    ///  <param name="array">An expression representing the array to index.</param>
    ///  <param name="indexes">An array that contains expressions used to index the array.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />
    ///  .</returns>
    {class} function ArrayAccess(&array: DNExpression; indexes: TArray<DNExpression>): DNIndexExpression; overload;
    ///<summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" />
    ///  representing the access to an indexed property.</summary>
    ///  <param name="instance">The object to which the property belongs. If the property is static/shared, it must be null.</param>
    ///  <param name="indexer">The <see cref="T:System.Reflection.PropertyInfo" />
    ///  that represents the property to index.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that are used to index the property.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />
    ///  .</returns>
    {class} function &Property(instance: DNExpression; indexer: DDN.mscorlib.DNPropertyInfo; arguments: TArray<DNExpression>): DNIndexExpression; overload;
    {class} function &Property(instance: DNExpression; indexer: DDN.mscorlib.DNPropertyInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNIndexExpression; overload;
    ///<summary>Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" />
    ///  that applies a delegate or lambda expression to a list of argument expressions.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the delegate or lambda expression to be applied.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that represent the arguments that the delegate or lambda expression is applied to.</param>
    ///<returns>An <see cref="T:System.Linq.Expressions.InvocationExpression" />
    ///  that applies the specified delegate or lambda expression to the provided arguments.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="expression" />
    ///  .Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />
    ///  .-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of an element of <paramref name="arguments" />
    ///  is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><paramref name="arguments" />
    ///  does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />
    ///  .</exception>
    {class} function Invoke(expression: DNExpression; arguments: TArray<DNExpression>): DNInvocationExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  representing a label without a default value.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  which this <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  will be associated with.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  without a default value.</returns>
    {class} function &Label(target: DNLabelTarget): DNLabelExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  representing a label with void type and no name.</summary>
    ///<returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  .</returns>
    {class} function &Label: DNLabelTarget; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  representing a label with void type and the given name.</summary>
    ///  <param name="name">The name of the label.</param>
    ///<returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  .</returns>
    {class} function &Label(name: string): DNLabelTarget; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  representing a label with the given type.</summary>
    ///  <param name="type">The type of value that is passed when jumping to the label.</param>
    ///<returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  .</returns>
    {class} function &Label(&type: DDN.mscorlib.DNType): DNLabelTarget; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  representing a label with the given type and name.</summary>
    ///  <param name="type">The type of value that is passed when jumping to the label.</param>
    ///  <param name="name">The name of the label.</param>
    ///<returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  .</returns>
    {class} function &Label(&type: DDN.mscorlib.DNType; name: string): DNLabelTarget; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  by first constructing a delegate type.</summary>
    ///  <param name="body">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  property equal to.</param>
    ///  <param name="parameters">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />
    ///  and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="body" />
    ///  is <see langword="null" />
    ///  .-or-One or more elements of <paramref name="parameters" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="parameters" />
    ///  contains more than sixteen elements.</exception>
    {class} function Lambda(body: DNExpression; parameters: TArray<DNParameterExpression>): DNLambdaExpression; overload;
    ///<summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
    ///  <param name="body">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  property equal to.</param>
    ///  <param name="tailCall">A <see cref="T:System.Boolean" />
    ///  that indicates if tail call optimization will be applied when compiling the created expression.</param>
    ///  <param name="parameters">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />
    ///  property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  properties set to the specified values.</returns>
    {class} function Lambda(body: DNExpression; tailCall: Boolean; parameters: TArray<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(body: DNExpression; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(body: DNExpression; tailCall: Boolean; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  by first constructing a delegate type. It can be used when the delegate type is not known at compile time.</summary>
    ///  <param name="delegateType">A <see cref="T:System.Type" />
    ///  that represents a delegate signature for the lambda.</param>
    ///  <param name="body">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  property equal to.</param>
    ///  <param name="parameters">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  collection.</param>
    ///<returns>An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" />
    ///  and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="delegateType" />
    ///  or <paramref name="body" />
    ///  is <see langword="null" />
    ///  .-or-One or more elements in <paramref name="parameters" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="delegateType" />
    ///  does not represent a delegate type.-or-
    ///  <paramref name="body" />
    ///  .Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />
    ///  .-or-
    ///  <paramref name="parameters" />
    ///  does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />
    ///  .-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of an element of <paramref name="parameters" />
    ///  is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />
    ///  .</exception>
    {class} function Lambda(delegateType: DDN.mscorlib.DNType; body: DNExpression; parameters: TArray<DNParameterExpression>): DNLambdaExpression; overload;
    ///<summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
    ///  <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  representing the delegate signature for the lambda.</param>
    ///  <param name="body">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  property equal to.</param>
    ///  <param name="tailCall">A <see cref="T:System.Boolean" />
    ///  that indicates if tail call optimization will be applied when compiling the created expression.</param>
    ///  <param name="parameters">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" />
    ///  property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" />
    ///  and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />
    ///  properties set to the specified values.</returns>
    {class} function Lambda(delegateType: DDN.mscorlib.DNType; body: DNExpression; tailCall: Boolean; parameters: TArray<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(delegateType: DDN.mscorlib.DNType; body: DNExpression; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(delegateType: DDN.mscorlib.DNType; body: DNExpression; tailCall: Boolean; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(body: DNExpression; name: string; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(delegateType: DDN.mscorlib.DNType; body: DNExpression; name: string; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    {class} function Lambda(delegateType: DDN.mscorlib.DNType; body: DNExpression; name: string; tailCall: Boolean; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    ///<summary>Creates a <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  object that represents a generic System.Func delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.</summary>
    ///  <param name="typeArgs">An array of one to seventeen <see cref="T:System.Type" />
    ///  objects that specify the type arguments for the <see langword="System.Func" />
    ///  delegate type.</param>
    ///<returns>The type of a System.Func delegate that has the specified type arguments.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="typeArgs" />
    ///  contains fewer than one or more than seventeen elements.</exception><exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function GetFuncType(typeArgs: TArray<DDN.mscorlib.DNType>): DDN.mscorlib.DNType;
    {class} function TryGetFuncType(typeArgs: TArray<DDN.mscorlib.DNType>; out funcType: DDN.mscorlib.DNType): Boolean;
    ///<summary>Creates a <see cref="T:System.Type" />
    ///  object that represents a generic System.Action delegate type that has specific type arguments.</summary>
    ///  <param name="typeArgs">An array of up to sixteen <see cref="T:System.Type" />
    ///  objects that specify the type arguments for the <see langword="System.Action" />
    ///  delegate type.</param>
    ///<returns>The type of a System.Action delegate that has the specified type arguments.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="typeArgs" />
    ///  contains more than sixteen elements.</exception><exception cref="T:System.ArgumentNullException"><paramref name="typeArgs" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function GetActionType(typeArgs: TArray<DDN.mscorlib.DNType>): DDN.mscorlib.DNType;
    {class} function TryGetActionType(typeArgs: TArray<DDN.mscorlib.DNType>; out actionType: DDN.mscorlib.DNType): Boolean;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />
    ///  that uses a method named "Add" to add elements to a collection.</summary>
    ///  <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />
    ///  property equal to.</param>
    ///  <param name="initializers">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />
    ///  and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />
    ///  or <paramref name="initializers" />
    ///  is <see langword="null" />
    ///  .-or-One or more elements of <paramref name="initializers" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="newExpression" />
    ///  .Type does not implement <see cref="T:System.Collections.IEnumerable" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />
    ///  .Type or its base type.-or-The add method on <paramref name="newExpression" />
    ///  .Type or its base type does not take exactly one argument.-or-The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the first element of <paramref name="initializers" />
    ///  is not assignable to the argument type of the add method on <paramref name="newExpression" />
    ///  .Type or its base type.-or-More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />
    ///  .Type and/or its base type.</exception>
    {class} function ListInit(newExpression: DNNewExpression; initializers: TArray<DNExpression>): DNListInitExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />
    ///  that uses a specified method to add elements to a collection.</summary>
    ///  <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />
    ///  property equal to.</param>
    ///  <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents an instance method that takes one argument, that adds an element to a collection.</param>
    ///  <param name="initializers">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />
    ///  and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />
    ///  or <paramref name="initializers" />
    ///  is <see langword="null" />
    ///  .-or-One or more elements of <paramref name="initializers" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="newExpression" />
    ///  .Type does not implement <see cref="T:System.Collections.IEnumerable" />
    ///  .-or-
    ///  <paramref name="addMethod" />
    ///  is not <see langword="null" />
    ///  and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.-or-
    ///  <paramref name="addMethod" />
    ///  is not <see langword="null" />
    ///  and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of one or more elements of <paramref name="initializers" />
    ///  is not assignable to the argument type of the method that <paramref name="addMethod" />
    ///  represents.</exception><exception cref="T:System.InvalidOperationException"><paramref name="addMethod" />
    ///  is <see langword="null" />
    ///  and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />
    ///  .Type or its base type.</exception>
    {class} function ListInit(newExpression: DNNewExpression; addMethod: DDN.mscorlib.DNMethodInfo; initializers: TArray<DNExpression>): DNListInitExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" />
    ///  that uses specified <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  objects to initialize a collection.</summary>
    ///  <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />
    ///  property equal to.</param>
    ///  <param name="initializers">An array of <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" />
    ///  and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" />
    ///  and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />
    ///  or <paramref name="initializers" />
    ///  is <see langword="null" />
    ///  .-or-One or more elements of <paramref name="initializers" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="newExpression" />
    ///  .Type does not implement <see cref="T:System.Collections.IEnumerable" />
    ///  .</exception>
    {class} function ListInit(newExpression: DNNewExpression; initializers: TArray<DNElementInit>): DNListInitExpression; overload;
    {class} function ListInit(newExpression: DNNewExpression; initializers: DDN.mscorlib.DNIEnumerable<DNElementInit>): DNListInitExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />
    ///  with the given body.</summary>
    ///  <param name="body">The body of the loop.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.LoopExpression" />
    ///  .</returns>
    {class} function Loop(body: DNExpression): DNLoopExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />
    ///  with the given body and break target.</summary>
    ///  <param name="body">The body of the loop.</param>
    ///  <param name="break">The break target used by the loop body.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.LoopExpression" />
    ///  .</returns>
    {class} function Loop(body: DNExpression; break: DNLabelTarget): DNLoopExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" />
    ///  that represents the initialization of a member by using a property accessor method.</summary>
    ///  <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents a property accessor method.</param>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" />
    ///  that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property set to the <see cref="T:System.Reflection.PropertyInfo" />
    ///  that represents the property accessed in <paramref name="propertyAccessor" />
    ///  , and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />
    ///  property set to <paramref name="expression" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />
    ///  or <paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />
    ///  does not represent a property accessor method.-or-The property accessed by <paramref name="propertyAccessor" />
    ///  does not have a <see langword="set" />
    ///  accessor.-or-
    ///  <paramref name="expression" />
    ///  .Type is not assignable to the type of the field or property that <paramref name="member" />
    ///  represents.</exception>
    {class} function Bind(propertyAccessor: DDN.mscorlib.DNMethodInfo; expression: DNExpression): DNMemberAssignment; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a field.</summary>
    ///  <param name="expression">The containing object of the field. This can be null for static fields.</param>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  that contains the field.</param>
    ///  <param name="fieldName">The field to be accessed.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  .</returns>
    {class} function Field(expression: DNExpression; &type: DDN.mscorlib.DNType; fieldName: string): DNMemberExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  accessing a property.</summary>
    ///  <param name="expression">The containing object of the property. This can be null for static properties.</param>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  that contains the property.</param>
    ///  <param name="propertyName">The property to be accessed.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  .</returns>
    {class} function &Property(expression: DNExpression; &type: DDN.mscorlib.DNType; propertyName: string): DNMemberExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a property by using a property accessor method.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property equal to. This can be null for static properties.</param>
    ///  <param name="propertyAccessor">The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents a property accessor method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property set to <paramref name="expression" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  property set to the <see cref="T:System.Reflection.PropertyInfo" />
    ///  that represents the property accessed in <paramref name="propertyAccessor" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />
    ///  is <see langword="null" />
    ///  .-or-The method that <paramref name="propertyAccessor" />
    ///  represents is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) and <paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="expression" />
    ///  .Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />
    ///  .-or-The method that <paramref name="propertyAccessor" />
    ///  represents is not a property accessor method.</exception>
    {class} function &Property(expression: DNExpression; propertyAccessor: DDN.mscorlib.DNMethodInfo): DNMemberExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing either a field or a property.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the object that the member belongs to. This can be null for static members.</param>
    ///  <param name="member">The <see cref="T:System.Reflection.MemberInfo" />
    ///  that describes the field or property to be accessed.</param>
    ///<returns>The <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that results from calling the appropriate factory method.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="member" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="member" />
    ///  does not represent a field or property.</exception>
    {class} function MakeMemberAccess(expression: DNExpression; member: DDN.mscorlib.DNMemberInfo): DNMemberExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />
    ///  .</summary>
    ///  <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />
    ///  property equal to.</param>
    ///  <param name="bindings">An array of <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" />
    ///  and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="newExpression" />
    ///  or <paramref name="bindings" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property of an element of <paramref name="bindings" />
    ///  does not represent a member of the type that <paramref name="newExpression" />
    ///  .Type represents.</exception>
    {class} function MemberInit(newExpression: DNNewExpression; bindings: TArray<DNMemberBinding>): DNMemberInitExpression; overload;
    {class} function MemberInit(newExpression: DNNewExpression; bindings: DDN.mscorlib.DNIEnumerable<DNMemberBinding>): DNMemberInitExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" />
    ///  where the member is a field or property.</summary>
    ///  <param name="member">A <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property equal to.</param>
    ///  <param name="initializers">An array of <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" />
    ///  that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="member" />
    ///  is <see langword="null" />
    ///  . -or-One or more elements of <paramref name="initializers" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="member" />
    ///  does not represent a field or property.-or-The <see cref="P:System.Reflection.FieldInfo.FieldType" />
    ///  or <see cref="P:System.Reflection.PropertyInfo.PropertyType" />
    ///  of the field or property that <paramref name="member" />
    ///  represents does not implement <see cref="T:System.Collections.IEnumerable" />
    ///  .</exception>
    {class} function ListBind(member: DDN.mscorlib.DNMemberInfo; initializers: TArray<DNElementInit>): DNMemberListBinding; overload;
    {class} function ListBind(member: DDN.mscorlib.DNMemberInfo; initializers: DDN.mscorlib.DNIEnumerable<DNElementInit>): DNMemberListBinding; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" />
    ///  object based on a specified property accessor method.</summary>
    ///  <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents a property accessor method.</param>
    ///  <param name="initializers">An array of <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" />
    ///  that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property set to the <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents the property accessed in <paramref name="propertyAccessor" />
    ///  , and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" />
    ///  populated with the elements of <paramref name="initializers" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />
    ///  is <see langword="null" />
    ///  . -or-One or more elements of <paramref name="initializers" />
    ///  are <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />
    ///  does not represent a property accessor method.-or-The <see cref="P:System.Reflection.PropertyInfo.PropertyType" />
    ///  of the property that the method represented by <paramref name="propertyAccessor" />
    ///  accesses does not implement <see cref="T:System.Collections.IEnumerable" />
    ///  .</exception>
    {class} function ListBind(propertyAccessor: DDN.mscorlib.DNMethodInfo; initializers: TArray<DNElementInit>): DNMemberListBinding; overload;
    {class} function ListBind(propertyAccessor: DDN.mscorlib.DNMethodInfo; initializers: DDN.mscorlib.DNIEnumerable<DNElementInit>): DNMemberListBinding; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" />
    ///  that represents the recursive initialization of members of a field or property.</summary>
    ///  <param name="member">The <see cref="T:System.Reflection.MemberInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property equal to.</param>
    ///  <param name="bindings">An array of <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" />
    ///  that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="member" />
    ///  or <paramref name="bindings" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="member" />
    ///  does not represent a field or property.-or-The <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property of an element of <paramref name="bindings" />
    ///  does not represent a member of the type of the field or property that <paramref name="member" />
    ///  represents.</exception>
    {class} function MemberBind(member: DDN.mscorlib.DNMemberInfo; bindings: TArray<DNMemberBinding>): DNMemberMemberBinding; overload;
    {class} function MemberBind(member: DDN.mscorlib.DNMemberInfo; bindings: DDN.mscorlib.DNIEnumerable<DNMemberBinding>): DNMemberMemberBinding; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" />
    ///  that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</summary>
    ///  <param name="propertyAccessor">The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents a property accessor method.</param>
    ///  <param name="bindings">An array of <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" />
    ///  that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property set to the <see cref="T:System.Reflection.PropertyInfo" />
    ///  that represents the property accessed in <paramref name="propertyAccessor" />
    ///  , and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="propertyAccessor" />
    ///  or <paramref name="bindings" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="propertyAccessor" />
    ///  does not represent a property accessor method.-or-The <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property of an element of <paramref name="bindings" />
    ///  does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" />
    ///  represents.</exception>
    {class} function MemberBind(propertyAccessor: DDN.mscorlib.DNMethodInfo; bindings: TArray<DNMemberBinding>): DNMemberMemberBinding; overload;
    {class} function MemberBind(propertyAccessor: DDN.mscorlib.DNMethodInfo; bindings: DDN.mscorlib.DNIEnumerable<DNMemberBinding>): DNMemberMemberBinding; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method that takes one argument.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is null.</exception>
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a static method that takes two arguments.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///  <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the second argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is null.</exception>
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression; arg1: DNExpression): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a static method that takes three arguments.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///  <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the second argument.</param>
    ///  <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the third argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is null.</exception>
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a static method that takes four arguments.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///  <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the second argument.</param>
    ///  <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the third argument.</param>
    ///  <param name="arg3">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the fourth argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is null.</exception>
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a static method that takes five arguments.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///  <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the second argument.</param>
    ///  <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the third argument.</param>
    ///  <param name="arg3">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the fourth argument.</param>
    ///  <param name="arg4">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the fifth argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is null.</exception>
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression; arg4: DNExpression): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method that has arguments.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents a <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The number of elements in <paramref name="arguments" />
    ///  does not equal the number of parameters for the method represented by <paramref name="method" />
    ///  .-or-One or more of the elements of <paramref name="arguments" />
    ///  is not assignable to the corresponding parameter for the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arguments: TArray<DNExpression>): DNMethodCallExpression; overload;
    {class} function Call(method: DDN.mscorlib.DNMethodInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a method that takes no arguments.</summary>
    ///  <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that specifies the instance for an instance method call (pass <see langword="null" />
    ///  for a <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method).</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  .-or-
    ///  <paramref name="instance" />
    ///  is <see langword="null" />
    ///  and <paramref name="method" />
    ///  represents an instance method.</exception><exception cref="T:System.ArgumentException"><paramref name="instance" />
    ///  .Type is not assignable to the declaring type of the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function Call(instance: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a method that takes arguments.</summary>
    ///  <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that specifies the instance for an instance method call (pass <see langword="null" />
    ///  for a <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method).</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  , <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  .-or-
    ///  <paramref name="instance" />
    ///  is <see langword="null" />
    ///  and <paramref name="method" />
    ///  represents an instance method.-or-
    ///  <paramref name="arguments" />
    ///  is not <see langword="null" />
    ///  and one or more of its elements is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="instance" />
    ///  .Type is not assignable to the declaring type of the method represented by <paramref name="method" />
    ///  .-or-The number of elements in <paramref name="arguments" />
    ///  does not equal the number of parameters for the method represented by <paramref name="method" />
    ///  .-or-One or more of the elements of <paramref name="arguments" />
    ///  is not assignable to the corresponding parameter for the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function Call(instance: DNExpression; method: DDN.mscorlib.DNMethodInfo; arguments: TArray<DNExpression>): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a method that takes two arguments.</summary>
    ///  <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).</param>
    ///  <param name="method">The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the target method.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///  <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the second argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function Call(instance: DNExpression; method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression; arg1: DNExpression): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a method that takes three arguments.</summary>
    ///  <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).</param>
    ///  <param name="method">The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the target method.</param>
    ///  <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the first argument.</param>
    ///  <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the second argument.</param>
    ///  <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the third argument.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  properties set to the specified values.</returns>
    {class} function Call(instance: DNExpression; method: DDN.mscorlib.DNMethodInfo; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNMethodCallExpression; overload;
    {class} function Call(instance: DNExpression; method: DDN.mscorlib.DNMethodInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents applying an array index operator to a multidimensional array.</summary>
    ///  <param name="array">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  instances - indexes for the array index operation.</param>
    ///  <param name="indexes">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="array" />
    ///  or <paramref name="indexes" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="array" />
    ///  .Type does not represent an array type.-or-The rank of <paramref name="array" />
    ///  .Type does not match the number of elements in <paramref name="indexes" />
    ///  .-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of one or more elements of <paramref name="indexes" />
    ///  does not represent the <see cref="T:System.Int32" />
    ///  type.</exception>
    {class} function ArrayIndex(&array: DNExpression; indexes: TArray<DNExpression>): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" />
    ///  that represents creating a one-dimensional array and initializing it from a list of elements.</summary>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  that represents the element type of the array.</param>
    ///  <param name="initializers">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />
    ///  and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="type" />
    ///  or <paramref name="initializers" />
    ///  is <see langword="null" />
    ///  .-or-An element of <paramref name="initializers" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of an element of <paramref name="initializers" />
    ///  represents a type that is not assignable to the type <paramref name="type" />
    ///  .</exception>
    {class} function NewArrayInit(&type: DDN.mscorlib.DNType; initializers: TArray<DNExpression>): DNNewArrayExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" />
    ///  that represents creating an array that has a specified rank.</summary>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  that represents the element type of the array.</param>
    ///  <param name="bounds">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />
    ///  and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="type" />
    ///  or <paramref name="bounds" />
    ///  is <see langword="null" />
    ///  .-or-An element of <paramref name="bounds" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of an element of <paramref name="bounds" />
    ///  does not represent an integral type.</exception>
    {class} function NewArrayBounds(&type: DDN.mscorlib.DNType; bounds: TArray<DNExpression>): DNNewArrayExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that represents calling the specified constructor that takes no arguments.</summary>
    ///  <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" />
    ///  and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="constructor" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The constructor that <paramref name="constructor" />
    ///  represents has at least one parameter.</exception>
    {class} function New(&constructor: DDN.mscorlib.DNConstructorInfo): DNNewExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that represents calling the specified constructor with the specified arguments.</summary>
    ///  <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />
    ///  property equal to.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />
    ///  collection.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" />
    ///  and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />
    ///  and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="constructor" />
    ///  is <see langword="null" />
    ///  .-or-An element of <paramref name="arguments" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The length of <paramref name="arguments" />
    ///  does match the number of parameters for the constructor that <paramref name="constructor" />
    ///  represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of an element of <paramref name="arguments" />
    ///  is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" />
    ///  represents.</exception>
    {class} function New(&constructor: DDN.mscorlib.DNConstructorInfo; arguments: TArray<DNExpression>): DNNewExpression; overload;
    {class} function New(&constructor: DDN.mscorlib.DNConstructorInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNNewExpression; overload;
    {class} function New(&constructor: DDN.mscorlib.DNConstructorInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>; members: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNMemberInfo>): DNNewExpression; overload;
    {class} function New(&constructor: DDN.mscorlib.DNConstructorInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>; members: TArray<DDN.mscorlib.DNMemberInfo>): DNNewExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that represents calling the parameterless constructor of the specified type.</summary>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  that has a constructor that takes no arguments.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" />
    ///  and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />
    ///  property set to the <see cref="T:System.Reflection.ConstructorInfo" />
    ///  that represents the constructor without parameters for the specified type.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The type that <paramref name="type" />
    ///  represents does not have a constructor without parameters.</exception>
    {class} function New(&type: DDN.mscorlib.DNType): DNNewExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node that can be used to identify a parameter or a variable in an expression tree.</summary>
    ///  <param name="type">The type of the parameter or variable.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node with the specified name and type.</returns>
    {class} function Parameter(&type: DDN.mscorlib.DNType): DNParameterExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node that can be used to identify a parameter or a variable in an expression tree.</summary>
    ///  <param name="type">The type of the parameter or variable.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node with the specified name and type</returns>
    {class} function Variable(&type: DDN.mscorlib.DNType): DNParameterExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node that can be used to identify a parameter or a variable in an expression tree.</summary>
    ///  <param name="type">The type of the parameter or variable.</param>
    ///  <param name="name">The name of the parameter or variable, used for debugging or printing purpose only.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" />
    ///  and the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function Parameter(&type: DDN.mscorlib.DNType; name: string): DNParameterExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node that can be used to identify a parameter or a variable in an expression tree.</summary>
    ///  <param name="type">The type of the parameter or variable.</param>
    ///  <param name="name">The name of the parameter or variable. This name is used for debugging or printing purpose only.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  node with the specified name and type.</returns>
    {class} function Variable(&type: DDN.mscorlib.DNType; name: string): DNParameterExpression; overload;
    ///<summary>Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />
    ///  .</summary>
    ///  <param name="variables">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />
    ///  collection.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" />
    ///  and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" />
    ///  property set to the specified value.</returns>
    {class} function RuntimeVariables(variables: TArray<DNParameterExpression>): DNRuntimeVariablesExpression; overload;
    {class} function RuntimeVariables(variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNRuntimeVariablesExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.SwitchCase" />
    ///  for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  .</summary>
    ///  <param name="body">The body of the case.</param>
    ///  <param name="testValues">The test values of the case.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.SwitchCase" />
    ///  .</returns>
    {class} function SwitchCase(body: DNExpression; testValues: TArray<DNExpression>): DNSwitchCase; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  that represents a <see langword="switch" />
    ///  statement without a default case.</summary>
    ///  <param name="switchValue">The value to be tested against each case.</param>
    ///  <param name="cases">The set of cases for this switch expression.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  .</returns>
    {class} function Switch(switchValue: DNExpression; cases: TArray<DNSwitchCase>): DNSwitchExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  that represents a <see langword="switch" />
    ///  statement that has a default case.</summary>
    ///  <param name="switchValue">The value to be tested against each case.</param>
    ///  <param name="defaultBody">The result of the switch if <paramref name="switchValue" />
    ///  does not match any of the cases.</param>
    ///  <param name="cases">The set of cases for this switch expression.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  .</returns>
    {class} function Switch(switchValue: DNExpression; defaultBody: DNExpression; cases: TArray<DNSwitchCase>): DNSwitchExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  that represents a <see langword="switch" />
    ///  statement that has a default case.</summary>
    ///  <param name="switchValue">The value to be tested against each case.</param>
    ///  <param name="defaultBody">The result of the switch if <paramref name="switchValue" />
    ///  does not match any of the cases.</param>
    ///  <param name="comparison">The equality comparison method to use.</param>
    ///  <param name="cases">The set of cases for this switch expression.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  .</returns>
    {class} function Switch(switchValue: DNExpression; defaultBody: DNExpression; comparison: DDN.mscorlib.DNMethodInfo; cases: TArray<DNSwitchCase>): DNSwitchExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  that represents a <see langword="switch" />
    ///  statement that has a default case..</summary>
    ///  <param name="type">The result type of the switch.</param>
    ///  <param name="switchValue">The value to be tested against each case.</param>
    ///  <param name="defaultBody">The result of the switch if <paramref name="switchValue" />
    ///  does not match any of the cases.</param>
    ///  <param name="comparison">The equality comparison method to use.</param>
    ///  <param name="cases">The set of cases for this switch expression.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />
    ///  .</returns>
    {class} function Switch(&type: DDN.mscorlib.DNType; switchValue: DNExpression; defaultBody: DNExpression; comparison: DDN.mscorlib.DNMethodInfo; cases: TArray<DNSwitchCase>): DNSwitchExpression; overload;
    {class} function Switch(switchValue: DNExpression; defaultBody: DNExpression; comparison: DDN.mscorlib.DNMethodInfo; cases: DDN.mscorlib.DNIEnumerable<DNSwitchCase>): DNSwitchExpression; overload;
    ///<summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  .</summary>
    ///  <param name="fileName">A <see cref="T:System.String" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  property set to the specified value.</returns>
    {class} function SymbolDocument(fileName: string): DNSymbolDocumentInfo; overload;
    ///<summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  .</summary>
    ///  <param name="fileName">A <see cref="T:System.String" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  equal to.</param>
    ///  <param name="language">A <see cref="T:System.Guid" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />
    ///  equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />
    ///  properties set to the specified value.</returns>
    {class} function SymbolDocument(fileName: string; language: DDN.mscorlib.DNGuid): DNSymbolDocumentInfo; overload;
    ///<summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  .</summary>
    ///  <param name="fileName">A <see cref="T:System.String" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  equal to.</param>
    ///  <param name="language">A <see cref="T:System.Guid" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />
    ///  equal to.</param>
    ///  <param name="languageVendor">A <see cref="T:System.Guid" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />
    ///  equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />
    ///  and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />
    ///  properties set to the specified value.</returns>
    {class} function SymbolDocument(fileName: string; language: DDN.mscorlib.DNGuid; languageVendor: DDN.mscorlib.DNGuid): DNSymbolDocumentInfo; overload;
    ///<summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  .</summary>
    ///  <param name="fileName">A <see cref="T:System.String" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  equal to.</param>
    ///  <param name="language">A <see cref="T:System.Guid" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />
    ///  equal to.</param>
    ///  <param name="languageVendor">A <see cref="T:System.Guid" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />
    ///  equal to.</param>
    ///  <param name="documentType">A <see cref="T:System.Guid" />
    ///  to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />
    ///  equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" />
    ///  and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" />
    ///  and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" />
    ///  and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" />
    ///  properties set to the specified value.</returns>
    {class} function SymbolDocument(fileName: string; language: DDN.mscorlib.DNGuid; languageVendor: DDN.mscorlib.DNGuid; documentType: DDN.mscorlib.DNGuid): DNSymbolDocumentInfo; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  representing a try block with a fault block and no catch statements.</summary>
    ///  <param name="body">The body of the try block.</param>
    ///  <param name="fault">The body of the fault block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  .</returns>
    {class} function TryFault(body: DNExpression; fault: DNExpression): DNTryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  representing a try block with a finally block and no catch statements.</summary>
    ///  <param name="body">The body of the try block.</param>
    ///  <param name="finally">The body of the finally block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  .</returns>
    {class} function TryFinally(body: DNExpression; &finally: DNExpression): DNTryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  representing a try block with any number of catch statements and neither a fault nor finally block.</summary>
    ///  <param name="body">The body of the try block.</param>
    ///  <param name="handlers">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  expressions representing the catch statements to be associated with the try block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  .</returns>
    {class} function TryCatch(body: DNExpression; handlers: TArray<DNCatchBlock>): DNTryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  representing a try block with any number of catch statements and a finally block.</summary>
    ///  <param name="body">The body of the try block.</param>
    ///  <param name="finally">The body of the finally block.</param>
    ///  <param name="handlers">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  expressions representing the catch statements to be associated with the try block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />
    ///  .</returns>
    {class} function TryCatchFinally(body: DNExpression; &finally: DNExpression; handlers: TArray<DNCatchBlock>): DNTryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  , given an operand, by calling the appropriate factory method.</summary>
    ///  <param name="unaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that specifies the type of unary operation.</param>
    ///  <param name="operand">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the operand.</param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  that specifies the type to be converted to (pass <see langword="null" />
    ///  if not applicable).</param>
    ///<returns>The <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that results from calling the appropriate factory method.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="operand" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="unaryType" />
    ///  does not correspond to a unary expression node.</exception>
    {class} function MakeUnary(unaryType: DNExpressionType; operand: DNExpression; &type: DDN.mscorlib.DNType): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  , given an operand and implementing method, by calling the appropriate factory method.</summary>
    ///  <param name="unaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that specifies the type of unary operation.</param>
    ///  <param name="operand">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the operand.</param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  that specifies the type to be converted to (pass <see langword="null" />
    ///  if not applicable).</param>
    ///  <param name="method">The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>The <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that results from calling the appropriate factory method.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="operand" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="unaryType" />
    ///  does not correspond to a unary expression node.</exception>
    {class} function MakeUnary(unaryType: DNExpressionType; operand: DNExpression; &type: DDN.mscorlib.DNType; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an arithmetic negation operation.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The unary minus operator is not defined for <paramref name="expression" />
    ///  .Type.</exception>
    {class} function Negate(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a unary plus operation.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The unary plus operator is not defined for <paramref name="expression" />
    ///  .Type.</exception>
    {class} function UnaryPlus(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an arithmetic negation operation that has overflow checking.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The unary minus operator is not defined for <paramref name="expression" />
    ///  .Type.</exception>
    {class} function NegateChecked(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a bitwise complement operation.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The unary not operator is not defined for <paramref name="expression" />
    ///  .Type.</exception>
    {class} function &Not(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Returns whether the expression evaluates to false.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to evaluate.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function IsFalse(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Returns whether the expression evaluates to true.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to evaluate.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function IsTrue(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Returns the expression representing the ones complement.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function OnesComplement(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a type conversion operation.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />
    ///  .Type and <paramref name="type" />
    ///  .</exception>
    {class} function Convert(expression: DNExpression; &type: DDN.mscorlib.DNType): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a conversion operation that throws an exception if the target type is overflowed.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />
    ///  .Type and <paramref name="type" />
    ///  .</exception>
    {class} function ConvertChecked(expression: DNExpression; &type: DDN.mscorlib.DNType): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an expression for obtaining the length of a one-dimensional array.</summary>
    ///  <param name="array">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to <paramref name="array" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="array" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="array" />
    ///  .Type does not represent an array type.</exception>
    {class} function ArrayLength(&array: DNExpression): DNUnaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a rethrowing of an exception.</summary>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a rethrowing of an exception.</returns>
    {class} function Rethrow: DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a rethrowing of an exception with a given type.</summary>
    ///  <param name="type">The new <see cref="T:System.Type" />
    ///  of the expression.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a rethrowing of an exception.</returns>
    {class} function Rethrow(&type: DDN.mscorlib.DNType): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a throwing of an exception.</summary>
    ///  <param name="value">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the exception.</returns>
    {class} function Throw(value: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the incrementing of the expression value by 1.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to increment.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the incremented expression.</returns>
    {class} function Increment(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the decrementing of the expression by 1.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to decrement.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the decremented expression.</returns>
    {class} function Decrement(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that increments the expression by 1 and assigns the result back to the expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PreIncrementAssign(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that increments the expression by 1 and assigns the result back to the expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PreIncrementAssign(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that decrements the expression by 1 and assigns the result back to the expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PreDecrementAssign(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that decrements the expression by 1 and assigns the result back to the expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PreDecrementAssign(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PostIncrementAssign(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PostIncrementAssign(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PostDecrementAssign(expression: DNExpression): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to apply the operations on.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the resultant expression.</returns>
    {class} function PostDecrementAssign(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function Assign(left: DNExpression; right: DNExpression): DNBinaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a reference equality comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function ReferenceEqual(left: DNExpression; right: DNExpression): DNBinaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an inequality comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the inequality operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function NotEqual(left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a reference inequality comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    {class} function ReferenceNotEqual(left: DNExpression; right: DNExpression): DNBinaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "less than" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the "less than" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function LessThan(left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "greater than or equal" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the "greater than or equal" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function GreaterThanOrEqual(left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a conditional <see langword="AND" />
    ///  operation that evaluates the second operand only if the first operand is resolved to true. The implementing method can be specified.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the bitwise <see langword="AND" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.-or-
    ///  <paramref name="method" />
    ///  is <see langword="null" />
    ///  and <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type are not the same Boolean type.</exception>
    {class} function AndAlso(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a conditional <see langword="OR" />
    ///  operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />
    ///  .</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the bitwise <see langword="OR" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.-or-
    ///  <paramref name="method" />
    ///  is <see langword="null" />
    ///  and <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type are not the same Boolean type.</exception>
    {class} function OrElse(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a coalescing operation, given a conversion function.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type are not convertible to each other.-or-
    ///  <paramref name="conversion" />
    ///  is not <see langword="null" />
    ///  and <paramref name="conversion" />
    ///  .Type is a delegate type that does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of <paramref name="left" />
    ///  does not represent a reference type or a nullable value type.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of <paramref name="left" />
    ///  represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />
    ///  .Type.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of <paramref name="right" />
    ///  is not equal to the return type of the delegate type <paramref name="conversion" />
    ///  .Type.</exception>
    {class} function Coalesce(left: DNExpression; right: DNExpression; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an addition assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function AddAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an addition assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function AddAssignChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic addition operation that has overflow checking. The implementing method can be specified.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the addition operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function AddChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic subtraction operation that does not have overflow checking.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the subtraction operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Subtract(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a subtraction assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function SubtractAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a subtraction assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function SubtractAssignChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic subtraction operation that has overflow checking.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the subtraction operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function SubtractChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic division operation. The implementing method can be specified.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the division operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Divide(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a division assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function DivideAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic remainder operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the modulus operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Modulo(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a remainder assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function ModuloAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic multiplication operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the multiplication operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Multiply(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a multiplication assignment operation that does not have overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function MultiplyAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a multiplication assignment operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function MultiplyAssignChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic multiplication operation that has overflow checking.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the multiplication operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function MultiplyChecked(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise left-shift operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the left-shift operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function LeftShift(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise left-shift assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function LeftShiftAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise right-shift operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the right-shift operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function RightShift(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise right-shift assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function RightShiftAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise <see langword="AND" />
    ///  operation. The implementing method can be specified.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the bitwise <see langword="AND" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function &And(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise AND assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function AndAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise <see langword="OR" />
    ///  operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the bitwise <see langword="OR" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function &Or(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise OR assignment operation.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function OrAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise <see langword="XOR" />
    ///  operation, using op_ExclusiveOr for user-defined types. The implementing method can be specified.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the <see langword="XOR" />
    ///  operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function ExclusiveOr(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a bitwise XOR assignment operation, using op_ExclusiveOr for user-defined types.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function ExclusiveOrAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents raising a number to a power.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the exponentiation operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.-or-
    ///  <paramref name="method" />
    ///  is <see langword="null" />
    ///  and <paramref name="left" />
    ///  .Type and/or <paramref name="right" />
    ///  .Type are not <see cref="T:System.Double" />
    ///  .</exception>
    {class} function Power(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents raising an expression to a power and assigning the result back to the expression.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///  <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  properties set to the specified values.</returns>
    {class} function PowerAssign(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo; conversion: DNLambdaExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents applying an array index operator to an array of rank one.</summary>
    ///  <param name="array">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="index">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="array" />
    ///  or <paramref name="index" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="array" />
    ///  .Type does not represent an array type.-or-
    ///  <paramref name="array" />
    ///  .Type represents an array type whose rank is not 1.-or-
    ///  <paramref name="index" />
    ///  .Type does not represent the <see cref="T:System.Int32" />
    ///  type.</exception>
    {class} function ArrayIndex(&array: DNExpression; index: DNExpression): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  that contains two expressions and has no variables.</summary>
    ///  <param name="arg0">The first expression in the block.</param>
    ///  <param name="arg1">The second expression in the block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  .</returns>
    {class} function Block(arg0: DNExpression; arg1: DNExpression): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  that contains three expressions and has no variables.</summary>
    ///  <param name="arg0">The first expression in the block.</param>
    ///  <param name="arg1">The second expression in the block.</param>
    ///  <param name="arg2">The third expression in the block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  .</returns>
    {class} function Block(arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  that contains four expressions and has no variables.</summary>
    ///  <param name="arg0">The first expression in the block.</param>
    ///  <param name="arg1">The second expression in the block.</param>
    ///  <param name="arg2">The third expression in the block.</param>
    ///  <param name="arg3">The fourth expression in the block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  .</returns>
    {class} function Block(arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  that contains five expressions and has no variables.</summary>
    ///  <param name="arg0">The first expression in the block.</param>
    ///  <param name="arg1">The second expression in the block.</param>
    ///  <param name="arg2">The third expression in the block.</param>
    ///  <param name="arg3">The fourth expression in the block.</param>
    ///  <param name="arg4">The fifth expression in the block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  .</returns>
    {class} function Block(arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression; arg4: DNExpression): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  that contains the given expressions and has no variables.</summary>
    ///  <param name="expressions">The expressions in the block.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />
    ///  .</returns>
    {class} function Block(expressions: TArray<DNExpression>): DNBlockExpression; overload;
    {class} function Block(variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>; expressions: DDN.mscorlib.DNIEnumerable<DNExpression>): DNBlockExpression; overload;
    {class} function Block(&type: DDN.mscorlib.DNType; variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>; expressions: DDN.mscorlib.DNIEnumerable<DNExpression>): DNBlockExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  representing a catch statement with the specified elements.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  of <see cref="T:System.Exception" />
    ///  this <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  will handle.</param>
    ///  <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  representing a reference to the <see cref="T:System.Exception" />
    ///  object caught by this handler.</param>
    ///  <param name="body">The body of the catch statement.</param>
    ///  <param name="filter">The body of the <see cref="T:System.Exception" />
    ///  filter.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  .</returns>
    {class} function MakeCatchBlock(&type: DDN.mscorlib.DNType; variable: DNParameterExpression; body: DNExpression; filter: DNExpression): DNCatchBlock;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that represents a conditional statement.</summary>
    ///  <param name="test">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  property equal to.</param>
    ///  <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  property equal to.</param>
    ///  <param name="ifFalse">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />
    ///  and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  , <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  , and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="test" />
    ///  or <paramref name="ifTrue" />
    ///  or <paramref name="ifFalse" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="test" />
    ///  .Type is not <see cref="T:System.Boolean" />
    ///  .-or-
    ///  <paramref name="ifTrue" />
    ///  .Type is not equal to <paramref name="ifFalse" />
    ///  .Type.</exception>
    {class} function Condition(test: DNExpression; ifTrue: DNExpression; ifFalse: DNExpression): DNConditionalExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that represents a conditional statement.</summary>
    ///  <param name="test">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  property equal to.</param>
    ///  <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  property equal to.</param>
    ///  <param name="ifFalse">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" />
    ///  and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  , <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  , and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  properties set to the specified values.</returns>
    {class} function Condition(test: DNExpression; ifTrue: DNExpression; ifFalse: DNExpression; &type: DDN.mscorlib.DNType): DNConditionalExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression; arg1: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///  <param name="arg3">The fourth argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression): DNDynamicExpression; overload;
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNDynamicExpression; overload;
    {class} function ElementInit(addMethod: DDN.mscorlib.DNMethodInfo; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNElementInit; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />
    ///  . The value passed to the label upon jumping can also be specified.</summary>
    ///  <param name="kind">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" />
    ///  of the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  .</param>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that the <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  will jump to.</param>
    ///  <param name="value">The value that will be passed to the associated label upon jumping.</param>
    ///  <param name="type">An <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.GotoExpression" />
    ///  with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" />
    ///  equal to <paramref name="kind" />
    ///  , the <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property set to <paramref name="target" />
    ///  , the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property set to <paramref name="type" />
    ///  , and <paramref name="value" />
    ///  to be passed to the target label upon jumping.</returns>
    {class} function MakeGoto(kind: DNGotoExpressionKind; target: DNLabelTarget; value: DNExpression; &type: DDN.mscorlib.DNType): DNGotoExpression;
    {class} function ArrayAccess(&array: DNExpression; indexes: DDN.mscorlib.DNIEnumerable<DNExpression>): DNIndexExpression; overload;
    ///<summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" />
    ///  representing the access to an indexed property.</summary>
    ///  <param name="instance">The object to which the property belongs. If the property is static/shared, it must be null.</param>
    ///  <param name="propertyName">The name of the indexer.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that are used to index the property.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />
    ///  .</returns>
    {class} function &Property(instance: DNExpression; propertyName: string; arguments: TArray<DNExpression>): DNIndexExpression; overload;
    {class} function Invoke(expression: DNExpression; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNInvocationExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  representing a label with the given default value.</summary>
    ///  <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  which this <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  will be associated with.</param>
    ///  <param name="defaultValue">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  when the label is reached through regular control flow.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  with the given default value.</returns>
    {class} function &Label(target: DNLabelTarget; defaultValue: DNExpression): DNLabelExpression; overload;
    ///<summary>Gets a <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  object that represents a generic System.Func or System.Action delegate type that has specific type arguments.</summary>
    ///  <param name="typeArgs">The type arguments of the delegate.</param>
    ///<returns>The delegate type.</returns>
    {class} function GetDelegateType(typeArgs: TArray<DDN.mscorlib.DNType>): DDN.mscorlib.DNType;
    {class} function ListInit(newExpression: DNNewExpression; initializers: DDN.mscorlib.DNIEnumerable<DNExpression>): DNListInitExpression; overload;
    {class} function ListInit(newExpression: DNNewExpression; addMethod: DDN.mscorlib.DNMethodInfo; initializers: DDN.mscorlib.DNIEnumerable<DNExpression>): DNListInitExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.LoopExpression" />
    ///  with the given body.</summary>
    ///  <param name="body">The body of the loop.</param>
    ///  <param name="break">The break target used by the loop body.</param>
    ///  <param name="continue">The continue target used by the loop body.</param>
    ///<returns>The created <see cref="T:System.Linq.Expressions.LoopExpression" />
    ///  .</returns>
    {class} function Loop(body: DNExpression; break: DNLabelTarget; &continue: DNLabelTarget): DNLoopExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" />
    ///  that represents the initialization of a field or property.</summary>
    ///  <param name="member">A <see cref="T:System.Reflection.MemberInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  property equal to.</param>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" />
    ///  that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" />
    ///  equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" />
    ///  and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="member" />
    ///  or <paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="member" />
    ///  does not represent a field or property.-or-The property represented by <paramref name="member" />
    ///  does not have a <see langword="set" />
    ///  accessor.-or-
    ///  <paramref name="expression" />
    ///  .Type is not assignable to the type of the field or property that <paramref name="member" />
    ///  represents.</exception>
    {class} function Bind(member: DDN.mscorlib.DNMemberInfo; expression: DNExpression): DNMemberAssignment; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a field given the name of the field.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  whose <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  contains a field named <paramref name="fieldName" />
    ///  . This can be null for static fields.</param>
    ///  <param name="fieldName">The name of a field to be accessed.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property set to <paramref name="expression" />
    ///  , and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  property set to the <see cref="T:System.Reflection.FieldInfo" />
    ///  that represents the field denoted by <paramref name="fieldName" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="fieldName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">No field named <paramref name="fieldName" />
    ///  is defined in <paramref name="expression" />
    ///  .Type or its base types.</exception>
    {class} function Field(expression: DNExpression; fieldName: string): DNMemberExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a property.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  whose <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  contains a property named <paramref name="propertyName" />
    ///  . This can be <see langword="null" />
    ///  for static properties.</param>
    ///  <param name="propertyName">The name of a property to be accessed.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property set to <paramref name="expression" />
    ///  , and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  property set to the <see cref="T:System.Reflection.PropertyInfo" />
    ///  that represents the property denoted by <paramref name="propertyName" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="propertyName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">No property named <paramref name="propertyName" />
    ///  is defined in <paramref name="expression" />
    ///  .Type or its base types.</exception>
    {class} function &Property(expression: DNExpression; propertyName: string): DNMemberExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a property or field.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  whose <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  contains a property or field named <paramref name="propertyOrFieldName" />
    ///  . This can be null for static members.</param>
    ///  <param name="propertyOrFieldName">The name of a property or field to be accessed.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />
    ///  , the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property set to <paramref name="expression" />
    ///  , and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  property set to the <see cref="T:System.Reflection.PropertyInfo" />
    ///  or <see cref="T:System.Reflection.FieldInfo" />
    ///  that represents the property or field denoted by <paramref name="propertyOrFieldName" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="propertyOrFieldName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">No property or field named <paramref name="propertyOrFieldName" />
    ///  is defined in <paramref name="expression" />
    ///  .Type or its base types.</exception>
    {class} function PropertyOrField(expression: DNExpression; propertyOrFieldName: string): DNMemberExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a method by calling the appropriate factory method.</summary>
    ///  <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  whose <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property value will be searched for a specific method.</param>
    ///  <param name="methodName">The name of the method.</param>
    ///  <param name="typeArguments">An array of <see cref="T:System.Type" />
    ///  objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that represents the arguments to the method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  , the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />
    ///  property equal to <paramref name="instance" />
    ///  , <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  set to the <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  set to the specified arguments.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="instance" />
    ///  or <paramref name="methodName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">No method whose name is <paramref name="methodName" />
    ///  , whose type parameters match <paramref name="typeArguments" />
    ///  , and whose parameter types match <paramref name="arguments" />
    ///  is found in <paramref name="instance" />
    ///  .Type or its base types.-or-More than one method whose name is <paramref name="methodName" />
    ///  , whose type parameters match <paramref name="typeArguments" />
    ///  , and whose parameter types match <paramref name="arguments" />
    ///  is found in <paramref name="instance" />
    ///  .Type or its base types.</exception>
    {class} function Call(instance: DNExpression; methodName: string; typeArguments: TArray<DDN.mscorlib.DNType>; arguments: TArray<DNExpression>): DNMethodCallExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that represents a call to a <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method by calling the appropriate factory method.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  that specifies the type that contains the specified <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method.</param>
    ///  <param name="methodName">The name of the method.</param>
    ///  <param name="typeArguments">An array of <see cref="T:System.Type" />
    ///  objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.</param>
    ///  <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that represent the arguments to the method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />
    ///  , the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />
    ///  property set to the <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the specified <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" />
    ///  property set to the specified arguments.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="type" />
    ///  or <paramref name="methodName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">No method whose name is <paramref name="methodName" />
    ///  , whose type parameters match <paramref name="typeArguments" />
    ///  , and whose parameter types match <paramref name="arguments" />
    ///  is found in <paramref name="type" />
    ///  or its base types.-or-More than one method whose name is <paramref name="methodName" />
    ///  , whose type parameters match <paramref name="typeArguments" />
    ///  , and whose parameter types match <paramref name="arguments" />
    ///  is found in <paramref name="type" />
    ///  or its base types.</exception>
    {class} function Call(&type: DDN.mscorlib.DNType; methodName: string; typeArguments: TArray<DDN.mscorlib.DNType>; arguments: TArray<DNExpression>): DNMethodCallExpression; overload;
    {class} function ArrayIndex(&array: DNExpression; indexes: DDN.mscorlib.DNIEnumerable<DNExpression>): DNMethodCallExpression; overload;
    {class} function NewArrayBounds(&type: DDN.mscorlib.DNType; bounds: DDN.mscorlib.DNIEnumerable<DNExpression>): DNNewArrayExpression; overload;
    {class} function SwitchCase(body: DNExpression; testValues: DDN.mscorlib.DNIEnumerable<DNExpression>): DNSwitchCase; overload;
    {class} function Switch(&type: DDN.mscorlib.DNType; switchValue: DNExpression; defaultBody: DNExpression; comparison: DDN.mscorlib.DNMethodInfo; cases: DDN.mscorlib.DNIEnumerable<DNSwitchCase>): DNSwitchExpression; overload;
    {class} function MakeTry(&type: DDN.mscorlib.DNType; body: DNExpression; &finally: DNExpression; fault: DNExpression; handlers: DDN.mscorlib.DNIEnumerable<DNCatchBlock>): DNTryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />
    ///  .</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />
    ///  for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" />
    ///  and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />
    ///  and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />
    ///  properties are set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function TypeIs(expression: DNExpression; &type: DDN.mscorlib.DNType): DNTypeBinaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />
    ///  that compares run-time type identity.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="T:System.Linq.Expressions.Expression" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />
    ///  for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" />
    ///  and for which the <see cref="T:System.Linq.Expressions.Expression" />
    ///  and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" />
    ///  properties are set to the specified values.</returns>
    {class} function TypeEqual(expression: DNExpression; &type: DDN.mscorlib.DNType): DNTypeBinaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an arithmetic negation operation.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the unary minus operator is not defined for <paramref name="expression" />
    ///  .Type.-or-
    ///  <paramref name="expression" />
    ///  .Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function Negate(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a unary plus operation.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the unary plus operator is not defined for <paramref name="expression" />
    ///  .Type.-or-
    ///  <paramref name="expression" />
    ///  .Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function UnaryPlus(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an arithmetic negation operation that has overflow checking. The implementing method can be specified.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the unary minus operator is not defined for <paramref name="expression" />
    ///  .Type.-or-
    ///  <paramref name="expression" />
    ///  .Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function NegateChecked(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Returns whether the expression evaluates to false.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to evaluate.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function IsFalse(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Returns whether the expression evaluates to true.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to evaluate.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function IsTrue(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Returns the expression representing the ones complement.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function OnesComplement(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an explicit reference or boxing conversion where <see langword="null" />
    ///  is supplied if the conversion fails.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function TypeAs(expression: DNExpression; &type: DDN.mscorlib.DNType): DNUnaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an explicit unboxing.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to unbox.</param>
    ///  <param name="type">The new <see cref="T:System.Type" />
    ///  of the expression.</param>
    ///<returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  .</returns>
    {class} function Unbox(expression: DNExpression; &type: DDN.mscorlib.DNType): DNUnaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  , <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  , and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />
    ///  .Type and <paramref name="type" />
    ///  .-or-
    ///  <paramref name="expression" />
    ///  .Type is not assignable to the argument type of the method represented by <paramref name="method" />
    ///  .-or-The return type of the method represented by <paramref name="method" />
    ///  is not assignable to <paramref name="type" />
    ///  .-or-
    ///  <paramref name="expression" />
    ///  .Type or <paramref name="type" />
    ///  is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />
    ///  .</exception><exception cref="T:System.Reflection.AmbiguousMatchException">More than one method that matches the <paramref name="method" />
    ///  description was found.</exception>
    {class} function ConvertChecked(expression: DNExpression; &type: DDN.mscorlib.DNType; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property set to the specified value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function Quote(expression: DNExpression): DNUnaryExpression;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a throwing of an exception with a given type.</summary>
    ///  <param name="value">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</param>
    ///  <param name="type">The new <see cref="T:System.Type" />
    ///  of the expression.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the exception.</returns>
    {class} function Throw(value: DNExpression; &type: DDN.mscorlib.DNType): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the incrementing of the expression by 1.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to increment.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the incremented expression.</returns>
    {class} function Increment(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the decrementing of the expression by 1.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to decrement.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents the decremented expression.</returns>
    {class} function Decrement(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an equality comparison. The implementing method can be specified.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the equality operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Equal(left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "greater than" numeric comparison. The implementing method can be specified.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the "greater than" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function GreaterThan(left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents a "less than or equal" numeric comparison.</summary>
    ///  <param name="left">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="liftToNull"><see langword="true" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="true" />
    ///  ; <see langword="false" />
    ///  to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  to <see langword="false" />
    ///  .</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />
    ///  , and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the "less than or equal" operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function LessThanOrEqual(left: DNExpression; right: DNExpression; liftToNull: Boolean; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that represents an arithmetic addition operation that does not have overflow checking. The implementing method can be specified.</summary>
    ///  <param name="left">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property equal to.</param>
    ///  <param name="right">A <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" />
    ///  and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  , <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="left" />
    ///  or <paramref name="right" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly two arguments.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the addition operator is not defined for <paramref name="left" />
    ///  .Type and <paramref name="right" />
    ///  .Type.</exception>
    {class} function Add(left: DNExpression; right: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNBinaryExpression; overload;
    {class} function Lambda(body: DNExpression; name: string; tailCall: Boolean; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNLambdaExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a field.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property equal to. For <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), <paramref name="expression" />
    ///  must be <see langword="null" />
    ///  .</param>
    ///  <param name="field">The <see cref="T:System.Reflection.FieldInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  and <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="field" />
    ///  is <see langword="null" />
    ///  .-or-The field represented by <paramref name="field" />
    ///  is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) and <paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="expression" />
    ///  .Type is not assignable to the declaring type of the field represented by <paramref name="field" />
    ///  .</exception>
    {class} function Field(expression: DNExpression; field: DDN.mscorlib.DNFieldInfo): DNMemberExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that represents accessing a property.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property equal to. This can be null for static properties.</param>
    ///  <param name="property">The <see cref="T:System.Reflection.PropertyInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.MemberExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />
    ///  and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  and <see cref="P:System.Linq.Expressions.MemberExpression.Member" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="property" />
    ///  is <see langword="null" />
    ///  .-or-The property that <paramref name="property" />
    ///  represents is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic) and <paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="expression" />
    ///  .Type is not assignable to the declaring type of the property that <paramref name="property" />
    ///  represents.</exception>
    {class} function &Property(expression: DNExpression; &property: DDN.mscorlib.DNPropertyInfo): DNMemberExpression; overload;
    {class} function NewArrayInit(&type: DDN.mscorlib.DNType; initializers: DDN.mscorlib.DNIEnumerable<DNExpression>): DNNewArrayExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a bitwise complement operation. The implementing method can be specified.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException"><paramref name="method" />
    ///  is <see langword="null" />
    ///  and the unary not operator is not defined for <paramref name="expression" />
    ///  .Type.-or-
    ///  <paramref name="expression" />
    ///  .Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />
    ///  .</exception>
    {class} function &Not(expression: DNExpression; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that represents a conversion operation for which the implementing method is specified.</summary>
    ///  <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property equal to.</param>
    ///  <param name="type">A <see cref="T:System.Type" />
    ///  to set the <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property equal to.</param>
    ///  <param name="method">A <see cref="T:System.Reflection.MethodInfo" />
    ///  to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  property equal to.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" />
    ///  that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" />
    ///  and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  , <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  , and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" />
    ///  properties set to the specified values.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="expression" />
    ///  or <paramref name="type" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="method" />
    ///  is not <see langword="null" />
    ///  and the method it represents returns <see langword="void" />
    ///  , is not <see langword="static" />
    ///  (<see langword="Shared" />
    ///  in Visual Basic), or does not take exactly one argument.</exception><exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />
    ///  .Type and <paramref name="type" />
    ///  .-or-
    ///  <paramref name="expression" />
    ///  .Type is not assignable to the argument type of the method represented by <paramref name="method" />
    ///  .-or-The return type of the method represented by <paramref name="method" />
    ///  is not assignable to <paramref name="type" />
    ///  .-or-
    ///  <paramref name="expression" />
    ///  .Type or <paramref name="type" />
    ///  is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />
    ///  .</exception><exception cref="T:System.Reflection.AmbiguousMatchException">More than one method that matches the <paramref name="method" />
    ///  description was found.</exception>
    {class} function Convert(expression: DNExpression; &type: DDN.mscorlib.DNType; method: DDN.mscorlib.DNMethodInfo): DNUnaryExpression; overload;

  end;

  ///<summary>Provides the base class from which the classes that represent expression tree nodes are derived. It also contains <see langword="static" />
  ///  (<see langword="Shared" />
  ///  in Visual Basic) factory methods to create the various node types. This is an <see langword="abstract" />
  ///  class.</summary>
  [DNTypeName('System.Linq.Expressions.Expression')]
  DNExpression = interface(DDN.mscorlib.DNObject)
  ['{57071121-58D1-3F8B-AC92-8E800D171A46}']
  { getters & setters } 

    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  values.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNExpression = class(TDNGenericImport<DNExpressionClass, DNExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNBinaryExpressionClass = interface(DNExpressionClass)
  ['{91789D04-E372-5290-8931-82B96CC59305}']
  end;

  ///<summary>Represents an expression that has a binary operator.</summary>
  [DNTypeName('System.Linq.Expressions.BinaryExpression')]
  DNBinaryExpression = interface(DNExpression)
  ['{EF49C1CA-EFE3-3547-B40F-BB563F5D10DB}']
  { getters & setters } 

    function get_CanReduce: Boolean;
    function get_Right: DNExpression;
    function get_Left: DNExpression;
    function get_Method: DDN.mscorlib.DNMethodInfo;
    function get_Conversion: DNLambdaExpression;
    function get_IsLifted: Boolean;
    function get_IsLiftedToNull: Boolean;
    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="left">The <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />
    ///  property of the result. </param>
    ///  <param name="conversion">The <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />
    ///  property of the result.</param>
    ///  <param name="right">The <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />
    ///  property of the result. </param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(left: DNExpression; conversion: DNLambdaExpression; right: DNExpression): DNBinaryExpression;
    ///<summary>Reduces the binary expression node to a simpler expression.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
    ///<returns>True if the expression tree node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
    ///<summary>Gets the right operand of the binary operation.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the right operand of the binary operation.</returns>
    property Right: DNExpression read get_Right;
    ///<summary>Gets the left operand of the binary operation.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the left operand of the binary operation.</returns>
    property Left: DNExpression read get_Left;
    ///<summary>Gets the implementing method for the binary operation.</summary>
    ///<returns>The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</returns>
    property Method: DDN.mscorlib.DNMethodInfo read get_Method;
    ///<summary>Gets the type conversion function that is used by a coalescing or compound assignment operation.</summary>
    ///<returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  that represents a type conversion function.</returns>
    property Conversion: DNLambdaExpression read get_Conversion;
    ///<summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator.</summary>
    ///<returns><see langword="true" />
    ///  if the node represents a lifted call; otherwise, <see langword="false" />
    ///  .</returns>
    property IsLifted: Boolean read get_IsLifted;
    ///<summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.</summary>
    ///<returns><see langword="true" />
    ///  if the operator's return type is lifted to a nullable type; otherwise, <see langword="false" />
    ///  .</returns>
    property IsLiftedToNull: Boolean read get_IsLiftedToNull;
    ///<summary>Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  values.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
  end;

  TDNBinaryExpression = class(TDNGenericImport<DNBinaryExpressionClass, DNBinaryExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNBlockExpressionClass = interface(DNExpressionClass)
  ['{9015D880-1C72-55B8-A5DD-152145139FA6}']
  end;

  ///<summary>Represents a block that contains a sequence of expressions where variables can be defined.</summary>
  [DNTypeName('System.Linq.Expressions.BlockExpression')]
  DNBlockExpression = interface(DNExpression)
  ['{4ADE1326-F32D-3684-A10B-F89B1981E42B}']
  { getters & setters } 

    function get_Expressions: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_Variables: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>;
    function get_Result: DNExpression;
    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>; expressions: DDN.mscorlib.DNIEnumerable<DNExpression>): DNBlockExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the expressions in this block.</summary>
    ///<returns>The read-only collection containing all the expressions in this block.</returns>
    property Expressions: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Expressions;
    ///<summary>Gets the variables defined in this block.</summary>
    ///<returns>The read-only collection containing all the variables defined in this block.</returns>
    property Variables: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression> read get_Variables;
    ///<summary>Gets the last expression in this block.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object representing the last expression in this block.</returns>
    property Result: DNExpression read get_Result;
    ///<summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.BlockExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNBlockExpression = class(TDNGenericImport<DNBlockExpressionClass, DNBlockExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNConditionalExpressionClass = interface(DNExpressionClass)
  ['{ECB3F797-8D2F-51B3-B15A-B7347D37F725}']
  end;

  ///<summary>Represents an expression that has a conditional operator.</summary>
  [DNTypeName('System.Linq.Expressions.ConditionalExpression')]
  DNConditionalExpression = interface(DNExpression)
  ['{452FF498-0D0D-3058-AA87-2ED4AC9A2ECB}']
  { getters & setters } 

    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_Test: DNExpression;
    function get_IfTrue: DNExpression;
    function get_IfFalse: DNExpression;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression</summary>
    ///  <param name="test">The <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />
    ///  property of the result.</param>
    ///  <param name="ifTrue">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />
    ///  property of the result.</param>
    ///  <param name="ifFalse">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" />
    ///  property of the result.</param>
    ///<returns>This expression if no children changed, or an expression with the updated children.</returns>
    function Update(test: DNExpression; ifTrue: DNExpression; ifFalse: DNExpression): DNConditionalExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets the test of the conditional operation.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the test of the conditional operation.</returns>
    property Test: DNExpression read get_Test;
    ///<summary>Gets the expression to execute if the test evaluates to <see langword="true" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the expression to execute if the test is <see langword="true" />
    ///  .</returns>
    property IfTrue: DNExpression read get_IfTrue;
    ///<summary>Gets the expression to execute if the test evaluates to <see langword="false" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the expression to execute if the test is <see langword="false" />
    ///  .</returns>
    property IfFalse: DNExpression read get_IfFalse;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNConditionalExpression = class(TDNGenericImport<DNConditionalExpressionClass, DNConditionalExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNConstantExpressionClass = interface(DNExpressionClass)
  ['{EF3717B5-F977-57DF-82AD-5D8C07442C0C}']
  end;

  ///<summary>Represents an expression that has a constant value.</summary>
  [DNTypeName('System.Linq.Expressions.ConstantExpression')]
  DNConstantExpression = interface(DNExpression)
  ['{C0BD600C-8151-3DE1-9A18-A2FBAFA21722}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Value: DDN.mscorlib.DNObject;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.ConstantExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the value of the constant expression.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  equal to the value of the represented expression.</returns>
    property Value: DDN.mscorlib.DNObject read get_Value;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNConstantExpression = class(TDNGenericImport<DNConstantExpressionClass, DNConstantExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNDebugInfoExpressionClass = interface(DNExpressionClass)
  ['{5712692D-C598-52D5-947B-6229D1A03888}']
  end;

  ///<summary>Emits or clears a sequence point for debug information. This allows the debugger to highlight the correct source code when debugging.</summary>
  [DNTypeName('System.Linq.Expressions.DebugInfoExpression')]
  DNDebugInfoExpression = interface(DNExpression)
  ['{EEE86BA5-8E06-3FD9-A26A-5A6D437DBFF2}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_StartLine: Int32;
    function get_StartColumn: Int32;
    function get_EndLine: Int32;
    function get_EndColumn: Int32;
    function get_Document: DNSymbolDocumentInfo;
    function get_IsClear: Boolean;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  .</summary>
    ///<returns>The number of the start line of the code that was used to generate the wrapped expression.</returns>
    property StartLine: Int32 read get_StartLine;
    ///<summary>Gets the start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  .</summary>
    ///<returns>The number of the start column of the code that was used to generate the wrapped expression.</returns>
    property StartColumn: Int32 read get_StartColumn;
    ///<summary>Gets the end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  .</summary>
    ///<returns>The number of the end line of the code that was used to generate the wrapped expression.</returns>
    property EndLine: Int32 read get_EndLine;
    ///<summary>Gets the end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  .</summary>
    ///<returns>The number of the end column of the code that was used to generate the wrapped expression.</returns>
    property EndColumn: Int32 read get_EndColumn;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that represents the source file.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />
    ///  that represents the source file.</returns>
    property Document: DNSymbolDocumentInfo read get_Document;
    ///<summary>Gets the value to indicate if the <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  is for clearing a sequence point.</summary>
    ///<returns>True if the <see cref="T:System.Linq.Expressions.DebugInfoExpression" />
    ///  is for clearing a sequence point, otherwise false.</returns>
    property IsClear: Boolean read get_IsClear;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNDebugInfoExpression = class(TDNGenericImport<DNDebugInfoExpressionClass, DNDebugInfoExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNDefaultExpressionClass = interface(DNExpressionClass)
  ['{C3CC3D36-48FE-51BA-ACE7-92FC8FB171FB}']
  end;

  ///<summary>Represents the default value of a type or an empty expression.</summary>
  [DNTypeName('System.Linq.Expressions.DefaultExpression')]
  DNDefaultExpression = interface(DNExpression)
  ['{703F4557-43C0-3DCF-919E-67EBF03D4644}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.DefaultExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNDefaultExpression = class(TDNGenericImport<DNDefaultExpressionClass, DNDefaultExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNDynamicExpressionClass = interface(DNExpressionClass)
  ['{2163DE95-A4EB-5C77-A332-F1BC68E8DD69}']
  { static methods } 

    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arguments">The arguments to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arguments: TArray<DNExpression>): DNDynamicExpression; overload;
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  ,  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression; arg1: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="returnType">The result type of the dynamic expression.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///  <param name="arg3">The fourth argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function &Dynamic(binder: DNCallSiteBinder; returnType: DDN.mscorlib.DNType; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression): DNDynamicExpression; overload;
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  .</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arguments">The arguments to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arguments: TArray<DNExpression>): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and one argument.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and two arguments.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression; arg1: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and three arguments.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression): DNDynamicExpression; overload;
    ///<summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  and four arguments.</summary>
    ///  <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</param>
    ///  <param name="binder">The runtime binder for the dynamic operation.</param>
    ///  <param name="arg0">The first argument to the dynamic operation.</param>
    ///  <param name="arg1">The second argument to the dynamic operation.</param>
    ///  <param name="arg2">The third argument to the dynamic operation.</param>
    ///  <param name="arg3">The fourth argument to the dynamic operation.</param>
    ///<returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" />
    ///  that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" />
    ///  equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />
    ///  , and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />
    ///  , <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />
    ///  , and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" />
    ///  set to the specified values.</returns>
    {class} function MakeDynamic(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder; arg0: DNExpression; arg1: DNExpression; arg2: DNExpression; arg3: DNExpression): DNDynamicExpression; overload;

  end;

  ///<summary>Represents a dynamic operation.</summary>
  [DNTypeName('System.Linq.Expressions.DynamicExpression')]
  DNDynamicExpression = interface(DNExpression)
  ['{7AD50124-4068-3266-B4E7-EED07F37B8F6}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Binder: DNCallSiteBinder;
    function get_DelegateType: DDN.mscorlib.DNType;
    function get_Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNDynamicExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.DynamicExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  , which determines the run-time behavior of the dynamic site.</summary>
    ///<returns>The <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  , which determines the run-time behavior of the dynamic site.</returns>
    property Binder: DNCallSiteBinder read get_Binder;
    ///<summary>Gets the type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />
    ///  .</returns>
    property DelegateType: DDN.mscorlib.DNType read get_DelegateType;
    ///<summary>Gets the arguments to the dynamic operation.</summary>
    ///<returns>The read-only collections containing the arguments to the dynamic operation.</returns>
    property Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Arguments;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNDynamicExpression = class(TDNGenericImport<DNDynamicExpressionClass, DNDynamicExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNGotoExpressionClass = interface(DNExpressionClass)
  ['{FB63F368-4E06-5FE6-B0E1-E909CFF59E51}']
  end;

  ///<summary>Represents an unconditional jump. This includes return statements, break and continue statements, and other jumps.</summary>
  [DNTypeName('System.Linq.Expressions.GotoExpression')]
  DNGotoExpression = interface(DNExpression)
  ['{F0DC023B-24DC-3A7F-A928-1F1A05E03124}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Value: DNExpression;
    function get_Target: DNLabelTarget;
    function get_Kind: DNGotoExpressionKind;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="target">The <see cref="P:System.Linq.Expressions.GotoExpression.Target" />
    ///  property of the result. </param>
    ///  <param name="value">The <see cref="P:System.Linq.Expressions.GotoExpression.Value" />
    ///  property of the result. </param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(target: DNLabelTarget; value: DNExpression): DNGotoExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.GotoExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>The value passed to the target, or null if the target is of type System.Void.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object representing the value passed to the target or null.</returns>
    property Value: DNExpression read get_Value;
    ///<summary>The target label where this node jumps to.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  object representing the target label for this node.</returns>
    property Target: DNLabelTarget read get_Target;
    ///<summary>The kind of the "go to" expression. Serves information purposes only.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.GotoExpressionKind" />
    ///  object representing the kind of the "go to" expression.</returns>
    property Kind: DNGotoExpressionKind read get_Kind;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNGotoExpression = class(TDNGenericImport<DNGotoExpressionClass, DNGotoExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNIndexExpressionClass = interface(DNExpressionClass)
  ['{37E35E28-53CF-5BA3-81FC-0316EDAEEB11}']
  end;

  ///<summary>Represents indexing a property or array.</summary>
  [DNTypeName('System.Linq.Expressions.IndexExpression')]
  DNIndexExpression = interface(DNExpression)
  ['{79C65FB9-134E-37BC-9028-657D7B399EA3}']
  { getters & setters } 

    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_Object: DNExpression;
    function get_Indexer: DDN.mscorlib.DNPropertyInfo;
    function get_Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(&object: DNExpression; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNIndexExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.IndexExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>An object to index.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the object to index.</returns>
    property &Object: DNExpression read get_Object;
    ///<summary>Gets the <see cref="T:System.Reflection.PropertyInfo" />
    ///  for the property if the expression represents an indexed property, returns null otherwise.</summary>
    ///<returns>The <see cref="T:System.Reflection.PropertyInfo" />
    ///  for the property if the expression represents an indexed property, otherwise null.</returns>
    property Indexer: DDN.mscorlib.DNPropertyInfo read get_Indexer;
    ///<summary>Gets the arguments that will be used to index the property or array.</summary>
    ///<returns>The read-only collection containing the arguments that will be used to index the property or array.</returns>
    property Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Arguments;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNIndexExpression = class(TDNGenericImport<DNIndexExpressionClass, DNIndexExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNInvocationExpressionClass = interface(DNExpressionClass)
  ['{6FE15B6C-70A0-5BE1-B599-8CF4669D5EFE}']
  end;

  ///<summary>Represents an expression that applies a delegate or lambda expression to a list of argument expressions.</summary>
  [DNTypeName('System.Linq.Expressions.InvocationExpression')]
  DNInvocationExpression = interface(DNExpression)
  ['{0704CC69-1CAB-396D-B00D-6485524D2E5E}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Expression: DNExpression;
    function get_Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(expression: DNExpression; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNInvocationExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.InvocationExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the delegate or lambda expression to be applied.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the delegate to be applied.</returns>
    property Expression: DNExpression read get_Expression;
    ///<summary>Gets the arguments that the delegate or lambda expression is applied to.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects which represent the arguments that the delegate is applied to.</returns>
    property Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Arguments;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNInvocationExpression = class(TDNGenericImport<DNInvocationExpressionClass, DNInvocationExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNLabelExpressionClass = interface(DNExpressionClass)
  ['{2DBE2271-8658-54FC-85A1-1A78FA90064F}']
  end;

  ///<summary>Represents a label, which can be put in any <see cref="T:System.Linq.Expressions.Expression" />
  ///  context. If it is jumped to, it will get the value provided by the corresponding <see cref="T:System.Linq.Expressions.GotoExpression" />
  ///  . Otherwise, it receives the value in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />
  ///  . If the <see cref="T:System.Type" />
  ///  equals System.Void, no value should be provided.</summary>
  [DNTypeName('System.Linq.Expressions.LabelExpression')]
  DNLabelExpression = interface(DNExpression)
  ['{38BFD387-4AC0-3CAA-A98A-BC27F1F06A33}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Target: DNLabelTarget;
    function get_DefaultValue: DNExpression;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="target">The <see cref="P:System.Linq.Expressions.LabelExpression.Target" />
    ///  property of the result.</param>
    ///  <param name="defaultValue">The <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />
    ///  property of the result</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(target: DNLabelTarget; defaultValue: DNExpression): DNLabelExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.LabelExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  which this label is associated with.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  which this label is associated with.</returns>
    property Target: DNLabelTarget read get_Target;
    ///<summary>The value of the <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  when the label is reached through regular control flow (for example, is not jumped to).</summary>
    ///<returns>The Expression object representing the value of the <see cref="T:System.Linq.Expressions.LabelExpression" />
    ///  .</returns>
    property DefaultValue: DNExpression read get_DefaultValue;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNLabelExpression = class(TDNGenericImport<DNLabelExpressionClass, DNLabelExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNLambdaExpressionClass = interface(DNExpressionClass)
  ['{C1E95244-8A29-56DE-99C1-794A0DF61F66}']
  end;

  ///<summary>Describes a lambda expression. This captures a block of code that is similar to a .NET method body.</summary>
  [DNTypeName('System.Linq.Expressions.LambdaExpression')]
  DNLambdaExpression = interface(DNExpression)
  ['{251E60FA-00EA-3F31-A271-A36E70686597}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>;
    function get_Name: string;
    function get_Body: DNExpression;
    function get_ReturnType: DDN.mscorlib.DNType;
    function get_TailCall: Boolean;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Produces a delegate that represents the lambda expression.</summary>
    ///<returns>A <see cref="T:System.Delegate" />
    ///  that contains the compiled version of the lambda expression.</returns>
    function Compile: DDN.mscorlib.DNDelegate; overload;
    ///<summary>Produces a delegate that represents the lambda expression.</summary>
    ///  <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
    ///<returns>A delegate containing the compiled version of the lambda.</returns>
    function Compile(debugInfoGenerator: DNDebugInfoGenerator): DDN.mscorlib.DNDelegate; overload;
    ///<summary>Produces an interpreted or compiled delegate that represents the lambda expression. </summary>
    ///  <param name="preferInterpretation"><see langword="true" />
    ///  to indicate that the expression should be compiled to an interpreted form, if it's available; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>A delegate that represents the compiled lambda expression described by the <see cref="T:System.Linq.Expressions.LambdaExpression" />
    ///  object.</returns>
    function Compile(preferInterpretation: Boolean): DDN.mscorlib.DNDelegate; overload;
    ///<summary>Compiles the lambda into a method definition.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder" />
    ///  which will be used to hold the lambda's IL.</param>
    procedure CompileToMethod(method: DDN.mscorlib.DNMethodBuilder); overload;
    ///<summary>Compiles the lambda into a method definition and custom debug information.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder" />
    ///  which will be used to hold the lambda's IL.</param>
    ///  <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
    procedure CompileToMethod(method: DDN.mscorlib.DNMethodBuilder; debugInfoGenerator: DNDebugInfoGenerator); overload;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.LambdaExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the parameters of the lambda expression.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects that represent the parameters of the lambda expression.</returns>
    property Parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression> read get_Parameters;
    ///<summary>Gets the name of the lambda expression.</summary>
    ///<returns>The name of the lambda expression.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the body of the lambda expression.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the body of the lambda expression.</returns>
    property Body: DNExpression read get_Body;
    ///<summary>Gets the return type of the lambda expression.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the type of the lambda expression.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the value that indicates if the lambda expression will be compiled with the tail call optimization.</summary>
    ///<returns>True if the lambda expression will be compiled with the tail call optimization, otherwise false.</returns>
    property TailCall: Boolean read get_TailCall;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNLambdaExpression = class(TDNGenericImport<DNLambdaExpressionClass, DNLambdaExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNExpressionClass<TDelegate> = interface(DNLambdaExpressionClass)
  ['{F9EA9BFB-39AA-577E-B556-5B4369F5105F}']
  end;

  ///<summary>Represents a strongly typed lambda expression as a data structure in the form of an expression tree. This class cannot be inherited.</summary>
  ///<typeparam name="TDelegate">The type of the delegate that the <see cref="T:System.Linq.Expressions.Expression`1" />
  ///  represents.</typeparam>
  [DNTypeName('System.Linq.Expressions.Expression`1')]
  DNExpression<TDelegate> = interface(DNLambdaExpression)
  ['{8435ACBF-36AC-3C1A-AABD-0D2E1EE84D84}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>;
    function get_Name: string;
    function get_Body: DNExpression;
    function get_ReturnType: DDN.mscorlib.DNType;
    function get_TailCall: Boolean;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Compiles the lambda expression described by the expression tree into executable code and produces a delegate that represents the lambda expression.</summary>
    ///<returns>A delegate of type <paramref name="TDelegate" />
    ///  that represents the compiled lambda expression described by the <see cref="T:System.Linq.Expressions.Expression`1" />
    ///  .</returns>
    function Compile: TDelegate; overload;
    ///<summary>Produces a delegate that represents the lambda expression.</summary>
    ///  <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
    ///<returns>A delegate containing the compiled version of the lambda.</returns>
    function Compile(debugInfoGenerator: DNDebugInfoGenerator): TDelegate; overload;
    ///<summary>Compiles the lambda expression described by the expression tree into interpreted or compiled code and produces a delegate that represents the lambda expression.</summary>
    ///  <param name="preferInterpretation"><see langword="true" />
    ///  to indicate that the expression should be compiled to an interpreted form, if it is available; <see langword="false" />
    ///  otherwise.</param>
    ///<returns>A delegate that represents the compiled lambda expression described by the <see cref="T:System.Linq.Expressions.Expression`1" />
    ///  .</returns>
    function Compile(preferInterpretation: Boolean): TDelegate; overload;
    function Update(body: DNExpression; parameters: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNExpression<TDelegate>;
    ///<summary>Compiles the lambda into a method definition.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder" />
    ///  which will be used to hold the lambda's IL.</param>
    procedure CompileToMethod(method: DDN.mscorlib.DNMethodBuilder); overload;
    ///<summary>Compiles the lambda into a method definition and custom debug information.</summary>
    ///  <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder" />
    ///  which will be used to hold the lambda's IL.</param>
    ///  <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
    procedure CompileToMethod(method: DDN.mscorlib.DNMethodBuilder; debugInfoGenerator: DNDebugInfoGenerator); overload;
    function Reduce: DNExpression;
    function ReduceAndCheck: DNExpression;
    function ReduceExtensions: DNExpression;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.LambdaExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the parameters of the lambda expression.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.ParameterExpression" />
    ///  objects that represent the parameters of the lambda expression.</returns>
    property Parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression> read get_Parameters;
    ///<summary>Gets the name of the lambda expression.</summary>
    ///<returns>The name of the lambda expression.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the body of the lambda expression.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the body of the lambda expression.</returns>
    property Body: DNExpression read get_Body;
    ///<summary>Gets the return type of the lambda expression.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the type of the lambda expression.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the value that indicates if the lambda expression will be compiled with the tail call optimization.</summary>
    ///<returns>True if the lambda expression will be compiled with the tail call optimization, otherwise false.</returns>
    property TailCall: Boolean read get_TailCall;
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNExpression<TDelegate> = class(TDNGenericImport<DNExpressionClass<TDelegate>, DNExpression<TDelegate>>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNListInitExpressionClass = interface(DNExpressionClass)
  ['{BBA23C76-D195-5E65-BDF2-264DE6E09A2B}']
  end;

  ///<summary>Represents a constructor call that has a collection initializer.</summary>
  [DNTypeName('System.Linq.Expressions.ListInitExpression')]
  DNListInitExpression = interface(DNExpression)
  ['{5D5CAF46-34F9-3338-97C5-3FE54AA65CD0}']
  { getters & setters } 

    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_CanReduce: Boolean;
    function get_NewExpression: DNNewExpression;
    function get_Initializers: DDN.mscorlib.DNReadOnlyCollection<DNElementInit>;

  { methods } 

    ///<summary>Reduces the binary expression node to a simpler expression.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    function Update(newExpression: DNNewExpression; initializers: DDN.mscorlib.DNIEnumerable<DNElementInit>): DNListInitExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.ListInitExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
    ///<summary>Gets the expression that contains a call to the constructor of a collection type.</summary>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that represents the call to the constructor of a collection type.</returns>
    property NewExpression: DNNewExpression read get_NewExpression;
    ///<summary>Gets the element initializers that are used to initialize a collection.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  objects which represent the elements that are used to initialize the collection.</returns>
    property Initializers: DDN.mscorlib.DNReadOnlyCollection<DNElementInit> read get_Initializers;
  end;

  TDNListInitExpression = class(TDNGenericImport<DNListInitExpressionClass, DNListInitExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNLoopExpressionClass = interface(DNExpressionClass)
  ['{D480B008-237E-59A4-88F8-43FE54D6CEDE}']
  end;

  ///<summary>Represents an infinite loop. It can be exited with "break".</summary>
  [DNTypeName('System.Linq.Expressions.LoopExpression')]
  DNLoopExpression = interface(DNExpression)
  ['{84E5D5C4-651C-32E9-B4D9-6064187F72A4}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Body: DNExpression;
    function get_BreakLabel: DNLabelTarget;
    function get_ContinueLabel: DNLabelTarget;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="breakLabel">The <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" />
    ///  property of the result.</param>
    ///  <param name="continueLabel">The <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" />
    ///  property of the result.</param>
    ///  <param name="body">The <see cref="P:System.Linq.Expressions.LoopExpression.Body" />
    ///  property of the result.</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(breakLabel: DNLabelTarget; continueLabel: DNLabelTarget; body: DNExpression): DNLoopExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.LoopExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.Expression" />
    ///  that is the body of the loop.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that is the body of the loop.</returns>
    property Body: DNExpression read get_Body;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that is used by the loop body as a break statement target.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that is used by the loop body as a break statement target.</returns>
    property BreakLabel: DNLabelTarget read get_BreakLabel;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that is used by the loop body as a continue statement target.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  that is used by the loop body as a continue statement target.</returns>
    property ContinueLabel: DNLabelTarget read get_ContinueLabel;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNLoopExpression = class(TDNGenericImport<DNLoopExpressionClass, DNLoopExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMemberExpressionClass = interface(DNExpressionClass)
  ['{6DC74673-28D7-5581-8DBC-CDA822F33036}']
  end;

  ///<summary>Represents accessing a field or property.</summary>
  [DNTypeName('System.Linq.Expressions.MemberExpression')]
  DNMemberExpression = interface(DNExpression)
  ['{BA22043F-22FF-311E-9A9A-90D9C1E1A01B}']
  { getters & setters } 

    function get_Member: DDN.mscorlib.DNMemberInfo;
    function get_Expression: DNExpression;
    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="expression">The <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  property of the result.</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(expression: DNExpression): DNMemberExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the field or property to be accessed.</summary>
    ///<returns>The <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents the field or property to be accessed.</returns>
    property Member: DDN.mscorlib.DNMemberInfo read get_Member;
    ///<summary>Gets the containing object of the field or property.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the containing object of the field or property.</returns>
    property Expression: DNExpression read get_Expression;
    ///<summary>Returns the node type of this <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNMemberExpression = class(TDNGenericImport<DNMemberExpressionClass, DNMemberExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMemberInitExpressionClass = interface(DNExpressionClass)
  ['{002E3297-D8F2-5111-ABE8-224AE6ED1A01}']
  end;

  ///<summary>Represents calling a constructor and initializing one or more members of the new object.</summary>
  [DNTypeName('System.Linq.Expressions.MemberInitExpression')]
  DNMemberInitExpression = interface(DNExpression)
  ['{77EA09CB-545C-334F-B423-7D3B92250C76}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_CanReduce: Boolean;
    function get_NodeType: DNExpressionType;
    function get_NewExpression: DNNewExpression;
    function get_Bindings: DDN.mscorlib.DNReadOnlyCollection<DNMemberBinding>;

  { methods } 

    ///<summary>Reduces the <see cref="T:System.Linq.Expressions.MemberInitExpression" />
    ///  to a simpler expression. </summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    function Update(newExpression: DNNewExpression; bindings: DDN.mscorlib.DNIEnumerable<DNMemberBinding>): DNMemberInitExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
    ///<summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the expression that represents the constructor call.</summary>
    ///<returns>A <see cref="T:System.Linq.Expressions.NewExpression" />
    ///  that represents the constructor call.</returns>
    property NewExpression: DNNewExpression read get_NewExpression;
    ///<summary>Gets the bindings that describe how to initialize the members of the newly created object.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  objects which describe how to initialize the members.</returns>
    property Bindings: DDN.mscorlib.DNReadOnlyCollection<DNMemberBinding> read get_Bindings;
  end;

  TDNMemberInitExpression = class(TDNGenericImport<DNMemberInitExpressionClass, DNMemberInitExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMethodCallExpressionClass = interface(DNExpressionClass)
  ['{B0E34F8F-57D7-59EF-9CD6-8DEAA39D3E1A}']
  end;

  ///<summary>Represents a call to either static or an instance method.</summary>
  [DNTypeName('System.Linq.Expressions.MethodCallExpression')]
  DNMethodCallExpression = interface(DNExpression)
  ['{50FFD00B-1F28-3BC5-8B54-A6F8DEA75FF5}']
  { getters & setters } 

    function get_NodeType: DNExpressionType;
    function get_Type: DDN.mscorlib.DNType;
    function get_Method: DDN.mscorlib.DNMethodInfo;
    function get_Object: DNExpression;
    function get_Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(&object: DNExpression; arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNMethodCallExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets the <see cref="T:System.Reflection.MethodInfo" />
    ///  for the method to be called.</summary>
    ///<returns>The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the called method.</returns>
    property Method: DDN.mscorlib.DNMethodInfo read get_Method;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the instance for instance method calls or null for static method calls.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the receiving object of the method.</returns>
    property &Object: DNExpression read get_Object;
    ///<summary>Gets a collection of expressions that represent arguments of the called method.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects which represent the arguments to the called method.</returns>
    property Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Arguments;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNMethodCallExpression = class(TDNGenericImport<DNMethodCallExpressionClass, DNMethodCallExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNNewArrayExpressionClass = interface(DNExpressionClass)
  ['{3223B2DB-BDFD-58ED-89CF-5A72785C09DD}']
  end;

  ///<summary>Represents creating a new array and possibly initializing the elements of the new array.</summary>
  [DNTypeName('System.Linq.Expressions.NewArrayExpression')]
  DNNewArrayExpression = interface(DNExpression)
  ['{5791C72D-EF6C-3D6F-A82E-F399353297BA}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_Expressions: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_NodeType: DNExpressionType;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(expressions: DDN.mscorlib.DNIEnumerable<DNExpression>): DNNewArrayExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets the bounds of the array if the value of the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property is <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />
    ///  , or the values to initialize the elements of the new array if the value of the <see cref="P:System.Linq.Expressions.Expression.NodeType" />
    ///  property is <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects which represent either the bounds of the array or the initialization values.</returns>
    property Expressions: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Expressions;
    ///<summary>Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  values.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNNewArrayExpression = class(TDNGenericImport<DNNewArrayExpressionClass, DNNewArrayExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNNewExpressionClass = interface(DNExpressionClass)
  ['{42F1B4AA-93AD-529B-9822-0A0ECF826088}']
  end;

  ///<summary>Represents a constructor call.</summary>
  [DNTypeName('System.Linq.Expressions.NewExpression')]
  DNNewExpression = interface(DNExpression)
  ['{602E5164-1022-372F-86DC-A7F7252382F8}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Constructor: DDN.mscorlib.DNConstructorInfo;
    function get_Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_Members: DDN.mscorlib.DNReadOnlyCollection<DDN.mscorlib.DNMemberInfo>;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(arguments: DDN.mscorlib.DNIEnumerable<DNExpression>): DNNewExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.NewExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the called constructor.</summary>
    ///<returns>The <see cref="T:System.Reflection.ConstructorInfo" />
    ///  that represents the called constructor.</returns>
    property &Constructor: DDN.mscorlib.DNConstructorInfo read get_Constructor;
    ///<summary>Gets the arguments to the constructor.</summary>
    ///<returns>A collection of <see cref="T:System.Linq.Expressions.Expression" />
    ///  objects that represent the arguments to the constructor.</returns>
    property Arguments: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_Arguments;
    ///<summary>Gets the members that can retrieve the values of the fields that were initialized with constructor arguments.</summary>
    ///<returns>A collection of <see cref="T:System.Reflection.MemberInfo" />
    ///  objects that represent the members that can retrieve the values of the fields that were initialized with constructor arguments.</returns>
    property Members: DDN.mscorlib.DNReadOnlyCollection<DDN.mscorlib.DNMemberInfo> read get_Members;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNNewExpression = class(TDNGenericImport<DNNewExpressionClass, DNNewExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNParameterExpressionClass = interface(DNExpressionClass)
  ['{89316903-B38F-5472-8B91-B49FC3ABA168}']
  end;

  ///<summary>Represents a named parameter expression.</summary>
  [DNTypeName('System.Linq.Expressions.ParameterExpression')]
  DNParameterExpression = interface(DNExpression)
  ['{7CA3F201-4497-3CA0-9C2A-BBA28AB7AF84}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Name: string;
    function get_IsByRef: Boolean;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.ParameterExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the name of the parameter or variable.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the name of the parameter.</returns>
    property Name: string read get_Name;
    ///<summary>Indicates that this ParameterExpression is to be treated as a <see langword="ByRef" />
    ///  parameter.</summary>
    ///<returns>True if this ParameterExpression is a <see langword="ByRef" />
    ///  parameter, otherwise false.</returns>
    property IsByRef: Boolean read get_IsByRef;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNParameterExpression = class(TDNGenericImport<DNParameterExpressionClass, DNParameterExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNRuntimeVariablesExpressionClass = interface(DNExpressionClass)
  ['{EE17A3C5-4D8E-5744-B546-BDA8839E78B7}']
  end;

  ///<summary>An expression that provides runtime read/write permission for variables.</summary>
  [DNTypeName('System.Linq.Expressions.RuntimeVariablesExpression')]
  DNRuntimeVariablesExpression = interface(DNExpression)
  ['{58A293FE-6B80-3E52-955D-611234F1FF8B}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Variables: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(variables: DDN.mscorlib.DNIEnumerable<DNParameterExpression>): DNRuntimeVariablesExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>The variables or parameters to which to provide runtime access.</summary>
    ///<returns>The read-only collection containing parameters that will be provided the runtime access.</returns>
    property Variables: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression> read get_Variables;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNRuntimeVariablesExpression = class(TDNGenericImport<DNRuntimeVariablesExpressionClass, DNRuntimeVariablesExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNSwitchExpressionClass = interface(DNExpressionClass)
  ['{73DBC495-6915-5348-B1D5-4D33F64D8396}']
  end;

  ///<summary>Represents a control expression that handles multiple selections by passing control to <see cref="T:System.Linq.Expressions.SwitchCase" />
  ///  .</summary>
  [DNTypeName('System.Linq.Expressions.SwitchExpression')]
  DNSwitchExpression = interface(DNExpression)
  ['{3D71D2B7-69F3-31EF-A771-730739C63CC3}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_SwitchValue: DNExpression;
    function get_Cases: DDN.mscorlib.DNReadOnlyCollection<DNSwitchCase>;
    function get_DefaultBody: DNExpression;
    function get_Comparison: DDN.mscorlib.DNMethodInfo;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(switchValue: DNExpression; cases: DDN.mscorlib.DNIEnumerable<DNSwitchCase>; defaultBody: DNExpression): DNSwitchExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.SwitchExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the test for the switch.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object representing the test for the switch.</returns>
    property SwitchValue: DNExpression read get_SwitchValue;
    ///<summary>Gets the collection of <see cref="T:System.Linq.Expressions.SwitchCase" />
    ///  objects for the switch.</summary>
    ///<returns>The collection of <see cref="T:System.Linq.Expressions.SwitchCase" />
    ///  objects.</returns>
    property Cases: DDN.mscorlib.DNReadOnlyCollection<DNSwitchCase> read get_Cases;
    ///<summary>Gets the test for the switch.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object representing the test for the switch.</returns>
    property DefaultBody: DNExpression read get_DefaultBody;
    ///<summary>Gets the equality comparison method, if any.</summary>
    ///<returns>The <see cref="T:System.Reflection.MethodInfo" />
    ///  object representing the equality comparison method.</returns>
    property Comparison: DDN.mscorlib.DNMethodInfo read get_Comparison;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNSwitchExpression = class(TDNGenericImport<DNSwitchExpressionClass, DNSwitchExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNTryExpressionClass = interface(DNExpressionClass)
  ['{1AA017DE-F994-5479-9662-FC4823BBF85A}']
  end;

  ///<summary>Represents a try/catch/finally/fault block.</summary>
  [DNTypeName('System.Linq.Expressions.TryExpression')]
  DNTryExpression = interface(DNExpression)
  ['{65F6F267-F64F-3B95-A17D-658ACBE7ED5B}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Body: DNExpression;
    function get_Handlers: DDN.mscorlib.DNReadOnlyCollection<DNCatchBlock>;
    function get_Finally: DNExpression;
    function get_Fault: DNExpression;
    function get_CanReduce: Boolean;

  { methods } 

    function Update(body: DNExpression; handlers: DDN.mscorlib.DNIEnumerable<DNCatchBlock>; &finally: DNExpression; fault: DNExpression): DNTryExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.TryExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the body of the try block.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the body of the try block.</returns>
    property Body: DNExpression read get_Body;
    ///<summary>Gets the collection of <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  expressions associated with the try block.</summary>
    ///<returns>The collection of <see cref="T:System.Linq.Expressions.CatchBlock" />
    ///  expressions associated with the try block.</returns>
    property Handlers: DDN.mscorlib.DNReadOnlyCollection<DNCatchBlock> read get_Handlers;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the finally block.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the finally block.</returns>
    property &Finally: DNExpression read get_Finally;
    ///<summary>Gets the <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the fault block.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  representing the fault block.</returns>
    property Fault: DNExpression read get_Fault;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNTryExpression = class(TDNGenericImport<DNTryExpressionClass, DNTryExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNTypeBinaryExpressionClass = interface(DNExpressionClass)
  ['{8174D038-D81C-5279-B0A6-515A5D091C5A}']
  end;

  ///<summary>Represents an operation between an expression and a type.</summary>
  [DNTypeName('System.Linq.Expressions.TypeBinaryExpression')]
  DNTypeBinaryExpression = interface(DNExpression)
  ['{F9FAAC1B-79BA-363C-A5BF-5657C5F68601}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Expression: DNExpression;
    function get_TypeOperand: DDN.mscorlib.DNType;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="expression">The <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />
    ///  property of the result.</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(expression: DNExpression): DNTypeBinaryExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" />
    ///  when overriding this method.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  of the expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the expression operand of a type test operation.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the expression operand of a type test operation.</returns>
    property Expression: DNExpression read get_Expression;
    ///<summary>Gets the type operand of a type test operation.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  that represents the type operand of a type test operation.</returns>
    property TypeOperand: DDN.mscorlib.DNType read get_TypeOperand;
    ///<summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
    ///<returns>True if the node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNTypeBinaryExpression = class(TDNGenericImport<DNTypeBinaryExpressionClass, DNTypeBinaryExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNUnaryExpressionClass = interface(DNExpressionClass)
  ['{0328AF99-A8C6-5FD9-B705-1CA8E4AD4D1E}']
  end;

  ///<summary>Represents an expression that has a unary operator.</summary>
  [DNTypeName('System.Linq.Expressions.UnaryExpression')]
  DNUnaryExpression = interface(DNExpression)
  ['{EDACA99F-7DF8-3000-9123-3B978FDD6840}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_NodeType: DNExpressionType;
    function get_Operand: DNExpression;
    function get_Method: DDN.mscorlib.DNMethodInfo;
    function get_IsLifted: Boolean;
    function get_IsLiftedToNull: Boolean;
    function get_CanReduce: Boolean;

  { methods } 

    ///<summary>Reduces the expression node to a simpler expression. </summary>
    ///<returns>The reduced expression.</returns>
    function Reduce: DNExpression;
    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="operand">The <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />
    ///  property of the result.</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(operand: DNExpression): DNUnaryExpression;
    ///<summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceAndCheck: DNExpression;
    ///<summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
    ///<returns>The reduced expression.</returns>
    function ReduceExtensions: DNExpression;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" />
    ///  represents.</summary>
    ///<returns>The <see cref="P:System.Linq.Expressions.UnaryExpression.Type" />
    ///  that represents the static type of the expression.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents this expression.</returns>
    property NodeType: DNExpressionType read get_NodeType;
    ///<summary>Gets the operand of the unary operation.</summary>
    ///<returns>An <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the operand of the unary operation.</returns>
    property Operand: DNExpression read get_Operand;
    ///<summary>Gets the implementing method for the unary operation.</summary>
    ///<returns>The <see cref="T:System.Reflection.MethodInfo" />
    ///  that represents the implementing method.</returns>
    property Method: DDN.mscorlib.DNMethodInfo read get_Method;
    ///<summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator.</summary>
    ///<returns><see langword="true" />
    ///  if the node represents a lifted call; otherwise, <see langword="false" />
    ///  .</returns>
    property IsLifted: Boolean read get_IsLifted;
    ///<summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.</summary>
    ///<returns><see langword="true" />
    ///  if the operator's return type is lifted to a nullable type; otherwise, <see langword="false" />
    ///  .</returns>
    property IsLiftedToNull: Boolean read get_IsLiftedToNull;
    ///<summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
    ///<returns>True if a node can be reduced, otherwise false.</returns>
    property CanReduce: Boolean read get_CanReduce;
  end;

  TDNUnaryExpression = class(TDNGenericImport<DNUnaryExpressionClass, DNUnaryExpression>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNExpressionVisitorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{A5A87F54-0024-5D85-8578-23FC429BEB96}']
  end;

  ///<summary>Represents a visitor or rewriter for expression trees.</summary>
  [DNTypeName('System.Linq.Expressions.ExpressionVisitor')]
  DNExpressionVisitor = interface(DDN.mscorlib.DNObject)
  ['{C5F1042A-D382-3360-BEC4-C723A62F606B}']
  { methods } 

    function Visit(nodes: DDN.mscorlib.DNReadOnlyCollection<DNExpression>): DDN.mscorlib.DNReadOnlyCollection<DNExpression>; overload;
    ///<summary>Dispatches the expression to one of the more specialized visit methods in this class.</summary>
    ///  <param name="node">The expression to visit.</param>
    ///<returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
    function Visit(node: DNExpression): DNExpression; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNExpressionVisitor = class(TDNGenericImport<DNExpressionVisitorClass, DNExpressionVisitor>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNDynamicExpressionVisitorClass = interface(DNExpressionVisitorClass)
  ['{20884C4D-E4DE-5D33-A3F1-343BA050C0EF}']
  end;

  ///<summary>Represents a visitor or rewriter for dynamic expression trees.</summary>
  [DNTypeName('System.Linq.Expressions.DynamicExpressionVisitor')]
  DNDynamicExpressionVisitor = interface(DNExpressionVisitor)
  ['{BAC48429-83CD-37B8-9921-2E962B6E6169}']
  { methods } 

    function Visit(nodes: DDN.mscorlib.DNReadOnlyCollection<DNExpression>): DDN.mscorlib.DNReadOnlyCollection<DNExpression>; overload;
    ///<summary>Dispatches the expression to one of the more specialized visit methods in this class.</summary>
    ///  <param name="node">The expression to visit.</param>
    ///<returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
    function Visit(node: DNExpression): DNExpression; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDynamicExpressionVisitor = class(TDNGenericImport<DNDynamicExpressionVisitorClass, DNDynamicExpressionVisitor>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNLabelTargetClass = interface(DDN.mscorlib.DNObjectClass)
  ['{185F6F89-FEB4-58D0-958D-1B47C80E62A3}']
  end;

  ///<summary>Used to represent the target of a <see cref="T:System.Linq.Expressions.GotoExpression" />
  ///  .</summary>
  [DNTypeName('System.Linq.Expressions.LabelTarget')]
  DNLabelTarget = interface(DDN.mscorlib.DNObject)
  ['{17DB098C-D299-32FE-AF65-6AE6EB0C3510}']
  { getters & setters } 

    function get_Name: string;
    function get_Type: DDN.mscorlib.DNType;

  { methods } 

    ///<summary>Returns a <see cref="T:System.String" />
    ///  that represents the current <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that represents the current <see cref="T:System.Object" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the name of the label.</summary>
    ///<returns>The name of the label.</returns>
    property Name: string read get_Name;
    ///<summary>The type of value that is passed when jumping to the label (or <see cref="T:System.Void" />
    ///  if no value should be passed).</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the type of the value that is passed when jumping to the label or <see cref="T:System.Void" />
    ///  if no value should be passed</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
  end;

  TDNLabelTarget = class(TDNGenericImport<DNLabelTargetClass, DNLabelTarget>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMemberBindingClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6EFAAC2D-347D-58D0-BF93-4D0644A4C4F4}']
  end;

  ///<summary>Provides the base class from which the classes that represent bindings that are used to initialize members of a newly created object derive.</summary>
  [DNTypeName('System.Linq.Expressions.MemberBinding')]
  DNMemberBinding = interface(DDN.mscorlib.DNObject)
  ['{5F122447-E06A-345F-BBD6-1327C454854E}']
  { getters & setters } 

    function get_BindingType: DNMemberBindingType;
    function get_Member: DDN.mscorlib.DNMemberInfo;

  { methods } 

    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the type of binding that is represented.</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.MemberBindingType" />
    ///  values.</returns>
    property BindingType: DNMemberBindingType read get_BindingType;
    ///<summary>Gets the field or property to be initialized.</summary>
    ///<returns>The <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents the field or property to be initialized.</returns>
    property Member: DDN.mscorlib.DNMemberInfo read get_Member;
  end;

  TDNMemberBinding = class(TDNGenericImport<DNMemberBindingClass, DNMemberBinding>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMemberAssignmentClass = interface(DNMemberBindingClass)
  ['{CF93536B-5AFA-598C-87D8-8698D7DF547C}']
  end;

  ///<summary>Represents assignment operation for a field or property of an object.</summary>
  [DNTypeName('System.Linq.Expressions.MemberAssignment')]
  DNMemberAssignment = interface(DNMemberBinding)
  ['{10882F5E-3D52-3B00-8E8B-31E352064C66}']
  { getters & setters } 

    function get_Expression: DNExpression;
    function get_BindingType: DNMemberBindingType;
    function get_Member: DDN.mscorlib.DNMemberInfo;

  { methods } 

    ///<summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
    ///  <param name="expression">The <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" />
    ///  property of the result.</param>
    ///<returns>This expression if no children are changed or an expression with the updated children.</returns>
    function Update(expression: DNExpression): DNMemberAssignment;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the expression to assign to the field or property.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  that represents the value to assign to the field or property.</returns>
    property Expression: DNExpression read get_Expression;
    ///<summary>Gets the type of binding that is represented.</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.MemberBindingType" />
    ///  values.</returns>
    property BindingType: DNMemberBindingType read get_BindingType;
    ///<summary>Gets the field or property to be initialized.</summary>
    ///<returns>The <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents the field or property to be initialized.</returns>
    property Member: DDN.mscorlib.DNMemberInfo read get_Member;
  end;

  TDNMemberAssignment = class(TDNGenericImport<DNMemberAssignmentClass, DNMemberAssignment>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMemberListBindingClass = interface(DNMemberBindingClass)
  ['{3F835938-4A72-555C-9032-2291B5EF8E60}']
  end;

  ///<summary>Represents initializing the elements of a collection member of a newly created object.</summary>
  [DNTypeName('System.Linq.Expressions.MemberListBinding')]
  DNMemberListBinding = interface(DNMemberBinding)
  ['{1812EE04-B6FF-3F2B-BF0F-B2DE2CAF47A8}']
  { getters & setters } 

    function get_Initializers: DDN.mscorlib.DNReadOnlyCollection<DNElementInit>;
    function get_BindingType: DNMemberBindingType;
    function get_Member: DDN.mscorlib.DNMemberInfo;

  { methods } 

    function Update(initializers: DDN.mscorlib.DNIEnumerable<DNElementInit>): DNMemberListBinding;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the element initializers for initializing a collection member of a newly created object.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.ElementInit" />
    ///  objects to initialize a collection member with.</returns>
    property Initializers: DDN.mscorlib.DNReadOnlyCollection<DNElementInit> read get_Initializers;
    ///<summary>Gets the type of binding that is represented.</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.MemberBindingType" />
    ///  values.</returns>
    property BindingType: DNMemberBindingType read get_BindingType;
    ///<summary>Gets the field or property to be initialized.</summary>
    ///<returns>The <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents the field or property to be initialized.</returns>
    property Member: DDN.mscorlib.DNMemberInfo read get_Member;
  end;

  TDNMemberListBinding = class(TDNGenericImport<DNMemberListBindingClass, DNMemberListBinding>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNMemberMemberBindingClass = interface(DNMemberBindingClass)
  ['{5BFE47A0-4ED7-50BC-9161-F7D7F3CF7B51}']
  end;

  ///<summary>Represents initializing members of a member of a newly created object.</summary>
  [DNTypeName('System.Linq.Expressions.MemberMemberBinding')]
  DNMemberMemberBinding = interface(DNMemberBinding)
  ['{6792C556-7187-323F-B950-88AA750B05E9}']
  { getters & setters } 

    function get_Bindings: DDN.mscorlib.DNReadOnlyCollection<DNMemberBinding>;
    function get_BindingType: DNMemberBindingType;
    function get_Member: DDN.mscorlib.DNMemberInfo;

  { methods } 

    function Update(bindings: DDN.mscorlib.DNIEnumerable<DNMemberBinding>): DNMemberMemberBinding;
    ///<summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</summary>
    ///<returns>A textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  .</returns>
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the bindings that describe how to initialize the members of a member.</summary>
    ///<returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  of <see cref="T:System.Linq.Expressions.MemberBinding" />
    ///  objects that describe how to initialize the members of the member.</returns>
    property Bindings: DDN.mscorlib.DNReadOnlyCollection<DNMemberBinding> read get_Bindings;
    ///<summary>Gets the type of binding that is represented.</summary>
    ///<returns>One of the <see cref="T:System.Linq.Expressions.MemberBindingType" />
    ///  values.</returns>
    property BindingType: DNMemberBindingType read get_BindingType;
    ///<summary>Gets the field or property to be initialized.</summary>
    ///<returns>The <see cref="T:System.Reflection.MemberInfo" />
    ///  that represents the field or property to be initialized.</returns>
    property Member: DDN.mscorlib.DNMemberInfo read get_Member;
  end;

  TDNMemberMemberBinding = class(TDNGenericImport<DNMemberMemberBindingClass, DNMemberMemberBinding>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNSwitchCaseClass = interface(DDN.mscorlib.DNObjectClass)
  ['{2F6A2E78-1956-5E0F-B21D-B03B28C0872C}']
  end;

  ///<summary>Represents one case of a <see cref="T:System.Linq.Expressions.SwitchExpression" />
  ///  .</summary>
  [DNTypeName('System.Linq.Expressions.SwitchCase')]
  DNSwitchCase = interface(DDN.mscorlib.DNObject)
  ['{2FDBBFCB-753F-31B3-B6CA-30D8C8745E35}']
  { getters & setters } 

    function get_TestValues: DDN.mscorlib.DNReadOnlyCollection<DNExpression>;
    function get_Body: DNExpression;

  { methods } 

    ///<summary>Returns a <see cref="T:System.String" />
    ///  that represents the current <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that represents the current <see cref="T:System.Object" />
    ///  .</returns>
    function ToString: string;
    function Update(testValues: DDN.mscorlib.DNIEnumerable<DNExpression>; body: DNExpression): DNSwitchCase;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the values of this case. This case is selected for execution when the <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" />
    ///  matches any of these values.</summary>
    ///<returns>The read-only collection of the values for this case block.</returns>
    property TestValues: DDN.mscorlib.DNReadOnlyCollection<DNExpression> read get_TestValues;
    ///<summary>Gets the body of this case.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.Expression" />
    ///  object that represents the body of the case block.</returns>
    property Body: DNExpression read get_Body;
  end;

  TDNSwitchCase = class(TDNGenericImport<DNSwitchCaseClass, DNSwitchCase>) end;

  //-------------namespace: System.Linq.Expressions----------------
  DNSymbolDocumentInfoClass = interface(DDN.mscorlib.DNObjectClass)
  ['{57BCF7D1-74BE-577F-BC23-920583FC051E}']
  end;

  ///<summary>Stores information necessary to emit debugging symbol information for a source file, in particular the file name and unique language identifier.</summary>
  [DNTypeName('System.Linq.Expressions.SymbolDocumentInfo')]
  DNSymbolDocumentInfo = interface(DDN.mscorlib.DNObject)
  ['{46D2036A-E6E7-39D0-BB7E-BBE171F9D132}']
  { getters & setters } 

    function get_FileName: string;
    function get_Language: DDN.mscorlib.DNGuid;
    function get_LanguageVendor: DDN.mscorlib.DNGuid;
    function get_DocumentType: DDN.mscorlib.DNGuid;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The source file name.</summary>
    ///<returns>The string representing the source file name.</returns>
    property FileName: string read get_FileName;
    ///<summary>Returns the language's unique identifier, if any.</summary>
    ///<returns>The language's unique identifier</returns>
    property Language: DDN.mscorlib.DNGuid read get_Language;
    ///<summary>Returns the language vendor's unique identifier, if any.</summary>
    ///<returns>The language vendor's unique identifier.</returns>
    property LanguageVendor: DDN.mscorlib.DNGuid read get_LanguageVendor;
    ///<summary>Returns the document type's unique identifier, if any. Defaults to the GUID for a text file.</summary>
    ///<returns>The document type's unique identifier.</returns>
    property DocumentType: DDN.mscorlib.DNGuid read get_DocumentType;
  end;

  TDNSymbolDocumentInfo = class(TDNGenericImport<DNSymbolDocumentInfoClass, DNSymbolDocumentInfo>) end;

  //-------------namespace: System.Linq----------------
  DNLookupClass<TKey, TElement> = interface(DNObjectClass)
  ['{9B3CD122-D1BD-5444-9134-E55394BF1FF0}']
  end;

  ///<summary>Represents a collection of keys each mapped to one or more values.</summary>
  ///<typeparam name="TKey">The type of the keys in the <see cref="T:System.Linq.Lookup`2" />
  ///  .</typeparam><typeparam name="TElement">The type of the elements of each <see cref="T:System.Collections.Generic.IEnumerable`1" />
  ///  value in the <see cref="T:System.Linq.Lookup`2" />
  ///  .</typeparam>
  [DNTypeName('System.Linq.Lookup`2')]
  DNLookup<TKey, TElement> = interface(DDN.mscorlib.DNIEnumerable<DNIGrouping<TKey, TElement>>)
  ['{92515A0A-5D25-32D0-BDEE-1A3C54AD88C5}']
  { getters & setters } 

    function get_Count: Int32;

  { methods } 

    function &Contains(key: TKey): Boolean;
    ///<summary>Returns a generic enumerator that iterates through the <see cref="T:System.Linq.Lookup`2" />
    ///  .</summary>
    ///<returns>An enumerator for the <see cref="T:System.Linq.Lookup`2" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator<DNIGrouping<TKey, TElement>>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of key/value collection pairs in the <see cref="T:System.Linq.Lookup`2" />
    ///  .</summary>
    ///<returns>The number of key/value collection pairs in the <see cref="T:System.Linq.Lookup`2" />
    ///  .</returns>
    property Count: Int32 read get_Count;
  end;

  TDNLookup<TKey, TElement> = class(TDNGenericImport<DNLookupClass<TKey, TElement>, DNLookup<TKey, TElement>>) end;

  //-------------namespace: System.Linq----------------
  DNParallelEnumerableClass = interface(DDN.mscorlib.DNObjectClass)
  ['{8DCBB390-57FB-56E7-92FC-B5316251650E}']
  { static methods } 

    ///<summary>Enables treatment of a data source as if it were ordered, overriding the default of unordered. AsOrdered may only be invoked on non-generic sequences returned by AsParallel, ParallelEnumerable.Range, and ParallelEnumerable.Repeat.</summary>
    ///  <param name="source">The input sequence.</param>
    ///<returns>The source sequence which will maintain the original ordering in the subsequent query operators.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="source" />
    ///  is a null reference (Nothing in Visual Basic).</exception><exception cref="T:System.InvalidOperationException">thrown if <paramref name="source" />
    ///  contains no elements-or- if AsOrdered is called midway through a query. It is allowed to be called immediately after <see cref="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />
    ///  , <see cref="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" />
    ///  or <see cref="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />
    ///  .</exception>
    {class} function AsOrdered(source: DNParallelQuery): DNParallelQuery; overload;
    ///<summary>Enables parallelization of a query.</summary>
    ///  <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" />
    ///  to convert to a <see cref="T:System.Linq.ParallelQuery" />
    ///  .</param>
    ///<returns>The source as a ParallelQuery to bind to ParallelEnumerable extension methods.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="source" />
    ///  is a null reference (Nothing in Visual Basic).</exception>
    {class} function AsParallel(source: DDN.mscorlib.DNIEnumerable): DNParallelQuery; overload;
    ///<summary>Generates a parallel sequence of integral numbers within a specified range.</summary>
    ///  <param name="start">The value of the first integer in the sequence.</param>
    ///  <param name="count">The number of sequential integers to generate.</param>
    ///<returns>An IEnumerable&lt;Int32&gt; in C# or IEnumerable(Of Int32) in Visual Basic that contains a range of sequential integral numbers.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />
    ///  is less than 0 -or- <paramref name="start" />
    ///  + <paramref name="count" />
    ///  - 1 is larger than <see cref="F:System.Int32.MaxValue" />
    ///  .</exception>
    {class} function Range(start: Int32; count: Int32): DNParallelQuery<Int32>;
    {class} function Sum(source: DNParallelQuery<Int32>): Int32; overload;
    {class} function Sum(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Sum(source: DNParallelQuery<Int64>): Int64; overload;
    {class} function Sum(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Sum(source: DNParallelQuery<Single>): Single; overload;
    {class} function Sum(source: DNParallelQuery<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Sum(source: DNParallelQuery<Double>): Double; overload;
    {class} function Sum(source: DNParallelQuery<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Sum(source: DNParallelQuery<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Sum(source: DNParallelQuery<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Min(source: DNParallelQuery<Int32>): Int32; overload;
    {class} function Min(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Min(source: DNParallelQuery<Int64>): Int64; overload;
    {class} function Min(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Min(source: DNParallelQuery<Single>): Single; overload;
    {class} function Min(source: DNParallelQuery<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Min(source: DNParallelQuery<Double>): Double; overload;
    {class} function Min(source: DNParallelQuery<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Min(source: DNParallelQuery<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Min(source: DNParallelQuery<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Max(source: DNParallelQuery<Int32>): Int32; overload;
    {class} function Max(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Max(source: DNParallelQuery<Int64>): Int64; overload;
    {class} function Max(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Max(source: DNParallelQuery<Single>): Single; overload;
    {class} function Max(source: DNParallelQuery<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Max(source: DNParallelQuery<Double>): Double; overload;
    {class} function Max(source: DNParallelQuery<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Max(source: DNParallelQuery<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Max(source: DNParallelQuery<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Average(source: DNParallelQuery<Int32>): Double; overload;
    {class} function Average(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DNParallelQuery<Int64>): Double; overload;
    {class} function Average(source: DNParallelQuery<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DNParallelQuery<Single>): Single; overload;
    {class} function Average(source: DNParallelQuery<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Average(source: DNParallelQuery<Double>): Double; overload;
    {class} function Average(source: DNParallelQuery<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DNParallelQuery<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Average(source: DNParallelQuery<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;

  end;

  ///<summary>Provides a set of methods for querying objects that implement ParallelQuery{TSource}. This is the parallel equivalent of <see cref="T:System.Linq.Enumerable" />
  ///  .</summary>
  [DNTypeName('System.Linq.ParallelEnumerable')]
  DNParallelEnumerable = interface(DDN.mscorlib.DNObject)
  ['{5A78107D-422E-3780-A055-CCB4E03850D0}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNParallelEnumerable = class(TDNGenericImport<DNParallelEnumerableClass, DNParallelEnumerable>) end;

  //-------------namespace: System.Linq----------------
  DNParallelQueryClass = interface(DNObjectClass)
  ['{A0828839-51DB-5957-98EC-EC9D504C66B9}']
  end;

  ///<summary>Represents a parallel sequence.</summary>
  [DNTypeName('System.Linq.ParallelQuery')]
  DNParallelQuery = interface(DDN.mscorlib.DNIEnumerable)
  ['{745887D1-9E17-3C0D-BEA2-E2A830C099D5}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNParallelQuery = class(TDNGenericImport<DNParallelQueryClass, DNParallelQuery>) end;

  //-------------namespace: System.Linq----------------
  DNParallelQueryClass<TSource> = interface(DNParallelQueryClass)
  ['{7EB052C7-DE84-575E-8ABC-0F0B6D9640FF}']
  end;

  ///<summary>Represents a parallel sequence.</summary>
  ///<typeparam name="TSource">The type of element in the source sequence.</typeparam>
  [DNTypeName('System.Linq.ParallelQuery`1')]
  DNParallelQuery<TSource> = interface(DNParallelQuery)
  ['{397C57EF-39C2-347E-BBFF-1614CD664EB4}']
  { methods } 

    ///<summary>Returns an enumerator that iterates through the sequence.</summary>
    ///<returns>An enumerator that iterates through the sequence.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator<TSource>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNParallelQuery<TSource> = class(TDNGenericImport<DNParallelQueryClass<TSource>, DNParallelQuery<TSource>>) end;

  //-------------namespace: System.Linq----------------
  DNOrderedParallelQueryClass<TSource> = interface(DNParallelQueryClass<TSource>)
  ['{4FD25A8E-C552-5C6F-ADAC-2C7E50CE7205}']
  end;

  ///<summary>Represents a sorted, parallel sequence.</summary>
  ///<typeparam name="TSource">The type of elements in the source collection.</typeparam>
  [DNTypeName('System.Linq.OrderedParallelQuery`1')]
  DNOrderedParallelQuery<TSource> = interface(DNParallelQuery<TSource>)
  ['{F20FAEEE-F8EE-33FD-912C-E445D7231FF5}']
  { methods } 

    ///<summary>Returns an enumerator that iterates through the sequence.</summary>
    ///<returns>An enumerator that iterates through the sequence.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator<TSource>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNOrderedParallelQuery<TSource> = class(TDNGenericImport<DNOrderedParallelQueryClass<TSource>, DNOrderedParallelQuery<TSource>>) end;

  //-------------namespace: System.Linq----------------
  DNQueryableClass = interface(DDN.mscorlib.DNObjectClass)
  ['{FDBC2164-3C3A-590B-B283-30B4B8E5FDF0}']
  { static methods } 

    ///<summary>Converts an <see cref="T:System.Collections.IEnumerable" />
    ///  to an <see cref="T:System.Linq.IQueryable" />
    ///  .</summary>
    ///  <param name="source">A sequence to convert.</param>
    ///<returns>An <see cref="T:System.Linq.IQueryable" />
    ///  that represents the input sequence.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="source" />
    ///  does not implement <see cref="T:System.Collections.Generic.IEnumerable`1" />
    ///  for some <paramref name="T" />
    ///  .</exception><exception cref="T:System.ArgumentNullException"><paramref name="source" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function AsQueryable(source: DDN.mscorlib.DNIEnumerable): DNIQueryable; overload;
    {class} function Sum(source: DNIQueryable<Int32>): Int32; overload;
    {class} function Sum(source: DNIQueryable<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Int32>; overload;
    {class} function Sum(source: DNIQueryable<Int64>): Int64; overload;
    {class} function Sum(source: DNIQueryable<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Int64>; overload;
    {class} function Sum(source: DNIQueryable<Single>): Single; overload;
    {class} function Sum(source: DNIQueryable<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Sum(source: DNIQueryable<Double>): Double; overload;
    {class} function Sum(source: DNIQueryable<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Sum(source: DNIQueryable<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Sum(source: DNIQueryable<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;
    {class} function Average(source: DNIQueryable<Int32>): Double; overload;
    {class} function Average(source: DNIQueryable<DDN.mscorlib.DNNullable<Int32>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DNIQueryable<Int64>): Double; overload;
    {class} function Average(source: DNIQueryable<DDN.mscorlib.DNNullable<Int64>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DNIQueryable<Single>): Single; overload;
    {class} function Average(source: DNIQueryable<DDN.mscorlib.DNNullable<Single>>): DDN.mscorlib.DNNullable<Single>; overload;
    {class} function Average(source: DNIQueryable<Double>): Double; overload;
    {class} function Average(source: DNIQueryable<DDN.mscorlib.DNNullable<Double>>): DDN.mscorlib.DNNullable<Double>; overload;
    {class} function Average(source: DNIQueryable<DDN.mscorlib.DNDecimal>): DDN.mscorlib.DNDecimal; overload;
    {class} function Average(source: DNIQueryable<DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>>): DDN.mscorlib.DNNullable<DDN.mscorlib.DNDecimal>; overload;

  end;

  ///<summary>Provides a set of <see langword="static" />
  ///  (<see langword="Shared" />
  ///  in Visual Basic) methods for querying data structures that implement <see cref="T:System.Linq.IQueryable`1" />
  ///  .</summary>
  [DNTypeName('System.Linq.Queryable')]
  DNQueryable = interface(DDN.mscorlib.DNObject)
  ['{B4018634-9CCE-32E1-946C-15F6FDEFAE24}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNQueryable = class(TDNGenericImport<DNQueryableClass, DNQueryable>) end;

  //-------------namespace: System.Diagnostics.Eventing----------------
  DNEventProviderTraceListenerClass = interface(DNObjectClass)
  ['{53D8952C-3120-5496-8E38-C7E6259DDE5D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProviderTraceListener" />
    ///  class using the specified provider identifier.</summary>
    ///  <param name="providerId">A unique string <see cref="T:System.Guid" />
    ///  that identifies the provider.</param>
    {class} function init(providerId: string): DNEventProviderTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProviderTraceListener" />
    ///  class using the specified provider identifier and name of the listener.</summary>
    ///  <param name="providerId">A unique string <see cref="T:System.Guid" />
    ///  that identifies the provider.</param>
    ///  <param name="name">Name of the listener.</param>
    {class} function init(providerId: string; name: string): DNEventProviderTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProviderTraceListener" />
    ///  class using the specified provider identifier, name of the listener, and delimiter.</summary>
    ///  <param name="providerId">A unique string <see cref="T:System.Guid" />
    ///  that identifies the provider.</param>
    ///  <param name="name">Name of the listener.</param>
    ///  <param name="delimiter">Delimiter used to delimit the event data. (For more details, see the <see cref="P:System.Diagnostics.Eventing.EventProviderTraceListener.Delimiter" />
    ///  property.)</param>
    {class} function init(providerId: string; name: string; delimiter: string): DNEventProviderTraceListener; overload;

  end;

  ///<summary>A listener for <see cref="T:System.Diagnostics.TraceSource" />
  ///  that writes events to the ETW subsytem. </summary>
  [DNTypeName('System.Diagnostics.Eventing.EventProviderTraceListener')]
  DNEventProviderTraceListener = interface(DNObject)
  ['{B1474432-9DA0-314E-ACC5-41F0AC435DD1}']
  { getters & setters } 

    function get_Delimiter: string;
    procedure set_Delimiter(value: string);
    function get_IsThreadSafe: Boolean;
    function get_Attributes: DDN.System.DNStringDictionary;
    function get_Name: string;
    procedure set_Name(value: string);
    function get_IndentLevel: Int32;
    procedure set_IndentLevel(value: Int32);
    function get_IndentSize: Int32;
    procedure set_IndentSize(value: Int32);
    function get_Filter: DDN.System.DNTraceFilter;
    procedure set_Filter(value: DDN.System.DNTraceFilter);
    function get_TraceOutputOptions: DDN.System.DNTraceOptions;
    procedure set_TraceOutputOptions(value: DDN.System.DNTraceOptions);

  { methods } 

    ///<summary>Flushes the output buffer.</summary>
    procedure Flush;
    ///<summary>Closes the output stream so it no longer receives tracing or debugging output.</summary>
    procedure Close;
    ///<summary>When overridden in a derived class, writes the specified message to the listener you create in the derived class.</summary>
    ///  <param name="message">A message to write.</param>
    procedure Write(message: string); overload;
    ///<summary>When overridden in a derived class, writes a message to the listener you create in the derived class, followed by a line terminator.</summary>
    ///  <param name="message">A message to write. </param>
    procedure WriteLine(message: string); overload;
    ///<summary>Writes trace information, a data object and event information to the listener specific output.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  object that contains the current process ID, thread ID, and stack trace information.
    ///</param>
    ///  <param name="source">A name used to identify the output, typically the name of the application that generated the trace event.</param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values specifying the type of event that has caused the trace.</param>
    ///  <param name="id">A numeric identifier for the event.
    ///</param>
    ///  <param name="data">The trace data to emit.</param>
    procedure TraceData(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; data: DDN.mscorlib.DNObject); overload;
    ///<summary>Writes trace information, a data object and event information to the listener specific output.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  object that contains the current process ID, thread ID, and stack trace information.
    ///</param>
    ///  <param name="source">A name used to identify the output, typically the name of the application that generated the trace event.</param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values specifying the type of event that has caused the trace.</param>
    ///  <param name="id">A numeric identifier for the event.
    ///</param>
    ///  <param name="data">An array of objects to emit as data.</param>
    procedure TraceData(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; data: TArray<DDN.mscorlib.DNObject>); overload;
    ///<summary>Writes trace and event information to the listener specific output.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  object that contains the current process ID, thread ID, and stack trace information.
    ///</param>
    ///  <param name="source">A name used to identify the output, typically the name of the application that generated the trace event.
    ///</param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values specifying the type of event that has caused the trace.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    procedure TraceEvent(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32); overload;
    ///<summary>Writes trace information, a message, and event information to the listener specific output.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  object that contains the current process ID, thread ID, and stack trace information.
    ///</param>
    ///  <param name="source">A name used to identify the output, typically the name of the application that generated the trace event.
    ///</param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values specifying the type of event that has caused the trace.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="message">A message to write.
    ///</param>
    procedure TraceEvent(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; message: string); overload;
    ///<summary>Writes trace information, a formatted array of objects and event information to the listener specific output.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  object that contains the current process ID, thread ID, and stack trace information.
    ///</param>
    ///  <param name="source">A name used to identify the output, typically the name of the application that generated the trace event.
    ///</param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values specifying the type of event that has caused the trace.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="format">A format string that contains zero or more format items, which correspond to objects in the <paramref name="args" />
    ///  array.</param>
    ///  <param name="args">An <see langword="object" />
    ///  array containing zero or more objects to format.
    ///</param>
    procedure TraceEvent(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; format: string; args: TArray<DDN.mscorlib.DNObject>); overload;
    ///<summary>Emits an error message and a detailed error message to the listener you create when you implement the <see cref="T:System.Diagnostics.TraceListener" />
    ///  class.</summary>
    ///  <param name="message">A message to emit.</param>
    ///  <param name="detailMessage">A detailed message to emit.</param>
    procedure Fail(message: string; detailMessage: string); overload;
    ///<summary>Writes trace information, a message, a related activity identity and event information to the listener specific output.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  object that contains the current process ID, thread ID, and stack trace information.
    ///</param>
    ///  <param name="source">A name used to identify the output, typically the name of the application that generated the trace event.
    ///</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="message">A message to write.</param>
    ///  <param name="relatedActivityId">A <see cref="T:System.Guid" />
    ///  object identifying a related activity.</param>
    procedure TraceTransfer(eventCache: DDN.System.DNTraceEventCache; source: string; id: Int32; message: string; relatedActivityId: DDN.mscorlib.DNGuid);
    procedure Dispose;
    procedure Fail(message: string); overload;
    procedure Write(o: DDN.mscorlib.DNObject); overload;
    procedure Write(o: DDN.mscorlib.DNObject; category: string); overload;
    procedure WriteLine(o: DDN.mscorlib.DNObject); overload;
    procedure WriteLine(o: DDN.mscorlib.DNObject; category: string); overload;
    procedure Write(message: string; category: string); overload;
    procedure WriteLine(message: string; category: string); overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets and sets the delimiter used to delimit the event data that is written to the ETW subsystem.</summary>
    ///<returns>The delimiter used to delimit the event data. The default delimiter is a comma.</returns>
    property Delimiter: string read get_Delimiter write set_Delimiter;
    ///<summary>Gets a value indicating whether the trace listener is thread safe.</summary>
    ///<returns><see langword="true" />
    ///  if the trace listener is thread safe; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsThreadSafe: Boolean read get_IsThreadSafe;
    property Attributes: DDN.System.DNStringDictionary read get_Attributes;
    property Name: string read get_Name write set_Name;
    property IndentLevel: Int32 read get_IndentLevel write set_IndentLevel;
    property IndentSize: Int32 read get_IndentSize write set_IndentSize;
    property Filter: DDN.System.DNTraceFilter read get_Filter write set_Filter;
    property TraceOutputOptions: DDN.System.DNTraceOptions read get_TraceOutputOptions write set_TraceOutputOptions;
  end;

  TDNEventProviderTraceListener = class(TDNGenericImport<DNEventProviderTraceListenerClass, DNEventProviderTraceListener>) end;

  //-------------namespace: System.Diagnostics----------------
  DNEventSchemaTraceListenerClass = interface(DNObjectClass)
  ['{7A22D4B6-C9CE-5342-BE56-33122D55B664}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
    ///  class, using the specified file as the recipient of debugging and tracing output.</summary>
    ///  <param name="fileName">The path for the log file.</param>
    {class} function init(fileName: string): DNEventSchemaTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
    ///  class with the specified name, using the specified file as the recipient of debugging and tracing output.</summary>
    ///  <param name="fileName">The path for the log file.</param>
    ///  <param name="name">The name of the listener.</param>
    {class} function init(fileName: string; name: string): DNEventSchemaTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
    ///  class with the specified name and specified buffer size, using the specified file as the recipient of debugging and tracing output.</summary>
    ///  <param name="fileName">The path for the log file.</param>
    ///  <param name="name">The name of the listener.</param>
    ///  <param name="bufferSize">The size of the output buffer, in bytes.</param>
    {class} function init(fileName: string; name: string; bufferSize: Int32): DNEventSchemaTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
    ///  class with the specified name and specified buffer size, using the specified file with the specified log retention policy as the recipient of the debugging and tracing output.</summary>
    ///  <param name="fileName">The path for the log file.</param>
    ///  <param name="name">The name of the listener.</param>
    ///  <param name="bufferSize">The size of the output buffer, in bytes.</param>
    ///  <param name="logRetentionOption">One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" />
    ///  values. </param>
    {class} function init(fileName: string; name: string; bufferSize: Int32; logRetentionOption: DNTraceLogRetentionOption): DNEventSchemaTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
    ///  class with the specified name and specified buffer size, using the specified file with the specified log retention policy and maximum size as the recipient of the debugging and tracing output.</summary>
    ///  <param name="fileName">The path for the log file.</param>
    ///  <param name="name">The name of the listener.</param>
    ///  <param name="bufferSize">The size of the output buffer, in bytes.</param>
    ///  <param name="logRetentionOption">One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" />
    ///  values.</param>
    ///  <param name="maximumFileSize">The maximum file size, in bytes.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumFileSize" />
    ///  is less than <paramref name="bufferSize" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumFileSize" />
    ///  is a negative number.</exception>
    {class} function init(fileName: string; name: string; bufferSize: Int32; logRetentionOption: DNTraceLogRetentionOption; maximumFileSize: Int64): DNEventSchemaTraceListener; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" />
    ///  class with the specified name and specified buffer size, using the specified file with the specified log retention policy, maximum size, and file count as the recipient of the debugging and tracing output.</summary>
    ///  <param name="fileName">The path for the log file.</param>
    ///  <param name="name">The name of the listener.</param>
    ///  <param name="bufferSize">The size of the output buffer, in bytes.</param>
    ///  <param name="logRetentionOption">One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" />
    ///  values.</param>
    ///  <param name="maximumFileSize">The maximum file size, in bytes.</param>
    ///  <param name="maximumNumberOfFiles">The maximum number of output log files.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumFileSize" />
    ///  is less than <paramref name="bufferSize" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumFileSize" />
    ///  is a negative number.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumNumberOfFiles" />
    ///  is less than 1, and <paramref name="logRetentionOption" />
    ///  is <see cref="F:System.Diagnostics.TraceLogRetentionOption.LimitedSequentialFiles" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumNumberOfFiles" />
    ///  is less than 2, and <paramref name="logRetentionOption" />
    ///  is <see cref="F:System.Diagnostics.TraceLogRetentionOption.LimitedCircularFiles" />
    ///  .</exception>
    {class} function init(fileName: string; name: string; bufferSize: Int32; logRetentionOption: DNTraceLogRetentionOption; maximumFileSize: Int64; maximumNumberOfFiles: Int32): DNEventSchemaTraceListener; overload;

  end;

  ///<summary>Directs tracing or debugging output of end-to-end events to an XML-encoded, schema-compliant log file.</summary>
  [DNTypeName('System.Diagnostics.EventSchemaTraceListener')]
  DNEventSchemaTraceListener = interface(DNObject)
  ['{64875632-E9C0-34F6-BAFC-DB922271A161}']
  { getters & setters } 

    function get_Writer: DDN.mscorlib.DNTextWriter;
    procedure set_Writer(value: DDN.mscorlib.DNTextWriter);
    function get_IsThreadSafe: Boolean;
    function get_BufferSize: Int32;
    function get_TraceLogRetentionOption: DNTraceLogRetentionOption;
    function get_MaximumFileSize: Int64;
    function get_MaximumNumberOfFiles: Int32;
    function get_Attributes: DDN.System.DNStringDictionary;
    function get_Name: string;
    procedure set_Name(value: string);
    function get_IndentLevel: Int32;
    procedure set_IndentLevel(value: Int32);
    function get_IndentSize: Int32;
    procedure set_IndentSize(value: Int32);
    function get_Filter: DDN.System.DNTraceFilter;
    procedure set_Filter(value: DDN.System.DNTraceFilter);
    function get_TraceOutputOptions: DDN.System.DNTraceOptions;
    procedure set_TraceOutputOptions(value: DDN.System.DNTraceOptions);

  { methods } 

    ///<summary>Writes a message to the log file without providing any additional context information.</summary>
    ///  <param name="message">The message to write.</param>
    procedure Write(message: string); overload;
    ///<summary>Closes the log file for this listener so that it no longer receives tracing or debugging output.</summary>
    procedure Close;
    ///<summary>Causes buffered data to be written to the log for this listener.</summary>
    procedure Flush;
    ///<summary>Writes a message followed by the current line terminator to the log file without providing any additional context information.</summary>
    ///  <param name="message">The message to write.</param>
    procedure WriteLine(message: string); overload;
    ///<summary>Writes error information, including a basic error message and a detailed error message, to the log file.</summary>
    ///  <param name="message">The basic error message to write.</param>
    ///  <param name="detailMessage">The detailed error message to append to the basic error message.</param>
    procedure Fail(message: string; detailMessage: string); overload;
    ///<summary>Writes trace information, a formatted message, and event information to the log file.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  that contains the current process ID, thread ID, and stack trace information.</param>
    ///  <param name="source">The source name. </param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="format">A format string that contains zero or more format items that correspond to objects in the <paramref name="args" />
    ///  array.</param>
    ///  <param name="args">An object array that contains zero or more objects to format.</param>
    procedure TraceEvent(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; format: string; args: TArray<DDN.mscorlib.DNObject>); overload;
    ///<summary>Writes trace information, a message, and event information to the log file.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  that contains the current process ID, thread ID, and stack trace information.</param>
    ///  <param name="source">The source name. </param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="message">The message to write.</param>
    procedure TraceEvent(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; message: string); overload;
    ///<summary>Writes trace information, a single data object, and event information to the log file.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  that contains the current process ID, thread ID, and stack trace information.</param>
    ///  <param name="source">The source name. </param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="data">A data object to emit.</param>
    procedure TraceData(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; data: DDN.mscorlib.DNObject); overload;
    ///<summary>Writes trace information, multiple data objects, and event information to the log file.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  that contains the current process ID, thread ID, and stack trace information.</param>
    ///  <param name="source">The source name. </param>
    ///  <param name="eventType">One of the <see cref="T:System.Diagnostics.TraceEventType" />
    ///  values.</param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="data">An array of data objects to emit.</param>
    procedure TraceData(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32; data: TArray<DDN.mscorlib.DNObject>); overload;
    ///<summary>Writes trace information, including the identity of a related activity, a message, and event information, to the log file.</summary>
    ///  <param name="eventCache">A <see cref="T:System.Diagnostics.TraceEventCache" />
    ///  that contains the current process ID, thread ID, and stack trace information.</param>
    ///  <param name="source">The source name. </param>
    ///  <param name="id">A numeric identifier for the event.</param>
    ///  <param name="message">A trace message to write.</param>
    ///  <param name="relatedActivityId">A <see cref="T:System.Guid" />
    ///  structure that identifies a related activity.</param>
    procedure TraceTransfer(eventCache: DDN.System.DNTraceEventCache; source: string; id: Int32; message: string; relatedActivityId: DDN.mscorlib.DNGuid);
    procedure Dispose;
    procedure Fail(message: string); overload;
    procedure Write(o: DDN.mscorlib.DNObject); overload;
    procedure Write(o: DDN.mscorlib.DNObject; category: string); overload;
    procedure WriteLine(o: DDN.mscorlib.DNObject); overload;
    procedure WriteLine(o: DDN.mscorlib.DNObject; category: string); overload;
    procedure TraceEvent(eventCache: DDN.System.DNTraceEventCache; source: string; eventType: DDN.System.DNTraceEventType; id: Int32); overload;
    procedure Write(message: string; category: string); overload;
    procedure WriteLine(message: string; category: string); overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the underlying text writer that writes to the log file.</summary>
    ///<returns>A <see cref="T:System.IO.TextWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.NotSupportedException">An attempt was made to assign a value to the <see cref="P:System.Diagnostics.EventSchemaTraceListener.Writer" />
    ///  property.</exception>
    property Writer: DDN.mscorlib.DNTextWriter read get_Writer write set_Writer;
    ///<summary>Gets a value indicating whether the trace listener is thread safe.</summary>
    ///<returns>Always returns <see langword="true" />
    ///  .</returns>
    property IsThreadSafe: Boolean read get_IsThreadSafe;
    ///<summary>Gets the size of the output buffer.</summary>
    ///<returns>The size of the output buffer, in bytes. </returns>
    property BufferSize: Int32 read get_BufferSize;
    ///<summary>Gets the trace log retention option for the file.</summary>
    ///<returns>One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" />
    ///  values. The default is <see cref="F:System.Diagnostics.TraceLogRetentionOption.SingleFileUnboundedSize" />
    ///  . </returns>
    property TraceLogRetentionOption: DNTraceLogRetentionOption read get_TraceLogRetentionOption;
    ///<summary>Gets the maximum size of the log file.</summary>
    ///<returns>The maximum file size, in bytes.</returns>
    property MaximumFileSize: Int64 read get_MaximumFileSize;
    ///<summary>Gets the maximum number of log files.</summary>
    ///<returns>The maximum number of log files, determined by the value of the <see cref="P:System.Diagnostics.EventSchemaTraceListener.TraceLogRetentionOption" />
    ///  property for the file.</returns>
    property MaximumNumberOfFiles: Int32 read get_MaximumNumberOfFiles;
    property Attributes: DDN.System.DNStringDictionary read get_Attributes;
    property Name: string read get_Name write set_Name;
    property IndentLevel: Int32 read get_IndentLevel write set_IndentLevel;
    property IndentSize: Int32 read get_IndentSize write set_IndentSize;
    property Filter: DDN.System.DNTraceFilter read get_Filter write set_Filter;
    property TraceOutputOptions: DDN.System.DNTraceOptions read get_TraceOutputOptions write set_TraceOutputOptions;
  end;

  TDNEventSchemaTraceListener = class(TDNGenericImport<DNEventSchemaTraceListenerClass, DNEventSchemaTraceListener>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNPipeStreamClass = interface(DDN.mscorlib.DNStreamClass)
  ['{FDD1EC2E-F4DE-5EAE-B61A-2B977564ACB6}']
  end;

  ///<summary>Exposes a <see cref="T:System.IO.Stream" />
  ///  object around a pipe, which supports both anonymous and named pipes.</summary>
  [DNTypeName('System.IO.Pipes.PipeStream')]
  DNPipeStream = interface(DDN.mscorlib.DNStream)
  ['{C98F14E4-AA9B-334B-8E1D-54E79CC9D37A}']
  { getters & setters } 

    function get_IsConnected: Boolean;
    function get_IsAsync: Boolean;
    function get_IsMessageComplete: Boolean;
    function get_TransmissionMode: DNPipeTransmissionMode;
    function get_InBufferSize: Int32;
    function get_OutBufferSize: Int32;
    function get_ReadMode: DNPipeTransmissionMode;
    procedure set_ReadMode(value: DNPipeTransmissionMode);
    function get_SafePipeHandle: DNSafePipeHandle;
    function get_CanRead: Boolean;
    function get_CanWrite: Boolean;
    function get_CanSeek: Boolean;
    function get_Length: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_CanTimeout: Boolean;
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
    ///  <param name="buffer">When this method returns, contains the specified byte array with the values between <paramref name="offset" />
    ///  and (<paramref name="offset" />
    ///  + <paramref name="count" />
    ///  - 1) replaced by the bytes read from the current source.</param>
    ///  <param name="offset">The byte offset in the <paramref name="buffer" />
    ///  array at which the bytes that are read will be placed.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///<returns>The total number of bytes that are read into <paramref name="buffer" />
    ///  . This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    ///<summary>Begins an asynchronous read operation.</summary>
    ///  <param name="buffer">The buffer to read data into.</param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  at which to begin reading.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///  <param name="callback">The method to call when the asynchronous read operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous read.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous read request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
    ///  <param name="buffer">The buffer that contains data to write to the pipe.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write to the current stream.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    ///<summary>Begins an asynchronous write operation.</summary>
    ///  <param name="buffer">The buffer that contains the data to write to the current stream.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write.</param>
    ///  <param name="callback">The method to call when the asynchronous write operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous write operation.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous write request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Flush;
    ///<summary>Sets the length of the current stream to the specified value.</summary>
    ///  <param name="value">The new length of the stream.</param>
    procedure SetLength(value: Int64);
    ///<summary>Sets the current position of the current stream to the specified value.</summary>
    ///  <param name="offset">The point, relative to <paramref name="origin" />
    ///  , to begin seeking from.</param>
    ///  <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />
    ///  , using a value of type <see cref="T:System.IO.SeekOrigin" />
    ///  .</param>
    ///<returns>The new position in the stream.</returns>
    function Seek(offset: Int64; origin: DDN.mscorlib.DNSeekOrigin): Int64;
    ///<summary>Reads a byte from a pipe.</summary>
    ///<returns>The byte, cast to <see cref="T:System.Int32" />
    ///  , or -1 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function ReadByte: Int32;
    ///<summary>Writes a byte to the current stream.</summary>
    ///  <param name="value">The byte to write to the stream.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WriteByte(value: Byte);
    ///<summary>Waits for the other end of the pipe to read all sent bytes.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WaitForPipeDrain;
    ///<summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    function GetAccessControl: DNPipeSecurity;
    ///<summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///  <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.ArgumentNullException"><paramref name="pipeSecurity" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    procedure SetAccessControl(pipeSecurity: DNPipeSecurity);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected; otherwise, <see langword="false" />
    ///  .</returns>
    property IsConnected: Boolean read get_IsConnected;
    ///<summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously or synchronously.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously; otherwise, <see langword="false" />
    ///  .</returns>
    property IsAsync: Boolean read get_IsAsync;
    ///<summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
    ///<returns><see langword="true" />
    ///  if there are no more characters to read in the message; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe is not connected.-or-The pipe handle has not been set.-or-The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" />
    ///  property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property IsMessageComplete: Boolean read get_IsMessageComplete;
    ///<summary>Gets the pipe transmission mode supported by the current pipe.</summary>
    ///<returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  values that indicates the transmission mode supported by the current pipe.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect in an anonymous client/server operation or with a named client. </exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property TransmissionMode: DNPipeTransmissionMode read get_TransmissionMode;
    ///<summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
    ///<returns>An integer value that represents the inbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unreadable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property InBufferSize: Int32 read get_InBufferSize;
    ///<summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
    ///<returns>The outbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property OutBufferSize: Int32 read get_OutBufferSize;
    ///<summary>Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object reads from the pipe.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  value.</exception><exception cref="T:System.NotSupportedException">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  value for this pipe stream.</exception><exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect with a named client.</exception><exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred with a named client.</exception>
    property ReadMode: DNPipeTransmissionMode read get_ReadMode write set_ReadMode;
    ///<summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object encapsulates.</summary>
    ///<returns>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" />
    ///  object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property SafePipeHandle: DNSafePipeHandle read get_SafePipeHandle;
    ///<summary>Gets a value indicating whether the current stream supports read operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports read operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanRead: Boolean read get_CanRead;
    ///<summary>Gets a value indicating whether the current stream supports write operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports write operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanWrite: Boolean read get_CanWrite;
    ///<summary>Gets a value indicating whether the current stream supports seek operations.</summary>
    ///<returns><see langword="false" />
    ///  in all cases.</returns>
    property CanSeek: Boolean read get_CanSeek;
    ///<summary>Gets the length of a stream, in bytes.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Length: Int64 read get_Length;
    ///<summary>Gets or sets the current position of the current stream.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Position: Int64 read get_Position write set_Position;
    property CanTimeout: Boolean read get_CanTimeout;
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNPipeStream = class(TDNGenericImport<DNPipeStreamClass, DNPipeStream>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNAnonymousPipeClientStreamClass = interface(DNPipeStreamClass)
  ['{C6922860-BA50-58D7-AA64-0C13887A6037}']
  { static getter & setter } 

    procedure set_ReadMode(value: DNPipeTransmissionMode);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  class with the specified string representation of the pipe handle.</summary>
    ///  <param name="pipeHandleAsString">A string that represents the pipe handle.</param>
    ///<exception cref="T:System.IO.IOException"><paramref name="pipeHandleAsString" />
    ///  is not a valid pipe handle.</exception>
    {class} function init(pipeHandleAsString: string): DNAnonymousPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  class with the specified pipe direction and a string representation of the pipe handle.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///  <param name="pipeHandleAsString">A string that represents the pipe handle.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="pipeHandleAsString" />
    ///  is an invalid handle.</exception><exception cref="T:System.ArgumentNullException"><paramref name="pipeHandleAsString" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception>
    {class} function init(direction: DNPipeDirection; pipeHandleAsString: string): DNAnonymousPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  class from the specified handle.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///  <param name="safePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object will encapsulate.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="safePipeHandle " />
    ///  is not a valid handle.</exception><exception cref="T:System.ArgumentNullException"><paramref name="safePipeHandle" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception><exception cref="T:System.IO.IOException">An I/O error, such as a disk error, has occurred.-or-The stream has been closed.</exception>
    {class} function init(direction: DNPipeDirection; safePipeHandle: DNSafePipeHandle): DNAnonymousPipeClientStream; overload;

  { static propertys } 

    ///<summary>Sets the reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object.</summary>
    ///<returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The transmission mode is not valid. For anonymous pipes, only <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />
    ///  is supported.</exception><exception cref="T:System.NotSupportedException">The transmission mode is <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.IO.IOException">The connection is broken or another I/O error occurs.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    {class} property ReadMode: DNPipeTransmissionMode write set_ReadMode;
  end;

  ///<summary>Exposes the client side of an anonymous pipe stream, which supports both synchronous and asynchronous read and write operations.</summary>
  [DNTypeName('System.IO.Pipes.AnonymousPipeClientStream')]
  DNAnonymousPipeClientStream = interface(DNPipeStream)
  ['{B610753A-191A-3D16-90B4-AEFCC889BB22}']
  { getters & setters } 

    function get_TransmissionMode: DNPipeTransmissionMode;
    procedure set_ReadMode(value: DNPipeTransmissionMode);
    function get_IsConnected: Boolean;
    function get_IsAsync: Boolean;
    function get_IsMessageComplete: Boolean;
    function get_InBufferSize: Int32;
    function get_OutBufferSize: Int32;
    function get_SafePipeHandle: DNSafePipeHandle;
    function get_CanRead: Boolean;
    function get_CanWrite: Boolean;
    function get_CanSeek: Boolean;
    function get_Length: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_CanTimeout: Boolean;
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
    ///  <param name="buffer">When this method returns, contains the specified byte array with the values between <paramref name="offset" />
    ///  and (<paramref name="offset" />
    ///  + <paramref name="count" />
    ///  - 1) replaced by the bytes read from the current source.</param>
    ///  <param name="offset">The byte offset in the <paramref name="buffer" />
    ///  array at which the bytes that are read will be placed.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///<returns>The total number of bytes that are read into <paramref name="buffer" />
    ///  . This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    ///<summary>Begins an asynchronous read operation.</summary>
    ///  <param name="buffer">The buffer to read data into.</param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  at which to begin reading.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///  <param name="callback">The method to call when the asynchronous read operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous read.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous read request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
    ///  <param name="buffer">The buffer that contains data to write to the pipe.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write to the current stream.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    ///<summary>Begins an asynchronous write operation.</summary>
    ///  <param name="buffer">The buffer that contains the data to write to the current stream.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write.</param>
    ///  <param name="callback">The method to call when the asynchronous write operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous write operation.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous write request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Flush;
    ///<summary>Sets the length of the current stream to the specified value.</summary>
    ///  <param name="value">The new length of the stream.</param>
    procedure SetLength(value: Int64);
    ///<summary>Sets the current position of the current stream to the specified value.</summary>
    ///  <param name="offset">The point, relative to <paramref name="origin" />
    ///  , to begin seeking from.</param>
    ///  <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />
    ///  , using a value of type <see cref="T:System.IO.SeekOrigin" />
    ///  .</param>
    ///<returns>The new position in the stream.</returns>
    function Seek(offset: Int64; origin: DDN.mscorlib.DNSeekOrigin): Int64;
    ///<summary>Reads a byte from a pipe.</summary>
    ///<returns>The byte, cast to <see cref="T:System.Int32" />
    ///  , or -1 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function ReadByte: Int32;
    ///<summary>Writes a byte to the current stream.</summary>
    ///  <param name="value">The byte to write to the stream.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WriteByte(value: Byte);
    ///<summary>Waits for the other end of the pipe to read all sent bytes.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WaitForPipeDrain;
    ///<summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    function GetAccessControl: DNPipeSecurity;
    ///<summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///  <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.ArgumentNullException"><paramref name="pipeSecurity" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    procedure SetAccessControl(pipeSecurity: DNPipeSecurity);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the pipe transmission mode supported by the current pipe.</summary>
    ///<returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  supported by the current pipe.</returns>
    property TransmissionMode: DNPipeTransmissionMode read get_TransmissionMode;
    ///<summary>Sets the reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object.</summary>
    ///<returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The transmission mode is not valid. For anonymous pipes, only <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />
    ///  is supported.</exception><exception cref="T:System.NotSupportedException">The transmission mode is <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.IO.IOException">The connection is broken or another I/O error occurs.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property ReadMode: DNPipeTransmissionMode write set_ReadMode;
    ///<summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected; otherwise, <see langword="false" />
    ///  .</returns>
    property IsConnected: Boolean read get_IsConnected;
    ///<summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously or synchronously.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously; otherwise, <see langword="false" />
    ///  .</returns>
    property IsAsync: Boolean read get_IsAsync;
    ///<summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
    ///<returns><see langword="true" />
    ///  if there are no more characters to read in the message; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe is not connected.-or-The pipe handle has not been set.-or-The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" />
    ///  property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property IsMessageComplete: Boolean read get_IsMessageComplete;
    ///<summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
    ///<returns>An integer value that represents the inbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unreadable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property InBufferSize: Int32 read get_InBufferSize;
    ///<summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
    ///<returns>The outbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property OutBufferSize: Int32 read get_OutBufferSize;
    ///<summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object encapsulates.</summary>
    ///<returns>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" />
    ///  object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property SafePipeHandle: DNSafePipeHandle read get_SafePipeHandle;
    ///<summary>Gets a value indicating whether the current stream supports read operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports read operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanRead: Boolean read get_CanRead;
    ///<summary>Gets a value indicating whether the current stream supports write operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports write operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanWrite: Boolean read get_CanWrite;
    ///<summary>Gets a value indicating whether the current stream supports seek operations.</summary>
    ///<returns><see langword="false" />
    ///  in all cases.</returns>
    property CanSeek: Boolean read get_CanSeek;
    ///<summary>Gets the length of a stream, in bytes.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Length: Int64 read get_Length;
    ///<summary>Gets or sets the current position of the current stream.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Position: Int64 read get_Position write set_Position;
    property CanTimeout: Boolean read get_CanTimeout;
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNAnonymousPipeClientStream = class(TDNGenericImport<DNAnonymousPipeClientStreamClass, DNAnonymousPipeClientStream>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNAnonymousPipeServerStreamClass = interface(DNPipeStreamClass)
  ['{8196832D-FC69-51B4-894E-41B8F91447B1}']
  { static getter & setter } 

    procedure set_ReadMode(value: DNPipeTransmissionMode);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  class.</summary>
    {class} function init: DNAnonymousPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  class with the specified pipe direction.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///<exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception>
    {class} function init(direction: DNPipeDirection): DNAnonymousPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  class with the specified pipe direction and inheritability mode.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes. Must be set to either <see cref="F:System.IO.HandleInheritability.None" />
    ///  or <see cref="F:System.IO.HandleInheritability.Inheritable" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inheritability" />
    ///  is not set to either <see cref="F:System.IO.HandleInheritability.None" />
    ///  or <see cref="F:System.IO.HandleInheritability.Inheritable" />
    ///  .</exception><exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception>
    {class} function init(direction: DNPipeDirection; inheritability: DNHandleInheritability): DNAnonymousPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  class with the specified pipe direction, inheritability mode, and buffer size.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes. Must be set to either <see cref="F:System.IO.HandleInheritability.None" />
    ///  or <see cref="F:System.IO.HandleInheritability.Inheritable" />
    ///  .</param>
    ///  <param name="bufferSize">The size of the buffer. This value must be greater than or equal to 0. </param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inheritability" />
    ///  is not set to either <see cref="F:System.IO.HandleInheritability.None" />
    ///  or <see cref="F:System.IO.HandleInheritability.Inheritable" />
    ///  .-or-
    ///  <paramref name="bufferSize" />
    ///  is less than 0.</exception><exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception>
    {class} function init(direction: DNPipeDirection; inheritability: DNHandleInheritability; bufferSize: Int32): DNAnonymousPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  class with the specified pipe direction, inheritability mode, buffer size, and pipe security.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes.</param>
    ///  <param name="bufferSize">The size of the buffer. This value must be greater than or equal to 0. </param>
    ///  <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="inheritability" />
    ///  is not set to either <see cref="F:System.IO.HandleInheritability.None" />
    ///  or <see cref="F:System.IO.HandleInheritability.Inheritable" />
    ///  .-or-
    ///  <paramref name="bufferSize" />
    ///  is less than 0.</exception><exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception>
    {class} function init(direction: DNPipeDirection; inheritability: DNHandleInheritability; bufferSize: Int32; pipeSecurity: DNPipeSecurity): DNAnonymousPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  class from the specified pipe handles.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" />
    ///  cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</param>
    ///  <param name="serverSafePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object will encapsulate.</param>
    ///  <param name="clientSafePipeHandle">A safe handle for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="serverSafePipeHandle" />
    ///  or <paramref name="clientSafePipeHandle" />
    ///  is an invalid handle.</exception><exception cref="T:System.ArgumentNullException"><paramref name="serverSafePipeHandle" />
    ///  or <paramref name="clientSafePipeHandle" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.NotSupportedException"><paramref name="direction" />
    ///  is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />
    ///  .</exception><exception cref="T:System.IO.IOException">An I/O error, such as a disk error, has occurred.-or-The stream has been closed.</exception>
    {class} function init(direction: DNPipeDirection; serverSafePipeHandle: DNSafePipeHandle; clientSafePipeHandle: DNSafePipeHandle): DNAnonymousPipeServerStream; overload;

  { static propertys } 

    ///<summary>Sets the reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object. For anonymous pipes, transmission mode must be <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />
    ///  .</summary>
    ///<returns>The reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The transmission mode is not valid. For anonymous pipes, only <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />
    ///  is supported. </exception><exception cref="T:System.NotSupportedException">The property is set to <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  , which is not supported for anonymous pipes.</exception><exception cref="T:System.IO.IOException">The connection is broken or another I/O error occurs.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    {class} property ReadMode: DNPipeTransmissionMode write set_ReadMode;
  end;

  ///<summary>Exposes a stream around an anonymous pipe, which supports both synchronous and asynchronous read and write operations.</summary>
  [DNTypeName('System.IO.Pipes.AnonymousPipeServerStream')]
  DNAnonymousPipeServerStream = interface(DNPipeStream)
  ['{884A81C3-57A0-33D5-A300-0AB2F1E3C609}']
  { getters & setters } 

    function get_ClientSafePipeHandle: DNSafePipeHandle;
    function get_TransmissionMode: DNPipeTransmissionMode;
    procedure set_ReadMode(value: DNPipeTransmissionMode);
    function get_IsConnected: Boolean;
    function get_IsAsync: Boolean;
    function get_IsMessageComplete: Boolean;
    function get_InBufferSize: Int32;
    function get_OutBufferSize: Int32;
    function get_SafePipeHandle: DNSafePipeHandle;
    function get_CanRead: Boolean;
    function get_CanWrite: Boolean;
    function get_CanSeek: Boolean;
    function get_Length: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_CanTimeout: Boolean;
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>Gets the connected <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object's handle as a string.</summary>
    ///<returns>A string that represents the connected <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object's handle.</returns>
    function GetClientHandleAsString: string;
    ///<summary>Closes the local copy of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object's handle.</summary>
    procedure DisposeLocalCopyOfClientHandle;
    ///<summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
    ///  <param name="buffer">When this method returns, contains the specified byte array with the values between <paramref name="offset" />
    ///  and (<paramref name="offset" />
    ///  + <paramref name="count" />
    ///  - 1) replaced by the bytes read from the current source.</param>
    ///  <param name="offset">The byte offset in the <paramref name="buffer" />
    ///  array at which the bytes that are read will be placed.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///<returns>The total number of bytes that are read into <paramref name="buffer" />
    ///  . This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    ///<summary>Begins an asynchronous read operation.</summary>
    ///  <param name="buffer">The buffer to read data into.</param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  at which to begin reading.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///  <param name="callback">The method to call when the asynchronous read operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous read.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous read request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
    ///  <param name="buffer">The buffer that contains data to write to the pipe.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write to the current stream.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    ///<summary>Begins an asynchronous write operation.</summary>
    ///  <param name="buffer">The buffer that contains the data to write to the current stream.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write.</param>
    ///  <param name="callback">The method to call when the asynchronous write operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous write operation.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous write request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Flush;
    ///<summary>Sets the length of the current stream to the specified value.</summary>
    ///  <param name="value">The new length of the stream.</param>
    procedure SetLength(value: Int64);
    ///<summary>Sets the current position of the current stream to the specified value.</summary>
    ///  <param name="offset">The point, relative to <paramref name="origin" />
    ///  , to begin seeking from.</param>
    ///  <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />
    ///  , using a value of type <see cref="T:System.IO.SeekOrigin" />
    ///  .</param>
    ///<returns>The new position in the stream.</returns>
    function Seek(offset: Int64; origin: DDN.mscorlib.DNSeekOrigin): Int64;
    ///<summary>Reads a byte from a pipe.</summary>
    ///<returns>The byte, cast to <see cref="T:System.Int32" />
    ///  , or -1 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function ReadByte: Int32;
    ///<summary>Writes a byte to the current stream.</summary>
    ///  <param name="value">The byte to write to the stream.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WriteByte(value: Byte);
    ///<summary>Waits for the other end of the pipe to read all sent bytes.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WaitForPipeDrain;
    ///<summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    function GetAccessControl: DNPipeSecurity;
    ///<summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///  <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.ArgumentNullException"><paramref name="pipeSecurity" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    procedure SetAccessControl(pipeSecurity: DNPipeSecurity);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the safe handle for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object that is currently connected to the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object.</summary>
    ///<returns>A handle for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" />
    ///  object that is currently connected to the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object.</returns>
    property ClientSafePipeHandle: DNSafePipeHandle read get_ClientSafePipeHandle;
    ///<summary>Gets the pipe transmission mode that is supported by the current pipe.</summary>
    ///<returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  that is supported by the current pipe.</returns>
    property TransmissionMode: DNPipeTransmissionMode read get_TransmissionMode;
    ///<summary>Sets the reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object. For anonymous pipes, transmission mode must be <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />
    ///  .</summary>
    ///<returns>The reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The transmission mode is not valid. For anonymous pipes, only <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />
    ///  is supported. </exception><exception cref="T:System.NotSupportedException">The property is set to <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  , which is not supported for anonymous pipes.</exception><exception cref="T:System.IO.IOException">The connection is broken or another I/O error occurs.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property ReadMode: DNPipeTransmissionMode write set_ReadMode;
    ///<summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected; otherwise, <see langword="false" />
    ///  .</returns>
    property IsConnected: Boolean read get_IsConnected;
    ///<summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously or synchronously.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously; otherwise, <see langword="false" />
    ///  .</returns>
    property IsAsync: Boolean read get_IsAsync;
    ///<summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
    ///<returns><see langword="true" />
    ///  if there are no more characters to read in the message; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe is not connected.-or-The pipe handle has not been set.-or-The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" />
    ///  property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property IsMessageComplete: Boolean read get_IsMessageComplete;
    ///<summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
    ///<returns>An integer value that represents the inbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unreadable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property InBufferSize: Int32 read get_InBufferSize;
    ///<summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
    ///<returns>The outbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property OutBufferSize: Int32 read get_OutBufferSize;
    ///<summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object encapsulates.</summary>
    ///<returns>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" />
    ///  object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property SafePipeHandle: DNSafePipeHandle read get_SafePipeHandle;
    ///<summary>Gets a value indicating whether the current stream supports read operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports read operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanRead: Boolean read get_CanRead;
    ///<summary>Gets a value indicating whether the current stream supports write operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports write operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanWrite: Boolean read get_CanWrite;
    ///<summary>Gets a value indicating whether the current stream supports seek operations.</summary>
    ///<returns><see langword="false" />
    ///  in all cases.</returns>
    property CanSeek: Boolean read get_CanSeek;
    ///<summary>Gets the length of a stream, in bytes.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Length: Int64 read get_Length;
    ///<summary>Gets or sets the current position of the current stream.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Position: Int64 read get_Position write set_Position;
    property CanTimeout: Boolean read get_CanTimeout;
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNAnonymousPipeServerStream = class(TDNGenericImport<DNAnonymousPipeServerStreamClass, DNAnonymousPipeServerStream>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNNamedPipeClientStreamClass = interface(DNPipeStreamClass)
  ['{862A5CF9-0F09-50D7-821A-C27C071A30CB}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe name.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".</exception>
    {class} function init(pipeName: string): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe and server names.</summary>
    ///  <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".</exception>
    {class} function init(serverName: string; pipeName: string): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe and server names, and the specified pipe direction.</summary>
    ///  <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.</exception>
    {class} function init(serverName: string; pipeName: string; direction: DNPipeDirection): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe and server names, and the specified pipe direction and pipe options.</summary>
    ///  <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.</exception>
    {class} function init(serverName: string; pipeName: string; direction: DNPipeDirection; options: DNPipeOptions): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe and server names, and the specified pipe direction, pipe options, and security impersonation level.</summary>
    ///  <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="impersonationLevel">One of the enumeration values that determines the security impersonation level.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="impersonationLevel" />
    ///  is not a valid <see cref="T:System.Security.Principal.TokenImpersonationLevel" />
    ///  value.</exception>
    {class} function init(serverName: string; pipeName: string; direction: DNPipeDirection; options: DNPipeOptions; impersonationLevel: DDN.mscorlib.DNTokenImpersonationLevel): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe and server names, and the specified pipe direction, pipe options, security impersonation level, and inheritability mode.</summary>
    ///  <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="impersonationLevel">One of the enumeration values that determines the security impersonation level.</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle will be inheritable by child processes.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="impersonationLevel" />
    ///  is not a valid <see cref="T:System.Security.Principal.TokenImpersonationLevel" />
    ///  value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  value.</exception>
    {class} function init(serverName: string; pipeName: string; direction: DNPipeDirection; options: DNPipeOptions; impersonationLevel: DDN.mscorlib.DNTokenImpersonationLevel; inheritability: DNHandleInheritability): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class with the specified pipe and server names, and the specified pipe options, security impersonation level, and inheritability mode.</summary>
    ///  <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="desiredAccessRights">One of the enumeration values that specifies the desired access rights of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="impersonationLevel">One of the enumeration values that determines the security impersonation level.</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle will be inheritable by child processes.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  or <paramref name="serverName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="impersonationLevel" />
    ///  is not a valid <see cref="T:System.Security.Principal.TokenImpersonationLevel" />
    ///  value.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  value.</exception>
    {class} function init(serverName: string; pipeName: string; desiredAccessRights: DNPipeAccessRights; options: DNPipeOptions; impersonationLevel: DDN.mscorlib.DNTokenImpersonationLevel; inheritability: DNHandleInheritability): DNNamedPipeClientStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  class for the specified pipe handle with the specified pipe direction.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="isAsync"><see langword="true" />
    ///  to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="isConnected"><see langword="true" />
    ///  to indicate that the pipe is connected; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="safePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  object will encapsulate.</param>
    ///<exception cref="T:System.IO.IOException"><paramref name="safePipeHandle" />
    ///  is not a valid handle.</exception><exception cref="T:System.ArgumentException"><paramref name="safePipeHandle" />
    ///  is not a valid handle.</exception><exception cref="T:System.ArgumentNullException"><paramref name="safePipeHandle" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.</exception><exception cref="T:System.IO.IOException">The stream has been closed. </exception>
    {class} function init(direction: DNPipeDirection; isAsync: Boolean; isConnected: Boolean; safePipeHandle: DNSafePipeHandle): DNNamedPipeClientStream; overload;

  end;

  ///<summary>Exposes a <see cref="T:System.IO.Stream" />
  ///  around a named pipe, which supports both synchronous and asynchronous read and write operations.</summary>
  [DNTypeName('System.IO.Pipes.NamedPipeClientStream')]
  DNNamedPipeClientStream = interface(DNPipeStream)
  ['{FD52A687-FD3A-3F99-83ED-6D2F9BF7E05E}']
  { getters & setters } 

    function get_NumberOfServerInstances: Int32;
    function get_IsConnected: Boolean;
    function get_IsAsync: Boolean;
    function get_IsMessageComplete: Boolean;
    function get_TransmissionMode: DNPipeTransmissionMode;
    function get_InBufferSize: Int32;
    function get_OutBufferSize: Int32;
    function get_ReadMode: DNPipeTransmissionMode;
    procedure set_ReadMode(value: DNPipeTransmissionMode);
    function get_SafePipeHandle: DNSafePipeHandle;
    function get_CanRead: Boolean;
    function get_CanWrite: Boolean;
    function get_CanSeek: Boolean;
    function get_Length: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_CanTimeout: Boolean;
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>Connects to a waiting server with an infinite time-out value.</summary>
    ///<exception cref="T:System.InvalidOperationException">The client is already connected.</exception>
    procedure Connect; overload;
    ///<summary>Connects to a waiting server within the specified time-out period.</summary>
    ///  <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
    ///<exception cref="T:System.TimeoutException">Could not connect to the server within the specified <paramref name="timeout" />
    ///  period.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />
    ///  is less than 0 and not set to <see cref="F:System.Threading.Timeout.Infinite" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The client is already connected.</exception><exception cref="T:System.IO.IOException">The server is connected to another client and the time-out period has expired.</exception>
    procedure Connect(timeout: Int32); overload;
    ///<summary>Asynchronously connects to a waiting server with an infinite timeout period.</summary>
    ///<returns>A task that represents the asynchronous connect operation.</returns>
    function ConnectAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously connects to a waiting server within the specified timeout period.</summary>
    ///  <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
    ///<returns>A task that represents the asynchronous connect operation.</returns>
    function ConnectAsync(timeout: Int32): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously connects to a waiting server and monitors cancellation requests.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />
    ///  .</param>
    ///<returns>A task that represents the asynchronous connect operation.</returns>
    function ConnectAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously connects to a waiting server within the specified timeout period and monitors cancellation requests.</summary>
    ///  <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />
    ///  .</param>
    ///<returns>A task that represents the asynchronous connect operation.</returns>
    function ConnectAsync(timeout: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
    ///  <param name="buffer">When this method returns, contains the specified byte array with the values between <paramref name="offset" />
    ///  and (<paramref name="offset" />
    ///  + <paramref name="count" />
    ///  - 1) replaced by the bytes read from the current source.</param>
    ///  <param name="offset">The byte offset in the <paramref name="buffer" />
    ///  array at which the bytes that are read will be placed.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///<returns>The total number of bytes that are read into <paramref name="buffer" />
    ///  . This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    ///<summary>Begins an asynchronous read operation.</summary>
    ///  <param name="buffer">The buffer to read data into.</param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  at which to begin reading.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///  <param name="callback">The method to call when the asynchronous read operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous read.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous read request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
    ///  <param name="buffer">The buffer that contains data to write to the pipe.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write to the current stream.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    ///<summary>Begins an asynchronous write operation.</summary>
    ///  <param name="buffer">The buffer that contains the data to write to the current stream.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write.</param>
    ///  <param name="callback">The method to call when the asynchronous write operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous write operation.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous write request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Flush;
    ///<summary>Sets the length of the current stream to the specified value.</summary>
    ///  <param name="value">The new length of the stream.</param>
    procedure SetLength(value: Int64);
    ///<summary>Sets the current position of the current stream to the specified value.</summary>
    ///  <param name="offset">The point, relative to <paramref name="origin" />
    ///  , to begin seeking from.</param>
    ///  <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />
    ///  , using a value of type <see cref="T:System.IO.SeekOrigin" />
    ///  .</param>
    ///<returns>The new position in the stream.</returns>
    function Seek(offset: Int64; origin: DDN.mscorlib.DNSeekOrigin): Int64;
    ///<summary>Reads a byte from a pipe.</summary>
    ///<returns>The byte, cast to <see cref="T:System.Int32" />
    ///  , or -1 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function ReadByte: Int32;
    ///<summary>Writes a byte to the current stream.</summary>
    ///  <param name="value">The byte to write to the stream.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WriteByte(value: Byte);
    ///<summary>Waits for the other end of the pipe to read all sent bytes.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WaitForPipeDrain;
    ///<summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    function GetAccessControl: DNPipeSecurity;
    ///<summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///  <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.ArgumentNullException"><paramref name="pipeSecurity" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    procedure SetAccessControl(pipeSecurity: DNPipeSecurity);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of server instances that share the same pipe name.</summary>
    ///<returns>The number of server instances that share the same pipe name.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe handle has not been set.-or-The current <see cref="T:System.IO.Pipes.NamedPipeClientStream" />
    ///  object has not yet connected to a <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  object.</exception><exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred.</exception><exception cref="T:System.ObjectDisposedException">The underlying pipe handle is closed.</exception>
    property NumberOfServerInstances: Int32 read get_NumberOfServerInstances;
    ///<summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected; otherwise, <see langword="false" />
    ///  .</returns>
    property IsConnected: Boolean read get_IsConnected;
    ///<summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously or synchronously.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously; otherwise, <see langword="false" />
    ///  .</returns>
    property IsAsync: Boolean read get_IsAsync;
    ///<summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
    ///<returns><see langword="true" />
    ///  if there are no more characters to read in the message; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe is not connected.-or-The pipe handle has not been set.-or-The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" />
    ///  property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property IsMessageComplete: Boolean read get_IsMessageComplete;
    ///<summary>Gets the pipe transmission mode supported by the current pipe.</summary>
    ///<returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  values that indicates the transmission mode supported by the current pipe.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect in an anonymous client/server operation or with a named client. </exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property TransmissionMode: DNPipeTransmissionMode read get_TransmissionMode;
    ///<summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
    ///<returns>An integer value that represents the inbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unreadable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property InBufferSize: Int32 read get_InBufferSize;
    ///<summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
    ///<returns>The outbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property OutBufferSize: Int32 read get_OutBufferSize;
    ///<summary>Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object reads from the pipe.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  value.</exception><exception cref="T:System.NotSupportedException">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  value for this pipe stream.</exception><exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect with a named client.</exception><exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred with a named client.</exception>
    property ReadMode: DNPipeTransmissionMode read get_ReadMode write set_ReadMode;
    ///<summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object encapsulates.</summary>
    ///<returns>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" />
    ///  object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property SafePipeHandle: DNSafePipeHandle read get_SafePipeHandle;
    ///<summary>Gets a value indicating whether the current stream supports read operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports read operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanRead: Boolean read get_CanRead;
    ///<summary>Gets a value indicating whether the current stream supports write operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports write operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanWrite: Boolean read get_CanWrite;
    ///<summary>Gets a value indicating whether the current stream supports seek operations.</summary>
    ///<returns><see langword="false" />
    ///  in all cases.</returns>
    property CanSeek: Boolean read get_CanSeek;
    ///<summary>Gets the length of a stream, in bytes.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Length: Int64 read get_Length;
    ///<summary>Gets or sets the current position of the current stream.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Position: Int64 read get_Position write set_Position;
    property CanTimeout: Boolean read get_CanTimeout;
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNNamedPipeClientStream = class(TDNGenericImport<DNNamedPipeClientStreamClass, DNNamedPipeClientStream>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNNamedPipeServerStreamClass = interface(DNPipeStreamClass)
  ['{7E2F268F-F8F6-51A3-BA55-7DC9DBBD6A97}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported. </exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name and pipe direction.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, and maximum number of server instances.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-A non-negative number is required.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )-or-
    ///<see cref="F:System.IO.HandleInheritability.None" />
    ///  or <see cref="F:System.IO.HandleInheritability.Inheritable" />
    ///  is required.-or-Access rights is limited to the <see cref="F:System.IO.Pipes.PipeAccessRights.ChangePermissions" />
    ///  , <see cref="F:System.IO.Pipes.PipeAccessRights.TakeOwnership" />
    ///  , and <see cref="F:System.IO.Pipes.PipeAccessRights.AccessSystemSecurity" />
    ///  flags.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, maximum number of server instances, and transmission mode.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///  <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32; transmissionMode: DNPipeTransmissionMode): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, and pipe options.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///  <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32; transmissionMode: DNPipeTransmissionMode; options: DNPipeOptions): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, and recommended in and out buffer sizes.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///  <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="inBufferSize">A positive value greater than 0 that indicates the input buffer size.</param>
    ///  <param name="outBufferSize">A positive value greater than 0 that indicates the output buffer size.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="inBufferSize" />
    ///  is negative.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32; transmissionMode: DNPipeTransmissionMode; options: DNPipeOptions; inBufferSize: Int32; outBufferSize: Int32): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, recommended in and out buffer sizes, and pipe security.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///  <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="inBufferSize">A positive value greater than 0 that indicates the input buffer size.</param>
    ///  <param name="outBufferSize">A positive value greater than 0 that indicates the output buffer size.</param>
    ///  <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="inBufferSize" />
    ///  is negative.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32; transmissionMode: DNPipeTransmissionMode; options: DNPipeOptions; inBufferSize: Int32; outBufferSize: Int32; pipeSecurity: DNPipeSecurity): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, recommended in and out buffer sizes, pipe security, and inheritability mode.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///  <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="inBufferSize">A positive value greater than 0 that indicates the input buffer size.</param>
    ///  <param name="outBufferSize">A positive value greater than 0 that indicates the output buffer size.</param>
    ///  <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="inBufferSize" />
    ///  is negative.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  value.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32; transmissionMode: DNPipeTransmissionMode; options: DNPipeOptions; inBufferSize: Int32; outBufferSize: Int32; pipeSecurity: DNPipeSecurity; inheritability: DNHandleInheritability): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, recommended in and out buffer sizes, pipe security, inheritability mode, and pipe access rights.</summary>
    ///  <param name="pipeName">The name of the pipe.</param>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  for this value.</param>
    ///  <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
    ///  <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
    ///  <param name="inBufferSize">The input buffer size.</param>
    ///  <param name="outBufferSize">The output buffer size.</param>
    ///  <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
    ///  <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes.</param>
    ///  <param name="additionalAccessRights">One of the enumeration values that specifies the access rights of the pipe.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="pipeName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="pipeName" />
    ///  is a zero-length string.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="pipeName" />
    ///  is set to "anonymous".-or-
    ///  <paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.-or-
    ///  <paramref name="maxNumberofServerInstances" />
    ///  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />
    ///  )-or-
    ///  <paramref name="options" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeOptions" />
    ///  value.-or-
    ///  <paramref name="inBufferSize" />
    ///  is negative.-or-
    ///  <paramref name="inheritability" />
    ///  is not a valid <see cref="T:System.IO.HandleInheritability" />
    ///  value.-or-
    ///  <paramref name="additionalAccessRights" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  value.</exception><exception cref="T:System.NotSupportedException"><paramref name="pipeName" />
    ///  contains a colon (":").</exception><exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception><exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
    {class} function init(pipeName: string; direction: DNPipeDirection; maxNumberOfServerInstances: Int32; transmissionMode: DNPipeTransmissionMode; options: DNPipeOptions; inBufferSize: Int32; outBufferSize: Int32; pipeSecurity: DNPipeSecurity; inheritability: DNHandleInheritability; additionalAccessRights: DNPipeAccessRights): DNNamedPipeServerStream; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  class from the specified pipe handle.</summary>
    ///  <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
    ///  <param name="isAsync"><see langword="true" />
    ///  to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="isConnected"><see langword="true" />
    ///  to indicate that the pipe is connected; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="safePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  object will encapsulate.</param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="direction" />
    ///  is not a valid <see cref="T:System.IO.Pipes.PipeDirection" />
    ///  value.</exception><exception cref="T:System.ArgumentNullException"><paramref name="safePipeHandle" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="safePipeHandle" />
    ///  is an invalid handle.</exception><exception cref="T:System.IO.IOException"><paramref name="safePipeHandle" />
    ///  is not a valid pipe handle.-or-The maximum number of server instances has been exceeded.</exception>
    {class} function init(direction: DNPipeDirection; isAsync: Boolean; isConnected: Boolean; safePipeHandle: DNSafePipeHandle): DNNamedPipeServerStream; overload;

  end;

  ///<summary>Exposes a <see cref="T:System.IO.Stream" />
  ///  around a named pipe, supporting both synchronous and asynchronous read and write operations.</summary>
  [DNTypeName('System.IO.Pipes.NamedPipeServerStream')]
  DNNamedPipeServerStream = interface(DNPipeStream)
  ['{EEE4B52F-087D-3660-8637-0CD5D6568F66}']
  { getters & setters } 

    function get_IsConnected: Boolean;
    function get_IsAsync: Boolean;
    function get_IsMessageComplete: Boolean;
    function get_TransmissionMode: DNPipeTransmissionMode;
    function get_InBufferSize: Int32;
    function get_OutBufferSize: Int32;
    function get_ReadMode: DNPipeTransmissionMode;
    procedure set_ReadMode(value: DNPipeTransmissionMode);
    function get_SafePipeHandle: DNSafePipeHandle;
    function get_CanRead: Boolean;
    function get_CanWrite: Boolean;
    function get_CanSeek: Boolean;
    function get_Length: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_CanTimeout: Boolean;
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>Waits for a client to connect to this <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  object.</summary>
    ///<exception cref="T:System.InvalidOperationException">A pipe connection has already been established.-or-The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception>
    procedure WaitForConnection;
    ///<summary>Asynchronously waits for a client to connect to this <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  object and monitors cancellation requests.</summary>
    ///  <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    ///<returns>A task that represents the asynchronous wait operation.</returns>
    function WaitForConnectionAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously waits for a client to connect to this <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  object.</summary>
    ///<returns>A task that represents the asynchronous wait operation.</returns>
    function WaitForConnectionAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>Begins an asynchronous operation to wait for a client to connect.</summary>
    ///  <param name="callback">The method to call when a client connects to the <see cref="T:System.IO.Pipes.NamedPipeServerStream" />
    ///  object.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous request from other requests.</param>
    ///<returns>An object that references the asynchronous request.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe was not opened asynchronously.-or-A pipe connection has already been established.-or-The pipe handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    function BeginWaitForConnection(callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends an asynchronous operation to wait for a client to connect.</summary>
    ///  <param name="asyncResult">The pending asynchronous request.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The pipe was not opened asynchronously.-or-The pipe handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    procedure EndWaitForConnection(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Disconnects the current connection.</summary>
    ///<exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.-or-The connected pipe has already disconnected.-or-The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    procedure Disconnect;
    ///<summary>Calls a delegate while impersonating the client.</summary>
    ///  <param name="impersonationWorker">The delegate that specifies a method to call.</param>
    ///<exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.-or-The connected pipe has already disconnected.-or-The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.IO.IOException">The pipe connection has been broken.-or-An I/O error occurred.</exception>
    procedure RunAsClient(impersonationWorker: DNPipeStreamImpersonationWorker);
    ///<summary>Gets the user name of the client on the other end of the pipe.</summary>
    ///<returns>The user name of the client on the other end of the pipe.</returns>
    ///<exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.-or-The connected pipe has already disconnected.-or-The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.IO.IOException">The pipe connection has been broken.-or-The user name of the client is longer than 19 characters.</exception>
    function GetImpersonationUserName: string;
    ///<summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
    ///  <param name="buffer">When this method returns, contains the specified byte array with the values between <paramref name="offset" />
    ///  and (<paramref name="offset" />
    ///  + <paramref name="count" />
    ///  - 1) replaced by the bytes read from the current source.</param>
    ///  <param name="offset">The byte offset in the <paramref name="buffer" />
    ///  array at which the bytes that are read will be placed.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///<returns>The total number of bytes that are read into <paramref name="buffer" />
    ///  . This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    ///<summary>Begins an asynchronous read operation.</summary>
    ///  <param name="buffer">The buffer to read data into.</param>
    ///  <param name="offset">The byte offset in <paramref name="buffer" />
    ///  at which to begin reading.</param>
    ///  <param name="count">The maximum number of bytes to read.</param>
    ///  <param name="callback">The method to call when the asynchronous read operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous read.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous read request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    ///<summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
    ///  <param name="buffer">The buffer that contains data to write to the pipe.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write to the current stream.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    ///<summary>Begins an asynchronous write operation.</summary>
    ///  <param name="buffer">The buffer that contains the data to write to the current stream.</param>
    ///  <param name="offset">The zero-based byte offset in <paramref name="buffer" />
    ///  at which to begin copying bytes to the current stream.</param>
    ///  <param name="count">The maximum number of bytes to write.</param>
    ///  <param name="callback">The method to call when the asynchronous write operation is completed.</param>
    ///  <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
    ///<returns>An <see cref="T:System.IAsyncResult" />
    ///  object that references the asynchronous write operation.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than 0.-or-
    ///  <paramref name="count" />
    ///  is less than 0.</exception><exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the number of bytes available in <paramref name="buffer" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    ///<summary>Ends a pending asynchronous write request.</summary>
    ///  <param name="asyncResult">The reference to the pending asynchronous request.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult" />
    ///  did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
    ///  method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    ///<summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure Flush;
    ///<summary>Sets the length of the current stream to the specified value.</summary>
    ///  <param name="value">The new length of the stream.</param>
    procedure SetLength(value: Int64);
    ///<summary>Sets the current position of the current stream to the specified value.</summary>
    ///  <param name="offset">The point, relative to <paramref name="origin" />
    ///  , to begin seeking from.</param>
    ///  <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />
    ///  , using a value of type <see cref="T:System.IO.SeekOrigin" />
    ///  .</param>
    ///<returns>The new position in the stream.</returns>
    function Seek(offset: Int64; origin: DDN.mscorlib.DNSeekOrigin): Int64;
    ///<summary>Reads a byte from a pipe.</summary>
    ///<returns>The byte, cast to <see cref="T:System.Int32" />
    ///  , or -1 indicates the end of the stream (the pipe has been closed).</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
    function ReadByte: Int32;
    ///<summary>Writes a byte to the current stream.</summary>
    ///  <param name="value">The byte to write to the stream.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WriteByte(value: Byte);
    ///<summary>Waits for the other end of the pipe to read all sent bytes.</summary>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    procedure WaitForPipeDrain;
    ///<summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    function GetAccessControl: DNPipeSecurity;
    ///<summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///  <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.ArgumentNullException"><paramref name="pipeSecurity" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception><exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception><exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
    procedure SetAccessControl(pipeSecurity: DNPipeSecurity);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object is connected; otherwise, <see langword="false" />
    ///  .</returns>
    property IsConnected: Boolean read get_IsConnected;
    ///<summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously or synchronously.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object was opened asynchronously; otherwise, <see langword="false" />
    ///  .</returns>
    property IsAsync: Boolean read get_IsAsync;
    ///<summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
    ///<returns><see langword="true" />
    ///  if there are no more characters to read in the message; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe is not connected.-or-The pipe handle has not been set.-or-The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" />
    ///  property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property IsMessageComplete: Boolean read get_IsMessageComplete;
    ///<summary>Gets the pipe transmission mode supported by the current pipe.</summary>
    ///<returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  values that indicates the transmission mode supported by the current pipe.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception><exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect in an anonymous client/server operation or with a named client. </exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property TransmissionMode: DNPipeTransmissionMode read get_TransmissionMode;
    ///<summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
    ///<returns>An integer value that represents the inbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unreadable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property InBufferSize: Int32 read get_InBufferSize;
    ///<summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
    ///<returns>The outbound buffer size, in bytes.</returns>
    ///<exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception><exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception><exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
    property OutBufferSize: Int32 read get_OutBufferSize;
    ///<summary>Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</summary>
    ///<returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object reads from the pipe.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  value.</exception><exception cref="T:System.NotSupportedException">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" />
    ///  value for this pipe stream.</exception><exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect with a named client.</exception><exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred with a named client.</exception>
    property ReadMode: DNPipeTransmissionMode read get_ReadMode write set_ReadMode;
    ///<summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object encapsulates.</summary>
    ///<returns>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" />
    ///  object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception><exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
    property SafePipeHandle: DNSafePipeHandle read get_SafePipeHandle;
    ///<summary>Gets a value indicating whether the current stream supports read operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports read operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanRead: Boolean read get_CanRead;
    ///<summary>Gets a value indicating whether the current stream supports write operations.</summary>
    ///<returns><see langword="true" />
    ///  if the stream supports write operations; otherwise, <see langword="false" />
    ///  .</returns>
    property CanWrite: Boolean read get_CanWrite;
    ///<summary>Gets a value indicating whether the current stream supports seek operations.</summary>
    ///<returns><see langword="false" />
    ///  in all cases.</returns>
    property CanSeek: Boolean read get_CanSeek;
    ///<summary>Gets the length of a stream, in bytes.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Length: Int64 read get_Length;
    ///<summary>Gets or sets the current position of the current stream.</summary>
    ///<returns>0 in all cases.</returns>
    ///<exception cref="T:System.NotSupportedException">Always thrown.</exception>
    property Position: Int64 read get_Position write set_Position;
    property CanTimeout: Boolean read get_CanTimeout;
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNNamedPipeServerStream = class(TDNGenericImport<DNNamedPipeServerStreamClass, DNNamedPipeServerStream>)
  public const
    ///<summary>Represents the maximum number of server instances that the system resources allow.</summary>
   MaxAllowedServerInstances = -1;
  end;

  //-------------namespace: System.IO.MemoryMappedFiles----------------
  DNMemoryMappedViewStreamClass = interface(DDN.mscorlib.DNUnmanagedMemoryStreamClass)
  ['{CBD98D5D-5589-5DAA-BA9B-6C12C43FA3ED}']
  end;

  ///<summary>Represents a view of a memory-mapped file as a sequentially accessed stream.</summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedViewStream')]
  DNMemoryMappedViewStream = interface(DDN.mscorlib.DNUnmanagedMemoryStream)
  ['{63C140CE-8AE0-3B66-A1FF-1F58E7EC6125}']
  { getters & setters } 

    function get_SafeMemoryMappedViewHandle: DNSafeMemoryMappedViewHandle;
    function get_PointerOffset: Int64;
    function get_CanRead: Boolean;
    function get_CanSeek: Boolean;
    function get_CanWrite: Boolean;
    function get_Length: Int64;
    function get_Capacity: Int64;
    function get_Position: Int64;
    procedure set_Position(value: Int64);
    function get_PositionPointer: PByte;
    procedure set_PositionPointer(value: PByte);
    function get_CanTimeout: Boolean;
    function get_ReadTimeout: Int32;
    procedure set_ReadTimeout(value: Int32);
    function get_WriteTimeout: Int32;
    procedure set_WriteTimeout(value: Int32);

  { methods } 

    ///<summary>Sets the length of the current stream.</summary>
    ///  <param name="value">The desired length of the current stream in bytes.</param>
    ///<exception cref="T:System.NotSupportedException">This method is not supported.</exception>
    procedure SetLength(value: Int64);
    ///<summary>Clears all buffers for this stream and causes any buffered data to be written to the underlying file.</summary>
    procedure Flush;
    function Read(buffer: TArray<Byte>; offset: Int32; count: Int32): Int32;
    function ReadByte: Int32;
    function FlushAsync(cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask<Int32>; overload;
    function Seek(offset: Int64; loc: DDN.mscorlib.DNSeekOrigin): Int64;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Write(buffer: TArray<Byte>; offset: Int32; count: Int32);
    procedure WriteByte(value: Byte);
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32; cancellationToken: DDN.mscorlib.DNCancellationToken): DDN.mscorlib.DNTask; overload;
    procedure Close;
    procedure Dispose;
    function BeginRead(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    function EndRead(asyncResult: DDN.mscorlib.DNIAsyncResult): Int32;
    function BeginWrite(buffer: TArray<Byte>; offset: Int32; count: Int32; callback: DDN.mscorlib.DNAsyncCallback; state: DDN.mscorlib.DNObject): DDN.mscorlib.DNIAsyncResult;
    procedure EndWrite(asyncResult: DDN.mscorlib.DNIAsyncResult);
    function CopyToAsync(destination: DDN.mscorlib.DNStream): DDN.mscorlib.DNTask; overload;
    function CopyToAsync(destination: DDN.mscorlib.DNStream; bufferSize: Int32): DDN.mscorlib.DNTask; overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream); overload;
    procedure CopyTo(destination: DDN.mscorlib.DNStream; bufferSize: Int32); overload;
    function FlushAsync: DDN.mscorlib.DNTask; overload;
    function ReadAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>; overload;
    function WriteAsync(buffer: TArray<Byte>; offset: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    function GetLifetimeService: DDN.mscorlib.DNObject;
    function InitializeLifetimeService: DDN.mscorlib.DNObject;
    function CreateObjRef(requestedType: DDN.mscorlib.DNType): DDN.mscorlib.DNObjRef;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a handle to the view of a memory-mapped file.</summary>
    ///<returns>A wrapper for the operating system's handle to the view of the file. </returns>
    property SafeMemoryMappedViewHandle: DNSafeMemoryMappedViewHandle read get_SafeMemoryMappedViewHandle;
    ///<summary>[Supported in the .NET Framework 4.5.1 and later versions] Gets the number of bytes by which the starting position of this view is offset from the beginning of the memory-mapped file.</summary>
    ///<returns>The number of bytes between the starting position of this view and the beginning of the memory-mapped file. </returns>
    ///<exception cref="T:System.InvalidOperationException">The object from which this instance was created is <see langword="null" />
    ///  . </exception>
    property PointerOffset: Int64 read get_PointerOffset;
    property CanRead: Boolean read get_CanRead;
    property CanSeek: Boolean read get_CanSeek;
    property CanWrite: Boolean read get_CanWrite;
    property Length: Int64 read get_Length;
    property Capacity: Int64 read get_Capacity;
    property Position: Int64 read get_Position write set_Position;
    property PositionPointer: PByte read get_PositionPointer write set_PositionPointer;
    property CanTimeout: Boolean read get_CanTimeout;
    property ReadTimeout: Int32 read get_ReadTimeout write set_ReadTimeout;
    property WriteTimeout: Int32 read get_WriteTimeout write set_WriteTimeout;
  end;

  TDNMemoryMappedViewStream = class(TDNGenericImport<DNMemoryMappedViewStreamClass, DNMemoryMappedViewStream>) end;

  //-------------namespace: System.Runtime.InteropServices----------------
  DNComAwareEventInfoClass = interface(DDN.mscorlib.DNEventInfoClass)
  ['{65F48C0B-8FB0-5AF1-9FA7-0B2BBFC8B5C7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.ComAwareEventInfo" />
    ///  class by using the specified type and a name of the event on the type.</summary>
    ///  <param name="type">The type of object.</param>
    ///  <param name="eventName">The name of an event on <paramref name="type" />
    ///  .</param>
    {class} function init(&type: DDN.mscorlib.DNType; eventName: string): DNComAwareEventInfo;

  end;

  ///<summary>Permits late-bound registration of an event handler.</summary>
  [DNTypeName('System.Runtime.InteropServices.ComAwareEventInfo')]
  DNComAwareEventInfo = interface(DDN.mscorlib.DNEventInfo)
  ['{BA1F0751-BB5A-34C6-A927-CB44517C154F}']
  { getters & setters } 

    function get_Attributes: DDN.mscorlib.DNEventAttributes;
    function get_DeclaringType: DDN.mscorlib.DNType;
    function get_Name: string;
    function get_ReflectedType: DDN.mscorlib.DNType;
    function get_MemberType: DDN.mscorlib.DNMemberTypes;
    function get_AddMethod: DDN.mscorlib.DNMethodInfo;
    function get_RemoveMethod: DDN.mscorlib.DNMethodInfo;
    function get_RaiseMethod: DDN.mscorlib.DNMethodInfo;
    function get_EventHandlerType: DDN.mscorlib.DNType;
    function get_IsSpecialName: Boolean;
    function get_IsMulticast: Boolean;
    function get_CustomAttributes: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNCustomAttributeData>;
    function get_MetadataToken: Int32;
    function get_Module: DDN.mscorlib.DNModule;

  { methods } 

    ///<summary>Attaches an event handler to a COM object.</summary>
    ///  <param name="target">The target object that the event delegate should bind to.</param>
    ///  <param name="handler">The event delegate.</param>
    procedure AddEventHandler(target: DDN.mscorlib.DNObject; handler: DDN.mscorlib.DNDelegate);
    ///<summary>Detaches an event handler from a COM object.</summary>
    ///  <param name="target">The target object that the event delegate is bound to.</param>
    ///  <param name="handler">The event delegate.</param>
    ///<exception cref="T:System.InvalidOperationException">The event does not have a public <see langword="remove" />
    ///  accessor.</exception><exception cref="T:System.ArgumentException">The handler that was passed in cannot be used.</exception><exception cref="T:System.Reflection.TargetException">
    ///  In the .NET for Windows Store apps or the Portable Class Library, catch <see cref="T:System.Exception" />
    ///  instead.The <paramref name="target" />
    ///  parameter is <see langword="null" />
    ///  and the event is not static.-or- The <see cref="T:System.Reflection.EventInfo" />
    ///  is not declared on the target.</exception><exception cref="T:System.MethodAccessException">
    ///  In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception, <see cref="T:System.MemberAccessException" />
    ///  , instead.The caller does not have access permission to the member.</exception>
    procedure RemoveEventHandler(target: DDN.mscorlib.DNObject; handler: DDN.mscorlib.DNDelegate);
    ///<summary>Gets the method that was used to add an event handler delegate to the event source.</summary>
    ///  <param name="nonPublic"><see langword="true" />
    ///  to return non-public methods; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The method that was used to add an event handler delegate to the event source.</returns>
    ///<exception cref="T:System.MethodAccessException"><paramref name="nonPublic" />
    ///  is <see langword="true" />
    ///  and the method used to add an event handler delegate is non-public, but the caller does not have permission to reflect on non-public methods.</exception>
    function GetAddMethod(nonPublic: Boolean): DDN.mscorlib.DNMethodInfo; overload;
    ///<summary>When overridden in a derived class, returns the method that was called when the event was raised.</summary>
    ///  <param name="nonPublic"><see langword="true" />
    ///  to return non-public methods; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>The object that was called when the event was raised.</returns>
    ///<exception cref="T:System.MethodAccessException"><paramref name="nonPublic" />
    ///  is <see langword="true" />
    ///  and the method used to add an event handler delegate is non-public, but the caller does not have permission to reflect on non-public methods. </exception>
    function GetRaiseMethod(nonPublic: Boolean): DDN.mscorlib.DNMethodInfo; overload;
    ///<summary>When overridden in a derived class, retrieves the <see cref="T:System.Reflection.MethodInfo" />
    ///  object for removing a method of the event.</summary>
    ///  <param name="nonPublic"><see langword="true" />
    ///  to return non-public methods; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>The method that was used to remove an event handler delegate from the event source.</returns>
    ///<exception cref="T:System.MethodAccessException"><paramref name="nonPublic" />
    ///  is <see langword="true" />
    ///  and the method used to add an event handler delegate is non-public, but the caller does not have permission to reflect on non-public methods. </exception>
    function GetRemoveMethod(nonPublic: Boolean): DDN.mscorlib.DNMethodInfo; overload;
    ///<summary>When overridden in a derived class, gets an array that contains all the custom attributes of the specified type that are applied to this member.</summary>
    ///  <param name="attributeType">The attribute type to search for. Only attributes that are assignable to this type can be returned.</param>
    ///  <param name="inherit"><see langword="true" />
    ///  to search this member's inheritance chain to find the attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An array that contains all the custom attributes of the specified type, or an array that has no elements if no attributes were defined.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="attributeType" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context</exception><exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded.</exception>
    function GetCustomAttributes(attributeType: DDN.mscorlib.DNType; inherit: Boolean): TArray<DDN.mscorlib.DNObject>; overload;
    ///<summary>When overridden in a derived class, gets an array that contains all the custom attributes that are applied to this member.</summary>
    ///  <param name="inherit"><see langword="true" />
    ///  to search this member's inheritance chain to find the attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An array that contains all the custom attributes, or an array that has no elements if no attributes were defined.</returns>
    ///<exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception><exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded.</exception>
    function GetCustomAttributes(inherit: Boolean): TArray<DDN.mscorlib.DNObject>; overload;
    ///<summary>Indicates whether one or more instances of the specified attribute are applied to this member.</summary>
    ///  <param name="attributeType">The attribute type to search for.</param>
    ///  <param name="inherit"><see langword="true" />
    ///  to search this member's inheritance chain to find the attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the specified attribute has been applied to this member; otherwise, <see langword="false" />
    ///  .</returns>
    function IsDefined(attributeType: DDN.mscorlib.DNType; inherit: Boolean): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetOtherMethods(nonPublic: Boolean): TArray<DDN.mscorlib.DNMethodInfo>; overload;
    function GetOtherMethods: TArray<DDN.mscorlib.DNMethodInfo>; overload;
    function GetAddMethod: DDN.mscorlib.DNMethodInfo; overload;
    function GetRemoveMethod: DDN.mscorlib.DNMethodInfo; overload;
    function GetRaiseMethod: DDN.mscorlib.DNMethodInfo; overload;
    function GetCustomAttributesData: DDN.mscorlib.DNIList<DDN.mscorlib.DNCustomAttributeData>;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the attributes for this event.</summary>
    ///<returns>The read-only attributes for this event.</returns>
    property Attributes: DDN.mscorlib.DNEventAttributes read get_Attributes;
    ///<summary>Gets the class that declares this member.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object for the class that declares this member.</returns>
    property DeclaringType: DDN.mscorlib.DNType read get_DeclaringType;
    ///<summary>Gets the name of the current member.</summary>
    ///<returns>The name of this member.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the class object that was used to initialize this instance.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object that was used to initialize the current object.</returns>
    property ReflectedType: DDN.mscorlib.DNType read get_ReflectedType;
    property MemberType: DDN.mscorlib.DNMemberTypes read get_MemberType;
    property AddMethod: DDN.mscorlib.DNMethodInfo read get_AddMethod;
    property RemoveMethod: DDN.mscorlib.DNMethodInfo read get_RemoveMethod;
    property RaiseMethod: DDN.mscorlib.DNMethodInfo read get_RaiseMethod;
    property EventHandlerType: DDN.mscorlib.DNType read get_EventHandlerType;
    property IsSpecialName: Boolean read get_IsSpecialName;
    property IsMulticast: Boolean read get_IsMulticast;
    property CustomAttributes: DDN.mscorlib.DNIEnumerable<DDN.mscorlib.DNCustomAttributeData> read get_CustomAttributes;
    property MetadataToken: Int32 read get_MetadataToken;
    property Module: DDN.mscorlib.DNModule read get_Module;
  end;

  TDNComAwareEventInfo = class(TDNGenericImport<DNComAwareEventInfoClass, DNComAwareEventInfo>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNCallSiteClass = interface(DDN.mscorlib.DNObjectClass)
  ['{CF5BB585-7D2C-5820-9CED-5D7625C9CE98}']
  { static methods } 

    ///<summary>Creates a call site with the given delegate type and binder.</summary>
    ///  <param name="delegateType">The call site delegate type.</param>
    ///  <param name="binder">The call site binder.</param>
    ///<returns>The new call site.</returns>
    {class} function Create(delegateType: DDN.mscorlib.DNType; binder: DNCallSiteBinder): DNCallSite;

  end;

  ///<summary>A dynamic call site base class. This type is used as a parameter type to the dynamic site targets.</summary>
  [DNTypeName('System.Runtime.CompilerServices.CallSite')]
  DNCallSite = interface(DDN.mscorlib.DNObject)
  ['{4D1003B0-101E-3F22-8385-B9EC933241F4}']
  { getters & setters } 

    function get_Binder: DNCallSiteBinder;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Class responsible for binding dynamic operations on the dynamic site.</summary>
    ///<returns>The <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  object responsible for binding dynamic operations.</returns>
    property Binder: DNCallSiteBinder read get_Binder;
  end;

  TDNCallSite = class(TDNGenericImport<DNCallSiteClass, DNCallSite>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNCallSiteClass<T> = interface(DNCallSiteClass)
  ['{9E2D81D5-337E-5090-BABD-C98E8AEFB481}']
  { static methods } 

    ///<summary>Creates an instance of the dynamic call site, initialized with the binder responsible for the runtime binding of the dynamic operations at this call site.</summary>
    ///  <param name="binder">The binder responsible for the runtime binding of the dynamic operations at this call site.</param>
    ///<returns>The new instance of dynamic call site.</returns>
    {class} function Create(binder: DNCallSiteBinder): DNCallSite<T>;

  end;

  ///<summary>Dynamic site type.</summary>
  ///<typeparam name="T">The delegate type.</typeparam>
  [DNTypeName('System.Runtime.CompilerServices.CallSite`1')]
  DNCallSite<T> = interface(DNCallSite)
  ['{075CCE7B-3A5F-3A98-9152-D4434E4DA73A}']
  { getters & setters } 

    function get_Update: T;
    function get_Binder: DNCallSiteBinder;

  { fields getter & setter } 

   function __fakeFieldGet_Target: T;
   procedure __fakeFieldSet_Target(value: T);

  { fields } 

    ///<summary>The Level 0 cache - a delegate specialized based on the site history.</summary>
   property Target: T read __fakeFieldGet_Target write __fakeFieldSet_Target;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The update delegate. Called when the dynamic site experiences cache miss.</summary>
    ///<returns>The update delegate.</returns>
    property Update: T read get_Update;
    ///<summary>Class responsible for binding dynamic operations on the dynamic site.</summary>
    ///<returns>The <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />
    ///  object responsible for binding dynamic operations.</returns>
    property Binder: DNCallSiteBinder read get_Binder;
  end;

  TDNCallSite<T> = class(TDNGenericImport<DNCallSiteClass<T>, DNCallSite<T>>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNCallSiteBinderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{34462BF9-1452-57B3-8E16-F9899ACF6DAB}']
  { static getter & setter } 

    {class} function get_UpdateLabel: DNLabelTarget;

  { static propertys } 

    ///<summary>Gets a label that can be used to cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.LabelTarget" />
    ///  object representing a label that can be used to trigger the binding update.</returns>
    {class} property UpdateLabel: DNLabelTarget read get_UpdateLabel;
  end;

  ///<summary>Class responsible for runtime binding of the dynamic operations on the dynamic call site.</summary>
  [DNTypeName('System.Runtime.CompilerServices.CallSiteBinder')]
  DNCallSiteBinder = interface(DDN.mscorlib.DNObject)
  ['{BCD9EDA4-1357-3A60-9EA1-6355DBD5BF0C}']
  { methods } 

    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNCallSiteBinder = class(TDNGenericImport<DNCallSiteBinderClass, DNCallSiteBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNDynamicMetaObjectBinderClass = interface(DNCallSiteBinderClass)
  ['{A6A76F5F-9880-5131-B78B-B7867857703B}']
  end;

  ///<summary>The dynamic call site binder that participates in the <see cref="T:System.Dynamic.DynamicMetaObject" />
  ///  binding protocol.</summary>
  [DNTypeName('System.Dynamic.DynamicMetaObjectBinder')]
  DNDynamicMetaObjectBinder = interface(DNCallSiteBinder)
  ['{6A983AD6-7E2D-3D4C-8EAA-FD2034A3E964}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;

  { methods } 

    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic operation.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
  end;

  TDNDynamicMetaObjectBinder = class(TDNGenericImport<DNDynamicMetaObjectBinderClass, DNDynamicMetaObjectBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNBinaryOperationBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{BA8D570D-6856-58AC-A568-8DE00E735847}']
  end;

  ///<summary>Represents the binary dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.BinaryOperationBinder')]
  DNBinaryOperationBinder = interface(DNDynamicMetaObjectBinder)
  ['{8ED92572-3BA2-3C0A-A0FA-141CB95C920D}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_Operation: DNExpressionType;

  { methods } 

    ///<summary>Performs the binding of the binary dynamic operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic binary operation.</param>
    ///  <param name="arg">The right hand side operand of the dynamic binary operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackBinaryOperation(target: DNDynamicMetaObject; arg: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic binary operation.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the binary dynamic operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic binary operation.</param>
    ///  <param name="arg">The right hand side operand of the dynamic binary operation.</param>
    ///  <param name="errorSuggestion">The binding result if the binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackBinaryOperation(target: DNDynamicMetaObject; arg: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>The binary operation kind.</summary>
    ///<returns>The <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  object representing the kind of binary operation.</returns>
    property Operation: DNExpressionType read get_Operation;
  end;

  TDNBinaryOperationBinder = class(TDNGenericImport<DNBinaryOperationBinderClass, DNBinaryOperationBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNConvertBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{68C2C489-7CC0-5997-9D4C-688617763E83}']
  end;

  ///<summary>Represents the convert dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.ConvertBinder')]
  DNConvertBinder = interface(DNDynamicMetaObjectBinder)
  ['{973E6069-DD67-316A-B894-42302D1B1E2F}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    function get_Explicit: Boolean;
    function get_ReturnType: DDN.mscorlib.DNType;

  { methods } 

    ///<summary>Performs the binding of the dynamic convert operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic convert operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackConvert(target: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic convert operation.</summary>
    ///  <param name="target">The target of the dynamic convert operation.</param>
    ///  <param name="args">An array of arguments of the dynamic convert operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic convert operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic convert operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackConvert(target: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The type to convert to.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object that represents the type to convert to.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type;
    ///<summary>Gets the value indicating if the conversion should consider explicit conversions.</summary>
    ///<returns><see langword="True" />
    ///  if there is an explicit conversion, otherwise <see langword="false" />
    ///  .</returns>
    property Explicit: Boolean read get_Explicit;
    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
  end;

  TDNConvertBinder = class(TDNGenericImport<DNConvertBinderClass, DNConvertBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNCreateInstanceBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{5E3B6808-F825-56EE-A339-6BC569483010}']
  end;

  ///<summary>Represents the dynamic create operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.CreateInstanceBinder')]
  DNCreateInstanceBinder = interface(DNDynamicMetaObjectBinder)
  ['{18AFA6C3-B588-374F-9FF3-39F79F0B0A3B}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_CallInfo: DNCallInfo;

  { methods } 

    ///<summary>Performs the binding of the dynamic create operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic create operation.</param>
    ///  <param name="args">The arguments of the dynamic create operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackCreateInstance(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic create operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic create operation.</param>
    ///  <param name="args">The arguments of the dynamic create operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackCreateInstance(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic create operation.</summary>
    ///  <param name="target">The target of the dynamic create operation.</param>
    ///  <param name="args">An array of arguments of the dynamic create operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the signature of the arguments at the call site.</summary>
    ///<returns>The signature of the arguments at the call site.</returns>
    property CallInfo: DNCallInfo read get_CallInfo;
  end;

  TDNCreateInstanceBinder = class(TDNGenericImport<DNCreateInstanceBinderClass, DNCreateInstanceBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNDeleteIndexBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{8ACCC0E5-0014-58C6-A0E8-1E8BBB869D49}']
  end;

  ///<summary>Represents the dynamic delete index operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.DeleteIndexBinder')]
  DNDeleteIndexBinder = interface(DNDynamicMetaObjectBinder)
  ['{CC51734E-887B-3AF6-AB1A-3C417974430E}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_CallInfo: DNCallInfo;

  { methods } 

    ///<summary>Performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic delete index operation.</param>
    ///  <param name="indexes">The arguments of the dynamic delete index operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackDeleteIndex(target: DNDynamicMetaObject; indexes: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic delete index operation.</summary>
    ///  <param name="target">The target of the dynamic delete index operation.</param>
    ///  <param name="args">An array of arguments of the dynamic delete index operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic delete index operation.</param>
    ///  <param name="indexes">The arguments of the dynamic delete index operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackDeleteIndex(target: DNDynamicMetaObject; indexes: TArray<DNDynamicMetaObject>; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the signature of the arguments at the call site.</summary>
    ///<returns>The signature of the arguments at the call site.</returns>
    property CallInfo: DNCallInfo read get_CallInfo;
  end;

  TDNDeleteIndexBinder = class(TDNGenericImport<DNDeleteIndexBinderClass, DNDeleteIndexBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNDeleteMemberBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{6B9B9B85-E9D0-53F2-95DE-5D8EF23C2785}']
  end;

  ///<summary>Represents the dynamic delete member operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.DeleteMemberBinder')]
  DNDeleteMemberBinder = interface(DNDynamicMetaObjectBinder)
  ['{A079571A-181F-3F2F-A556-8CDEBC1621B2}']
  { getters & setters } 

    function get_Name: string;
    function get_IgnoreCase: Boolean;
    function get_ReturnType: DDN.mscorlib.DNType;

  { methods } 

    ///<summary>Performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic delete member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackDeleteMember(target: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic delete member operation.</summary>
    ///  <param name="target">The target of the dynamic delete member operation.</param>
    ///  <param name="args">An array of arguments of the dynamic delete member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic delete member operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackDeleteMember(target: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the member to delete.</summary>
    ///<returns>The name of the member to delete.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
    ///<returns>True if the string comparison should ignore the case, otherwise false.</returns>
    property IgnoreCase: Boolean read get_IgnoreCase;
    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
  end;

  TDNDeleteMemberBinder = class(TDNGenericImport<DNDeleteMemberBinderClass, DNDeleteMemberBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNGetIndexBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{53780E3C-7403-58B9-8634-8180CDE79977}']
  end;

  ///<summary>Represents the dynamic get index operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.GetIndexBinder')]
  DNGetIndexBinder = interface(DNDynamicMetaObjectBinder)
  ['{5AD435E4-178B-32C4-A0AE-F4075DE49C43}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_CallInfo: DNCallInfo;

  { methods } 

    ///<summary>Performs the binding of the dynamic get index operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic get index operation.</param>
    ///  <param name="indexes">The arguments of the dynamic get index operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackGetIndex(target: DNDynamicMetaObject; indexes: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic get index operation.</summary>
    ///  <param name="target">The target of the dynamic get index operation.</param>
    ///  <param name="args">An array of arguments of the dynamic get index operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic get index operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic get index operation.</param>
    ///  <param name="indexes">The arguments of the dynamic get index operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackGetIndex(target: DNDynamicMetaObject; indexes: TArray<DNDynamicMetaObject>; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the signature of the arguments at the call site.</summary>
    ///<returns>The signature of the arguments at the call site.</returns>
    property CallInfo: DNCallInfo read get_CallInfo;
  end;

  TDNGetIndexBinder = class(TDNGenericImport<DNGetIndexBinderClass, DNGetIndexBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNGetMemberBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{075F6E9F-CAA5-5CAD-BDD0-38A378E34FC2}']
  end;

  ///<summary>Represents the dynamic get member operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.GetMemberBinder')]
  DNGetMemberBinder = interface(DNDynamicMetaObjectBinder)
  ['{76C49417-49E8-301F-BDE1-7A8BCB1C27FB}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_Name: string;
    function get_IgnoreCase: Boolean;

  { methods } 

    ///<summary>Performs the binding of the dynamic get member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic get member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackGetMember(target: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic get member operation.</summary>
    ///  <param name="target">The target of the dynamic get member operation.</param>
    ///  <param name="args">An array of arguments of the dynamic get member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic get member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic get member operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackGetMember(target: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the name of the member to obtain.</summary>
    ///<returns>The name of the member to obtain.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
    ///<returns>True if the case is ignored, otherwise false.</returns>
    property IgnoreCase: Boolean read get_IgnoreCase;
  end;

  TDNGetMemberBinder = class(TDNGenericImport<DNGetMemberBinderClass, DNGetMemberBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNInvokeBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{467A2FAE-A5A2-501A-82B4-353C9E365BDA}']
  end;

  ///<summary>Represents the invoke dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.InvokeBinder')]
  DNInvokeBinder = interface(DNDynamicMetaObjectBinder)
  ['{98DBA2B2-D1B2-3F8C-BAF5-C0DE2F86F02B}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_CallInfo: DNCallInfo;

  { methods } 

    ///<summary>Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic invoke operation.</param>
    ///  <param name="args">The arguments of the dynamic invoke operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackInvoke(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic invoke operation.</param>
    ///  <param name="args">The arguments of the dynamic invoke operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackInvoke(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic invoke operation.</summary>
    ///  <param name="target">The target of the dynamic invoke operation.</param>
    ///  <param name="args">An array of arguments of the dynamic invoke operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the signature of the arguments at the call site.</summary>
    ///<returns>The signature of the arguments at the call site.</returns>
    property CallInfo: DNCallInfo read get_CallInfo;
  end;

  TDNInvokeBinder = class(TDNGenericImport<DNInvokeBinderClass, DNInvokeBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNInvokeMemberBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{EE6CFFB5-1859-56F8-9FD9-E290FD94B861}']
  end;

  ///<summary>Represents the invoke member dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.InvokeMemberBinder')]
  DNInvokeMemberBinder = interface(DNDynamicMetaObjectBinder)
  ['{48CDD99E-177D-349C-A2CA-5CCD50A9D752}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_Name: string;
    function get_IgnoreCase: Boolean;
    function get_CallInfo: DNCallInfo;

  { methods } 

    ///<summary>Performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic invoke member operation.</param>
    ///  <param name="args">The arguments of the dynamic invoke member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackInvokeMember(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic invoke member operation.</summary>
    ///  <param name="target">The target of the dynamic invoke member operation.</param>
    ///  <param name="args">An array of arguments of the dynamic invoke member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic invoke member operation.</param>
    ///  <param name="args">The arguments of the dynamic invoke member operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackInvokeMember(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic invoke operation.</param>
    ///  <param name="args">The arguments of the dynamic invoke operation.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackInvoke(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the name of the member to invoke.</summary>
    ///<returns>The name of the member to invoke.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
    ///<returns>True if the case is ignored, otherwise false.</returns>
    property IgnoreCase: Boolean read get_IgnoreCase;
    ///<summary>Gets the signature of the arguments at the call site.</summary>
    ///<returns>The signature of the arguments at the call site.</returns>
    property CallInfo: DNCallInfo read get_CallInfo;
  end;

  TDNInvokeMemberBinder = class(TDNGenericImport<DNInvokeMemberBinderClass, DNInvokeMemberBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNSetIndexBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{4B73D843-88C7-5CD2-86D8-08B551A0851B}']
  end;

  ///<summary>Represents the dynamic set index operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.SetIndexBinder')]
  DNSetIndexBinder = interface(DNDynamicMetaObjectBinder)
  ['{B6401EEF-824B-33DA-AD20-4D7A5AD59D69}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_CallInfo: DNCallInfo;

  { methods } 

    ///<summary>Performs the binding of the dynamic set index operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic set index operation.</param>
    ///  <param name="indexes">The arguments of the dynamic set index operation.</param>
    ///  <param name="value">The value to set to the collection.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackSetIndex(target: DNDynamicMetaObject; indexes: TArray<DNDynamicMetaObject>; value: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic set index operation.</summary>
    ///  <param name="target">The target of the dynamic set index operation.</param>
    ///  <param name="args">An array of arguments of the dynamic set index operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>When overridden in the derived class, performs the binding of the dynamic set index operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic set index operation.</param>
    ///  <param name="indexes">The arguments of the dynamic set index operation.</param>
    ///  <param name="value">The value to set to the collection.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackSetIndex(target: DNDynamicMetaObject; indexes: TArray<DNDynamicMetaObject>; value: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the signature of the arguments at the call site.</summary>
    ///<returns>The signature of the arguments at the call site.</returns>
    property CallInfo: DNCallInfo read get_CallInfo;
  end;

  TDNSetIndexBinder = class(TDNGenericImport<DNSetIndexBinderClass, DNSetIndexBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNSetMemberBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{3F9001FC-B825-5B95-B7FE-88BA83C1F05A}']
  end;

  ///<summary>Represents the dynamic set member operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.SetMemberBinder')]
  DNSetMemberBinder = interface(DNDynamicMetaObjectBinder)
  ['{E70B4C11-B8CF-3EE6-9DB5-B4ECB078E384}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_Name: string;
    function get_IgnoreCase: Boolean;

  { methods } 

    ///<summary>Performs the binding of the dynamic set member operation.</summary>
    ///  <param name="target">The target of the dynamic set member operation.</param>
    ///  <param name="args">An array of arguments of the dynamic set member operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic set member operation.</param>
    ///  <param name="value">The value to set to the member.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackSetMember(target: DNDynamicMetaObject; value: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic set member operation.</param>
    ///  <param name="value">The value to set to the member.</param>
    ///  <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackSetMember(target: DNDynamicMetaObject; value: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>Gets the name of the member to obtain.</summary>
    ///<returns>The name of the member to obtain.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
    ///<returns>True if the case is ignored, otherwise false.</returns>
    property IgnoreCase: Boolean read get_IgnoreCase;
  end;

  TDNSetMemberBinder = class(TDNGenericImport<DNSetMemberBinderClass, DNSetMemberBinder>) end;

  //-------------namespace: System.Dynamic----------------
  DNUnaryOperationBinderClass = interface(DNDynamicMetaObjectBinderClass)
  ['{6E0C0F71-441A-57D2-AC27-02F09C1619B7}']
  end;

  ///<summary>Represents the unary dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
  [DNTypeName('System.Dynamic.UnaryOperationBinder')]
  DNUnaryOperationBinder = interface(DNDynamicMetaObjectBinder)
  ['{A3E57BC0-4680-3F4F-847B-96360A2C990F}']
  { getters & setters } 

    function get_ReturnType: DDN.mscorlib.DNType;
    function get_Operation: DNExpressionType;

  { methods } 

    ///<summary>Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic unary operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackUnaryOperation(target: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the dynamic unary operation.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Bind(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.</summary>
    ///  <param name="target">The target of the dynamic unary operation.</param>
    ///  <param name="errorSuggestion">The binding result in case the binding fails, or null.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function FallbackUnaryOperation(target: DNDynamicMetaObject; errorSuggestion: DNDynamicMetaObject): DNDynamicMetaObject; overload;
    function Bind(args: TArray<DDN.mscorlib.DNObject>; parameters: DDN.mscorlib.DNReadOnlyCollection<DNParameterExpression>; returnLabel: DNLabelTarget): DNExpression; overload;
    ///<summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
    ///  <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" />
    ///  property of the resulting expression; any type is allowed.</param>
    ///<returns>The update expression.</returns>
    function GetUpdateExpression(&type: DDN.mscorlib.DNType): DNExpression;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    ///<summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
    ///  <param name="target">The target of the dynamic operation.</param>
    ///  <param name="args">An array of arguments of the dynamic operation.</param>
    ///<returns>The <see cref="T:System.Dynamic.DynamicMetaObject" />
    ///  representing the result of the binding.</returns>
    function Defer(target: DNDynamicMetaObject; args: TArray<DNDynamicMetaObject>): DNDynamicMetaObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The result type of the operation.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  object representing the result type of the operation.</returns>
    property ReturnType: DDN.mscorlib.DNType read get_ReturnType;
    ///<summary>The unary operation kind.</summary>
    ///<returns>The object of the <see cref="T:System.Linq.Expressions.ExpressionType" />
    ///  that represents the unary operation kind.</returns>
    property Operation: DNExpressionType read get_Operation;
  end;

  TDNUnaryOperationBinder = class(TDNGenericImport<DNUnaryOperationBinderClass, DNUnaryOperationBinder>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNCallSiteHelpersClass = interface(DDN.mscorlib.DNObjectClass)
  ['{809B9BDC-6F43-59E7-A870-A00CE714F956}']
  { static methods } 

    ///<summary>Checks if a <see cref="T:System.Reflection.MethodBase" />
    ///  is internally used by DLR and should not be displayed on the language code's stack.</summary>
    ///  <param name="mb">The input <see cref="T:System.Reflection.MethodBase" />
    ///</param>
    ///<returns>True if the input <see cref="T:System.Reflection.MethodBase" />
    ///  is internally used by DLR and should not be displayed on the language code's stack. Otherwise, false.</returns>
    {class} function IsInternalFrame(mb: DDN.mscorlib.DNMethodBase): Boolean;

  end;

  ///<summary>Class that contains helper methods for DLR CallSites.</summary>
  [DNTypeName('System.Runtime.CompilerServices.CallSiteHelpers')]
  DNCallSiteHelpers = interface(DDN.mscorlib.DNObject)
  ['{0EEE6BAC-3911-3134-9282-363968BB9E79}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNCallSiteHelpers = class(TDNGenericImport<DNCallSiteHelpersClass, DNCallSiteHelpers>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNCallSiteOpsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{EB46A7F1-5950-5403-9FA3-C65B4EB6DAFA}']
  { static methods } 

    ///<summary>Checks if a dynamic site requires an update.</summary>
    ///  <param name="site">An instance of the dynamic call site.</param>
    ///<returns>true if rule does not need updating, false otherwise.</returns>
    {class} function SetNotMatched(site: DNCallSite): Boolean;
    ///<summary>Checks whether the executed rule matched</summary>
    ///  <param name="site">An instance of the dynamic call site.</param>
    ///<returns>true if rule matched, false otherwise.</returns>
    {class} function GetMatch(site: DNCallSite): Boolean;
    ///<summary>Clears the match flag on the matchmaker call site.</summary>
    ///  <param name="site">An instance of the dynamic call site.</param>
    {class} procedure ClearMatch(site: DNCallSite);

  end;

  ///<summary>Creates and caches binding rules.</summary>
  [DNTypeName('System.Runtime.CompilerServices.CallSiteOps')]
  DNCallSiteOps = interface(DDN.mscorlib.DNObject)
  ['{32D98445-057B-359D-8569-68C1CF2419C3}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNCallSiteOps = class(TDNGenericImport<DNCallSiteOpsClass, DNCallSiteOps>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNClosureClass = interface(DDN.mscorlib.DNObjectClass)
  ['{2DB44898-4CA9-52E8-9576-49AEFFD7811F}']
  { constructors } 

    ///<summary>Creates an object to hold state of a dynamically generated method.</summary>
    ///  <param name="constants">The constant values that are used by the method.</param>
    ///  <param name="locals">The hoisted local variables from the parent context.</param>
    {class} function init(constants: TArray<DDN.mscorlib.DNObject>; locals: TArray<DDN.mscorlib.DNObject>): DNClosure;

  { static fields getter & setter } 

   function __fakeFieldGet_Constants: TArray<DDN.mscorlib.DNObject>;
   function __fakeFieldGet_Locals: TArray<DDN.mscorlib.DNObject>;

  { static fields } 

    ///<summary>Represents the non-trivial constants and locally executable expressions that are referenced by a dynamically generated method.</summary>
    {class} property Constants: TArray<DDN.mscorlib.DNObject> read __fakeFieldGet_Constants;
    ///<summary>Represents the hoisted local variables from the parent context.</summary>
    {class} property Locals: TArray<DDN.mscorlib.DNObject> read __fakeFieldGet_Locals;

  end;

  ///<summary>Represents the runtime state of a dynamically generated method.</summary>
  [DNTypeName('System.Runtime.CompilerServices.Closure')]
  DNClosure = interface(DDN.mscorlib.DNObject)
  ['{EAD5CB0A-0A3A-31D6-86B6-F3FF288ABC75}']
  { fields getter & setter } 

   function __fakeFieldGet_Constants: TArray<DDN.mscorlib.DNObject>;
   function __fakeFieldGet_Locals: TArray<DDN.mscorlib.DNObject>;

  { fields } 

    ///<summary>Represents the non-trivial constants and locally executable expressions that are referenced by a dynamically generated method.</summary>
   property Constants: TArray<DDN.mscorlib.DNObject> read __fakeFieldGet_Constants;
    ///<summary>Represents the hoisted local variables from the parent context.</summary>
   property Locals: TArray<DDN.mscorlib.DNObject> read __fakeFieldGet_Locals;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNClosure = class(TDNGenericImport<DNClosureClass, DNClosure>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNDebugInfoGeneratorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{A6BB4B0C-F26E-5E0F-B15B-F934EDB62583}']
  { static methods } 

    ///<summary>Creates a program database (PDB) symbol generator.</summary>
    ///<returns>A PDB symbol generator.</returns>
    {class} function CreatePdbGenerator: DNDebugInfoGenerator;

  end;

  ///<summary>Generates debug information for lambda expressions in an expression tree.</summary>
  [DNTypeName('System.Runtime.CompilerServices.DebugInfoGenerator')]
  DNDebugInfoGenerator = interface(DDN.mscorlib.DNObject)
  ['{08BB7FFD-FA62-3E00-9CAF-2FF883CC52C9}']
  { methods } 

    ///<summary>Marks a sequence point in Microsoft intermediate language (MSIL) code.</summary>
    ///  <param name="method">The lambda expression that is generated.</param>
    ///  <param name="ilOffset">The offset within MSIL code at which to mark the sequence point.</param>
    ///  <param name="sequencePoint">Debug information that corresponds to the sequence point.</param>
    procedure MarkSequencePoint(method: DNLambdaExpression; ilOffset: Int32; sequencePoint: DNDebugInfoExpression);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDebugInfoGenerator = class(TDNGenericImport<DNDebugInfoGeneratorClass, DNDebugInfoGenerator>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNExecutionScopeClass = interface(DDN.mscorlib.DNObjectClass)
  ['{27A95380-3E27-5F99-B5D9-13FA6862172D}']
  end;

  ///<summary>Represents the runtime state of a dynamically generated method.</summary>
  [DNTypeName('System.Runtime.CompilerServices.ExecutionScope')]
  DNExecutionScope = interface(DDN.mscorlib.DNObject)
  ['{AC27F267-2762-3BCD-9E36-E7542E948F3C}']
  { fields getter & setter } 

   function __fakeFieldGet_Parent: DNExecutionScope;
   procedure __fakeFieldSet_Parent(value: DNExecutionScope);
   function __fakeFieldGet_Globals: TArray<DDN.mscorlib.DNObject>;
   procedure __fakeFieldSet_Globals(value: TArray<DDN.mscorlib.DNObject>);
   function __fakeFieldGet_Locals: TArray<DDN.mscorlib.DNObject>;
   procedure __fakeFieldSet_Locals(value: TArray<DDN.mscorlib.DNObject>);

  { fields } 

    ///<summary>Represents the execution scope of the calling delegate.</summary>
   property Parent: DNExecutionScope read __fakeFieldGet_Parent write __fakeFieldSet_Parent;
    ///<summary>Represents the non-trivial constants and locally executable expressions that are referenced by a dynamically generated method.</summary>
   property Globals: TArray<DDN.mscorlib.DNObject> read __fakeFieldGet_Globals write __fakeFieldSet_Globals;
    ///<summary>Represents the hoisted local variables from the parent context.</summary>
   property Locals: TArray<DDN.mscorlib.DNObject> read __fakeFieldGet_Locals write __fakeFieldSet_Locals;

  { methods } 

    ///<summary>Creates an array to store the hoisted local variables.</summary>
    ///<returns>An array to store hoisted local variables.</returns>
    function CreateHoistedLocals: TArray<DDN.mscorlib.DNObject>;
    ///<summary>Creates a delegate that can be used to execute a dynamically generated method.</summary>
    ///  <param name="indexLambda">The index of the object that stores information about associated lambda expression of the dynamic method.</param>
    ///  <param name="locals">An array that contains the hoisted local variables from the parent context.</param>
    ///<returns>A <see cref="T:System.Delegate" />
    ///  that can execute a dynamically generated method.</returns>
    function CreateDelegate(indexLambda: Int32; locals: TArray<DDN.mscorlib.DNObject>): DDN.mscorlib.DNDelegate;
    ///<summary>Frees a specified expression tree of external parameter references by replacing the parameter with its current value.</summary>
    ///  <param name="expression">An expression tree to free of external parameter references.</param>
    ///  <param name="locals">An array that contains the hoisted local variables.</param>
    ///<returns>An expression tree that does not contain external parameter references.</returns>
    function IsolateExpression(expression: DNExpression; locals: TArray<DDN.mscorlib.DNObject>): DNExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNExecutionScope = class(TDNGenericImport<DNExecutionScopeClass, DNExecutionScope>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNReadOnlyCollectionBuilderClass<T> = interface(DNObjectClass)
  ['{F68329FD-7F52-5FC6-BCCA-F8E98EF3297A}']
  { constructors } 

    ///<summary>Constructs a ReadOnlyCollectionBuilder.</summary>
    {class} function init: DNReadOnlyCollectionBuilder<T>; overload;
    ///<summary>Constructs a ReadOnlyCollectionBuilder with a given initial capacity. The contents are empty but builder will have reserved room for the given number of elements before any reallocations are required.</summary>
    ///  <param name="capacity">Initial capacity.</param>
    {class} function init(capacity: Int32): DNReadOnlyCollectionBuilder<T>; overload;
    {class} function init(collection: DDN.mscorlib.DNIEnumerable<T>): DNReadOnlyCollectionBuilder<T>; overload;

  end;

  ///<summary>The builder for read only collection.</summary>
  ///<typeparam name="T">The type of the collection element.</typeparam>
  [DNTypeName('System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1')]
  DNReadOnlyCollectionBuilder<T> = interface(DDN.mscorlib.DNIList<T>)
  ['{82C86E9E-0EE9-38CE-9081-0DA70555B3DE}']
  { getters & setters } 

    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    function IndexOf(item: T): Int32;
    procedure Insert(index: Int32; item: T);
    ///<summary>Removes the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />
    ///  item at the specified index.</summary>
    ///  <param name="index">The zero-based index of the item to remove.</param>
    procedure RemoveAt(index: Int32);
    function &Contains(item: T): Boolean;
    procedure CopyTo(&array: TArray<T>; arrayIndex: Int32);
    ///<summary>Returns an enumerator that iterates through the collection.</summary>
    ///<returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" />
    ///  that can be used to iterate through the collection.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator<T>;
    ///<summary>Reverses the order of the elements in the entire <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />
    ///  .</summary>
    procedure Reverse; overload;
    ///<summary>Reverses the order of the elements in the specified range.</summary>
    ///  <param name="index">The zero-based starting index of the range to reverse.</param>
    ///  <param name="count">The number of elements in the range to reverse.</param>
    procedure Reverse(index: Int32; count: Int32); overload;
    ///<summary>Copies the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />
    ///  to a new array.</summary>
    ///<returns>An array containing copies of the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />
    ///  .</returns>
    function ToArray: TArray<T>;
    ///<summary>Creates a <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  containing all of the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />
    ///  , avoiding copying the elements to the new array if possible. Resets the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />
    ///  after the <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  has been created.</summary>
    ///<returns>A new instance of <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
    ///  .</returns>
    function ToReadOnlyCollection: DDN.mscorlib.DNReadOnlyCollection<T>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets and sets the capacity of this ReadOnlyCollectionBuilder.</summary>
    ///<returns>The capacity of this ReadOnlyCollectionBuilder.</returns>
    property Capacity: Int32 read get_Capacity write set_Capacity;
    ///<summary>Returns number of elements in the ReadOnlyCollectionBuilder.</summary>
    ///<returns>The number of elements in the ReadOnlyCollectionBuilder.</returns>
    property Count: Int32 read get_Count;
  end;

  TDNReadOnlyCollectionBuilder<T> = class(TDNGenericImport<DNReadOnlyCollectionBuilderClass<T>, DNReadOnlyCollectionBuilder<T>>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNRuleCacheClass<T> = interface(DDN.mscorlib.DNObjectClass)
  ['{D3516F87-A7F0-54FB-8118-AF1CF5A77DE0}']
  end;

  ///<summary>Represents a cache of runtime binding rules.</summary>
  ///<typeparam name="T">The delegate type.</typeparam>
  [DNTypeName('System.Runtime.CompilerServices.RuleCache`1')]
  DNRuleCache<T> = interface(DDN.mscorlib.DNObject)
  ['{843EC5E4-1C53-3234-8CF0-FF8BA9473544}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNRuleCache<T> = class(TDNGenericImport<DNRuleCacheClass<T>, DNRuleCache<T>>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNRuntimeOpsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{8783E89C-8A85-5F6B-A816-B21DB6F58B7C}']
  { static methods } 

    {class} function ExpandoTryGetValue(expando: DNExpandoObject; indexClass: DDN.mscorlib.DNObject; index: Int32; name: string; ignoreCase: Boolean; out value: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Sets the value of an item in an expando object.</summary>
    ///  <param name="expando">The expando object.</param>
    ///  <param name="indexClass">The class of the expando object.</param>
    ///  <param name="index">The index of the member.</param>
    ///  <param name="value">The value of the member.</param>
    ///  <param name="name">The name of the member.</param>
    ///  <param name="ignoreCase">true if the name should be matched ignoring case; false otherwise.</param>
    ///<returns>Returns the index for the set member.</returns>
    {class} function ExpandoTrySetValue(expando: DNExpandoObject; indexClass: DDN.mscorlib.DNObject; index: Int32; value: DDN.mscorlib.DNObject; name: string; ignoreCase: Boolean): DDN.mscorlib.DNObject;
    ///<summary>Checks the version of the Expando object.</summary>
    ///  <param name="expando">The Expando object.</param>
    ///  <param name="version">The version to check.</param>
    ///<returns>Returns true if the version is equal; otherwise, false.</returns>
    {class} function ExpandoCheckVersion(expando: DNExpandoObject; version: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Promotes an Expando object from one class to a new class.</summary>
    ///  <param name="expando">The Expando object.</param>
    ///  <param name="oldClass">The old class of the Expando object.</param>
    ///  <param name="newClass">The new class of the Expando object.</param>
    {class} procedure ExpandoPromoteClass(expando: DNExpandoObject; oldClass: DDN.mscorlib.DNObject; newClass: DDN.mscorlib.DNObject);
    ///<summary>Quotes the provided expression tree.</summary>
    ///  <param name="expression">The expression to quote.</param>
    ///  <param name="hoistedLocals">The hoisted local state provided by the compiler.</param>
    ///  <param name="locals">The actual hoisted local values.</param>
    ///<returns>The quoted expression.</returns>
    {class} function Quote(expression: DNExpression; hoistedLocals: DDN.mscorlib.DNObject; locals: TArray<DDN.mscorlib.DNObject>): DNExpression;
    ///<summary>Combines two runtime variable lists and returns a new list.</summary>
    ///  <param name="first">The first list.</param>
    ///  <param name="second">The second list.</param>
    ///  <param name="indexes">The index array indicating which list to get variables from.</param>
    ///<returns>The merged runtime variables.</returns>
    {class} function MergeRuntimeVariables(first: DNIRuntimeVariables; second: DNIRuntimeVariables; indexes: TArray<Int32>): DNIRuntimeVariables;
    ///<summary>Creates an interface that can be used to modify closed over variables at runtime.</summary>
    ///  <param name="data">The closure array.</param>
    ///  <param name="indexes">An array of indicies into the closure array where variables are found.</param>
    ///<returns>An interface to access variables.</returns>
    {class} function CreateRuntimeVariables(data: TArray<DDN.mscorlib.DNObject>; indexes: TArray<Int64>): DNIRuntimeVariables; overload;
    ///<summary>Creates an interface that can be used to modify closed over variables at runtime.</summary>
    ///<returns>An interface to access variables.</returns>
    {class} function CreateRuntimeVariables: DNIRuntimeVariables; overload;
    ///<summary>Deletes the value of an item in an expando object.</summary>
    ///  <param name="expando">The expando object.</param>
    ///  <param name="indexClass">The class of the expando object.</param>
    ///  <param name="index">The index of the member.</param>
    ///  <param name="name">The name of the member.</param>
    ///  <param name="ignoreCase">true if the name should be matched ignoring case; false otherwise.</param>
    ///<returns>true if the item was successfully removed; otherwise, false.</returns>
    {class} function ExpandoTryDeleteValue(expando: DNExpandoObject; indexClass: DDN.mscorlib.DNObject; index: Int32; name: string; ignoreCase: Boolean): Boolean;

  end;

  ///<summary>Contains helper methods called from dynamically generated methods.</summary>
  [DNTypeName('System.Runtime.CompilerServices.RuntimeOps')]
  DNRuntimeOps = interface(DDN.mscorlib.DNObject)
  ['{382FF925-51E8-36DE-A45B-B3130C1B73F7}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNRuntimeOps = class(TDNGenericImport<DNRuntimeOpsClass, DNRuntimeOps>) end;

  //-------------namespace: System.Runtime.CompilerServices----------------
  DNStrongBoxClass<T> = interface(DNObjectClass)
  ['{EC821084-B4D6-5A62-8608-A362311BCCFE}']
  { constructors } 

    ///<summary>Initializes a new StrongBox which can receive a value when used in a reference call.</summary>
    {class} function init: DNStrongBox<T>; overload;
    {class} function init(value: T): DNStrongBox<T>; overload;

  end;

  ///<summary>Holds a reference to a value.</summary>
  ///<typeparam name="T">The type of the value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" />
  ///  references.</typeparam>
  [DNTypeName('System.Runtime.CompilerServices.StrongBox`1')]
  DNStrongBox<T> = interface(DNIStrongBox)
  ['{C4521547-B39F-37D3-8E93-67687516BD6A}']
  { fields getter & setter } 

   function __fakeFieldGet_Value: T;
   procedure __fakeFieldSet_Value(value: T);

  { fields } 

    ///<summary>Represents the value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" />
    ///  references.</summary>
   property Value: T read __fakeFieldGet_Value write __fakeFieldSet_Value;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNStrongBox<T> = class(TDNGenericImport<DNStrongBoxClass<T>, DNStrongBox<T>>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafeMemoryMappedFileHandleClass = interface(DDN.mscorlib.DNSafeHandleZeroOrMinusOneIsInvalidClass)
  ['{5D11D27F-FF02-5CA2-B9B9-B80A3A3A366A}']
  end;

  ///<summary>Provides a safe handle that represents a memory-mapped file for sequential access.</summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle')]
  DNSafeMemoryMappedFileHandle = interface(DDN.mscorlib.DNSafeHandleZeroOrMinusOneIsInvalid)
  ['{AC0FD8B9-81F8-3BBE-9F9A-6EFF76C768C8}']
  { getters & setters } 

    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafeMemoryMappedFileHandle = class(TDNGenericImport<DNSafeMemoryMappedFileHandleClass, DNSafeMemoryMappedFileHandle>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafeNCryptHandleClass = interface(DDN.mscorlib.DNSafeHandleZeroOrMinusOneIsInvalidClass)
  ['{B5A81318-8F8B-557D-B009-C49AC837FBA7}']
  end;

  ///<summary>Provides a safe handle that can be used by Cryptography Next Generation (CNG) objects.</summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafeNCryptHandle')]
  DNSafeNCryptHandle = interface(DDN.mscorlib.DNSafeHandleZeroOrMinusOneIsInvalid)
  ['{7E6E4B23-E285-3902-BE11-1FBE52E40F86}']
  { getters & setters } 

    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafeNCryptHandle = class(TDNGenericImport<DNSafeNCryptHandleClass, DNSafeNCryptHandle>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafeNCryptKeyHandleClass = interface(DNSafeNCryptHandleClass)
  ['{D9135D1B-C023-5899-BAB4-19738FCE55AA}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle" />
    ///  class.</summary>
    {class} function init: DNSafeNCryptKeyHandle; overload;
    {class} function init(handle: IntPtr; parentHandle: DDN.mscorlib.DNSafeHandle): DNSafeNCryptKeyHandle; overload;

  end;

  ///<summary>Provides a safe handle that represents a key (NCRYPT_KEY_HANDLE).</summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle')]
  DNSafeNCryptKeyHandle = interface(DNSafeNCryptHandle)
  ['{60BE2FF8-FDDA-34FC-8B3E-636723C09825}']
  { getters & setters } 

    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafeNCryptKeyHandle = class(TDNGenericImport<DNSafeNCryptKeyHandleClass, DNSafeNCryptKeyHandle>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafeNCryptProviderHandleClass = interface(DNSafeNCryptHandleClass)
  ['{2BAC7F90-7D64-5E9E-A9C1-D4493B1028DF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle" />
    ///  class.</summary>
    {class} function init: DNSafeNCryptProviderHandle;

  end;

  ///<summary>Provides a safe handle that represents a key storage provider (NCRYPT_PROV_HANDLE).</summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle')]
  DNSafeNCryptProviderHandle = interface(DNSafeNCryptHandle)
  ['{A62D2278-04C5-39AA-9306-F5BF4E6090D2}']
  { getters & setters } 

    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafeNCryptProviderHandle = class(TDNGenericImport<DNSafeNCryptProviderHandleClass, DNSafeNCryptProviderHandle>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafeNCryptSecretHandleClass = interface(DNSafeNCryptHandleClass)
  ['{1F56CE4B-5EE1-54D3-A383-E79414AF23AF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle" />
    ///  class.</summary>
    {class} function init: DNSafeNCryptSecretHandle;

  end;

  ///<summary>Provides a safe handle that represents a secret agreement value (NCRYPT_SECRET_HANDLE).</summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle')]
  DNSafeNCryptSecretHandle = interface(DNSafeNCryptHandle)
  ['{3CDC8272-242A-3C71-B6CD-A3A47BD64896}']
  { getters & setters } 

    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafeNCryptSecretHandle = class(TDNGenericImport<DNSafeNCryptSecretHandleClass, DNSafeNCryptSecretHandle>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafePipeHandleClass = interface(DDN.mscorlib.DNSafeHandleZeroOrMinusOneIsInvalidClass)
  ['{A3DD8E7B-D61E-5A14-9B9C-116F81DC4296}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" />
    ///  class.</summary>
    ///  <param name="preexistingHandle">An <see cref="T:System.IntPtr" />
    ///  object that represents the pre-existing handle to use.</param>
    ///  <param name="ownsHandle"><see langword="true" />
    ///  to reliably release the handle during the finalization phase; <see langword="false" />
    ///  to prevent reliable release (not recommended).</param>
    {class} function init(preexistingHandle: IntPtr; ownsHandle: Boolean): DNSafePipeHandle;

  end;

  ///<summary>Represents a wrapper class for a pipe handle. </summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafePipeHandle')]
  DNSafePipeHandle = interface(DDN.mscorlib.DNSafeHandleZeroOrMinusOneIsInvalid)
  ['{FB017894-B72B-34E1-B885-2FFF041C6C5C}']
  { getters & setters } 

    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafePipeHandle = class(TDNGenericImport<DNSafePipeHandleClass, DNSafePipeHandle>) end;

  //-------------namespace: Microsoft.Win32.SafeHandles----------------
  DNSafeMemoryMappedViewHandleClass = interface(DDN.mscorlib.DNSafeBufferClass)
  ['{B53664B2-3636-50FA-9EE7-33883F0B2EFF}']
  end;

  ///<summary>Provides a safe handle that represents a view of a block of unmanaged memory for random access. </summary>
  [DNTypeName('Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle')]
  DNSafeMemoryMappedViewHandle = interface(DDN.mscorlib.DNSafeBuffer)
  ['{C96C10C1-0F9D-3B15-80FB-836783ACE9BF}']
  { getters & setters } 

    function get_ByteLength: UInt64;
    function get_IsInvalid: Boolean;
    function get_IsClosed: Boolean;

  { methods } 

    procedure AcquirePointer(out pointer: PByte);
    procedure Initialize(numBytes: UInt64); overload;
    procedure Initialize(numElements: UInt32; sizeOfEachElement: UInt32); overload;
    procedure ReleasePointer;
    function DangerousGetHandle: IntPtr;
    procedure Close;
    procedure Dispose;
    procedure SetHandleAsInvalid;
    procedure DangerousAddRef(out success: Boolean);
    procedure DangerousRelease;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property ByteLength: UInt64 read get_ByteLength;
    property IsInvalid: Boolean read get_IsInvalid;
    property IsClosed: Boolean read get_IsClosed;
  end;

  TDNSafeMemoryMappedViewHandle = class(TDNGenericImport<DNSafeMemoryMappedViewHandleClass, DNSafeMemoryMappedViewHandle>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNPipeAccessRuleClass = interface(DDN.mscorlib.DNAccessRuleClass)
  ['{87305EE8-5721-5AFC-9B43-5EC35AA2683A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAccessRule" />
    ///  class with the specified identity, pipe access rights, and access control type.</summary>
    ///  <param name="identity">The name of the user account.</param>
    ///  <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  values that specifies the type of operation associated with the access rule.</param>
    ///  <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" />
    ///  values that specifies whether to allow or deny the operation.</param>
    {class} function init(identity: string; rights: DNPipeAccessRights; &type: DDN.mscorlib.DNAccessControlType): DNPipeAccessRule; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAccessRule" />
    ///  class with the specified identity, pipe access rights, and access control type.</summary>
    ///  <param name="identity">An <see cref="T:System.Security.Principal.IdentityReference" />
    ///  object that encapsulates a reference to a user account.</param>
    ///  <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  values that specifies the type of operation associated with the access rule.</param>
    ///  <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" />
    ///  values that specifies whether to allow or deny the operation.</param>
    {class} function init(identity: DDN.mscorlib.DNIdentityReference; rights: DNPipeAccessRights; &type: DDN.mscorlib.DNAccessControlType): DNPipeAccessRule; overload;

  end;

  ///<summary>Represents an abstraction of an access control entry (ACE) that defines an access rule for a pipe.</summary>
  [DNTypeName('System.IO.Pipes.PipeAccessRule')]
  DNPipeAccessRule = interface(DDN.mscorlib.DNAccessRule)
  ['{46B53ED0-F6FD-3A93-BF16-88D1DA1D528B}']
  { getters & setters } 

    function get_PipeAccessRights: DNPipeAccessRights;
    function get_AccessControlType: DDN.mscorlib.DNAccessControlType;
    function get_IdentityReference: DDN.mscorlib.DNIdentityReference;
    function get_IsInherited: Boolean;
    function get_InheritanceFlags: DDN.mscorlib.DNInheritanceFlags;
    function get_PropagationFlags: DDN.mscorlib.DNPropagationFlags;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  flags that are associated with the current <see cref="T:System.IO.Pipes.PipeAccessRule" />
    ///  object.</summary>
    ///<returns>A bitwise combination of the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  values.</returns>
    property PipeAccessRights: DNPipeAccessRights read get_PipeAccessRights;
    property AccessControlType: DDN.mscorlib.DNAccessControlType read get_AccessControlType;
    property IdentityReference: DDN.mscorlib.DNIdentityReference read get_IdentityReference;
    property IsInherited: Boolean read get_IsInherited;
    property InheritanceFlags: DDN.mscorlib.DNInheritanceFlags read get_InheritanceFlags;
    property PropagationFlags: DDN.mscorlib.DNPropagationFlags read get_PropagationFlags;
  end;

  TDNPipeAccessRule = class(TDNGenericImport<DNPipeAccessRuleClass, DNPipeAccessRule>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNPipeAuditRuleClass = interface(DDN.mscorlib.DNAuditRuleClass)
  ['{5C1051CB-D3DF-5516-AC21-F5AA2F4A1285}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAuditRule" />
    ///  class for a user account specified in a <see cref="T:System.Security.Principal.IdentityReference" />
    ///  object.</summary>
    ///  <param name="identity">An <see cref="T:System.Security.Principal.IdentityReference" />
    ///  object that encapsulates a reference to a user account.</param>
    ///  <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  values that specifies the type of operation associated with the access rule.</param>
    ///  <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" />
    ///  values that specifies when to perform auditing.</param>
    {class} function init(identity: DDN.mscorlib.DNIdentityReference; rights: DNPipeAccessRights; flags: DDN.mscorlib.DNAuditFlags): DNPipeAuditRule; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAuditRule" />
    ///  class for a named user account.</summary>
    ///  <param name="identity">The name of the user account.</param>
    ///  <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  values that specifies the type of operation associated with the access rule.</param>
    ///  <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" />
    ///  values that specifies when to perform auditing.</param>
    {class} function init(identity: string; rights: DNPipeAccessRights; flags: DDN.mscorlib.DNAuditFlags): DNPipeAuditRule; overload;

  end;

  ///<summary>Represents an abstraction of an access control entry (ACE) that defines an audit rule for a pipe.</summary>
  [DNTypeName('System.IO.Pipes.PipeAuditRule')]
  DNPipeAuditRule = interface(DDN.mscorlib.DNAuditRule)
  ['{20E3BC0A-2B9C-3530-BCD7-75C9D6B4C513}']
  { getters & setters } 

    function get_PipeAccessRights: DNPipeAccessRights;
    function get_AuditFlags: DDN.mscorlib.DNAuditFlags;
    function get_IdentityReference: DDN.mscorlib.DNIdentityReference;
    function get_IsInherited: Boolean;
    function get_InheritanceFlags: DDN.mscorlib.DNInheritanceFlags;
    function get_PropagationFlags: DDN.mscorlib.DNPropagationFlags;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  flags that are associated with the current <see cref="T:System.IO.Pipes.PipeAuditRule" />
    ///  object.</summary>
    ///<returns>A bitwise combination of the <see cref="T:System.IO.Pipes.PipeAccessRights" />
    ///  values. </returns>
    property PipeAccessRights: DNPipeAccessRights read get_PipeAccessRights;
    property AuditFlags: DDN.mscorlib.DNAuditFlags read get_AuditFlags;
    property IdentityReference: DDN.mscorlib.DNIdentityReference read get_IdentityReference;
    property IsInherited: Boolean read get_IsInherited;
    property InheritanceFlags: DDN.mscorlib.DNInheritanceFlags read get_InheritanceFlags;
    property PropagationFlags: DDN.mscorlib.DNPropagationFlags read get_PropagationFlags;
  end;

  TDNPipeAuditRule = class(TDNGenericImport<DNPipeAuditRuleClass, DNPipeAuditRule>) end;

  //-------------namespace: System.IO.Pipes----------------
  DNPipeSecurityClass = interface(DDN.mscorlib.DNNativeObjectSecurityClass)
  ['{A254AFF3-00EA-5DB9-9E4C-602C08CA1BE4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  class.</summary>
    {class} function init: DNPipeSecurity;

  end;

  ///<summary>Represents the access control and audit security for a pipe.</summary>
  [DNTypeName('System.IO.Pipes.PipeSecurity')]
  DNPipeSecurity = interface(DDN.mscorlib.DNNativeObjectSecurity)
  ['{38F17941-745F-38A1-B714-2EBCAACA1DE5}']
  { getters & setters } 

    function get_AccessRightType: DDN.mscorlib.DNType;
    function get_AccessRuleType: DDN.mscorlib.DNType;
    function get_AuditRuleType: DDN.mscorlib.DNType;
    function get_AreAccessRulesProtected: Boolean;
    function get_AreAuditRulesProtected: Boolean;
    function get_AreAccessRulesCanonical: Boolean;
    function get_AreAuditRulesCanonical: Boolean;

  { methods } 

    ///<summary>Adds an access rule to the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The access rule to add.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure AddAccessRule(rule: DNPipeAccessRule);
    ///<summary>Sets an access rule in the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The rule to set.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure SetAccessRule(rule: DNPipeAccessRule);
    ///<summary>Removes all access rules in the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object and then adds the specified access rule.</summary>
    ///  <param name="rule">The access rule to add.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure ResetAccessRule(rule: DNPipeAccessRule);
    ///<summary>Removes an access rule from the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The access rule to remove.</param>
    ///<returns><see langword="true" />
    ///  if the operation is successful; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    function RemoveAccessRule(rule: DNPipeAccessRule): Boolean;
    ///<summary>Removes the specified access rule from the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The access rule to remove.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure RemoveAccessRuleSpecific(rule: DNPipeAccessRule);
    ///<summary>Adds an audit rule to the System Access Control List (SACL)that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The audit rule to add.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure AddAuditRule(rule: DNPipeAuditRule);
    ///<summary>Sets an audit rule in the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The rule to set.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure SetAuditRule(rule: DNPipeAuditRule);
    ///<summary>Removes an audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The audit rule to remove.</param>
    ///<returns><see langword="true" />
    ///  if the audit rule was removed; otherwise, <see langword="false" />
    ///</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    function RemoveAuditRule(rule: DNPipeAuditRule): Boolean;
    ///<summary>Removes all audit rules that have the same security identifier as the specified audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The audit rule to remove.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure RemoveAuditRuleAll(rule: DNPipeAuditRule);
    ///<summary>Removes the specified audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///  <param name="rule">The audit rule to remove.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rule" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    procedure RemoveAuditRuleSpecific(rule: DNPipeAuditRule);
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.AccessRule" />
    ///  class with the specified values.</summary>
    ///  <param name="identityReference">The identity that the access rule applies to. It must be an object that can be cast as a <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  object.</param>
    ///  <param name="accessMask">The access mask of this rule. The access mask is a 32-bit collection of anonymous bits, the meaning of which is defined by the individual integrators</param>
    ///  <param name="isInherited"><see langword="true" />
    ///  if this rule is inherited from a parent container; otherwise false.</param>
    ///  <param name="inheritanceFlags">One of the <see cref="T:System.Security.AccessControl.InheritanceFlags" />
    ///  values that specifies the inheritance properties of the access rule.</param>
    ///  <param name="propagationFlags">One of the <see cref="T:System.Security.AccessControl.PropagationFlags" />
    ///  values that specifies whether inherited access rules are automatically propagated. The propagation flags are ignored if <paramref name="inheritanceFlags" />
    ///  is set to <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />
    ///  .</param>
    ///  <param name="type">Specifies the valid access control type.</param>
    ///<returns>The <see cref="T:System.Security.AccessControl.AccessRule" />
    ///  object that this method creates.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />
    ///  , <paramref name="inheritanceFlags" />
    ///  , <paramref name="propagationFlags" />
    ///  , or <paramref name="type" />
    ///  specifies an invalid value.</exception><exception cref="T:System.ArgumentNullException"><paramref name="identityReference" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="accessMask" />
    ///  is zero.</exception><exception cref="T:System.ArgumentException"><paramref name="identityReference" />
    ///  is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  nor of a type, such as <see cref="T:System.Security.Principal.NTAccount" />
    ///  , that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  .</exception>
    function AccessRuleFactory(identityReference: DDN.mscorlib.DNIdentityReference; accessMask: Int32; isInherited: Boolean; inheritanceFlags: DDN.mscorlib.DNInheritanceFlags; propagationFlags: DDN.mscorlib.DNPropagationFlags; &type: DDN.mscorlib.DNAccessControlType): DDN.mscorlib.DNAccessRule;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.AuditRule" />
    ///  class with the specified values.</summary>
    ///  <param name="identityReference">The identity that the access rule applies to. It must be an object that can be cast as a <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  object.</param>
    ///  <param name="accessMask">The access mask of this rule. The access mask is a 32-bit collection of anonymous bits, the meaning of which is defined by the individual integrators</param>
    ///  <param name="isInherited"><see langword="true" />
    ///  if this rule is inherited from a parent container; otherwise, false..</param>
    ///  <param name="inheritanceFlags">One of the <see cref="T:System.Security.AccessControl.InheritanceFlags" />
    ///  values that specifies the inheritance properties of the access rule.</param>
    ///  <param name="propagationFlags">One of the <see cref="T:System.Security.AccessControl.PropagationFlags" />
    ///  values that specifies whether inherited access rules are automatically propagated. The propagation flags are ignored if <paramref name="inheritanceFlags" />
    ///  is set to <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />
    ///  .</param>
    ///  <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" />
    ///  values that specifies the valid access control type.</param>
    ///<returns>The <see cref="T:System.Security.AccessControl.AuditRule" />
    ///  object that this method creates.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="accessMask" />
    ///  , <paramref name="inheritanceFlags" />
    ///  , <paramref name="propagationFlags" />
    ///  , or <paramref name="flags" />
    ///  properties specify an invalid value.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="identityReference" />
    ///  property is <see langword="null" />
    ///  . -or-The <paramref name="accessMask" />
    ///  property is zero.</exception><exception cref="T:System.ArgumentException">The <paramref name="identityReference" />
    ///  property is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  nor of a type, such as <see cref="T:System.Security.Principal.NTAccount" />
    ///  , that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />
    ///  .</exception>
    function AuditRuleFactory(identityReference: DDN.mscorlib.DNIdentityReference; accessMask: Int32; isInherited: Boolean; inheritanceFlags: DDN.mscorlib.DNInheritanceFlags; propagationFlags: DDN.mscorlib.DNPropagationFlags; flags: DDN.mscorlib.DNAuditFlags): DDN.mscorlib.DNAuditRule;
    function GetAccessRules(includeExplicit: Boolean; includeInherited: Boolean; targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNAuthorizationRuleCollection;
    function GetAuditRules(includeExplicit: Boolean; includeInherited: Boolean; targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNAuthorizationRuleCollection;
    function GetOwner(targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNIdentityReference;
    procedure SetOwner(identity: DDN.mscorlib.DNIdentityReference);
    function GetGroup(targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNIdentityReference;
    procedure SetGroup(identity: DDN.mscorlib.DNIdentityReference);
    procedure PurgeAccessRules(identity: DDN.mscorlib.DNIdentityReference);
    procedure PurgeAuditRules(identity: DDN.mscorlib.DNIdentityReference);
    procedure SetAccessRuleProtection(isProtected: Boolean; preserveInheritance: Boolean);
    procedure SetAuditRuleProtection(isProtected: Boolean; preserveInheritance: Boolean);
    function GetSecurityDescriptorSddlForm(includeSections: DDN.mscorlib.DNAccessControlSections): string;
    procedure SetSecurityDescriptorSddlForm(sddlForm: string); overload;
    procedure SetSecurityDescriptorSddlForm(sddlForm: string; includeSections: DDN.mscorlib.DNAccessControlSections); overload;
    function GetSecurityDescriptorBinaryForm: TArray<Byte>;
    procedure SetSecurityDescriptorBinaryForm(binaryForm: TArray<Byte>); overload;
    procedure SetSecurityDescriptorBinaryForm(binaryForm: TArray<Byte>; includeSections: DDN.mscorlib.DNAccessControlSections); overload;
    function ModifyAccessRule(modification: DDN.mscorlib.DNAccessControlModification; rule: DDN.mscorlib.DNAccessRule; out modified: Boolean): Boolean;
    function ModifyAuditRule(modification: DDN.mscorlib.DNAccessControlModification; rule: DDN.mscorlib.DNAuditRule; out modified: Boolean): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Type" />
    ///  of the securable object that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///<returns>The type of the securable object that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</returns>
    property AccessRightType: DDN.mscorlib.DNType read get_AccessRightType;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  of the object that is associated with the access rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///<returns>The type of the object that is associated with the access rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</returns>
    property AccessRuleType: DDN.mscorlib.DNType read get_AccessRuleType;
    ///<summary>Gets the <see cref="T:System.Type" />
    ///  object associated with the audit rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</summary>
    ///<returns>The type of the object that is associated with the audit rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" />
    ///  object.</returns>
    property AuditRuleType: DDN.mscorlib.DNType read get_AuditRuleType;
    property AreAccessRulesProtected: Boolean read get_AreAccessRulesProtected;
    property AreAuditRulesProtected: Boolean read get_AreAuditRulesProtected;
    property AreAccessRulesCanonical: Boolean read get_AreAccessRulesCanonical;
    property AreAuditRulesCanonical: Boolean read get_AreAuditRulesCanonical;
  end;

  TDNPipeSecurity = class(TDNGenericImport<DNPipeSecurityClass, DNPipeSecurity>) end;

  //-------------namespace: System.IO.MemoryMappedFiles----------------
  DNMemoryMappedFileSecurityClass = interface(DDN.mscorlib.DNObjectSecurityClass<DNMemoryMappedFileRights>)
  ['{29E663D3-1D0A-5176-B328-196BF6482561}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
    ///  class. </summary>
    {class} function init: DNMemoryMappedFileSecurity;

  end;

  ///<summary>Represents the permissions that can be granted for file access and operations on memory-mapped files. </summary>
  [DNTypeName('System.IO.MemoryMappedFiles.MemoryMappedFileSecurity')]
  DNMemoryMappedFileSecurity = interface(DDN.mscorlib.DNObjectSecurity<DNMemoryMappedFileRights>)
  ['{5A2856BD-CC21-3A39-AF94-05B8F9C89AC5}']
  { getters & setters } 

    function get_AccessRightType: DDN.mscorlib.DNType;
    function get_AccessRuleType: DDN.mscorlib.DNType;
    function get_AuditRuleType: DDN.mscorlib.DNType;
    function get_AreAccessRulesProtected: Boolean;
    function get_AreAuditRulesProtected: Boolean;
    function get_AreAccessRulesCanonical: Boolean;
    function get_AreAuditRulesCanonical: Boolean;

  { methods } 

    function AccessRuleFactory(identityReference: DDN.mscorlib.DNIdentityReference; accessMask: Int32; isInherited: Boolean; inheritanceFlags: DDN.mscorlib.DNInheritanceFlags; propagationFlags: DDN.mscorlib.DNPropagationFlags; &type: DDN.mscorlib.DNAccessControlType): DDN.mscorlib.DNAccessRule;
    function AuditRuleFactory(identityReference: DDN.mscorlib.DNIdentityReference; accessMask: Int32; isInherited: Boolean; inheritanceFlags: DDN.mscorlib.DNInheritanceFlags; propagationFlags: DDN.mscorlib.DNPropagationFlags; flags: DDN.mscorlib.DNAuditFlags): DDN.mscorlib.DNAuditRule;
    procedure AddAccessRule(rule: DDN.mscorlib.DNAccessRule<DNMemoryMappedFileRights>);
    procedure SetAccessRule(rule: DDN.mscorlib.DNAccessRule<DNMemoryMappedFileRights>);
    procedure ResetAccessRule(rule: DDN.mscorlib.DNAccessRule<DNMemoryMappedFileRights>);
    function RemoveAccessRule(rule: DDN.mscorlib.DNAccessRule<DNMemoryMappedFileRights>): Boolean;
    procedure RemoveAccessRuleAll(rule: DDN.mscorlib.DNAccessRule<DNMemoryMappedFileRights>);
    procedure RemoveAccessRuleSpecific(rule: DDN.mscorlib.DNAccessRule<DNMemoryMappedFileRights>);
    procedure AddAuditRule(rule: DDN.mscorlib.DNAuditRule<DNMemoryMappedFileRights>);
    procedure SetAuditRule(rule: DDN.mscorlib.DNAuditRule<DNMemoryMappedFileRights>);
    function RemoveAuditRule(rule: DDN.mscorlib.DNAuditRule<DNMemoryMappedFileRights>): Boolean;
    procedure RemoveAuditRuleAll(rule: DDN.mscorlib.DNAuditRule<DNMemoryMappedFileRights>);
    procedure RemoveAuditRuleSpecific(rule: DDN.mscorlib.DNAuditRule<DNMemoryMappedFileRights>);
    function GetAccessRules(includeExplicit: Boolean; includeInherited: Boolean; targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNAuthorizationRuleCollection;
    function GetAuditRules(includeExplicit: Boolean; includeInherited: Boolean; targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNAuthorizationRuleCollection;
    function GetOwner(targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNIdentityReference;
    procedure SetOwner(identity: DDN.mscorlib.DNIdentityReference);
    function GetGroup(targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNIdentityReference;
    procedure SetGroup(identity: DDN.mscorlib.DNIdentityReference);
    procedure PurgeAccessRules(identity: DDN.mscorlib.DNIdentityReference);
    procedure PurgeAuditRules(identity: DDN.mscorlib.DNIdentityReference);
    procedure SetAccessRuleProtection(isProtected: Boolean; preserveInheritance: Boolean);
    procedure SetAuditRuleProtection(isProtected: Boolean; preserveInheritance: Boolean);
    function GetSecurityDescriptorSddlForm(includeSections: DDN.mscorlib.DNAccessControlSections): string;
    procedure SetSecurityDescriptorSddlForm(sddlForm: string); overload;
    procedure SetSecurityDescriptorSddlForm(sddlForm: string; includeSections: DDN.mscorlib.DNAccessControlSections); overload;
    function GetSecurityDescriptorBinaryForm: TArray<Byte>;
    procedure SetSecurityDescriptorBinaryForm(binaryForm: TArray<Byte>); overload;
    procedure SetSecurityDescriptorBinaryForm(binaryForm: TArray<Byte>; includeSections: DDN.mscorlib.DNAccessControlSections); overload;
    function ModifyAccessRule(modification: DDN.mscorlib.DNAccessControlModification; rule: DDN.mscorlib.DNAccessRule; out modified: Boolean): Boolean;
    function ModifyAuditRule(modification: DDN.mscorlib.DNAccessControlModification; rule: DDN.mscorlib.DNAuditRule; out modified: Boolean): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property AccessRightType: DDN.mscorlib.DNType read get_AccessRightType;
    property AccessRuleType: DDN.mscorlib.DNType read get_AccessRuleType;
    property AuditRuleType: DDN.mscorlib.DNType read get_AuditRuleType;
    property AreAccessRulesProtected: Boolean read get_AreAccessRulesProtected;
    property AreAuditRulesProtected: Boolean read get_AreAuditRulesProtected;
    property AreAccessRulesCanonical: Boolean read get_AreAccessRulesCanonical;
    property AreAuditRulesCanonical: Boolean read get_AreAuditRulesCanonical;
  end;

  TDNMemoryMappedFileSecurity = class(TDNGenericImport<DNMemoryMappedFileSecurityClass, DNMemoryMappedFileSecurity>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNDSACngClass = interface(DDN.mscorlib.DNDSAClass)
  ['{C0D249F5-47DE-5C11-A8B1-AEE853A4E0CC}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.DSACng" />
    ///  class with a random 2,048-bit key pair. </summary>
    {class} function init: DNDSACng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.DSACng" />
    ///  class with a randomly generated key of the specified size. </summary>
    ///  <param name="keySize">The size of the key to generate in bits. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="keySize" />
    ///  is not valid. </exception>
    {class} function init(keySize: Int32): DNDSACng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.DSACng" />
    ///  class with the specified key. </summary>
    ///  <param name="key">The key to use for DSA operations. </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  is not a valid DSA key. </exception><exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(key: DNCngKey): DNDSACng; overload;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Digital Signature Algorithm (DSA).</summary>
  [DNTypeName('System.Security.Cryptography.DSACng')]
  DNDSACng = interface(DDN.mscorlib.DNDSA)
  ['{08B3195E-5EA7-3F6D-9BC5-E9056BF367A4}']
  { getters & setters } 

    function get_Key: DNCngKey;
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_SignatureAlgorithm: string;
    function get_KeyExchangeAlgorithm: string;
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);

  { methods } 

    ///<summary>Creates the digital signature for the specified data.</summary>
    ///  <param name="rgbHash">The data to be signed.</param>
    ///<returns>The digital signature for the specified data.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="rgbHash" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException"><paramref name="rgbHash" />
    ///  is shorter in length than the Q value of the DSA key . </exception>
    function CreateSignature(rgbHash: TArray<Byte>): TArray<Byte>;
    ///<summary>Verifies if the specified digital signature matches the specified data. </summary>
    ///  <param name="rgbHash">The signed data.</param>
    ///  <param name="rgbSignature">The digital signature to be verified.</param>
    ///<returns><see langword="true" />
    ///  if <paramref name="rgbSignature" />
    ///  matches the signature computed using the specified data; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="rgbHash" />
    ///  parameter is <see langword="null" />
    ///  .-or- The <paramref name="rgbSignature" />
    ///  parameter is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException"><paramref name="rgbHash" />
    ///  is shorter in length than the Q value of the DSA key . </exception>
    function VerifySignature(rgbHash: TArray<Byte>; rgbSignature: TArray<Byte>): Boolean;
    ///<summary>Exports the DSA algorithm parameters. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>The DSA algorithm parameters. </returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">DSA key is not a valid public or private key.</exception>
    function ExportParameters(includePrivateParameters: Boolean): DDN.mscorlib.DNDSAParameters;
    ///<summary>Replaces the existing key that the current instance is working with by creating a new <see cref="T:System.Security.Cryptography.CngKey" />
    ///  for the parameters structure. </summary>
    ///  <param name="parameters">The DSA parameters. </param>
    ///<exception cref="T:System.ArgumentException">The specified DSA parameters are not valid. </exception>
    procedure ImportParameters(parameters: DDN.mscorlib.DNDSAParameters);
    function SignData(data: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    function SignData(data: TArray<Byte>; offset: Int32; count: Int32; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    function SignData(data: DDN.mscorlib.DNStream; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    function VerifyData(data: TArray<Byte>; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    function VerifyData(data: TArray<Byte>; offset: Int32; count: Int32; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    function VerifyData(data: DDN.mscorlib.DNStream; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    procedure FromXmlString(xmlString: string);
    function ToXmlString(includePrivateParameters: Boolean): string;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the key that will be used by the <see cref="T:System.Security.Cryptography.DSACng" />
    ///  object for any cryptographic operation that it performs. </summary>
    ///<returns>The key used by the <see cref="T:System.Security.Cryptography.DSACng" />
    ///  object to perform cryptographic operations. </returns>
    property Key: DNCngKey read get_Key;
    ///<summary>Gets the key sizes, in bits, that are supported by the DSA algorithm.</summary>
    ///<returns>An array that contains the key sizes supported by the algorithm.</returns>
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
    ///<summary>Gets the name of the signature algorithm. </summary>
    ///<returns>The string "DSA".</returns>
    property SignatureAlgorithm: string read get_SignatureAlgorithm;
    ///<summary>Gets the name of the key exchange algorithm.</summary>
    ///<returns>Always <see langword="null" />
    ///  .</returns>
    property KeyExchangeAlgorithm: string read get_KeyExchangeAlgorithm;
    property KeySize: Int32 read get_KeySize write set_KeySize;
  end;

  TDNDSACng = class(TDNGenericImport<DNDSACngClass, DNDSACng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECDiffieHellmanClass = interface(DDN.mscorlib.DNAsymmetricAlgorithmClass)
  ['{F2D343A4-DBAB-5FEF-A8FF-B9D9C0209B5F}']
  { static methods } 

    ///<summary>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</summary>
    ///<returns>A new instance of the default implementation of this class.</returns>
    {class} function Create: DNECDiffieHellman; overload;
    ///<summary>Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</summary>
    ///  <param name="algorithm">The name of an implementation of the ECDH algorithm.</param>
    ///<returns>A new instance of the specified implementation of this class. If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="algorithm" />
    ///  parameter is <see langword="null" />
    ///  . </exception>
    {class} function Create(algorithm: string): DNECDiffieHellman; overload;
    ///<summary>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve. </summary>
    ///  <param name="curve">The curve to use to generate a new public/private key-pair. </param>
    ///<returns>A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. </returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" />
    ///  does not validate. </exception>
    {class} function Create(curve: DNECCurve): DNECDiffieHellman; overload;
    ///<summary>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. </summary>
    ///  <param name="parameters">The parameters  for the elliptic curve cryptography (ECC) algorithm. </param>
    ///<returns>A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. </returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" />
    ///  does not validate. </exception>
    {class} function Create(parameters: DNECParameters): DNECDiffieHellman; overload;

  end;

  ///<summary>Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from. This class provides the basic set of operations that all ECDH implementations must support.</summary>
  [DNTypeName('System.Security.Cryptography.ECDiffieHellman')]
  DNECDiffieHellman = interface(DDN.mscorlib.DNAsymmetricAlgorithm)
  ['{306543FF-7167-31E6-9F1B-A6DC30F5E519}']
  { getters & setters } 

    function get_KeyExchangeAlgorithm: string;
    function get_SignatureAlgorithm: string;
    function get_PublicKey: DNECDiffieHellmanPublicKey;
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;

  { methods } 

    ///<summary>Derives bytes that can be used as a key, given another party's public key.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    function DeriveKeyMaterial(otherPartyPublicKey: DNECDiffieHellmanPublicKey): TArray<Byte>;
    ///<summary>Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm  to use to derive the key material.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    function DeriveKeyFromHash(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm  to use to derive the key material.</param>
    ///  <param name="secretPrepend">A value to prepend to the derived secret before hashing.</param>
    ///  <param name="secretAppend">A value to append to the derived secret before hashing.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    ///<exception cref="T:System.NotImplementedException">A derived class must override this method.</exception>
    function DeriveKeyFromHash(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; secretPrepend: TArray<Byte>; secretAppend: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to derive the key material.</param>
    ///  <param name="hmacKey">The key for the HMAC.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    function DeriveKeyFromHmac(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; hmacKey: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to derive the key material.</param>
    ///  <param name="hmacKey">The key for the HMAC.</param>
    ///  <param name="secretPrepend">A value to prepend to the derived secret before hashing.</param>
    ///  <param name="secretAppend">A value to append to the derived secret before hashing.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    ///<exception cref="T:System.NotImplementedException">A derived class must override this method.</exception>
    function DeriveKeyFromHmac(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; hmacKey: TArray<Byte>; secretPrepend: TArray<Byte>; secretAppend: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="prfLabel">The ASCII-encoded PRF label.</param>
    ///  <param name="prfSeed">The 64-byte PRF seed.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    ///<exception cref="T:System.NotImplementedException">A derived class must override this method.</exception>
    function DeriveKeyTls(otherPartyPublicKey: DNECDiffieHellmanPublicKey; prfLabel: TArray<Byte>; prfSeed: TArray<Byte>): TArray<Byte>;
    ///<summary>When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  key to an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
    ///  method. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otehrwise,  <see langword="false" />
    ///  to include public parameters only.</param>
    ///<returns>An object that represents the point on the curve for this key. It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
    ///  method. </returns>
    ///<exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
    function ExportParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  key to an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
    ///  method. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>An object that represents the point on the curve for this key, using the explicit curve format. </returns>
    ///<exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
    function ExportExplicitParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  object. </summary>
    ///  <param name="parameters">The curve's parameters to import. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" />
    ///  does not validate. </exception><exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
    procedure ImportParameters(parameters: DNECParameters);
    ///<summary>When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve. </summary>
    ///  <param name="curve">The curve used to generate an ephemeral public/private key pair. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" />
    ///  does not validate. </exception><exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
    procedure GenerateKey(curve: DNECCurve);
    procedure Dispose;
    procedure Clear;
    procedure FromXmlString(xmlString: string);
    function ToXmlString(includePrivateParameters: Boolean): string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the key exchange algorithm.</summary>
    ///<returns>The name of the key exchange algorithm. </returns>
    property KeyExchangeAlgorithm: string read get_KeyExchangeAlgorithm;
    ///<summary>Gets the name of the signature algorithm.</summary>
    ///<returns>Always <see langword="null" />
    ///  .</returns>
    property SignatureAlgorithm: string read get_SignatureAlgorithm;
    ///<summary>Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</summary>
    ///<returns>The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  instance.</returns>
    property PublicKey: DNECDiffieHellmanPublicKey read get_PublicKey;
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
  end;

  TDNECDiffieHellman = class(TDNGenericImport<DNECDiffieHellmanClass, DNECDiffieHellman>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECDiffieHellmanCngClass = interface(DNECDiffieHellmanClass)
  ['{CFA2843C-02A2-55E6-A879-04C7454B4DA8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  class with a random key pair.</summary>
    {class} function init: DNECDiffieHellmanCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  class with a random key pair, using the specified key size.</summary>
    ///  <param name="keySize">The size of the key. Valid key sizes are 256, 384, and 521 bits.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="keySize" />
    ///  specifies an invalid length.</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
    {class} function init(keySize: Int32): DNECDiffieHellmanCng; overload;
    ///<summary>Creates a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  class whose public/private key pair is generated over the specified curve. </summary>
    ///  <param name="curve">The curve used to generate the public/private key pair. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" />
    ///  does not validate. </exception>
    {class} function init(curve: DNECCurve): DNECDiffieHellmanCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  class by using the specified <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object.</summary>
    ///  <param name="key">The key that will be used as input to the cryptographic operations performed by the current object. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  does not specify an Elliptic Curve Diffie-Hellman (ECDH) algorithm group.</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
    {class} function init(key: DNCngKey): DNECDiffieHellmanCng; overload;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. This class is used to perform cryptographic operations.</summary>
  [DNTypeName('System.Security.Cryptography.ECDiffieHellmanCng')]
  DNECDiffieHellmanCng = interface(DNECDiffieHellman)
  ['{D407780B-8E4C-3CAE-A77D-D1A0F8CDBEFC}']
  { getters & setters } 

    function get_HashAlgorithm: DNCngAlgorithm;
    procedure set_HashAlgorithm(value: DNCngAlgorithm);
    function get_HmacKey: TArray<Byte>;
    procedure set_HmacKey(value: TArray<Byte>);
    function get_KeyDerivationFunction: DNECDiffieHellmanKeyDerivationFunction;
    procedure set_KeyDerivationFunction(value: DNECDiffieHellmanKeyDerivationFunction);
    function get_Label: TArray<Byte>;
    procedure set_Label(value: TArray<Byte>);
    function get_SecretAppend: TArray<Byte>;
    procedure set_SecretAppend(value: TArray<Byte>);
    function get_SecretPrepend: TArray<Byte>;
    procedure set_SecretPrepend(value: TArray<Byte>);
    function get_Seed: TArray<Byte>;
    procedure set_Seed(value: TArray<Byte>);
    function get_Key: DNCngKey;
    function get_PublicKey: DNECDiffieHellmanPublicKey;
    function get_UseSecretAgreementAsHmacKey: Boolean;
    function get_KeyExchangeAlgorithm: string;
    function get_SignatureAlgorithm: string;
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;

  { methods } 

    ///<summary>Derives the key material that is generated from the secret agreement between two parties, given an <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />
    ///  object that contains the second party's public key. </summary>
    ///  <param name="otherPartyPublicKey">The public key from the other party in the key exchange.</param>
    ///<returns>A byte array that contains the key material. This information is generated from the secret agreement that is calculated from the current object's private key and the specified public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is not an <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  key. </exception>
    function DeriveKeyMaterial(otherPartyPublicKey: DNECDiffieHellmanPublicKey): TArray<Byte>; overload;
    ///<summary>Derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="prfLabel">The ASCII-encoded PRF label.</param>
    ///  <param name="prfSeed">The 64-byte PRF seed.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="prfLabel" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="prfSeed" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is not an ECDH key, or it is not the correct size.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="prfSeed" />
    ///  is not exactly 64 bytes in length.-or-All other cryptographic errors.</exception>
    function DeriveKeyTls(otherPartyPublicKey: DNECDiffieHellmanPublicKey; prfLabel: TArray<Byte>; prfSeed: TArray<Byte>): TArray<Byte>;
    ///<summary>Gets a handle to the secret agreement generated between two parties, given an <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />
    ///  object that contains the second party's public key.</summary>
    ///  <param name="otherPartyPublicKey">The public key from the other party in the key exchange.</param>
    ///<returns>A handle to the secret agreement. This information is calculated from the current object's private key and the specified public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is not an <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />
    ///  key. </exception>
    function DeriveSecretAgreementHandle(otherPartyPublicKey: DNECDiffieHellmanPublicKey): DNSafeNCryptSecretHandle; overload;
    ///<summary>Gets a handle to the secret agreement generated between two parties, given a <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that contains the second party's public key.</summary>
    ///  <param name="otherPartyPublicKey">An object that contains the public part of the Elliptic Curve Diffie-Hellman (ECDH) key from the other party in the key exchange.</param>
    ///<returns>A handle to the secret agreement. This information is calculated from the current object's private key and the specified public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is not an ECDH key, or it is not the correct size.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    function DeriveSecretAgreementHandle(otherPartyPublicKey: DNCngKey): DNSafeNCryptSecretHandle; overload;
    ///<summary>This method is not implemented.</summary>
    ///  <param name="xmlString">The XML-based key information to be deserialized.</param>
    ///<exception cref="T:System.NotImplementedException">This method was not overridden for this instance.</exception>
    procedure FromXmlString(xmlString: string); overload;
    ///<summary>Deserializes the key information from an XML string by using the specified format.</summary>
    ///  <param name="xml">The XML-based key information to be deserialized.</param>
    ///  <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="xml" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="xml" />
    ///  is malformed.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="format" />
    ///  specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    procedure FromXmlString(xml: string; format: DNECKeyXmlFormat); overload;
    ///<summary>This method is not implemented.</summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>Not applicable.</returns>
    ///<exception cref="T:System.NotImplementedException">This method was not overridden for this instance.</exception>
    function ToXmlString(includePrivateParameters: Boolean): string; overload;
    ///<summary>Serializes the key information to an XML string by using the specified format.</summary>
    ///  <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</param>
    ///<returns>A string object that contains the key information, serialized to an XML string, according to the requested format.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="format" />
    ///  specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</exception>
    function ToXmlString(format: DNECKeyXmlFormat): string; overload;
    ///<summary>Imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object as a key into the current instance. </summary>
    ///  <param name="parameters">The curve's parameters to import. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" />
    ///  does not validate. </exception><exception cref="T:System.NotSupportedException"><paramref name="parameters" />
    ///  references a curve that cannot be imported.. </exception><exception cref="T:System.PlatformNotSupportedException"><paramref name="parameters" />
    ///  references a curve that is not supported by this platform. </exception>
    procedure ImportParameters(parameters: DNECParameters);
    ///<summary>Exports the key and explicit curve parameters used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object into an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>The key and explicit curve parameters used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object.</returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The method cannot obtain curve values. </exception><exception cref="T:System.PlatformNotSupportedException">Explicit export is not supported by this platform. Windows 10 or higher is required. </exception>
    function ExportExplicitParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>Exports the key used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object into an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The key and named curve parameters used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object. </returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The method cannot obtain curve values. </exception>
    function ExportParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>Derives the key material that is generated from the secret agreement between two parties, given a <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that contains the second party's public key. </summary>
    ///  <param name="otherPartyPublicKey">An object that contains the public part of the Elliptic Curve Diffie-Hellman (ECDH) key from the other party in the key exchange.</param>
    ///<returns>A byte array that contains the key material. This information is generated from the secret agreement that is calculated from the current object's private key and the specified public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is invalid. Either its <see cref="P:System.Security.Cryptography.CngKey.AlgorithmGroup" />
    ///  property does not specify <see cref="P:System.Security.Cryptography.CngAlgorithmGroup.ECDiffieHellman" />
    ///  or its key size does not match the key size of this instance.</exception><exception cref="T:System.InvalidOperationException">This object's <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" />
    ///  property specifies the <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />
    ///  key derivation function, but either <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />
    ///  or <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    function DeriveKeyMaterial(otherPartyPublicKey: DNCngKey): TArray<Byte>; overload;
    ///<summary>Derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm  to use to derive the key material.</param>
    ///  <param name="secretPrepend">A value to prepend to the derived secret before hashing.</param>
    ///  <param name="secretAppend">A value to append to the derived secret before hashing.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is not an ECDH key, or it is not the correct size.-or-
    ///  <paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    function DeriveKeyFromHash(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; secretPrepend: TArray<Byte>; secretAppend: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to derive the key material.</param>
    ///  <param name="hmacKey">The key for the HMAC.</param>
    ///  <param name="secretPrepend">A value to prepend to the derived secret before hashing.</param>
    ///  <param name="secretAppend">A value to append to the derived secret before hashing.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="otherPartyPublicKey" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="otherPartyPublicKey" />
    ///  is not an ECDH key, or it is not the correct size.-or-
    ///  <paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    function DeriveKeyFromHmac(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; hmacKey: TArray<Byte>; secretPrepend: TArray<Byte>; secretAppend: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>Generates a new ephemeral public/private key pair for the specified curve. </summary>
    ///  <param name="curve">The curve used to generate an ephemeral public/private key pair. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" />
    ///  does not validate. </exception>
    procedure GenerateKey(curve: DNECCurve);
    ///<summary>Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm  to use to derive the key material.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    function DeriveKeyFromHash(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</summary>
    ///  <param name="otherPartyPublicKey">The other party's public key.</param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to derive the key material.</param>
    ///  <param name="hmacKey">The key for the HMAC.</param>
    ///<returns>The key material from the key exchange with the other partyâ€™s public key.</returns>
    function DeriveKeyFromHmac(otherPartyPublicKey: DNECDiffieHellmanPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; hmacKey: TArray<Byte>): TArray<Byte>; overload;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the hash algorithm to use when generating key material.</summary>
    ///<returns>An object that specifies the hash algorithm.</returns>
    ///<exception cref="T:System.ArgumentNullException">The value is <see langword="null." />
    ///</exception>
    property HashAlgorithm: DNCngAlgorithm read get_HashAlgorithm write set_HashAlgorithm;
    ///<summary>Gets or sets the Hash-based Message Authentication Code (HMAC) key to use when deriving key material.</summary>
    ///<returns>The Hash-based Message Authentication Code (HMAC) key to use when deriving key material.</returns>
    property HmacKey: TArray<Byte> read get_HmacKey write set_HmacKey;
    ///<summary>Gets or sets the key derivation function for the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  class.</summary>
    ///<returns>One of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" />
    ///  enumeration values: <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />
    ///  , <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />
    ///  , or <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />
    ///  . The default value is <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The enumeration value is out of range.</exception>
    property KeyDerivationFunction: DNECDiffieHellmanKeyDerivationFunction read get_KeyDerivationFunction write set_KeyDerivationFunction;
    ///<summary>Gets or sets the label value that is used for key derivation.</summary>
    ///<returns>The label value.</returns>
    property &Label: TArray<Byte> read get_Label write set_Label;
    ///<summary>Gets or sets a value that will be appended to the secret agreement when generating key material.</summary>
    ///<returns>The value that is appended to the secret agreement.</returns>
    property SecretAppend: TArray<Byte> read get_SecretAppend write set_SecretAppend;
    ///<summary>Gets or sets a value that will be added to the beginning of the secret agreement when deriving key material.</summary>
    ///<returns>The value that is appended to the beginning of the secret agreement during key derivation.</returns>
    property SecretPrepend: TArray<Byte> read get_SecretPrepend write set_SecretPrepend;
    ///<summary>Gets or sets the seed value that will be used when deriving key material.</summary>
    ///<returns>The seed value.</returns>
    property Seed: TArray<Byte> read get_Seed write set_Seed;
    ///<summary>Specifies the <see cref="T:System.Security.Cryptography.CngKey" />
    ///  that is used by the current object for cryptographic operations.</summary>
    ///<returns>The key pair used by this object to perform cryptographic operations.</returns>
    property Key: DNCngKey read get_Key;
    ///<summary>Gets the public key that can be used by another <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  object to generate a shared secret agreement.</summary>
    ///<returns>The public key that is associated with this instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
    ///  object.</returns>
    property PublicKey: DNECDiffieHellmanPublicKey read get_PublicKey;
    ///<summary>Gets a value that indicates whether the secret agreement is used as a Hash-based Message Authentication Code (HMAC) key to derive key material.</summary>
    ///<returns><see langword="true" />
    ///  if the secret agreement is used as an HMAC key to derive key material; otherwise, <see langword="false" />
    ///  .</returns>
    property UseSecretAgreementAsHmacKey: Boolean read get_UseSecretAgreementAsHmacKey;
    ///<summary>Gets the name of the key exchange algorithm.</summary>
    ///<returns>The name of the key exchange algorithm. </returns>
    property KeyExchangeAlgorithm: string read get_KeyExchangeAlgorithm;
    ///<summary>Gets the name of the signature algorithm.</summary>
    ///<returns>Always <see langword="null" />
    ///  .</returns>
    property SignatureAlgorithm: string read get_SignatureAlgorithm;
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
  end;

  TDNECDiffieHellmanCng = class(TDNGenericImport<DNECDiffieHellmanCngClass, DNECDiffieHellmanCng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECDsaClass = interface(DDN.mscorlib.DNAsymmetricAlgorithmClass)
  ['{FC8AC58B-2665-593B-8365-7D26AC438EBA}']
  { static methods } 

    ///<summary>Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</summary>
    ///<returns>A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  ) of this class.</returns>
    {class} function Create: DNECDsa; overload;
    ///<summary>Creates a new instance of the specified implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</summary>
    ///  <param name="algorithm">The name of an ECDSA implementation. The following strings all refer to the same implementation, which is the only implementation currently supported in the .NET Framework:- "ECDsa"- "ECDsaCng"- "System.Security.Cryptography.ECDsaCng"You can also provide the name of a custom ECDSA implementation.</param>
    ///<returns>A new instance of the specified implementation of this class. If the specified algorithm name does not map to an ECDSA implementation, this method returns <see langword="null" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="algorithm" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    {class} function Create(algorithm: string): DNECDsa; overload;
    ///<summary>Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) with a newly generated key over the specified curve.</summary>
    ///  <param name="curve">The curve to use for key generation.</param>
    ///<returns>A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  ) of this class.</returns>
    {class} function Create(curve: DNECCurve): DNECDsa; overload;
    ///<summary>Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) using the specified parameters as the key.</summary>
    ///  <param name="parameters">The parameters representing the key to use.</param>
    ///<returns>A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  ) of this class.</returns>
    {class} function Create(parameters: DNECParameters): DNECDsa; overload;

  end;

  ///<summary>Provides an abstract base class that encapsulates the Elliptic Curve Digital Signature Algorithm (ECDSA).</summary>
  [DNTypeName('System.Security.Cryptography.ECDsa')]
  DNECDsa = interface(DDN.mscorlib.DNAsymmetricAlgorithm)
  ['{CF96A7B5-296F-3481-8E08-5784E0C09927}']
  { getters & setters } 

    function get_KeyExchangeAlgorithm: string;
    function get_SignatureAlgorithm: string;
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;

  { methods } 

    ///<summary>Computes the hash value of the specified byte array using the specified hash algorithm and signs the resulting hash value. </summary>
    ///  <param name="data">The input data for which to compute the hash. </param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
    ///<returns>The ECDSA signature for the specified data. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function SignData(data: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Computes the hash value of a portion of the specified byte array using the specified hash algorithm and signs the resulting hash value. </summary>
    ///  <param name="data">The input data for which to compute the hash. </param>
    ///  <param name="offset">The offset into the array at which to begin using data. </param>
    ///  <param name="count">The number of bytes in the array to use as data. </param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
    ///<returns>The ECDSA signature for the specified data. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than zero. -or-
    ///  <paramref name="count" />
    ///  is less than zero. -or-
    ///  <paramref name="offset" />
    ///  + <paramref name="count" />
    ///  â€“ 1 results in an index that is beyond the upper bound of <paramref name="data" />
    ///  .  </exception>
    function SignData(data: TArray<Byte>; offset: Int32; count: Int32; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Computes the hash value of the specified stream using the specified hash algorithm and signs the resulting hash value.</summary>
    ///  <param name="data">The input stream for which to compute the hash. </param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
    ///<returns>The ECDSA signature for the specified data. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function SignData(data: DDN.mscorlib.DNStream; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Verifies that a digital signature is valid by calculating the hash value of the specified data using the specified hash algorithm and comparing it to the provided signature. </summary>
    ///  <param name="data">The signed data. </param>
    ///  <param name="signature">The signature data to be verified. </param>
    ///  <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function VerifyData(data: TArray<Byte>; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    ///<summary>Verifies that a digital signature is valid by calculating the hash value of the data in a portion of a byte array using the specified hash algorithm and comparing it to the provided signature. </summary>
    ///  <param name="data">The signed data. </param>
    ///  <param name="offset">The starting index at which to compute the hash. </param>
    ///  <param name="count">The number of bytes to hash. </param>
    ///  <param name="signature">The signature data to be verified. </param>
    ///  <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than zero. -or-
    ///  <paramref name="count" />
    ///  is less than zero.-or-
    ///  <paramref name="offset" />
    ///  + <paramref name="count" />
    ///  â€“ 1 results in an index that is beyond the upper bound of <paramref name="data" />
    ///  .  </exception>
    function VerifyData(data: TArray<Byte>; offset: Int32; count: Int32; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    ///<summary>Verifies that a digital signature is valid by calculating the hash value of the specified stream using the specified hash algorithm and comparing it to the provided signature. </summary>
    ///  <param name="data">The signed data. </param>
    ///  <param name="signature">The signature data to be verified. </param>
    ///  <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function VerifyData(data: DDN.mscorlib.DNStream; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    ///<summary>When overridden in a derived class, exports the named or explicit parameters for an elliptic curve. If the curve has a name, the <see cref="F:System.Security.Cryptography.ECParameters.Curve" />
    ///  field contains named curve parameters, otherwise it
    ///  contains explicit parameters.</summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The parameters representing the point on the curve for this key.</returns>
    ///<exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
    function ExportParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>When overridden in a derived class, exports the explicit parameters for an elliptic curve.</summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The parameters representing the point on the curve for this key, using the explicit curve format.</returns>
    ///<exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
    function ExportExplicitParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>When overridden in a derived class, imports the specified parameters.</summary>
    ///  <param name="parameters">The curve parameters.</param>
    ///<exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
    procedure ImportParameters(parameters: DNECParameters);
    ///<summary>When overridden in a derived class, generates a new public/private key pair for the specified curve.</summary>
    ///  <param name="curve">The curve to use.</param>
    ///<exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
    procedure GenerateKey(curve: DNECCurve);
    ///<summary>Generates a digital signature for the specified hash value. </summary>
    ///  <param name="hash">The hash value of the data that is being signed.</param>
    ///<returns>A digital signature that consists of the given hash value encrypted with the private key.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="hash" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    function SignHash(hash: TArray<Byte>): TArray<Byte>;
    ///<summary>Verifies a digital signature against the specified hash value.</summary>
    ///  <param name="hash">The hash value of a block of data.</param>
    ///  <param name="signature">The digital signature to be verified.</param>
    ///<returns><see langword="true" />
    ///  if the hash value equals the decrypted signature; otherwise, <see langword="false" />
    ///  .</returns>
    function VerifyHash(hash: TArray<Byte>; signature: TArray<Byte>): Boolean;
    procedure Dispose;
    procedure Clear;
    procedure FromXmlString(xmlString: string);
    function ToXmlString(includePrivateParameters: Boolean): string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the key exchange algorithm.</summary>
    ///<returns>Always <see langword="null" />
    ///  .</returns>
    property KeyExchangeAlgorithm: string read get_KeyExchangeAlgorithm;
    ///<summary>Gets the name of the signature algorithm.</summary>
    ///<returns>The string "ECDsa".</returns>
    property SignatureAlgorithm: string read get_SignatureAlgorithm;
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
  end;

  TDNECDsa = class(TDNGenericImport<DNECDsaClass, DNECDsa>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECDsaCngClass = interface(DNECDsaClass)
  ['{C6FCE214-49ED-5B99-B043-31C2A1121E43}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  class with a random key pair.</summary>
    ///<exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
    {class} function init: DNECDsaCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  class with a random key pair, using the specified key size.</summary>
    ///  <param name="keySize">The size of the key. Valid key sizes are 256, 384, and 521 bits.</param>
    ///<exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="keySize" />
    ///  specifies an invalid length. </exception>
    {class} function init(keySize: Int32): DNECDsaCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  class whose public/private key pair is generated over the specified curve.</summary>
    ///  <param name="curve">The curve used to generate the public/private key pair. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" />
    ///  does not validate.</exception>
    {class} function init(curve: DNECCurve): DNECDsaCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" />
    ///  class by using the specified <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object.</summary>
    ///  <param name="key">The key that will be used as input to the cryptographic operations performed by the current object.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  does not specify an Elliptic Curve Digital Signature Algorithm (ECDSA) group.</exception><exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
    {class} function init(key: DNCngKey): DNECDsaCng; overload;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA). </summary>
  [DNTypeName('System.Security.Cryptography.ECDsaCng')]
  DNECDsaCng = interface(DNECDsa)
  ['{3954C6A3-6A49-3BC6-81C4-392984639FA3}']
  { getters & setters } 

    function get_HashAlgorithm: DNCngAlgorithm;
    procedure set_HashAlgorithm(value: DNCngAlgorithm);
    function get_Key: DNCngKey;
    function get_KeyExchangeAlgorithm: string;
    function get_SignatureAlgorithm: string;
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;

  { methods } 

    ///<summary>This method is not implemented.</summary>
    ///  <param name="xmlString">The XML-based key information to be deserialized.</param>
    ///<exception cref="T:System.NotImplementedException">This method was not overridden for this instance. </exception>
    procedure FromXmlString(xmlString: string); overload;
    ///<summary>Deserializes the key information from an XML string by using the specified format.</summary>
    ///  <param name="xml">The XML-based key information to be deserialized.</param>
    ///  <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="xml" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="format" />
    ///  specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    procedure FromXmlString(xml: string; format: DNECKeyXmlFormat); overload;
    ///<summary>Generates a signature for the specified data.</summary>
    ///  <param name="data">The message data to be signed.</param>
    ///<returns>A digital signature for the specified data.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
    function SignData(data: TArray<Byte>): TArray<Byte>; overload;
    ///<summary>Generates a signature for the specified hash value.</summary>
    ///  <param name="hash">The hash value of the data to be signed.</param>
    ///<returns>A digital signature for the specified hash value.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="hash" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
    function SignHash(hash: TArray<Byte>): TArray<Byte>;
    ///<summary>This method is not implemented.</summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>Not applicable.</returns>
    ///<exception cref="T:System.NotImplementedException">This method is not implemented.</exception>
    function ToXmlString(includePrivateParameters: Boolean): string; overload;
    ///<summary>Serializes the key information to an XML string by using the specified format.</summary>
    ///  <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</param>
    ///<returns>A string object that contains the key information, serialized to an XML string according to the requested format.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="format" />
    ///  specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    function ToXmlString(format: DNECKeyXmlFormat): string; overload;
    ///<summary>Verifies the digital signature of the specified data. </summary>
    ///  <param name="data">The data that was signed.</param>
    ///  <param name="signature">The signature to be verified.</param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  or <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception>
    function VerifyData(data: TArray<Byte>; signature: TArray<Byte>): Boolean; overload;
    ///<summary>Verifies the specified digital signature against a specified hash value.</summary>
    ///  <param name="hash">The hash value of the data to be verified.</param>
    ///  <param name="signature">The digital signature of the data to be verified against the hash value.</param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="hash" />
    ///  or <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception>
    function VerifyHash(hash: TArray<Byte>; signature: TArray<Byte>): Boolean;
    ///<summary>Replaces the existing key that the current instance is working with by creating a new <see cref="T:System.Security.Cryptography.CngKey" />
    ///  for the parameters structure.</summary>
    ///  <param name="parameters">The curve parameters.</param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" />
    ///  does not contain valid values. </exception><exception cref="T:System.NotSupportedException"><paramref name="parameters" />
    ///  references a curve that cannot be imported. </exception><exception cref="T:System.PlatformNotSupportedException"><paramref name="parameters" />
    ///  references a curve that is not supported by this platform. </exception>
    procedure ImportParameters(parameters: DNECParameters);
    ///<summary>Exports the key and explicit curve parameters used by the Elliptic curve cryptography (ECC) object into an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The key and explicit curve parameters used by the ECC object. </returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">An error occurred while obtaining the curve values. </exception><exception cref="T:System.PlatformNotSupportedException">Explicit export is not supported by this platform. Windows 10 or higher is required.</exception>
    function ExportExplicitParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>Exports the key used by the Elliptic curve cryptography (ECC) object into an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. If the key was created as a named curve, the <see cref="F:System.Security.Cryptography.ECParameters.Curve" />
    ///  field contains named curve parameters; otherwise, it contains explicit parameters.</summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The key and named curve parameters used by the ECC object. </returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">An error occurred while obtaining the curve values. </exception>
    function ExportParameters(includePrivateParameters: Boolean): DNECParameters;
    ///<summary>Generates a digital signature for the specified length of data, beginning at the specified offset. </summary>
    ///  <param name="data">The message data to be signed.</param>
    ///  <param name="offset">The location in the string at which to start signing.</param>
    ///  <param name="count">The length of the string, in characters, following <paramref name="offset" />
    ///  that will be signed.</param>
    ///<returns>A digital signature for the specified length of data.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />
    ///  or <paramref name="offset" />
    ///  caused reading outside the bounds of the data string. </exception><exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
    function SignData(data: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    ///<summary>Generates a signature for the specified data stream, reading to the end of the stream.</summary>
    ///  <param name="data">The data stream to be signed.</param>
    ///<returns>A digital signature for the specified data stream.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
    function SignData(data: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    ///<summary>Verifies a signature for the specified length of data, beginning at the specified offset.</summary>
    ///  <param name="data">The data that was signed.</param>
    ///  <param name="offset">The location in the data at which the signed data begins.</param>
    ///  <param name="count">The length of the data, in characters, following <paramref name="offset" />
    ///  that will be signed.</param>
    ///  <param name="signature">The signature to be verified.</param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  or <paramref name="count" />
    ///  is less then zero. -or-
    ///  <paramref name="offset" />
    ///  or <paramref name="count" />
    ///  is larger than the length of the byte array passed in the <paramref name="data" />
    ///  parameter.</exception><exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  or <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception>
    function VerifyData(data: TArray<Byte>; offset: Int32; count: Int32; signature: TArray<Byte>): Boolean; overload;
    ///<summary>Verifies the digital signature of the specified data stream, reading to the end of the stream.</summary>
    ///  <param name="data">The data stream that was signed.</param>
    ///  <param name="signature">The signature to be verified.</param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  or <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception>
    function VerifyData(data: DDN.mscorlib.DNStream; signature: TArray<Byte>): Boolean; overload;
    ///<summary>Generates a key to use for the ECDsaCng algorithm.</summary>
    ///  <param name="curve">The curve to use to generate the key.</param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="curve" />
    ///  does not validate.</exception>
    procedure GenerateKey(curve: DNECCurve);
    ///<summary>Computes the hash value of the specified byte array using the specified hash algorithm and signs the resulting hash value. </summary>
    ///  <param name="data">The input data for which to compute the hash. </param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
    ///<returns>The ECDSA signature for the specified data. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function SignData(data: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Computes the hash value of a portion of the specified byte array using the specified hash algorithm and signs the resulting hash value. </summary>
    ///  <param name="data">The input data for which to compute the hash. </param>
    ///  <param name="offset">The offset into the array at which to begin using data. </param>
    ///  <param name="count">The number of bytes in the array to use as data. </param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
    ///<returns>The ECDSA signature for the specified data. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than zero. -or-
    ///  <paramref name="count" />
    ///  is less than zero. -or-
    ///  <paramref name="offset" />
    ///  + <paramref name="count" />
    ///  â€“ 1 results in an index that is beyond the upper bound of <paramref name="data" />
    ///  .  </exception>
    function SignData(data: TArray<Byte>; offset: Int32; count: Int32; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Computes the hash value of the specified stream using the specified hash algorithm and signs the resulting hash value.</summary>
    ///  <param name="data">The input stream for which to compute the hash. </param>
    ///  <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
    ///<returns>The ECDSA signature for the specified data. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function SignData(data: DDN.mscorlib.DNStream; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>; overload;
    ///<summary>Verifies that a digital signature is valid by calculating the hash value of the specified data using the specified hash algorithm and comparing it to the provided signature. </summary>
    ///  <param name="data">The signed data. </param>
    ///  <param name="signature">The signature data to be verified. </param>
    ///  <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function VerifyData(data: TArray<Byte>; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    ///<summary>Verifies that a digital signature is valid by calculating the hash value of the data in a portion of a byte array using the specified hash algorithm and comparing it to the provided signature. </summary>
    ///  <param name="data">The signed data. </param>
    ///  <param name="offset">The starting index at which to compute the hash. </param>
    ///  <param name="count">The number of bytes to hash. </param>
    ///  <param name="signature">The signature data to be verified. </param>
    ///  <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  is less than zero. -or-
    ///  <paramref name="count" />
    ///  is less than zero.-or-
    ///  <paramref name="offset" />
    ///  + <paramref name="count" />
    ///  â€“ 1 results in an index that is beyond the upper bound of <paramref name="data" />
    ///  .  </exception>
    function VerifyData(data: TArray<Byte>; offset: Int32; count: Int32; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    ///<summary>Verifies that a digital signature is valid by calculating the hash value of the specified stream using the specified hash algorithm and comparing it to the provided signature. </summary>
    ///  <param name="data">The signed data. </param>
    ///  <param name="signature">The signature data to be verified. </param>
    ///  <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
    ///<returns><see langword="true" />
    ///  if the signature is valid; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception>
    function VerifyData(data: DDN.mscorlib.DNStream; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): Boolean; overload;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the hash algorithm to use when signing and verifying data.</summary>
    ///<returns>An object that specifies the hash algorithm.</returns>
    ///<exception cref="T:System.ArgumentNullException">The value is <see langword="null" />
    ///  .</exception>
    property HashAlgorithm: DNCngAlgorithm read get_HashAlgorithm write set_HashAlgorithm;
    ///<summary>Gets or sets the key to use when signing and verifying data.</summary>
    ///<returns>An object that specifies the key.</returns>
    property Key: DNCngKey read get_Key;
    ///<summary>Gets the name of the key exchange algorithm.</summary>
    ///<returns>Always <see langword="null" />
    ///  .</returns>
    property KeyExchangeAlgorithm: string read get_KeyExchangeAlgorithm;
    ///<summary>Gets the name of the signature algorithm.</summary>
    ///<returns>The string "ECDsa".</returns>
    property SignatureAlgorithm: string read get_SignatureAlgorithm;
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
  end;

  TDNECDsaCng = class(TDNGenericImport<DNECDsaCngClass, DNECDsaCng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNRSACngClass = interface(DDN.mscorlib.DNRSAClass)
  ['{AB9AFD52-E689-5F39-938E-FC9206709E4A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.RSACng" />
    ///  class with a random 2,048-bit key pair. </summary>
    {class} function init: DNRSACng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.RSACng" />
    ///  class with a randomly generated key of the specified size. </summary>
    ///  <param name="keySize">The size of the key to generate in bits. </param>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="keySize" />
    ///  is not valid. </exception>
    {class} function init(keySize: Int32): DNRSACng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.RSACng" />
    ///  class with the specified key. </summary>
    ///  <param name="key">The key to use for RSA operations. </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  is not a valid RSA key. </exception><exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(key: DNCngKey): DNRSACng; overload;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the RSA algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.RSACng')]
  DNRSACng = interface(DDN.mscorlib.DNRSA)
  ['{1DCBF670-90D3-33C2-8621-80376632951B}']
  { getters & setters } 

    function get_Key: DNCngKey;
    function get_KeyExchangeAlgorithm: string;
    function get_SignatureAlgorithm: string;
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;

  { methods } 

    ///<summary>Decrypts input data using the specified padding mode.</summary>
    ///  <param name="data">The data to decrypt.</param>
    ///  <param name="padding">The padding mode.</param>
    ///<returns>The decrypted data.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="padding" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="padding" />
    ///  does not equal <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1" />
    ///  , or else the <see cref="P:System.Security.Cryptography.RSAEncryptionPadding.Mode" />
    ///  of <paramref name="padding" />
    ///  does not equal <see cref="F:System.Security.Cryptography.RSAEncryptionPaddingMode.Oaep" />
    ///  .    </exception>
    function Decrypt(data: TArray<Byte>; padding: DDN.mscorlib.DNRSAEncryptionPadding): TArray<Byte>;
    ///<summary>Encrypts the input data using the specified padding.</summary>
    ///  <param name="data">The data to encrypt.</param>
    ///  <param name="padding">The padding mode.</param>
    ///<returns>Returns <see cref="T:System.Byte" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="padding" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="padding" />
    ///  does not equal <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />
    ///  or <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pss" />
    ///  . </exception>
    function Encrypt(data: TArray<Byte>; padding: DDN.mscorlib.DNRSAEncryptionPadding): TArray<Byte>;
    ///<summary>Signs data that was hashed by using the specified hashing algorithm and padding mode.</summary>
    ///  <param name="hash">The hash to sign.</param>
    ///  <param name="hashAlgorithm">The hash algorithm name.</param>
    ///  <param name="padding">The padding mode.</param>
    ///<returns>The signed data.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="hash" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="padding" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  property of <paramref name="hashAlgorithm" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="padding" />
    ///  does not equal <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />
    ///  or <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pss" />
    ///  . </exception>
    function SignHash(hash: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): TArray<Byte>;
    ///<summary>Verifies data that was signed and already hashed with the specified algorithm and padding mode. </summary>
    ///  <param name="hash">The hash to verify. </param>
    ///  <param name="signature">The signature of the data. </param>
    ///  <param name="hashAlgorithm">The hash algorithm name. </param>
    ///  <param name="padding">The padding mode. </param>
    ///<returns><see langword="true" />
    ///  if the signature verifies for the hash; otherwise, <see langword="false" />
    ///  . </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="hash" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="signature" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="padding" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The value of the <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  property of <paramref name="hashAlgorithm" />
    ///  is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="padding" />
    ///  does not equal <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />
    ///  or <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pss" />
    ///  . -or-The signature is badly formatted. (In the .NET Framework 4.6 and 4.6.1 only; starting with the .NET Framework 4.6.2, the method returns <see langword="false" />
    ///  if a signature is badly formatted.</exception>
    function VerifyHash(hash: TArray<Byte>; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): Boolean;
    ///<summary>Decrypts the input data using the private key.</summary>
    ///  <param name="rgb">The cipher text to be decrypted. </param>
    ///<returns>The resulting decryption of the <paramref name="rgb" />
    ///  parameter in plain text.</returns>
    ///<exception cref="T:System.NotSupportedException">This method call is not supported.</exception>
    function DecryptValue(rgb: TArray<Byte>): TArray<Byte>;
    ///<summary>Encrypts the input data using the public key.</summary>
    ///  <param name="rgb">The plain text to be encrypted.</param>
    ///<returns>The resulting encryption of the <paramref name="rgb" />
    ///  parameter as cipher text.</returns>
    ///<exception cref="T:System.NotSupportedException">This method call is not supported.</exception>
    function EncryptValue(rgb: TArray<Byte>): TArray<Byte>;
    ///<summary>Exports the key used by the RSA object into a <see cref="T:System.Security.Cryptography.RSAParameters" />
    ///  object. </summary>
    ///  <param name="includePrivateParameters"><see langword="true" />
    ///  to include private parameters; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>The key used by the RSA object. </returns>
    function ExportParameters(includePrivateParameters: Boolean): DDN.mscorlib.DNRSAParameters;
    ///<summary>Replaces the existing key that the current instance is working with by creating a new <see cref="T:System.Security.Cryptography.CngKey" />
    ///  for the parameters structure. </summary>
    ///  <param name="parameters">The RSA parameters. </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="parameters" />
    ///  contains neither an exponent nor a modulus. </exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" />
    ///  is not a valid RSA key. -or-
    ///  <paramref name="parameters" />
    ///  is a full key pair and the default KSP is used. </exception>
    procedure ImportParameters(parameters: DDN.mscorlib.DNRSAParameters);
    function SignData(data: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): TArray<Byte>; overload;
    function SignData(data: TArray<Byte>; offset: Int32; count: Int32; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): TArray<Byte>; overload;
    function SignData(data: DDN.mscorlib.DNStream; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): TArray<Byte>; overload;
    function VerifyData(data: TArray<Byte>; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): Boolean; overload;
    function VerifyData(data: TArray<Byte>; offset: Int32; count: Int32; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): Boolean; overload;
    function VerifyData(data: DDN.mscorlib.DNStream; signature: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): Boolean; overload;
    procedure FromXmlString(xmlString: string);
    function ToXmlString(includePrivateParameters: Boolean): string;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the key that will be used by the <see cref="T:System.Security.Cryptography.RSACng" />
    ///  object for any cryptographic operation that it performs. </summary>
    ///<returns>The key used by the <see cref="T:System.Security.Cryptography.RSACng" />
    ///  object. </returns>
    property Key: DNCngKey read get_Key;
    ///<summary>Gets the name of the key exchange algorithm available with this implementation of RSA.</summary>
    ///<returns>Returns "RSA".</returns>
    property KeyExchangeAlgorithm: string read get_KeyExchangeAlgorithm;
    ///<summary>Gets the name of the signature algorithm available with this implementation of RSA.</summary>
    ///<returns>Returns "RSA".</returns>
    property SignatureAlgorithm: string read get_SignatureAlgorithm;
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
  end;

  TDNRSACng = class(TDNGenericImport<DNRSACngClass, DNRSACng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngAlgorithmClass = interface(DDN.mscorlib.DNObjectClass)
  ['{55A0E28E-9545-56F9-A4D4-F54817ED5016}']
  { static getter & setter } 

    {class} function get_Rsa: DNCngAlgorithm;
    {class} function get_ECDiffieHellman: DNCngAlgorithm;
    {class} function get_ECDiffieHellmanP256: DNCngAlgorithm;
    {class} function get_ECDiffieHellmanP384: DNCngAlgorithm;
    {class} function get_ECDiffieHellmanP521: DNCngAlgorithm;
    {class} function get_ECDsa: DNCngAlgorithm;
    {class} function get_ECDsaP256: DNCngAlgorithm;
    {class} function get_ECDsaP384: DNCngAlgorithm;
    {class} function get_ECDsaP521: DNCngAlgorithm;
    {class} function get_MD5: DNCngAlgorithm;
    {class} function get_Sha1: DNCngAlgorithm;
    {class} function get_Sha256: DNCngAlgorithm;
    {class} function get_Sha384: DNCngAlgorithm;
    {class} function get_Sha512: DNCngAlgorithm;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  class.</summary>
    ///  <param name="algorithm">The name of the algorithm to initialize.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="algorithm" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <paramref name="algorithm" />
    ///  parameter length is 0 (zero).</exception>
    {class} function init(algorithm: string): DNCngAlgorithm;

  { static propertys } 

    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies the RSA hash algorithm.</summary>
    ///<returns>An object that specifies the RSA algorithm.</returns>
    {class} property Rsa: DNCngAlgorithm read get_Rsa;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm whose curve is described via a key property.</summary>
    ///<returns>An object that specifies an ECDH key exchange algorithm whose curve is described via a key property.</returns>
    {class} property ECDiffieHellman: DNCngAlgorithm read get_ECDiffieHellman;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-256 curve.</summary>
    ///<returns>An object that specifies an ECDH algorithm that uses the P-256 curve.</returns>
    {class} property ECDiffieHellmanP256: DNCngAlgorithm read get_ECDiffieHellmanP256;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-384 curve.</summary>
    ///<returns>An object that specifies an ECDH algorithm that uses the P-384 curve.</returns>
    {class} property ECDiffieHellmanP384: DNCngAlgorithm read get_ECDiffieHellmanP384;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-521 curve.</summary>
    ///<returns>An object that specifies an ECDH algorithm that uses the P-521 curve.</returns>
    {class} property ECDiffieHellmanP521: DNCngAlgorithm read get_ECDiffieHellmanP521;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) whose curve is described via a key property.</summary>
    ///<returns>An object that specifies an ECDSA whose curve is described via a key property.</returns>
    {class} property ECDsa: DNCngAlgorithm read get_ECDsa;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-256 curve.</summary>
    ///<returns>An object that specifies an ECDSA algorithm that uses the P-256 curve.</returns>
    {class} property ECDsaP256: DNCngAlgorithm read get_ECDsaP256;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-384 curve.</summary>
    ///<returns>An object that specifies an ECDSA algorithm that uses the P-384 curve.</returns>
    {class} property ECDsaP384: DNCngAlgorithm read get_ECDsaP384;
    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-521 curve.</summary>
    ///<returns>An object that specifies an ECDSA algorithm that uses the P-521 curve.</returns>
    {class} property ECDsaP521: DNCngAlgorithm read get_ECDsaP521;
    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies the Message Digest 5 (MD5) hash algorithm.</summary>
    ///<returns>An object that specifies the MD5 algorithm.</returns>
    {class} property MD5: DNCngAlgorithm read get_MD5;
    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies the Secure Hash Algorithm 1 (SHA-1) algorithm.</summary>
    ///<returns>An object that specifies the SHA-1 algorithm.</returns>
    {class} property Sha1: DNCngAlgorithm read get_Sha1;
    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies the Secure Hash Algorithm 256 (SHA-256) algorithm.</summary>
    ///<returns>An object that specifies the SHA-256 algorithm.</returns>
    {class} property Sha256: DNCngAlgorithm read get_Sha256;
    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies the Secure Hash Algorithm 384 (SHA-384) algorithm.</summary>
    ///<returns>An object that specifies the SHA-384 algorithm.</returns>
    {class} property Sha384: DNCngAlgorithm read get_Sha384;
    ///<summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object that specifies the Secure Hash Algorithm 512 (SHA-512) algorithm.</summary>
    ///<returns>An object that specifies the SHA-512 algorithm.</returns>
    {class} property Sha512: DNCngAlgorithm read get_Sha512;
  end;

  ///<summary>Encapsulates the name of an encryption algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.CngAlgorithm')]
  DNCngAlgorithm = interface(DDN.mscorlib.DNObject)
  ['{DDF05353-AAD4-3541-B038-B933F04064CD}']
  { getters & setters } 

    function get_Algorithm: string;

  { methods } 

    ///<summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object.</summary>
    ///  <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="obj" />
    ///  parameter is a <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  that specifies the same algorithm as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(obj: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Compares the specified <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object. </summary>
    ///  <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="other" />
    ///  parameter specifies the same algorithm as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(other: DNCngAlgorithm): Boolean; overload;
    ///<summary>Generates a hash value for the algorithm name that is embedded in the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object.</summary>
    ///<returns>The hash value of the embedded algorithm name.</returns>
    function GetHashCode: Int32;
    ///<summary>Gets the name of the algorithm that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object specifies.</summary>
    ///<returns>The embedded algorithm name.</returns>
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the algorithm name that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object specifies.</summary>
    ///<returns>The embedded algorithm name.</returns>
    property Algorithm: string read get_Algorithm;
  end;

  TDNCngAlgorithm = class(TDNGenericImport<DNCngAlgorithmClass, DNCngAlgorithm>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngAlgorithmGroupClass = interface(DDN.mscorlib.DNObjectClass)
  ['{2224D91B-7FF8-5BF5-83EB-D5276D871555}']
  { static getter & setter } 

    {class} function get_DiffieHellman: DNCngAlgorithmGroup;
    {class} function get_Dsa: DNCngAlgorithmGroup;
    {class} function get_ECDiffieHellman: DNCngAlgorithmGroup;
    {class} function get_ECDsa: DNCngAlgorithmGroup;
    {class} function get_Rsa: DNCngAlgorithmGroup;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  class.</summary>
    ///  <param name="algorithmGroup">The name of the algorithm group to initialize.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="algorithmGroup" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <paramref name="algorithmGroup" />
    ///  parameter length is 0 (zero).</exception>
    {class} function init(algorithmGroup: string): DNCngAlgorithmGroup;

  { static propertys } 

    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object that specifies the Diffie-Hellman family of algorithms.</summary>
    ///<returns>An object that specifies the Diffie-Hellman family of algorithms.</returns>
    {class} property DiffieHellman: DNCngAlgorithmGroup read get_DiffieHellman;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object that specifies the Digital Signature Algorithm (DSA) family of algorithms.</summary>
    ///<returns>An object that specifies the DSA family of algorithms.</returns>
    {class} property Dsa: DNCngAlgorithmGroup read get_Dsa;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object that specifies the Elliptic Curve Diffie-Hellman (ECDH) family of algorithms.</summary>
    ///<returns>An object that specifies the ECDH family of algorithms.</returns>
    {class} property ECDiffieHellman: DNCngAlgorithmGroup read get_ECDiffieHellman;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object that specifies the Elliptic Curve Digital Signature Algorithm (ECDSA) family of algorithms.</summary>
    ///<returns>An object that specifies the ECDSA family of algorithms.</returns>
    {class} property ECDsa: DNCngAlgorithmGroup read get_ECDsa;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object that specifies the Rivest-Shamir-Adleman (RSA) family of algorithms.</summary>
    ///<returns>An object that specifies the RSA family of algorithms.</returns>
    {class} property Rsa: DNCngAlgorithmGroup read get_Rsa;
  end;

  ///<summary>Encapsulates the name of an encryption algorithm group. </summary>
  [DNTypeName('System.Security.Cryptography.CngAlgorithmGroup')]
  DNCngAlgorithmGroup = interface(DDN.mscorlib.DNObject)
  ['{EE2C8BB4-3D3D-35C5-BB75-7E087EEF11CD}']
  { getters & setters } 

    function get_AlgorithmGroup: string;

  { methods } 

    ///<summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object.</summary>
    ///  <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="obj" />
    ///  parameter is a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  that specifies the same algorithm group as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(obj: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Compares the specified <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object.</summary>
    ///  <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="other" />
    ///  parameter specifies the same algorithm group as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(other: DNCngAlgorithmGroup): Boolean; overload;
    ///<summary>Generates a hash value for the algorithm group name that is embedded in the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" />
    ///  object.</summary>
    ///<returns>The hash value of the embedded algorithm group name.</returns>
    function GetHashCode: Int32;
    ///<summary>Gets the name of the algorithm group that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object specifies.</summary>
    ///<returns>The embedded algorithm group name.</returns>
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the name of the algorithm group that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" />
    ///  object specifies.</summary>
    ///<returns>The embedded algorithm group name.</returns>
    property AlgorithmGroup: string read get_AlgorithmGroup;
  end;

  TDNCngAlgorithmGroup = class(TDNGenericImport<DNCngAlgorithmGroupClass, DNCngAlgorithmGroup>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngKeyClass = interface(DNObjectClass)
  ['{516FFB2F-3C27-5C6E-9E0D-1FC380F87167}']
  { static methods } 

    ///<summary>Creates a <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that can be used with the specified algorithm.</summary>
    ///  <param name="algorithm">The algorithm that the key will be used with.</param>
    ///<returns>An ephemeral key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="algorithm" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Create(algorithm: DNCngAlgorithm): DNCngKey; overload;
    ///<summary>Creates a named <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that provides the specified algorithm.</summary>
    ///  <param name="algorithm">The algorithm that the key will be used with.</param>
    ///  <param name="keyName">The key name. If a name is not provided, the key will not be persisted.</param>
    ///<returns>A persisted or ephemeral key that provides the specified algorithm.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="algorithm" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Create(algorithm: DNCngAlgorithm; keyName: string): DNCngKey; overload;
    ///<summary>Creates a named <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that provides the specified algorithm, using the supplied key creation parameters.</summary>
    ///  <param name="algorithm">The algorithm that the key will be used with.</param>
    ///  <param name="keyName">The key name. If a name is not provided, the key will not be persisted.</param>
    ///  <param name="creationParameters">An object that specifies advanced parameters for the method, including the <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  .</param>
    ///<returns>A persisted or ephemeral key that provides the specified algorithm.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="algorithm" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Create(algorithm: DNCngAlgorithm; keyName: string; creationParameters: DNCngKeyCreationParameters): DNCngKey; overload;
    ///<summary>Checks to see whether a named key exists in the default key storage provider (KSP).</summary>
    ///  <param name="keyName">The key name.</param>
    ///<returns><see langword="true" />
    ///  if the named key exists in the default KSP; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Exists(keyName: string): Boolean; overload;
    ///<summary>Checks to see whether a named key exists in the specified key storage provider (KSP).</summary>
    ///  <param name="keyName">The key name.</param>
    ///  <param name="provider">The KSP to check for the key.</param>
    ///<returns><see langword="true" />
    ///  if the named key exists in the specified provider; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  or <paramref name="provider" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Exists(keyName: string; provider: DNCngProvider): Boolean; overload;
    ///<summary>Checks to see whether a named key exists in the specified key storage provider (KSP), according to the specified options.</summary>
    ///  <param name="keyName">The key name.</param>
    ///  <param name="provider">The KSP to search for the key.</param>
    ///  <param name="options">A bitwise combination of the enumeration values that specify options for opening a key.</param>
    ///<returns><see langword="true" />
    ///  if the named key exists in the specified provider; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  or <paramref name="provider" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Exists(keyName: string; provider: DNCngProvider; options: DNCngKeyOpenOptions): Boolean; overload;
    ///<summary>Creates a new key by importing the specified key material into the default key storage provider (KSP) and using the specified format.</summary>
    ///  <param name="keyBlob">An array that contains the key information.</param>
    ///  <param name="format">An object that specifies the format of the <paramref name="keyBlob" />
    ///  array.</param>
    ///<returns>A new key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyBlob" />
    ///  or <paramref name="format" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Import(keyBlob: TArray<Byte>; format: DNCngKeyBlobFormat): DNCngKey; overload;
    ///<summary>Creates a new key by importing the specified key material into the specified key storage provider (KSP), using the specified format.</summary>
    ///  <param name="keyBlob">An array that contains the key information.</param>
    ///  <param name="format">An object that specifies the format of the <paramref name="keyBlob" />
    ///  array.</param>
    ///  <param name="provider">The KSP.</param>
    ///<returns>A new key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyBlob" />
    ///  , <paramref name="format" />
    ///  , or <paramref name="provider" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Import(keyBlob: TArray<Byte>; format: DNCngKeyBlobFormat; provider: DNCngProvider): DNCngKey; overload;
    ///<summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that represents an existing named key.</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///<returns>An existing key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Open(keyName: string): DNCngKey; overload;
    ///<summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that represents an existing named key, using the specified key storage provider (KSP).</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///  <param name="provider">The KSP that contains the key.</param>
    ///<returns>An existing key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  or <paramref name="provider" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Open(keyName: string; provider: DNCngProvider): DNCngKey; overload;
    ///<summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object that represents an existing named key, using the specified key storage provider (KSP) and key open options.</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///  <param name="provider">The KSP that contains the key.</param>
    ///  <param name="openOptions">A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.</param>
    ///<returns>An existing key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  or <paramref name="provider" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Open(keyName: string; provider: DNCngProvider; openOptions: DNCngKeyOpenOptions): DNCngKey; overload;
    ///<summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object by using a handle to an existing key.</summary>
    ///  <param name="keyHandle">A handle to an existing key.</param>
    ///  <param name="keyHandleOpenOptions">One of the enumeration values that indicates whether <paramref name="keyHandle" />
    ///  represents an ephemeral key or a named key.</param>
    ///<returns>An existing key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyHandle" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="keyHandle" />
    ///  is invalid or malformed, or it is already closed. This exception is also thrown if the key is an ephemeral key that is created by the common language runtime (CLR), but the <see cref="F:System.Security.Cryptography.CngKeyHandleOpenOptions.EphemeralKey" />
    ///  value is not specified.</exception><exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    {class} function Open(keyHandle: DNSafeNCryptKeyHandle; keyHandleOpenOptions: DNCngKeyHandleOpenOptions): DNCngKey; overload;

  end;

  ///<summary>Defines the core functionality for keys that are used with Cryptography Next Generation (CNG) objects.</summary>
  [DNTypeName('System.Security.Cryptography.CngKey')]
  DNCngKey = interface(DDN.mscorlib.DNIDisposable)
  ['{6176C309-BD82-3039-A631-F1DAFAC1CD64}']
  { getters & setters } 

    function get_AlgorithmGroup: DNCngAlgorithmGroup;
    function get_Algorithm: DNCngAlgorithm;
    function get_ExportPolicy: DNCngExportPolicies;
    function get_Handle: DNSafeNCryptKeyHandle;
    function get_IsEphemeral: Boolean;
    function get_IsMachineKey: Boolean;
    function get_KeyName: string;
    function get_KeySize: Int32;
    function get_KeyUsage: DNCngKeyUsages;
    function get_ParentWindowHandle: IntPtr;
    procedure set_ParentWindowHandle(value: IntPtr);
    function get_Provider: DNCngProvider;
    function get_ProviderHandle: DNSafeNCryptProviderHandle;
    function get_UniqueName: string;
    function get_UIPolicy: DNCngUIPolicy;

  { methods } 

    ///<summary>Removes the key that is associated with the object.</summary>
    ///<exception cref="T:System.ObjectDisposedException">An attempt was made to access a deleted key.</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    procedure Delete;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.CngKey" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Exports the key material into a BLOB, in the specified format.</summary>
    ///  <param name="format">An object that specifies the format of the key BLOB.</param>
    ///<returns>A BLOB that contains the key material in the specified format.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="format" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors. Typically, the <see cref="P:System.Security.Cryptography.CngKey.ExportPolicy" />
    ///  does not allow the key to be exported. </exception>
    function &Export(format: DNCngKeyBlobFormat): TArray<Byte>;
    ///<summary>Gets a property, given a name and a set of property options.</summary>
    ///  <param name="name">The name of the desired property.</param>
    ///  <param name="options">A bitwise combination of the enumeration values that specify options for the named property.</param>
    ///<returns>An object that contains the raw value of the specified property.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
    function GetProperty(name: string; options: DNCngPropertyOptions): DNCngProperty;
    ///<summary>Checks to see whether the specified property exists on the key.</summary>
    ///  <param name="name">The property name to check.</param>
    ///  <param name="options">A bitwise combination of the enumeration values that specify options for the named property.</param>
    ///<returns><see langword="true" />
    ///  if the specified property is found; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception>
    function HasProperty(name: string; options: DNCngPropertyOptions): Boolean;
    ///<summary>Sets a named property on the key.</summary>
    ///  <param name="property">The key property to set.</param>
    procedure SetProperty(&property: DNCngProperty);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the algorithm group that is used by the key.</summary>
    ///<returns>An object that specifies the name of an encryption algorithm group.</returns>
    property AlgorithmGroup: DNCngAlgorithmGroup read get_AlgorithmGroup;
    ///<summary>Gets the algorithm that is used by the key.</summary>
    ///<returns>An object that specifies the name of an encryption algorithm.</returns>
    property Algorithm: DNCngAlgorithm read get_Algorithm;
    ///<summary>Gets the export policy that is used by the key.</summary>
    ///<returns>An object that specifies the export policy for the key.</returns>
    property ExportPolicy: DNCngExportPolicies read get_ExportPolicy;
    ///<summary>Gets a safe handle that represents a native key (NCRYPT_KEY_HANDLE). </summary>
    ///<returns>A safe handle that represents the key.</returns>
    property Handle: DNSafeNCryptKeyHandle read get_Handle;
    ///<summary>Gets the persistence state of the key.</summary>
    ///<returns><see langword="true" />
    ///  if the key is ephemeral; otherwise, <see langword="false" />
    ///  . </returns>
    property IsEphemeral: Boolean read get_IsEphemeral;
    ///<summary>Gets the scope (machine or user) of the key.</summary>
    ///<returns><see langword="true" />
    ///  if the key is available on a machine-wide basis; <see langword="false" />
    ///  if the key is only for the current user.</returns>
    property IsMachineKey: Boolean read get_IsMachineKey;
    ///<summary>Gets the name of the key.</summary>
    ///<returns>The name of the key. If the key is ephemeral, the value is <see langword="null" />
    ///  .</returns>
    property KeyName: string read get_KeyName;
    ///<summary>Gets the key size in bits.</summary>
    ///<returns>The key size in bits.</returns>
    property KeySize: Int32 read get_KeySize;
    ///<summary>Gets the cryptographic operations specified by the key.</summary>
    ///<returns>A bitwise combination of the enumeration values that specify the usages allowed for the key.</returns>
    property KeyUsage: DNCngKeyUsages read get_KeyUsage;
    ///<summary>Gets or sets the window handle (HWND) that should be used for user interface (UI) prompts caused by accessing the key.</summary>
    ///<returns>The parent window handle for the key.</returns>
    property ParentWindowHandle: IntPtr read get_ParentWindowHandle write set_ParentWindowHandle;
    ///<summary>Gets the key storage provider (KSP) that manages the key.</summary>
    ///<returns>The KSP that manages the key.</returns>
    property Provider: DNCngProvider read get_Provider;
    ///<summary>Gets a native handle (an NCRYPT_PROV_HANDLE) to the key storage provider (KSP).</summary>
    ///<returns>A handle to the KSP.</returns>
    property ProviderHandle: DNSafeNCryptProviderHandle read get_ProviderHandle;
    ///<summary>Gets the unique name for the key.</summary>
    ///<returns>An alternate name for the key. If the key is ephemeral, the value is <see langword="null" />
    ///  .</returns>
    property UniqueName: string read get_UniqueName;
    ///<summary>Gets parameters that control the user interface (UI) for accessing the key.  </summary>
    ///<returns>An object that contains configuration parameters for displaying the UI.</returns>
    property UIPolicy: DNCngUIPolicy read get_UIPolicy;
  end;

  TDNCngKey = class(TDNGenericImport<DNCngKeyClass, DNCngKey>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngKeyBlobFormatClass = interface(DDN.mscorlib.DNObjectClass)
  ['{A2B3847C-A665-5115-9CC9-E47402D73BFD}']
  { static getter & setter } 

    {class} function get_EccPrivateBlob: DNCngKeyBlobFormat;
    {class} function get_EccPublicBlob: DNCngKeyBlobFormat;
    {class} function get_EccFullPrivateBlob: DNCngKeyBlobFormat;
    {class} function get_EccFullPublicBlob: DNCngKeyBlobFormat;
    {class} function get_GenericPrivateBlob: DNCngKeyBlobFormat;
    {class} function get_GenericPublicBlob: DNCngKeyBlobFormat;
    {class} function get_OpaqueTransportBlob: DNCngKeyBlobFormat;
    {class} function get_Pkcs8PrivateBlob: DNCngKeyBlobFormat;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  class by using the specified format.</summary>
    ///  <param name="format">The key BLOB format to initialize.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="format" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <paramref name="format" />
    ///  parameter length is 0 (zero).</exception>
    {class} function init(format: string): DNCngKeyBlobFormat;

  { static propertys } 

    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a private key BLOB for an elliptic curve cryptography (ECC) key.</summary>
    ///<returns>An object that specifies an ECC private key BLOB.</returns>
    {class} property EccPrivateBlob: DNCngKeyBlobFormat read get_EccPrivateBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a public key BLOB for an elliptic curve cryptography (ECC) key.</summary>
    ///<returns>An object that specifies an ECC public key BLOB.</returns>
    {class} property EccPublicBlob: DNCngKeyBlobFormat read get_EccPublicBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a private key BLOB for an elliptic curve cryptography (ECC) key which contains explicit curve parameters.</summary>
    ///<returns>An object describing a private key BLOB.</returns>
    {class} property EccFullPrivateBlob: DNCngKeyBlobFormat read get_EccFullPrivateBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a public key BLOB for an elliptic curve cryptography (ECC) key which contains explicit curve parameters.</summary>
    ///<returns>An object describing a public key BLOB.</returns>
    {class} property EccFullPublicBlob: DNCngKeyBlobFormat read get_EccFullPublicBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a generic private key BLOB.</summary>
    ///<returns>An object that specifies a generic private key BLOB.</returns>
    {class} property GenericPrivateBlob: DNCngKeyBlobFormat read get_GenericPrivateBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a generic public key BLOB.</summary>
    ///<returns>An object that specifies a generic public key BLOB.</returns>
    {class} property GenericPublicBlob: DNCngKeyBlobFormat read get_GenericPublicBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies an opaque transport key BLOB.</summary>
    ///<returns>An object that specifies an opaque transport key BLOB.</returns>
    {class} property OpaqueTransportBlob: DNCngKeyBlobFormat read get_OpaqueTransportBlob;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies a Private Key Information Syntax Standard (PKCS #8) key BLOB.</summary>
    ///<returns>An object that specifies a PKCS #8 private key BLOB.</returns>
    {class} property Pkcs8PrivateBlob: DNCngKeyBlobFormat read get_Pkcs8PrivateBlob;
  end;

  ///<summary>Specifies a key BLOB format for use with Microsoft Cryptography Next Generation (CNG) objects. </summary>
  [DNTypeName('System.Security.Cryptography.CngKeyBlobFormat')]
  DNCngKeyBlobFormat = interface(DDN.mscorlib.DNObject)
  ['{BD6B75F6-063A-3DCF-A8C7-750CEB8A92FF}']
  { getters & setters } 

    function get_Format: string;

  { methods } 

    ///<summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object.</summary>
    ///  <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="obj" />
    ///  parameter is a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object that specifies the same key BLOB format as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(obj: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Compares the specified <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object.</summary>
    ///  <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="other" />
    ///  parameter specifies the same key BLOB format as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(other: DNCngKeyBlobFormat): Boolean; overload;
    ///<summary>Generates a hash value for the embedded key BLOB format in the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object.</summary>
    ///<returns>The hash value of the embedded key BLOB format. </returns>
    function GetHashCode: Int32;
    ///<summary>Gets the name of the key BLOB format that the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object specifies.</summary>
    ///<returns>The embedded key BLOB format name.</returns>
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the name of the key BLOB format that the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" />
    ///  object specifies.</summary>
    ///<returns>The embedded key BLOB format name.</returns>
    property Format: string read get_Format;
  end;

  TDNCngKeyBlobFormat = class(TDNGenericImport<DNCngKeyBlobFormatClass, DNCngKeyBlobFormat>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngKeyCreationParametersClass = interface(DDN.mscorlib.DNObjectClass)
  ['{5A671751-1364-53DD-9250-9D5765636197}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngKeyCreationParameters" />
    ///  class.</summary>
    {class} function init: DNCngKeyCreationParameters;

  end;

  ///<summary>Contains advanced properties for key creation.</summary>
  [DNTypeName('System.Security.Cryptography.CngKeyCreationParameters')]
  DNCngKeyCreationParameters = interface(DDN.mscorlib.DNObject)
  ['{5F828D16-3D84-34F5-8EC8-B5BFD0D6804B}']
  { getters & setters } 

    function get_ExportPolicy: DDN.mscorlib.DNNullable<DNCngExportPolicies>;
    procedure set_ExportPolicy(value: DDN.mscorlib.DNNullable<DNCngExportPolicies>);
    function get_KeyCreationOptions: DNCngKeyCreationOptions;
    procedure set_KeyCreationOptions(value: DNCngKeyCreationOptions);
    function get_KeyUsage: DDN.mscorlib.DNNullable<DNCngKeyUsages>;
    procedure set_KeyUsage(value: DDN.mscorlib.DNNullable<DNCngKeyUsages>);
    function get_ParentWindowHandle: IntPtr;
    procedure set_ParentWindowHandle(value: IntPtr);
    function get_Parameters: DNCngPropertyCollection;
    function get_Provider: DNCngProvider;
    procedure set_Provider(value: DNCngProvider);
    function get_UIPolicy: DNCngUIPolicy;
    procedure set_UIPolicy(value: DNCngUIPolicy);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the key export policy.</summary>
    ///<returns>An object that specifies a key export policy. The default value is <see langword="null" />
    ///  , which indicates that the key storage provider's default export policy is set.</returns>
    property ExportPolicy: DDN.mscorlib.DNNullable<DNCngExportPolicies> read get_ExportPolicy write set_ExportPolicy;
    ///<summary>Gets or sets the key creation options.</summary>
    ///<returns>An object that specifies options for creating keys. The default value is <see langword="null" />
    ///  , which indicates that the key storage provider's default key creation options are set.</returns>
    property KeyCreationOptions: DNCngKeyCreationOptions read get_KeyCreationOptions write set_KeyCreationOptions;
    ///<summary>Gets or sets the cryptographic operations that apply to the current key. </summary>
    ///<returns>A bitwise combination of one or more enumeration values that specify key usage. The default value is <see langword="null" />
    ///  , which indicates that the key storage provider's default key usage is set.</returns>
    property KeyUsage: DDN.mscorlib.DNNullable<DNCngKeyUsages> read get_KeyUsage write set_KeyUsage;
    ///<summary>Gets or sets the window handle that should be used as the parent window for dialog boxes that are created by Cryptography Next Generation (CNG) classes.</summary>
    ///<returns>The HWND of the parent window that is used for CNG dialog boxes.</returns>
    property ParentWindowHandle: IntPtr read get_ParentWindowHandle write set_ParentWindowHandle;
    ///<summary>Enables a <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object to be created with additional properties that are set before the key is finalized.</summary>
    ///<returns>A collection object that contains any additional parameters that you must set on a <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object during key creation.</returns>
    property Parameters: DNCngPropertyCollection read get_Parameters;
    ///<summary>Gets or sets the key storage provider (KSP) to create a key in.</summary>
    ///<returns>An object that specifies the KSP that a new key will be created in.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.CngKeyCreationParameters.Provider" />
    ///  property is set to a <see langword="null" />
    ///  value.</exception>
    property Provider: DNCngProvider read get_Provider write set_Provider;
    ///<summary>Gets or sets information about the user interface to display when a key is created or accessed.</summary>
    ///<returns>An object that contains details about the user interface shown by Cryptography Next Generation (CNG) classes when a key is created or accessed. A <see langword="null" />
    ///  value indicates that the key storage provider's default user interface policy is set.</returns>
    property UIPolicy: DNCngUIPolicy read get_UIPolicy write set_UIPolicy;
  end;

  TDNCngKeyCreationParameters = class(TDNGenericImport<DNCngKeyCreationParametersClass, DNCngKeyCreationParameters>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngProviderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F74A1313-EC15-5EA5-BCF8-72DD9E9716E9}']
  { static getter & setter } 

    {class} function get_MicrosoftSmartCardKeyStorageProvider: DNCngProvider;
    {class} function get_MicrosoftSoftwareKeyStorageProvider: DNCngProvider;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  class.</summary>
    ///  <param name="provider">The name of the key storage provider (KSP) to initialize.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="provider" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <paramref name="provider" />
    ///  parameter length is 0 (zero).</exception>
    {class} function init(provider: string): DNCngProvider;

  { static propertys } 

    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object that specifies the Microsoft Smart Card Key Storage Provider.</summary>
    ///<returns>An object that specifies the Microsoft Smart Card Key Storage Provider.</returns>
    {class} property MicrosoftSmartCardKeyStorageProvider: DNCngProvider read get_MicrosoftSmartCardKeyStorageProvider;
    ///<summary>Gets a <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object that specifies the Microsoft Software Key Storage Provider.</summary>
    ///<returns>An object that specifies the Microsoft Software Key Storage Provider.</returns>
    {class} property MicrosoftSoftwareKeyStorageProvider: DNCngProvider read get_MicrosoftSoftwareKeyStorageProvider;
  end;

  ///<summary>Encapsulates the name of a key storage provider (KSP) for use with Cryptography Next Generation (CNG) objects.</summary>
  [DNTypeName('System.Security.Cryptography.CngProvider')]
  DNCngProvider = interface(DDN.mscorlib.DNObject)
  ['{077E73E7-8435-313B-87E6-18691E1E917E}']
  { getters & setters } 

    function get_Provider: string;

  { methods } 

    ///<summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object.</summary>
    ///  <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="obj" />
    ///  parameter is a <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  that specifies the same key storage provider(KSP) as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(obj: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Compares the specified <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object to the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object.</summary>
    ///  <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="other" />
    ///  parameter specifies the same key storage provider (KSP) as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(other: DNCngProvider): Boolean; overload;
    ///<summary>Generates a hash value for the name of the key storage provider (KSP) that is embedded in the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object.</summary>
    ///<returns>The hash value of the embedded KSP name.</returns>
    function GetHashCode: Int32;
    ///<summary>Gets the name of the key storage provider (KSP) that the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object specifies.</summary>
    ///<returns>The embedded KSP name.</returns>
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the name of the key storage provider (KSP) that the current <see cref="T:System.Security.Cryptography.CngProvider" />
    ///  object specifies.</summary>
    ///<returns>The embedded KSP name.</returns>
    property Provider: string read get_Provider;
  end;

  TDNCngProvider = class(TDNGenericImport<DNCngProviderClass, DNCngProvider>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngUIPolicyClass = interface(DDN.mscorlib.DNObjectClass)
  ['{4072695A-6A9E-5F60-8FBB-54D05BCAEEF9}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" />
    ///  class by using the specified protection level.</summary>
    ///  <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.</param>
    {class} function init(protectionLevel: DNCngUIProtectionLevels): DNCngUIPolicy; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" />
    ///  class by using the specified protection level and friendly name.</summary>
    ///  <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
    ///  <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
    {class} function init(protectionLevel: DNCngUIProtectionLevels; friendlyName: string): DNCngUIPolicy; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" />
    ///  class by using the specified protection level, friendly name, and description.</summary>
    ///  <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
    ///  <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
    ///  <param name="description">The full-text description of the key. Specify a null string to use the default description.</param>
    {class} function init(protectionLevel: DNCngUIProtectionLevels; friendlyName: string; description: string): DNCngUIPolicy; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" />
    ///  class by using the specified protection level, friendly name, description string, and use context.</summary>
    ///  <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
    ///  <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
    ///  <param name="description">The full-text description of the key. Specify a null string to use the default description.</param>
    ///  <param name="useContext">A description of how the key will be used. Specify a null string to use the default description.</param>
    {class} function init(protectionLevel: DNCngUIProtectionLevels; friendlyName: string; description: string; useContext: string): DNCngUIPolicy; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" />
    ///  class by using the specified protection level, friendly name, description string, use context, and title.</summary>
    ///  <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
    ///  <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
    ///  <param name="description">The full-text description of the key. Specify a null string to use the default description.</param>
    ///  <param name="useContext">A description of how the key will be used. Specify a null string to use the default description.</param>
    ///  <param name="creationTitle">The title for the dialog box that provides the UI prompt. Specify a null string to use the default title.</param>
    {class} function init(protectionLevel: DNCngUIProtectionLevels; friendlyName: string; description: string; useContext: string; creationTitle: string): DNCngUIPolicy; overload;

  end;

  ///<summary>Encapsulates optional configuration parameters for the user interface (UI) that Cryptography Next Generation (CNG) displays when you access a protected key.</summary>
  [DNTypeName('System.Security.Cryptography.CngUIPolicy')]
  DNCngUIPolicy = interface(DDN.mscorlib.DNObject)
  ['{D97C43F4-8E33-3595-B805-AEA64AF6BF42}']
  { getters & setters } 

    function get_CreationTitle: string;
    function get_Description: string;
    function get_FriendlyName: string;
    function get_ProtectionLevel: DNCngUIProtectionLevels;
    function get_UseContext: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the title that is displayed by the UI prompt.</summary>
    ///<returns>The title of the dialog box that appears when the key is accessed.</returns>
    property CreationTitle: string read get_CreationTitle;
    ///<summary>Gets the description string that is displayed by the UI prompt.</summary>
    ///<returns>The description text for the dialog box that appears when the key is accessed.</returns>
    property Description: string read get_Description;
    ///<summary>Gets the friendly name that is displayed by the UI prompt.</summary>
    ///<returns>The friendly name that is used to describe the key in the dialog box that appears when the key is accessed.</returns>
    property FriendlyName: string read get_FriendlyName;
    ///<summary>Gets the UI protection level for the key.</summary>
    ///<returns>An object that describes the level of UI protection to apply to the key.</returns>
    property ProtectionLevel: DNCngUIProtectionLevels read get_ProtectionLevel;
    ///<summary>Gets the description of how the key will be used.</summary>
    ///<returns>The description of how the key will be used.</returns>
    property UseContext: string read get_UseContext;
  end;

  TDNCngUIPolicy = class(TDNGenericImport<DNCngUIPolicyClass, DNCngUIPolicy>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECCurve_NamedCurvesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0EE9F263-45C9-53FE-9ECE-59878DAE772A}']
  { static getter & setter } 

    {class} function get_brainpoolP160r1: DNECCurve;
    {class} function get_brainpoolP160t1: DNECCurve;
    {class} function get_brainpoolP192r1: DNECCurve;
    {class} function get_brainpoolP192t1: DNECCurve;
    {class} function get_brainpoolP224r1: DNECCurve;
    {class} function get_brainpoolP224t1: DNECCurve;
    {class} function get_brainpoolP256r1: DNECCurve;
    {class} function get_brainpoolP256t1: DNECCurve;
    {class} function get_brainpoolP320r1: DNECCurve;
    {class} function get_brainpoolP320t1: DNECCurve;
    {class} function get_brainpoolP384r1: DNECCurve;
    {class} function get_brainpoolP384t1: DNECCurve;
    {class} function get_brainpoolP512r1: DNECCurve;
    {class} function get_brainpoolP512t1: DNECCurve;
    {class} function get_nistP256: DNECCurve;
    {class} function get_nistP384: DNECCurve;
    {class} function get_nistP521: DNECCurve;

  { static propertys } 

    ///<summary>Gets a brainpoolP160r1 named curve.</summary>
    ///<returns>A brainpoolP160r1 named curve.</returns>
    {class} property brainpoolP160r1: DNECCurve read get_brainpoolP160r1;
    ///<summary>Gets a brainpoolP160t1 named curve.</summary>
    ///<returns>A brainpoolP160t1 named curve.</returns>
    {class} property brainpoolP160t1: DNECCurve read get_brainpoolP160t1;
    ///<summary>Gets a brainpoolP192r1 named curve.</summary>
    ///<returns>A brainpoolP192r1 named curve.</returns>
    {class} property brainpoolP192r1: DNECCurve read get_brainpoolP192r1;
    ///<summary>Gets a brainpoolP192t1 named curve.</summary>
    ///<returns>A brainpoolP192t1 named curve.</returns>
    {class} property brainpoolP192t1: DNECCurve read get_brainpoolP192t1;
    ///<summary>Gets a brainpoolP224r1 named curve.</summary>
    ///<returns>A brainpoolP224r1 named curve.</returns>
    {class} property brainpoolP224r1: DNECCurve read get_brainpoolP224r1;
    ///<summary>Gets a brainpoolP224t1 named curve.</summary>
    ///<returns>A brainpoolP224t1 named curve.</returns>
    {class} property brainpoolP224t1: DNECCurve read get_brainpoolP224t1;
    ///<summary>Gets a brainpoolP256r1 named curve.</summary>
    ///<returns>A brainpoolP256r1 named curve.</returns>
    {class} property brainpoolP256r1: DNECCurve read get_brainpoolP256r1;
    ///<summary>Gets a brainpoolP256t1 named curve.</summary>
    ///<returns>A brainpoolP256t1 named curve.</returns>
    {class} property brainpoolP256t1: DNECCurve read get_brainpoolP256t1;
    ///<summary>Gets a brainpoolP320r1 named curve.</summary>
    ///<returns>A brainpoolP320r1 named curve.</returns>
    {class} property brainpoolP320r1: DNECCurve read get_brainpoolP320r1;
    ///<summary>Gets a brainpoolP320t1 named curve.</summary>
    ///<returns>A brainpoolP320t1 named curve.</returns>
    {class} property brainpoolP320t1: DNECCurve read get_brainpoolP320t1;
    ///<summary>Gets a brainpoolP384r1 named curve.</summary>
    ///<returns>A brainpoolP384r1 named curve.</returns>
    {class} property brainpoolP384r1: DNECCurve read get_brainpoolP384r1;
    ///<summary>Gets a brainpoolP384t1 named curve.</summary>
    ///<returns>A brainpoolP384t1 named curve.</returns>
    {class} property brainpoolP384t1: DNECCurve read get_brainpoolP384t1;
    ///<summary>Gets a brainpoolP512r1 named curve.</summary>
    ///<returns>A brainpoolP512r1 named curve.</returns>
    {class} property brainpoolP512r1: DNECCurve read get_brainpoolP512r1;
    ///<summary>Gets a brainpoolP512t1 named curve.</summary>
    ///<returns>A brainpoolP512t1 named curve.</returns>
    {class} property brainpoolP512t1: DNECCurve read get_brainpoolP512t1;
    ///<summary>Gets a nistP256 named curve.</summary>
    ///<returns>A nistP256 named curve.</returns>
    {class} property nistP256: DNECCurve read get_nistP256;
    ///<summary>Gets a nistP384 named curve.</summary>
    ///<returns>A nistP384 named curve.</returns>
    {class} property nistP384: DNECCurve read get_nistP384;
    ///<summary>Gets a nistP521 named curve.</summary>
    ///<returns>A nistP521 named curve.</returns>
    {class} property nistP521: DNECCurve read get_nistP521;
  end;

  ///<summary>Represents a factory class for creating named curves.</summary>
  [DNTypeName('System.Security.Cryptography.ECCurve+NamedCurves')]
  DNECCurve_NamedCurves = interface(DDN.mscorlib.DNObject)
  ['{F9245C8B-EF76-324A-84A7-AA4081C29663}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNECCurve_NamedCurves = class(TDNGenericImport<DNECCurve_NamedCurvesClass, DNECCurve_NamedCurves>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECDiffieHellmanPublicKeyClass = interface(DNObjectClass)
  ['{10956E50-DDFD-5371-B9BF-E5BC9B993A16}']
  end;

  ///<summary>Provides an abstract base class from which all <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
  ///  implementations must inherit.</summary>
  [DNTypeName('System.Security.Cryptography.ECDiffieHellmanPublicKey')]
  DNECDiffieHellmanPublicKey = interface(DDN.mscorlib.DNIDisposable)
  ['{D1178442-F7D0-3691-A85E-3CA5AA9B5F02}']
  { methods } 

    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Serializes the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />
    ///  public key to an XML string.</summary>
    ///<returns>An XML string that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.</returns>
    function ToXmlString: string;
    ///<summary>When overridden in a derived class, exports the named or explicit <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  for an <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object.  </summary>
    ///<returns>An object that represents the point on the curve for this key.</returns>
    ///<exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
    function ExportParameters: DNECParameters;
    ///<summary>When overridden in a derived class, exports the explicit <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  for an <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object.  </summary>
    ///<returns>An object that represents the point on the curve for this key, using the explicit curve format. </returns>
    ///<exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
    function ExportExplicitParameters: DNECParameters;
    ///<summary>Serializes the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />
    ///  key BLOB to a byte array.</summary>
    ///<returns>A byte array that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.</returns>
    function ToByteArray: TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNECDiffieHellmanPublicKey = class(TDNGenericImport<DNECDiffieHellmanPublicKeyClass, DNECDiffieHellmanPublicKey>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECDiffieHellmanCngPublicKeyClass = interface(DNECDiffieHellmanPublicKeyClass)
  ['{E56A16E0-4825-51AC-89B5-B6F953D135A4}']
  { static methods } 

    ///<summary>Converts a byte array that contains a public key to a <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  object according to the specified format.</summary>
    ///  <param name="publicKeyBlob">A byte array that contains an Elliptic Curve Diffie-Hellman (ECDH) public key.</param>
    ///  <param name="format">An object that specifies the format of the key BLOB.</param>
    ///<returns>An object that contains the ECDH public key that is serialized in the byte array.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="publicKeyBlob" />
    ///  or <paramref name="format" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <paramref name="publicKeyBlob" />
    ///  parameter does not contain an <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  key. </exception>
    {class} function FromByteArray(publicKeyBlob: TArray<Byte>; format: DNCngKeyBlobFormat): DNECDiffieHellmanPublicKey;
    ///<summary>Converts an XML string to an <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  object.</summary>
    ///  <param name="xml">An XML string that contains an Elliptic Curve Diffie-Hellman (ECDH) key.</param>
    ///<returns>An object that contains the ECDH public key that is specified by the given XML.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="xml" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <paramref name="xml" />
    ///  parameter does not specify an <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  key.</exception>
    {class} function FromXmlString(xml: string): DNECDiffieHellmanCngPublicKey;

  end;

  ///<summary>Specifies an Elliptic Curve Diffie-Hellman (ECDH) public key for use with the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />
  ///  class.</summary>
  [DNTypeName('System.Security.Cryptography.ECDiffieHellmanCngPublicKey')]
  DNECDiffieHellmanCngPublicKey = interface(DNECDiffieHellmanPublicKey)
  ['{8F8E78A2-9595-38C4-A08C-0B164CA33D44}']
  { getters & setters } 

    function get_BlobFormat: DNCngKeyBlobFormat;

  { methods } 

    ///<summary>Serializes the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  public key to an XML string in RFC 4050 format.</summary>
    ///<returns>An XML string that contains the serialized <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  public key.</returns>
    function ToXmlString: string;
    ///<summary>Exports the key and explicit curve parameters used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object into an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. </summary>
    ///<returns>The key and explicit curve parameters used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object.</returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The method cannot obtain curve values. </exception><exception cref="T:System.PlatformNotSupportedException">Explicit export is not supported by this platform. Windows 10 or higher is required. </exception>
    function ExportExplicitParameters: DNECParameters;
    ///<summary>Exports the key used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object into an <see cref="T:System.Security.Cryptography.ECParameters" />
    ///  object. </summary>
    ///<returns>The key and named curve parameters used by the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object.</returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The method cannot obtain curve values. </exception>
    function ExportParameters: DNECParameters;
    ///<summary>Converts the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  object to a <see cref="T:System.Security.Cryptography.CngKey" />
    ///  object.</summary>
    ///<returns>An object that contains the key represented by the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  object.</returns>
    function Import: DNCngKey;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Serializes the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />
    ///  key BLOB to a byte array.</summary>
    ///<returns>A byte array that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.</returns>
    function ToByteArray: TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the key BLOB format for a <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />
    ///  object.</summary>
    ///<returns>The format that the key BLOB is expressed in.</returns>
    property BlobFormat: DNCngKeyBlobFormat read get_BlobFormat;
  end;

  TDNECDiffieHellmanCngPublicKey = class(TDNGenericImport<DNECDiffieHellmanCngPublicKeyClass, DNECDiffieHellmanCngPublicKey>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNMD5CngClass = interface(DDN.mscorlib.DNMD5Class)
  ['{625F2E8A-316F-5C89-A0B2-ACE3D258D817}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.MD5Cng" />
    ///  class. </summary>
    ///<exception cref="T:System.InvalidOperationException">This implementation is not part of the Windows Platform FIPS-validated cryptographic algorithms.</exception>
    {class} function init: DNMD5Cng;

  end;

  ///<summary>Provides a CNG (Cryptography Next Generation) implementation of the MD5 (Message Digest 5) 128-bit hashing algorithm.</summary>
  [DNTypeName('System.Security.Cryptography.MD5Cng')]
  DNMD5Cng = interface(DDN.mscorlib.DNMD5)
  ['{9A3FD0A2-F31A-3165-B4B7-9F0641101882}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNMD5Cng = class(TDNGenericImport<DNMD5CngClass, DNMD5Cng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA1CngClass = interface(DDN.mscorlib.DNSHA1Class)
  ['{5ED325E5-ECC5-593D-A5F7-544451E43755}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA1Cng" />
    ///  class. </summary>
    {class} function init: DNSHA1Cng;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA).</summary>
  [DNTypeName('System.Security.Cryptography.SHA1Cng')]
  DNSHA1Cng = interface(DDN.mscorlib.DNSHA1)
  ['{05ED922D-E6AD-31CA-9A49-F50FC6761A29}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA1Cng = class(TDNGenericImport<DNSHA1CngClass, DNSHA1Cng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA256CngClass = interface(DDN.mscorlib.DNSHA256Class)
  ['{70456A1E-F18E-5099-A2FE-2290C7FD9370}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA256Cng" />
    ///  class. </summary>
    {class} function init: DNSHA256Cng;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA) for 256-bit hash values.</summary>
  [DNTypeName('System.Security.Cryptography.SHA256Cng')]
  DNSHA256Cng = interface(DDN.mscorlib.DNSHA256)
  ['{5CCDDA25-1166-3FD3-A267-B58AAE8404D0}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA256Cng = class(TDNGenericImport<DNSHA256CngClass, DNSHA256Cng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA256CryptoServiceProviderClass = interface(DDN.mscorlib.DNSHA256Class)
  ['{5BB1F8A4-A184-58A1-A52C-9FD92DE90473}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA256CryptoServiceProvider" />
    ///  class. </summary>
    {class} function init: DNSHA256CryptoServiceProvider;

  end;

  ///<summary>Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the <see cref="T:System.Security.Cryptography.SHA256" />
  ///  algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.SHA256CryptoServiceProvider')]
  DNSHA256CryptoServiceProvider = interface(DDN.mscorlib.DNSHA256)
  ['{5F94830F-94ED-3788-ABAD-298E40367B5B}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or reinitializes, an instance of a hash algorithm.</summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA256CryptoServiceProvider = class(TDNGenericImport<DNSHA256CryptoServiceProviderClass, DNSHA256CryptoServiceProvider>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA384CngClass = interface(DDN.mscorlib.DNSHA384Class)
  ['{B54652B0-1676-59A8-A1DC-7E942EFF3E41}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA384Cng" />
    ///  class. </summary>
    {class} function init: DNSHA384Cng;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA) for 384-bit hash values.</summary>
  [DNTypeName('System.Security.Cryptography.SHA384Cng')]
  DNSHA384Cng = interface(DDN.mscorlib.DNSHA384)
  ['{F2297229-7509-3F26-AC4A-59ADAFB5813A}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA384Cng = class(TDNGenericImport<DNSHA384CngClass, DNSHA384Cng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA384CryptoServiceProviderClass = interface(DDN.mscorlib.DNSHA384Class)
  ['{0152EB3E-9B2B-5882-87B6-3BD69CFCE1B4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA384CryptoServiceProvider" />
    ///  class. </summary>
    {class} function init: DNSHA384CryptoServiceProvider;

  end;

  ///<summary>Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the <see cref="T:System.Security.Cryptography.SHA384" />
  ///  algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.SHA384CryptoServiceProvider')]
  DNSHA384CryptoServiceProvider = interface(DDN.mscorlib.DNSHA384)
  ['{9D51BAC9-A860-3B50-8A60-4CB3EFCD6379}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or reinitializes, an instance of a hash algorithm.</summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA384CryptoServiceProvider = class(TDNGenericImport<DNSHA384CryptoServiceProviderClass, DNSHA384CryptoServiceProvider>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA512CngClass = interface(DDN.mscorlib.DNSHA512Class)
  ['{1AB1D289-4C3F-54E6-BBCD-D0B4D96FF7B3}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA512Cng" />
    ///  class. </summary>
    {class} function init: DNSHA512Cng;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA) for 512-bit hash values.</summary>
  [DNTypeName('System.Security.Cryptography.SHA512Cng')]
  DNSHA512Cng = interface(DDN.mscorlib.DNSHA512)
  ['{1D95B8A2-A542-3E26-A347-F9AC247F10E5}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA512Cng = class(TDNGenericImport<DNSHA512CngClass, DNSHA512Cng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNSHA512CryptoServiceProviderClass = interface(DDN.mscorlib.DNSHA512Class)
  ['{63A7A744-4072-56D7-BA2F-A35C7EAA8FE6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA512CryptoServiceProvider" />
    ///  class. </summary>
    {class} function init: DNSHA512CryptoServiceProvider;

  end;

  ///<summary>Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the <see cref="T:System.Security.Cryptography.SHA512" />
  ///  algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.SHA512CryptoServiceProvider')]
  DNSHA512CryptoServiceProvider = interface(DDN.mscorlib.DNSHA512)
  ['{3A882AC7-BC63-3525-B777-C89C0D9C2D05}']
  { getters & setters } 

    function get_HashSize: Int32;
    function get_Hash: TArray<Byte>;
    function get_InputBlockSize: Int32;
    function get_OutputBlockSize: Int32;
    function get_CanTransformMultipleBlocks: Boolean;
    function get_CanReuseTransform: Boolean;

  { methods } 

    ///<summary>Initializes, or reinitializes, an instance of a hash algorithm.</summary>
    procedure Initialize;
    function ComputeHash(inputStream: DDN.mscorlib.DNStream): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>): TArray<Byte>; overload;
    function ComputeHash(buffer: TArray<Byte>; offset: Int32; count: Int32): TArray<Byte>; overload;
    function TransformBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32; outputBuffer: TArray<Byte>; outputOffset: Int32): Int32;
    function TransformFinalBlock(inputBuffer: TArray<Byte>; inputOffset: Int32; inputCount: Int32): TArray<Byte>;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property HashSize: Int32 read get_HashSize;
    property Hash: TArray<Byte> read get_Hash;
    property InputBlockSize: Int32 read get_InputBlockSize;
    property OutputBlockSize: Int32 read get_OutputBlockSize;
    property CanTransformMultipleBlocks: Boolean read get_CanTransformMultipleBlocks;
    property CanReuseTransform: Boolean read get_CanReuseTransform;
  end;

  TDNSHA512CryptoServiceProvider = class(TDNGenericImport<DNSHA512CryptoServiceProviderClass, DNSHA512CryptoServiceProvider>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNIncrementalHashClass = interface(DNObjectClass)
  ['{999C85BB-6749-5DC9-800B-E8931A92AB0C}']
  { static methods } 

    ///<summary>Creates an <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  for the specified algorithm.</summary>
    ///  <param name="hashAlgorithm">The name of the hash algorithm to perform.</param>
    ///<returns>An <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  instance ready to compute the hash algorithm specified by <paramref name="hashAlgorithm" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or an empty string.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="hashAlgorithm" />
    ///  is not a known hash algorithm.</exception>
    {class} function CreateHash(hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): DNIncrementalHash;
    ///<summary>Creates an <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  for the Hash-based Message Authentication Code (HMAC)
    ///  algorithm using the specified hash algorithm and key.</summary>
    ///  <param name="hashAlgorithm">The name of the hash algorithm to perform within the HMAC.</param>
    ///  <param name="key">     The secret key for the HMAC. The key can be of any length, but a key longer than the output size
    ///  of the specified hash algorithm will be hashed to derive a correctly-sized key. Therefore,
    ///  the recommended size of the secret key is the output size of the specified hash algorithm.</param>
    ///<returns>An instance of the <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  class ready to compute the specified hash algorithm.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />
    ///  .<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />
    ///  is <see langword="null" />
    ///  or
    ///  an empty string.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="hashAlgorithm" />
    ///  is not a known hash algorithm.</exception>
    {class} function CreateHMAC(hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; key: TArray<Byte>): DNIncrementalHash;

  end;

  ///<summary>Provides support for computing a hash or Hash-based Message Authentication Code (HMAC) value incrementally across several segments.</summary>
  [DNTypeName('System.Security.Cryptography.IncrementalHash')]
  DNIncrementalHash = interface(DDN.mscorlib.DNIDisposable)
  ['{708AD401-5F47-31EE-82FE-F6AD970A408B}']
  { getters & setters } 

    function get_AlgorithmName: DDN.mscorlib.DNHashAlgorithmName;

  { methods } 

    ///<summary>Appends the specified data to the data already processed in the hash or HMAC.</summary>
    ///  <param name="data">The data to process.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  object has already been disposed.</exception>
    procedure AppendData(data: TArray<Byte>); overload;
    ///<summary>Appends the specified number of bytes from the specified data, starting at the specified offset, to the data already processed in the hash or Hash-based Message Authentication Code (HMAC).</summary>
    ///  <param name="data">The data to process.</param>
    ///  <param name="offset">The offset into the byte array from which to begin using data.</param>
    ///  <param name="count">The number of bytes to use from <paramref name="data" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="data" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />
    ///  or <paramref name="offset" />
    ///  is negative.-or-<paramref name="count" />
    ///  is larger than the lenght of <paramref name="data" />
    ///  .</exception><exception cref="T:System.ArgumentException">The sum of <paramref name="offset" />
    ///  and <paramref name="count" />
    ///  is larger than the data length.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  object has already been disposed.</exception>
    procedure AppendData(data: TArray<Byte>; offset: Int32; count: Int32); overload;
    ///<summary>Releases the resources used by the current instance of the <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  class.</summary>
    procedure Dispose;
    ///<summary>Retrieves the hash or Hash-based Message Authentication Code (HMAC) for the data accumulated from prior calls to the
    ///<see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" />
    ///  method,  and resets the object to its initial state.</summary>
    ///<returns>The computed hash or HMAC.</returns>
    ///<exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Security.Cryptography.IncrementalHash" />
    ///  object has already been disposed.</exception>
    function GetHashAndReset: TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the algorithm being performed.</summary>
    ///<returns>The name of the algorithm being performed.</returns>
    property AlgorithmName: DDN.mscorlib.DNHashAlgorithmName read get_AlgorithmName;
  end;

  TDNIncrementalHash = class(TDNGenericImport<DNIncrementalHashClass, DNIncrementalHash>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNManifestSignatureInformationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{C4529C08-24A7-5CCC-8766-873DD7D1A464}']
  { static methods } 

    ///<summary>Gathers and verifies information about the signatures of manifests that belong to a specified activation context.</summary>
    ///  <param name="application">The activation context of the manifest. Activation contexts belong to an application and contain multiple manifests.</param>
    ///<returns>A collection that contains a <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" />
    ///  object for each manifest that is verified.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="application" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    {class} function VerifySignature(application: DDN.mscorlib.DNActivationContext): DNManifestSignatureInformationCollection; overload;
    ///<summary>Gathers and verifies information about the signatures of manifests that belong to a specified activation context and manifest type.</summary>
    ///  <param name="application">The activation context of the manifest. Activation contexts belong to an application and contain multiple manifests.</param>
    ///  <param name="manifests">The type of manifest. This parameter specifies which manifests in the activation context you want to verify.</param>
    ///<returns>A collection that contains a <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" />
    ///  object for each manifest that is verified.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="application" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    {class} function VerifySignature(application: DDN.mscorlib.DNActivationContext; manifests: DNManifestKinds): DNManifestSignatureInformationCollection; overload;
    ///<summary>Gathers and verifies information about the signatures of manifests that belong to a specified activation context and manifest type, and allows certificates to be selected for revocation.</summary>
    ///  <param name="application">The application context of the manifests. Activation contexts belong to an application and contain multiple manifests.</param>
    ///  <param name="manifests">The type of manifest. This parameter specifies which manifests in the activation context you want to verify.</param>
    ///  <param name="revocationFlag">One of the enumeration values that specifies which certificates in the chain are checked for revocation. The default is <see cref="F:System.Security.Cryptography.X509Certificates.X509RevocationFlag.ExcludeRoot" />
    ///  .</param>
    ///  <param name="revocationMode">Determines whether the X.509 verification should look online for revocation lists. </param>
    ///<returns>A collection that contains a <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" />
    ///  object for each manifest that is verified.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="application" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException">A value specified for the <paramref name="revocationFlag" />
    ///  or <paramref name="revocationMode" />
    ///  parameter is invalid.</exception>
    {class} function VerifySignature(application: DDN.mscorlib.DNActivationContext; manifests: DNManifestKinds; revocationFlag: DDN.System.DNX509RevocationFlag; revocationMode: DDN.System.DNX509RevocationMode): DNManifestSignatureInformationCollection; overload;

  end;

  ///<summary>Provides information for a manifest signature. </summary>
  [DNTypeName('System.Security.Cryptography.ManifestSignatureInformation')]
  DNManifestSignatureInformation = interface(DDN.mscorlib.DNObject)
  ['{81920FAE-D60F-34F6-979F-E5CAED18FF90}']
  { getters & setters } 

    function get_AuthenticodeSignature: DNAuthenticodeSignatureInformation;
    function get_Manifest: DNManifestKinds;
    function get_StrongNameSignature: DNStrongNameSignatureInformation;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the Authenticode signature information for a manifest. </summary>
    ///<returns>An <see cref="T:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation" />
    ///  object that contains Authenticode signature information for the manifest, or <see langword="null" />
    ///  if there is no signature.</returns>
    property AuthenticodeSignature: DNAuthenticodeSignatureInformation read get_AuthenticodeSignature;
    ///<summary>Gets the type of a manifest.</summary>
    ///<returns>One of the <see cref="T:System.Security.ManifestKinds" />
    ///  values.</returns>
    property Manifest: DNManifestKinds read get_Manifest;
    ///<summary>Gets the details of the strong name signature of a manifest.</summary>
    ///<returns>A <see cref="P:System.Security.Cryptography.ManifestSignatureInformation.StrongNameSignature" />
    ///  object that contains the signature, or <see langword="null" />
    ///  if there is no strong name signature.</returns>
    property StrongNameSignature: DNStrongNameSignatureInformation read get_StrongNameSignature;
  end;

  TDNManifestSignatureInformation = class(TDNGenericImport<DNManifestSignatureInformationClass, DNManifestSignatureInformation>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNStrongNameSignatureInformationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{B2A5BBB5-8974-5B3B-B8D0-83035BC93F55}']
  end;

  ///<summary>Holds the strong name signature information for a manifest.</summary>
  [DNTypeName('System.Security.Cryptography.StrongNameSignatureInformation')]
  DNStrongNameSignatureInformation = interface(DDN.mscorlib.DNObject)
  ['{248B5F24-96E6-3728-B14B-69E19A4ACD70}']
  { getters & setters } 

    function get_HashAlgorithm: string;
    function get_HResult: Int32;
    function get_IsValid: Boolean;
    function get_PublicKey: DDN.mscorlib.DNAsymmetricAlgorithm;
    function get_VerificationResult: DNSignatureVerificationResult;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the hash algorithm that is used to calculate the strong name signature.</summary>
    ///<returns>The name of the hash algorithm that is used to calculate the strong name signature.</returns>
    property HashAlgorithm: string read get_HashAlgorithm;
    ///<summary>Gets the HRESULT value of the result code.</summary>
    ///<returns>The HRESULT value of the result code.</returns>
    property HResult: Int32 read get_HResult;
    ///<summary>Gets a value indicating whether the strong name signature is valid.</summary>
    ///<returns><see langword="true" />
    ///  if the strong name signature is valid; otherwise, <see langword="false" />
    ///  .</returns>
    property IsValid: Boolean read get_IsValid;
    ///<summary>Gets the public key that is used to verify the signature.</summary>
    ///<returns>The public key that is used to verify the signature. </returns>
    property PublicKey: DDN.mscorlib.DNAsymmetricAlgorithm read get_PublicKey;
    ///<summary>Gets the results of verifying the strong name signature.</summary>
    ///<returns>The result codes for signature verification.</returns>
    property VerificationResult: DNSignatureVerificationResult read get_VerificationResult;
  end;

  TDNStrongNameSignatureInformation = class(TDNGenericImport<DNStrongNameSignatureInformationClass, DNStrongNameSignatureInformation>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNAesCngClass = interface(DDN.mscorlib.DNAesClass)
  ['{DF5BBE4E-17B7-5B04-B6D1-F58EFADE7328}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  class with an ephemeral key.</summary>
    {class} function init: DNAesCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  class with the specified key name, which represents an existing persisted AES key. </summary>
    ///  <param name="keyName">The name of the key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException">
    ///  Cryptography Next Generation (CNG) is not supported on this system.
    ///</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
    ///</exception>
    {class} function init(keyName: string): DNAesCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  class with the specified key name, which represents an existing persisted AES key, and the specified key storage provider (KSP).</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///  <param name="provider">The KSP that contains the key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="provider" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException">
    ///  Cryptography Next Generation (CNG) is not supported on this system.
    ///</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
    ///</exception>
    {class} function init(keyName: string; provider: DNCngProvider): DNAesCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  class with the specified key name, which represents an existing persisted AES key,  the specified key storage provider (KSP) and key open options.</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///  <param name="provider">The KSP that contains the key.</param>
    ///  <param name="openOptions">A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="provider" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException">
    ///  Cryptography Next Generation (CNG) is not supported on this system.
    ///</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
    ///</exception>
    {class} function init(keyName: string; provider: DNCngProvider; openOptions: DNCngKeyOpenOptions): DNAesCng; overload;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Advanced Encryption Standard (AES) algorithm.</summary>
  [DNTypeName('System.Security.Cryptography.AesCng')]
  DNAesCng = interface(DDN.mscorlib.DNAes)
  ['{D3A8D465-069E-3116-AE2B-BFEE03FDE1D8}']
  { getters & setters } 

    function get_Key: TArray<Byte>;
    procedure set_Key(value: TArray<Byte>);
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_BlockSize: Int32;
    procedure set_BlockSize(value: Int32);
    function get_FeedbackSize: Int32;
    procedure set_FeedbackSize(value: Int32);
    function get_IV: TArray<Byte>;
    procedure set_IV(value: TArray<Byte>);
    function get_LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_Mode: DDN.mscorlib.DNCipherMode;
    procedure set_Mode(value: DDN.mscorlib.DNCipherMode);
    function get_Padding: DDN.mscorlib.DNPaddingMode;
    procedure set_Padding(value: DDN.mscorlib.DNPaddingMode);

  { methods } 

    ///<summary>Creates a symmetric AES decryptor object with the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />
    ///  ).</summary>
    ///<returns>A symmetric AES decryptor object.</returns>
    function CreateDecryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric AES decryptor object with the specified key and initialization vector (IV).</summary>
    ///  <param name="rgbKey">The secret key to use for the AES algorithm. The key size must be 128, 192, or 256 bits.</param>
    ///  <param name="rgbIV">The initialization vector to use for the AES algorithm.</param>
    ///<returns>A symmetric AES decryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="rgbKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="rgbKey" />
    ///  is not a valid size for this algorithm.-or-<paramref name="rgbIV" />
    ///  size does not match the block size for this algorithm.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="rgbKey" />
    ///  is a known weak key for this algorithm and cannot be used.-or-
    ///  <paramref name="rgbIV" />
    ///  is <see langword="null" />
    ///  .</exception>
    function CreateDecryptor(rgbKey: TArray<Byte>; rgbIV: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric AES encryptor object using the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />
    ///  ).</summary>
    ///<returns>A symmetric AES encryptor object.</returns>
    function CreateEncryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric AES encryptor object with the specified key and initialization vector (IV).</summary>
    ///  <param name="rgbKey">The secret key to use for the AES algorithm. The key size must be 128, 192, or 256 bits.</param>
    ///  <param name="rgbIV">The initialization vector to use for the AES algorithm.</param>
    ///<returns>A symmetric AES encryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="rgbKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="rgbKey" />
    ///  is not a valid size for this algorithm.-or-<paramref name="rgbIV" />
    ///  size does not match the block size for this algorithm.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="rgbKey" />
    ///  is a known weak key for this algorithm and cannot be used.-or-
    ///  <paramref name="rgbIV" />
    ///  is <see langword="null" />
    ///  .</exception>
    function CreateEncryptor(rgbKey: TArray<Byte>; rgbIV: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Generates a random key to use for the AES algorithm.</summary>
    procedure GenerateKey;
    ///<summary>Generates a random initialization vector (IV) to use for the AES algorithm.</summary>
    procedure GenerateIV;
    function ValidKeySize(bitLength: Int32): Boolean;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the key for the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  algorithm.</summary>
    ///<returns>The key for the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  algorithm.</returns>
    property Key: TArray<Byte> read get_Key write set_Key;
    ///<summary>Gets or sets the size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  algorithm.</summary>
    ///<returns>The size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.AesCng" />
    ///  algorithm.</returns>
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property BlockSize: Int32 read get_BlockSize write set_BlockSize;
    property FeedbackSize: Int32 read get_FeedbackSize write set_FeedbackSize;
    property IV: TArray<Byte> read get_IV write set_IV;
    property LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalBlockSizes;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
    property Mode: DDN.mscorlib.DNCipherMode read get_Mode write set_Mode;
    property Padding: DDN.mscorlib.DNPaddingMode read get_Padding write set_Padding;
  end;

  TDNAesCng = class(TDNGenericImport<DNAesCngClass, DNAesCng>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNAesCryptoServiceProviderClass = interface(DDN.mscorlib.DNAesClass)
  ['{5C8D805D-ABC5-5E06-AFA7-5F0D5DC96644}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCryptoServiceProvider" />
    ///  class. </summary>
    ///<exception cref="T:System.PlatformNotSupportedException">There is no supported key size for the current platform.</exception>
    {class} function init: DNAesCryptoServiceProvider;

  end;

  ///<summary>Performs symmetric encryption and decryption using the Cryptographic Application Programming Interfaces (CAPI) implementation of the Advanced Encryption Standard (AES) algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.AesCryptoServiceProvider')]
  DNAesCryptoServiceProvider = interface(DDN.mscorlib.DNAes)
  ['{D23347DE-DC31-3687-B1E3-46DD0B93ACFD}']
  { getters & setters } 

    function get_Key: TArray<Byte>;
    procedure set_Key(value: TArray<Byte>);
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_BlockSize: Int32;
    procedure set_BlockSize(value: Int32);
    function get_FeedbackSize: Int32;
    procedure set_FeedbackSize(value: Int32);
    function get_IV: TArray<Byte>;
    procedure set_IV(value: TArray<Byte>);
    function get_LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_Mode: DDN.mscorlib.DNCipherMode;
    procedure set_Mode(value: DDN.mscorlib.DNCipherMode);
    function get_Padding: DDN.mscorlib.DNPaddingMode;
    procedure set_Padding(value: DDN.mscorlib.DNPaddingMode);

  { methods } 

    ///<summary>Generates a random initialization vector (IV) to use for the algorithm.</summary>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The initialization vector (IV) could not be generated. </exception>
    procedure GenerateIV;
    ///<summary>Creates a symmetric AES decryptor object using the current key and initialization vector (IV).</summary>
    ///<returns>A symmetric AES decryptor object.</returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The current key is invalid or missing.</exception>
    function CreateDecryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric AES encryptor object using the current key and initialization vector (IV).</summary>
    ///<returns>A symmetric AES encryptor object.</returns>
    function CreateEncryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric AES decryptor object using the specified key and initialization vector (IV).</summary>
    ///  <param name="key">The secret key to use for the symmetric algorithm.</param>
    ///  <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
    ///<returns>A symmetric AES decryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  or <paramref name="iv" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  is invalid.</exception>
    function CreateDecryptor(key: TArray<Byte>; iv: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric encryptor object using the specified key and initialization vector (IV).</summary>
    ///  <param name="key">The secret key to use for the symmetric algorithm.</param>
    ///  <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
    ///<returns>A symmetric AES encryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="key" />
    ///  or <paramref name="iv" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  is invalid.</exception>
    function CreateEncryptor(key: TArray<Byte>; iv: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Generates a random key to use for the algorithm. </summary>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The key could not be generated.</exception>
    procedure GenerateKey;
    function ValidKeySize(bitLength: Int32): Boolean;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the symmetric key that is used for encryption and decryption.</summary>
    ///<returns>The symmetric key that is used for encryption and decryption.</returns>
    ///<exception cref="T:System.ArgumentNullException">The value for the key is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.Cryptography.CryptographicException">The size of the key is invalid.</exception>
    property Key: TArray<Byte> read get_Key write set_Key;
    ///<summary>Gets or sets the size, in bits, of the secret key. </summary>
    ///<returns>The size, in bits, of the key.</returns>
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property BlockSize: Int32 read get_BlockSize write set_BlockSize;
    property FeedbackSize: Int32 read get_FeedbackSize write set_FeedbackSize;
    property IV: TArray<Byte> read get_IV write set_IV;
    property LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalBlockSizes;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
    property Mode: DDN.mscorlib.DNCipherMode read get_Mode write set_Mode;
    property Padding: DDN.mscorlib.DNPaddingMode read get_Padding write set_Padding;
  end;

  TDNAesCryptoServiceProvider = class(TDNGenericImport<DNAesCryptoServiceProviderClass, DNAesCryptoServiceProvider>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNAesManagedClass = interface(DDN.mscorlib.DNAesClass)
  ['{162E044A-C39B-52B1-BB67-C1BE191E633E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesManaged" />
    ///  class. </summary>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The Windows security policy setting for FIPS is enabled.</exception><exception cref="T:System.InvalidOperationException">This implementation is not part of the Windows Platform FIPS-validated cryptographic algorithms.</exception>
    {class} function init: DNAesManaged;

  end;

  ///<summary>Provides a managed implementation of the Advanced Encryption Standard (AES) symmetric algorithm. </summary>
  [DNTypeName('System.Security.Cryptography.AesManaged')]
  DNAesManaged = interface(DDN.mscorlib.DNAes)
  ['{ADEDF0DE-9DAE-31A4-9AC1-34D1217A19E0}']
  { getters & setters } 

    function get_FeedbackSize: Int32;
    procedure set_FeedbackSize(value: Int32);
    function get_IV: TArray<Byte>;
    procedure set_IV(value: TArray<Byte>);
    function get_Key: TArray<Byte>;
    procedure set_Key(value: TArray<Byte>);
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_Mode: DDN.mscorlib.DNCipherMode;
    procedure set_Mode(value: DDN.mscorlib.DNCipherMode);
    function get_Padding: DDN.mscorlib.DNPaddingMode;
    procedure set_Padding(value: DDN.mscorlib.DNPaddingMode);
    function get_BlockSize: Int32;
    procedure set_BlockSize(value: Int32);
    function get_LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;

  { methods } 

    ///<summary>Creates a symmetric decryptor object using the current key and initialization vector (IV).</summary>
    ///<returns>A symmetric decryptor object.</returns>
    function CreateDecryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric decryptor object using the specified key and initialization vector (IV).</summary>
    ///  <param name="key">The secret key to use for the symmetric algorithm.</param>
    ///  <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
    ///<returns>A symmetric decryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  or <paramref name="iv" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  is invalid.</exception>
    function CreateDecryptor(key: TArray<Byte>; iv: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric encryptor object using the current key and initialization vector (IV).</summary>
    ///<returns>A symmetric encryptor object.</returns>
    function CreateEncryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric encryptor object using the specified key and initialization vector (IV).</summary>
    ///  <param name="key">The secret key to use for the symmetric algorithm.</param>
    ///  <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
    ///<returns>A symmetric encryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  or <paramref name="iv" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="key" />
    ///  is invalid.</exception>
    function CreateEncryptor(key: TArray<Byte>; iv: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Generates a random initialization vector (IV) to use for the symmetric algorithm.</summary>
    procedure GenerateIV;
    ///<summary>Generates a random key to use for the symmetric algorithm. </summary>
    procedure GenerateKey;
    function ValidKeySize(bitLength: Int32): Boolean;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the number of bits to use as feedback. </summary>
    ///<returns>The feedback size, in bits.</returns>
    property FeedbackSize: Int32 read get_FeedbackSize write set_FeedbackSize;
    ///<summary>Gets or sets the initialization vector (IV) to use for the symmetric algorithm. </summary>
    ///<returns>The initialization vector to use for the symmetric algorithm</returns>
    property IV: TArray<Byte> read get_IV write set_IV;
    ///<summary>Gets or sets the secret key used for the symmetric algorithm.</summary>
    ///<returns>The key for the symmetric algorithm.</returns>
    property Key: TArray<Byte> read get_Key write set_Key;
    ///<summary>Gets or sets the size, in bits, of the secret key used for the symmetric algorithm. </summary>
    ///<returns>The size, in bits, of the key used by the symmetric algorithm.</returns>
    property KeySize: Int32 read get_KeySize write set_KeySize;
    ///<summary>Gets or sets the mode for operation of the symmetric algorithm.</summary>
    ///<returns>One of the enumeration values that specifies the block cipher mode to use for encryption. The default is <see cref="F:System.Security.Cryptography.CipherMode.CBC" />
    ///  .</returns>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException"><see cref="P:System.Security.Cryptography.AesManaged.Mode" />
    ///  is set to <see cref="F:System.Security.Cryptography.CipherMode.CFB" />
    ///  or <see cref="F:System.Security.Cryptography.CipherMode.OFB" />
    ///  .</exception>
    property Mode: DDN.mscorlib.DNCipherMode read get_Mode write set_Mode;
    ///<summary>Gets or sets the padding mode used in the symmetric algorithm. </summary>
    ///<returns>One of the enumeration values that specifies the type of padding to apply. The default is <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />
    ///  .</returns>
    property Padding: DDN.mscorlib.DNPaddingMode read get_Padding write set_Padding;
    property BlockSize: Int32 read get_BlockSize write set_BlockSize;
    property LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalBlockSizes;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
  end;

  TDNAesManaged = class(TDNGenericImport<DNAesManagedClass, DNAesManaged>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNTripleDESCngClass = interface(DDN.mscorlib.DNTripleDESClass)
  ['{A1A394AB-C5DD-5FAE-8606-4483994485C1}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  class with an ephemeral key.</summary>
    {class} function init: DNTripleDESCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  class with the specified key name, which represents an existing persisted 3DES key.</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException">
    ///  Cryptography Next Generation (CNG) is not supported on this system.
    ///</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
    ///</exception>
    {class} function init(keyName: string): DNTripleDESCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  class with the specified key name, which represents an existing persisted 3DES key, and the specified key storage provider (KSP).</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///  <param name="provider">The KSP that contains the key.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="provider" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException">
    ///  Cryptography Next Generation (CNG) is not supported on this system.
    ///</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
    ///</exception>
    {class} function init(keyName: string; provider: DNCngProvider): DNTripleDESCng; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  class with the specified key name, which represents an existing persisted 3DES key,  the specified key storage provider (KSP) and key open options.</summary>
    ///  <param name="keyName">The name of the key.</param>
    ///  <param name="provider">The KSP that contains the key.</param>
    ///  <param name="openOptions">A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="keyName" />
    ///  is <see langword="null" />
    ///  . -or-
    ///  <paramref name="provider" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.PlatformNotSupportedException">
    ///  Cryptography Next Generation (CNG) is not supported on this system.
    ///</exception><exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
    ///</exception>
    {class} function init(keyName: string; provider: DNCngProvider; openOptions: DNCngKeyOpenOptions): DNTripleDESCng; overload;

  end;

  ///<summary>Provides a Cryptography Next Generation (CNG) implementation of the Triple Data Encryption Standard (3DES) algorithm.</summary>
  [DNTypeName('System.Security.Cryptography.TripleDESCng')]
  DNTripleDESCng = interface(DDN.mscorlib.DNTripleDES)
  ['{CD61B14A-5D96-3D0B-A32F-4087690125A5}']
  { getters & setters } 

    function get_Key: TArray<Byte>;
    procedure set_Key(value: TArray<Byte>);
    function get_KeySize: Int32;
    procedure set_KeySize(value: Int32);
    function get_BlockSize: Int32;
    procedure set_BlockSize(value: Int32);
    function get_FeedbackSize: Int32;
    procedure set_FeedbackSize(value: Int32);
    function get_IV: TArray<Byte>;
    procedure set_IV(value: TArray<Byte>);
    function get_LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes>;
    function get_Mode: DDN.mscorlib.DNCipherMode;
    procedure set_Mode(value: DDN.mscorlib.DNCipherMode);
    function get_Padding: DDN.mscorlib.DNPaddingMode;
    procedure set_Padding(value: DDN.mscorlib.DNPaddingMode);

  { methods } 

    ///<summary>Creates a symmetric 3DES decryptor object with the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />
    ///  ).</summary>
    ///<returns>A symmetric 3DES decryptor object.</returns>
    function CreateDecryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric 3DES decryptor object with the specified key and initialization vector (IV).</summary>
    ///  <param name="rgbKey">The secret key to use for the 3DES algorithm. The key size must be 192 bits.</param>
    ///  <param name="rgbIV">The initialization vector to use for the 3DES algorithm.</param>
    ///<returns>A symmetric 3DES decryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="rgbKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="rgbKey" />
    ///  is not a valid size for this algorithm.-or-<paramref name="rgbIV" />
    ///  size does not match the block size for this algorithm.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="rgbKey" />
    ///  is a known weak key for this algorithm and cannot be used.-or-
    ///  <paramref name="rgbIV" />
    ///  is <see langword="null" />
    ///  .</exception>
    function CreateDecryptor(rgbKey: TArray<Byte>; rgbIV: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric 3DES encryptor object using the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />
    ///  ).</summary>
    ///<returns>A symmetric 3DES encryptor object.</returns>
    function CreateEncryptor: DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Creates a symmetric 3DES encryptor object with the specified key and initialization vector (IV).</summary>
    ///  <param name="rgbKey">The secret key to use for the 3DES algorithm. The key size must be 192 bits.</param>
    ///  <param name="rgbIV">The initialization vector to use for the 3DES algorithm.</param>
    ///<returns>A symmetric 3DES encryptor object.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="rgbKey" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="rgbKey" />
    ///  is not a valid size for this algorithm.-or-<paramref name="rgbIV" />
    ///  size does not match the block size for this algorithm.</exception><exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="rgbKey" />
    ///  is a known weak key for this algorithm and cannot be used.-or-
    ///  <paramref name="rgbIV" />
    ///  is <see langword="null" />
    ///  .</exception>
    function CreateEncryptor(rgbKey: TArray<Byte>; rgbIV: TArray<Byte>): DDN.mscorlib.DNICryptoTransform; overload;
    ///<summary>Generates a random key to use for the 3DES algorithm.</summary>
    procedure GenerateKey;
    ///<summary>Generates a random initialization vector (IV) to use for the 3DES algorithm.</summary>
    procedure GenerateIV;
    function ValidKeySize(bitLength: Int32): Boolean;
    procedure Dispose;
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the key for the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  algorithm.</summary>
    ///<returns>The key for the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  algorithm.</returns>
    property Key: TArray<Byte> read get_Key write set_Key;
    ///<summary>Gets or sets the size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  algorithm.</summary>
    ///<returns>The size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.TripleDESCng" />
    ///  algorithm.</returns>
    property KeySize: Int32 read get_KeySize write set_KeySize;
    property BlockSize: Int32 read get_BlockSize write set_BlockSize;
    property FeedbackSize: Int32 read get_FeedbackSize write set_FeedbackSize;
    property IV: TArray<Byte> read get_IV write set_IV;
    property LegalBlockSizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalBlockSizes;
    property LegalKeySizes: TArray<DDN.mscorlib.DNKeySizes> read get_LegalKeySizes;
    property Mode: DDN.mscorlib.DNCipherMode read get_Mode write set_Mode;
    property Padding: DDN.mscorlib.DNPaddingMode read get_Padding write set_Padding;
  end;

  TDNTripleDESCng = class(TDNGenericImport<DNTripleDESCngClass, DNTripleDESCng>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNAuthenticodeSignatureInformationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{88CFAC2E-984C-5CE8-970B-4EFA1089BF82}']
  end;

  ///<summary>Provides information about an Authenticode signature for a manifest. </summary>
  [DNTypeName('System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation')]
  DNAuthenticodeSignatureInformation = interface(DDN.mscorlib.DNObject)
  ['{5187D08D-6816-34BA-A486-6B60A83A92B5}']
  { getters & setters } 

    function get_Description: string;
    function get_DescriptionUrl: DDN.System.DNUri;
    function get_HashAlgorithm: string;
    function get_HResult: Int32;
    function get_SignatureChain: DDN.System.DNX509Chain;
    function get_SigningCertificate: DDN.System.DNX509Certificate2;
    function get_Timestamp: DNTimestampInformation;
    function get_TrustStatus: DNTrustStatus;
    function get_VerificationResult: DNSignatureVerificationResult;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the description of the signing certificate.</summary>
    ///<returns>The description of the signing certificate.</returns>
    property Description: string read get_Description;
    ///<summary>Gets the description URL of the signing certificate.</summary>
    ///<returns>The description URL of the signing certificate.</returns>
    property DescriptionUrl: DDN.System.DNUri read get_DescriptionUrl;
    ///<summary>Gets the hash algorithm used to compute the signature.</summary>
    ///<returns>The hash algorithm used to compute the signature.</returns>
    property HashAlgorithm: string read get_HashAlgorithm;
    ///<summary>Gets the HRESULT value from verifying the signature.</summary>
    ///<returns>The HRESULT value from verifying the signature.</returns>
    property HResult: Int32 read get_HResult;
    ///<summary>Gets the chain of certificates used to verify the Authenticode signature.</summary>
    ///<returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Chain" />
    ///  object that contains the certificate chain.</returns>
    property SignatureChain: DDN.System.DNX509Chain read get_SignatureChain;
    ///<summary>Gets the certificate that signed the manifest.</summary>
    ///<returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  object that represents the certificate.</returns>
    property SigningCertificate: DDN.System.DNX509Certificate2 read get_SigningCertificate;
    ///<summary>Gets the time stamp that was applied to the Authenticode signature.</summary>
    ///<returns>A <see cref="T:System.Security.Cryptography.X509Certificates.TimestampInformation" />
    ///  object that contains the signature time stamp.</returns>
    property Timestamp: DNTimestampInformation read get_Timestamp;
    ///<summary>Gets the trustworthiness of the Authenticode signature.</summary>
    ///<returns>One of the <see cref="T:System.Security.Cryptography.X509Certificates.TrustStatus" />
    ///  values. </returns>
    property TrustStatus: DNTrustStatus read get_TrustStatus;
    ///<summary>Gets the result of verifying the Authenticode signature.</summary>
    ///<returns>One of the <see cref="T:System.Security.Cryptography.SignatureVerificationResult" />
    ///  values.</returns>
    property VerificationResult: DNSignatureVerificationResult read get_VerificationResult;
  end;

  TDNAuthenticodeSignatureInformation = class(TDNGenericImport<DNAuthenticodeSignatureInformationClass, DNAuthenticodeSignatureInformation>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNCertificateRequestClass = interface(DDN.mscorlib.DNObjectClass)
  ['{FE574F2A-35BC-52F9-BB09-7176A268A3A4}']
  { constructors } 

    {class} function init(subjectName: string; key: DNECDsa; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): DNCertificateRequest; overload;
    {class} function init(subjectName: DDN.System.DNX500DistinguishedName; key: DNECDsa; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): DNCertificateRequest; overload;
    {class} function init(subjectName: string; key: DDN.mscorlib.DNRSA; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): DNCertificateRequest; overload;
    {class} function init(subjectName: DDN.System.DNX500DistinguishedName; key: DDN.mscorlib.DNRSA; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName; padding: DDN.mscorlib.DNRSASignaturePadding): DNCertificateRequest; overload;
    {class} function init(subjectName: DDN.System.DNX500DistinguishedName; publicKey: DDN.System.DNPublicKey; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): DNCertificateRequest; overload;

  end;

  [DNTypeName('System.Security.Cryptography.X509Certificates.CertificateRequest')]
  DNCertificateRequest = interface(DDN.mscorlib.DNObject)
  ['{0754A543-BA00-3A5E-957B-8E0FFCB60062}']
  { getters & setters } 

    function get_SubjectName: DDN.System.DNX500DistinguishedName;
    function get_CertificateExtensions: DDN.mscorlib.DNCollection<DDN.System.DNX509Extension>;
    function get_PublicKey: DDN.System.DNPublicKey;
    function get_HashAlgorithm: DDN.mscorlib.DNHashAlgorithmName;

  { methods } 

    function CreateSigningRequest: TArray<Byte>; overload;
    function CreateSigningRequest(signatureGenerator: DNX509SignatureGenerator): TArray<Byte>; overload;
    function CreateSelfSigned(notBefore: DDN.mscorlib.DNDateTimeOffset; notAfter: DDN.mscorlib.DNDateTimeOffset): DDN.System.DNX509Certificate2;
    function Create(issuerCertificate: DDN.System.DNX509Certificate2; notBefore: DDN.mscorlib.DNDateTimeOffset; notAfter: DDN.mscorlib.DNDateTimeOffset; serialNumber: TArray<Byte>): DDN.System.DNX509Certificate2; overload;
    function Create(issuerName: DDN.System.DNX500DistinguishedName; generator: DNX509SignatureGenerator; notBefore: DDN.mscorlib.DNDateTimeOffset; notAfter: DDN.mscorlib.DNDateTimeOffset; serialNumber: TArray<Byte>): DDN.System.DNX509Certificate2; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property SubjectName: DDN.System.DNX500DistinguishedName read get_SubjectName;
    property CertificateExtensions: DDN.mscorlib.DNCollection<DDN.System.DNX509Extension> read get_CertificateExtensions;
    property PublicKey: DDN.System.DNPublicKey read get_PublicKey;
    property HashAlgorithm: DDN.mscorlib.DNHashAlgorithmName read get_HashAlgorithm;
  end;

  TDNCertificateRequest = class(TDNGenericImport<DNCertificateRequestClass, DNCertificateRequest>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNDSACertificateExtensionsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{1FAD86A5-969A-5AF8-AE88-2DF278C5CD6A}']
  { static methods } 

    ///<summary>Gets the <see cref="T:System.Security.Cryptography.DSA" />
    ///  public key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  .</summary>
    ///  <param name="certificate">The certificate. </param>
    ///<returns>The public key, or <see langword="null" />
    ///  if the certificate does not have a DSA public key. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="certificate" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException">Windows reports an error. See the <see cref="P:System.Exception.Message" />
    ///  property for more information. </exception>
    {class} function GetDSAPublicKey(certificate: DDN.System.DNX509Certificate2): DDN.mscorlib.DNDSA;
    ///<summary>Gets the <see cref="T:System.Security.Cryptography.DSA" />
    ///  private key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  .</summary>
    ///  <param name="certificate">The certificate. </param>
    ///<returns>The private key, or <see langword="null" />
    ///  if the certificate does not have a DSA private key. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="certificate" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function GetDSAPrivateKey(certificate: DDN.System.DNX509Certificate2): DDN.mscorlib.DNDSA;
    {class} function CopyWithPrivateKey(certificate: DDN.System.DNX509Certificate2; privateKey: DDN.mscorlib.DNDSA): DDN.System.DNX509Certificate2;

  end;

  ///<summary>Provides extension methods for retrieving <see cref="T:System.Security.Cryptography.DSA" />
  ///  implementations for the public and private keys of an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  ///  . </summary>
  [DNTypeName('System.Security.Cryptography.X509Certificates.DSACertificateExtensions')]
  DNDSACertificateExtensions = interface(DDN.mscorlib.DNObject)
  ['{E201F334-F39B-3E64-AC38-F088990231E1}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNDSACertificateExtensions = class(TDNGenericImport<DNDSACertificateExtensionsClass, DNDSACertificateExtensions>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNECDsaCertificateExtensionsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{62D92075-F518-5865-9DF5-B4EFE3C41B45}']
  { static methods } 

    ///<summary>Gets the <see cref="T:System.Security.Cryptography.ECDsa" />
    ///  private key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  certificate.</summary>
    ///  <param name="certificate">The certificate. </param>
    ///<returns>The private key, or <see langword="null" />
    ///  if the certificate does not have an ECDsa private key. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="certificate" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function GetECDsaPrivateKey(certificate: DDN.System.DNX509Certificate2): DNECDsa;
    {class} function CopyWithPrivateKey(certificate: DDN.System.DNX509Certificate2; privateKey: DNECDsa): DDN.System.DNX509Certificate2;
    ///<summary>Gets the <see cref="T:System.Security.Cryptography.ECDsa" />
    ///  public key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  certificate.</summary>
    ///  <param name="certificate">The certificate. </param>
    ///<returns>The public key, or <see langword="null" />
    ///  if the certificate does not have an ECDsa public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="certificate" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException">The handle is invalid. </exception>
    {class} function GetECDsaPublicKey(certificate: DDN.System.DNX509Certificate2): DNECDsa;

  end;

  ///<summary>Provides extension methods for retrieving <see cref="T:System.Security.Cryptography.ECDsa" />
  ///  implementations for the
  ///  public and private keys of a <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  ///  certificate.</summary>
  [DNTypeName('System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions')]
  DNECDsaCertificateExtensions = interface(DDN.mscorlib.DNObject)
  ['{25620048-FE22-3108-9DC6-A6756291A037}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNECDsaCertificateExtensions = class(TDNGenericImport<DNECDsaCertificateExtensionsClass, DNECDsaCertificateExtensions>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNRSACertificateExtensionsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{A3328EB8-BF63-5658-8792-5E8CDF66F9E5}']
  { static methods } 

    {class} function CopyWithPrivateKey(certificate: DDN.System.DNX509Certificate2; privateKey: DDN.mscorlib.DNRSA): DDN.System.DNX509Certificate2;
    ///<summary>Gets the <see cref="T:System.Security.Cryptography.RSA" />
    ///  public key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  .</summary>
    ///  <param name="certificate">The certificate. </param>
    ///<returns>The public key, or <see langword="null" />
    ///  if the certificate does not have an RSA public key.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="certificate" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Security.Cryptography.CryptographicException">Windows reports an error. See the <see cref="P:System.Exception.Message" />
    ///  property for more information. </exception>
    {class} function GetRSAPublicKey(certificate: DDN.System.DNX509Certificate2): DDN.mscorlib.DNRSA;
    ///<summary>Gets the <see cref="T:System.Security.Cryptography.RSA" />
    ///  private key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  .</summary>
    ///  <param name="certificate">The certificate. </param>
    ///<returns>The private key, or <see langword="null" />
    ///  if the certificate does not have an RSA private key. </returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="certificate" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function GetRSAPrivateKey(certificate: DDN.System.DNX509Certificate2): DDN.mscorlib.DNRSA;

  end;

  ///<summary>Provides extension methods for retrieving <see cref="T:System.Security.Cryptography.RSA" />
  ///  implementations for the public and private keys of an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  ///  . </summary>
  [DNTypeName('System.Security.Cryptography.X509Certificates.RSACertificateExtensions')]
  DNRSACertificateExtensions = interface(DDN.mscorlib.DNObject)
  ['{5214D10D-04E7-3685-B40A-8ED8C645213F}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNRSACertificateExtensions = class(TDNGenericImport<DNRSACertificateExtensionsClass, DNRSACertificateExtensions>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNSubjectAlternativeNameBuilderClass = interface(DDN.mscorlib.DNObjectClass)
  ['{711F18AC-7E82-5D35-80EF-D2411807C577}']
  { constructors } 

    {class} function init: DNSubjectAlternativeNameBuilder;

  end;

  [DNTypeName('System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder')]
  DNSubjectAlternativeNameBuilder = interface(DDN.mscorlib.DNObject)
  ['{2751367F-B20B-3CD0-AEFC-636C928D1DC9}']
  { methods } 

    procedure AddEmailAddress(emailAddress: string);
    procedure AddDnsName(dnsName: string);
    procedure AddUri(uri: DDN.System.DNUri);
    procedure AddIpAddress(ipAddress: DDN.System.DNIPAddress);
    procedure AddUserPrincipalName(upn: string);
    function Build(critical: Boolean): DDN.System.DNX509Extension;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSubjectAlternativeNameBuilder = class(TDNGenericImport<DNSubjectAlternativeNameBuilderClass, DNSubjectAlternativeNameBuilder>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNTimestampInformationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{CEA97551-CB5A-59DF-93CA-B5CBE6564192}']
  end;

  ///<summary>Provides details about the time stamp that was applied to an Authenticode signature for a manifest. </summary>
  [DNTypeName('System.Security.Cryptography.X509Certificates.TimestampInformation')]
  DNTimestampInformation = interface(DDN.mscorlib.DNObject)
  ['{7204D74E-DDA3-35CA-A5CD-A3D14EECFAB0}']
  { getters & setters } 

    function get_HashAlgorithm: string;
    function get_HResult: Int32;
    function get_IsValid: Boolean;
    function get_SignatureChain: DDN.System.DNX509Chain;
    function get_SigningCertificate: DDN.System.DNX509Certificate2;
    function get_Timestamp: DDN.mscorlib.DNDateTime;
    function get_VerificationResult: DNSignatureVerificationResult;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the hash algorithm used to compute the time stamp signature.</summary>
    ///<returns>The hash algorithm used to compute the time stamp signature.</returns>
    property HashAlgorithm: string read get_HashAlgorithm;
    ///<summary>Gets the HRESULT value that results from verifying the signature.</summary>
    ///<returns>The HRESULT value that results from verifying the signature.</returns>
    property HResult: Int32 read get_HResult;
    ///<summary>Gets a value indicating whether the time stamp of the signature is valid.</summary>
    ///<returns><see langword="true" />
    ///  if the time stamp is valid; otherwise, <see langword="false" />
    ///  . </returns>
    property IsValid: Boolean read get_IsValid;
    ///<summary>Gets the chain of certificates used to verify the time stamp of the signature.</summary>
    ///<returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Chain" />
    ///  object that represents the certificate chain.</returns>
    property SignatureChain: DDN.System.DNX509Chain read get_SignatureChain;
    ///<summary>Gets the certificate that signed the time stamp.</summary>
    ///<returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
    ///  object that represents the certificate.</returns>
    property SigningCertificate: DDN.System.DNX509Certificate2 read get_SigningCertificate;
    ///<summary>Gets the time stamp that was applied to the signature.</summary>
    ///<returns>A <see cref="T:System.DateTime" />
    ///  object that represents the time stamp.</returns>
    property Timestamp: DDN.mscorlib.DNDateTime read get_Timestamp;
    ///<summary>Gets the result of verifying the time stamp signature.</summary>
    ///<returns>One of the <see cref="T:System.Security.Cryptography.SignatureVerificationResult" />
    ///  values.</returns>
    property VerificationResult: DNSignatureVerificationResult read get_VerificationResult;
  end;

  TDNTimestampInformation = class(TDNGenericImport<DNTimestampInformationClass, DNTimestampInformation>) end;

  //-------------namespace: System.Security.Cryptography.X509Certificates----------------
  DNX509SignatureGeneratorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{06F9FE82-5D7F-5151-99A1-CCD54ADB420E}']
  { static methods } 

    {class} function CreateForECDsa(key: DNECDsa): DNX509SignatureGenerator;
    {class} function CreateForRSA(key: DDN.mscorlib.DNRSA; signaturePadding: DDN.mscorlib.DNRSASignaturePadding): DNX509SignatureGenerator;

  end;

  [DNTypeName('System.Security.Cryptography.X509Certificates.X509SignatureGenerator')]
  DNX509SignatureGenerator = interface(DDN.mscorlib.DNObject)
  ['{34EB2F68-483D-353A-8C40-FC51D8679264}']
  { getters & setters } 

    function get_PublicKey: DDN.System.DNPublicKey;

  { methods } 

    function GetSignatureAlgorithmIdentifier(hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>;
    function SignData(data: TArray<Byte>; hashAlgorithm: DDN.mscorlib.DNHashAlgorithmName): TArray<Byte>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property PublicKey: DDN.System.DNPublicKey read get_PublicKey;
  end;

  TDNX509SignatureGenerator = class(TDNGenericImport<DNX509SignatureGeneratorClass, DNX509SignatureGenerator>) end;

  //-------------namespace: System.Threading----------------
  DNReaderWriterLockSlimClass = interface(DNObjectClass)
  ['{FB903A20-4A81-576A-B03F-F7F488BD4321}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  class with default property values.</summary>
    {class} function init: DNReaderWriterLockSlim; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  class, specifying the lock recursion policy.</summary>
    ///  <param name="recursionPolicy">One of the enumeration values that specifies the lock recursion policy.</param>
    {class} function init(recursionPolicy: DNLockRecursionPolicy): DNReaderWriterLockSlim; overload;

  end;

  ///<summary>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</summary>
  [DNTypeName('System.Threading.ReaderWriterLockSlim')]
  DNReaderWriterLockSlim = interface(DDN.mscorlib.DNIDisposable)
  ['{9303E068-8DEA-3576-84AD-64120761B60F}']
  { getters & setters } 

    function get_IsReadLockHeld: Boolean;
    function get_IsUpgradeableReadLockHeld: Boolean;
    function get_IsWriteLockHeld: Boolean;
    function get_RecursionPolicy: DNLockRecursionPolicy;
    function get_CurrentReadCount: Int32;
    function get_RecursiveReadCount: Int32;
    function get_RecursiveUpgradeCount: Int32;
    function get_RecursiveWriteCount: Int32;
    function get_WaitingReadCount: Int32;
    function get_WaitingUpgradeCount: Int32;
    function get_WaitingWriteCount: Int32;

  { methods } 

    ///<summary>Tries to enter the lock in read mode.</summary>
    ///<exception cref="T:System.Threading.LockRecursionException">The current thread cannot acquire the write lock when it holds the read lock.-or-The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  , and the current thread has attempted to acquire the read lock when it already holds the read lock. -or-The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  , and the current thread has attempted to acquire the read lock when it already holds the write lock. -or-The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    procedure EnterReadLock;
    ///<summary>Tries to enter the lock in read mode, with an optional time-out.</summary>
    ///  <param name="timeout">The interval to wait, or -1 milliseconds to wait indefinitely. </param>
    ///<returns><see langword="true" />
    ///  if the calling thread entered read mode, otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" />
    ///  is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.-or-The value of <paramref name="timeout" />
    ///  is greater than <see cref="F:System.Int32.MaxValue" />
    ///  milliseconds. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    function TryEnterReadLock(timeout: DDN.mscorlib.DNTimeSpan): Boolean; overload;
    ///<summary>Tries to enter the lock in read mode, with an optional integer time-out.</summary>
    ///  <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />
    ///  ) to wait indefinitely.</param>
    ///<returns><see langword="true" />
    ///  if the calling thread entered read mode, otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" />
    ///  is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" />
    ///  (-1), which is the only negative value allowed.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    function TryEnterReadLock(millisecondsTimeout: Int32): Boolean; overload;
    ///<summary>Tries to enter the lock in write mode.</summary>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock in any mode. -or-The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    procedure EnterWriteLock;
    ///<summary>Tries to enter the lock in write mode, with an optional time-out.</summary>
    ///  <param name="timeout">The interval to wait, or -1 milliseconds to wait indefinitely.</param>
    ///<returns><see langword="true" />
    ///  if the calling thread entered write mode, otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" />
    ///  is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.-or-The value of <paramref name="timeout" />
    ///  is greater than <see cref="F:System.Int32.MaxValue" />
    ///  milliseconds. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    function TryEnterWriteLock(timeout: DDN.mscorlib.DNTimeSpan): Boolean; overload;
    ///<summary>Tries to enter the lock in write mode, with an optional time-out.</summary>
    ///  <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />
    ///  ) to wait indefinitely.</param>
    ///<returns><see langword="true" />
    ///  if the calling thread entered write mode, otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" />
    ///  is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" />
    ///  (-1), which is the only negative value allowed. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    function TryEnterWriteLock(millisecondsTimeout: Int32): Boolean; overload;
    ///<summary>Tries to enter the lock in upgradeable mode.</summary>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock in any mode. -or-The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    procedure EnterUpgradeableReadLock;
    ///<summary>Tries to enter the lock in upgradeable mode, with an optional time-out.</summary>
    ///  <param name="timeout">The interval to wait, or -1 milliseconds to wait indefinitely.</param>
    ///<returns><see langword="true" />
    ///  if the calling thread entered upgradeable mode, otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" />
    ///  is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.-or-The value of <paramref name="timeout" />
    ///  is greater than <see cref="F:System.Int32.MaxValue" />
    ///  milliseconds. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    function TryEnterUpgradeableReadLock(timeout: DDN.mscorlib.DNTimeSpan): Boolean; overload;
    ///<summary>Tries to enter the lock in upgradeable mode, with an optional time-out.</summary>
    ///  <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />
    ///  ) to wait indefinitely.</param>
    ///<returns><see langword="true" />
    ///  if the calling thread entered upgradeable mode, otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
    ///  property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />
    ///  and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception><exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" />
    ///  is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" />
    ///  (-1), which is the only negative value allowed. </exception><exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object has been disposed. </exception>
    function TryEnterUpgradeableReadLock(millisecondsTimeout: Int32): Boolean; overload;
    ///<summary>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</summary>
    ///<exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in read mode. </exception>
    procedure ExitReadLock;
    ///<summary>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</summary>
    ///<exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in write mode.</exception>
    procedure ExitWriteLock;
    ///<summary>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</summary>
    ///<exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in upgradeable mode.</exception>
    procedure ExitUpgradeableReadLock;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  class.</summary>
    ///<exception cref="T:System.Threading.SynchronizationLockException"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
    ///  is greater than zero. -or-
    ///<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
    ///  is greater than zero. -or-
    ///<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
    ///  is greater than zero. </exception>
    procedure Dispose;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value that indicates whether the current thread has entered the lock in read mode.</summary>
    ///<returns><see langword="true" />
    ///  if the current thread has entered read mode; otherwise, <see langword="false" />
    ///  .</returns>
    property IsReadLockHeld: Boolean read get_IsReadLockHeld;
    ///<summary>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode. </summary>
    ///<returns><see langword="true" />
    ///  if the current thread has entered upgradeable mode; otherwise, <see langword="false" />
    ///  .</returns>
    property IsUpgradeableReadLockHeld: Boolean read get_IsUpgradeableReadLockHeld;
    ///<summary>Gets a value that indicates whether the current thread has entered the lock in write mode.</summary>
    ///<returns><see langword="true" />
    ///  if the current thread has entered write mode; otherwise, <see langword="false" />
    ///  .</returns>
    property IsWriteLockHeld: Boolean read get_IsWriteLockHeld;
    ///<summary>Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" />
    ///  object.</summary>
    ///<returns>One of the enumeration values that specifies the lock recursion policy.</returns>
    property RecursionPolicy: DNLockRecursionPolicy read get_RecursionPolicy;
    ///<summary>Gets the total number of unique threads that have entered the lock in read mode.</summary>
    ///<returns>The number of unique threads that have entered the lock in read mode.</returns>
    property CurrentReadCount: Int32 read get_CurrentReadCount;
    ///<summary>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</summary>
    ///<returns>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.</returns>
    property RecursiveReadCount: Int32 read get_RecursiveReadCount;
    ///<summary>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</summary>
    ///<returns>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.</returns>
    property RecursiveUpgradeCount: Int32 read get_RecursiveUpgradeCount;
    ///<summary>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</summary>
    ///<returns>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.</returns>
    property RecursiveWriteCount: Int32 read get_RecursiveWriteCount;
    ///<summary>Gets the total number of threads that are waiting to enter the lock in read mode.</summary>
    ///<returns>The total number of threads that are waiting to enter read mode.</returns>
    property WaitingReadCount: Int32 read get_WaitingReadCount;
    ///<summary>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</summary>
    ///<returns>The total number of threads that are waiting to enter upgradeable mode.</returns>
    property WaitingUpgradeCount: Int32 read get_WaitingUpgradeCount;
    ///<summary>Gets the total number of threads that are waiting to enter the lock in write mode.</summary>
    ///<returns>The total number of threads that are waiting to enter write mode.</returns>
    property WaitingWriteCount: Int32 read get_WaitingWriteCount;
  end;

  TDNReaderWriterLockSlim = class(TDNGenericImport<DNReaderWriterLockSlimClass, DNReaderWriterLockSlim>) end;

  //-------------namespace: System.Threading.Tasks----------------
  DNTaskExtensionsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D4619DFC-B19C-5AAF-BE91-01BF3393D6CD}']
  { static methods } 

    {class} function Unwrap(task: DDN.mscorlib.DNTask<DDN.mscorlib.DNTask>): DDN.mscorlib.DNTask; overload;

  end;

  ///<summary>Provides a set of static (Shared in Visual Basic) methods for working with specific kinds of <see cref="T:System.Threading.Tasks.Task" />
  ///  instances.</summary>
  [DNTypeName('System.Threading.Tasks.TaskExtensions')]
  DNTaskExtensions = interface(DDN.mscorlib.DNObject)
  ['{2BDA3557-5B63-39A0-B915-DEF4BA0E01DF}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNTaskExtensions = class(TDNGenericImport<DNTaskExtensionsClass, DNTaskExtensions>) end;

  //-------------namespace: System.Collections.Generic----------------
  DNHashSet_EnumeratorClass<T> = interface(DDN.mscorlib.DNValueTypeClass)
  ['{81608DA9-6A0D-5C2E-A4F5-F07B517CB3D0}']
  end;

  ///<summary>Enumerates the elements of a <see cref="T:System.Collections.Generic.HashSet`1" />
  ///  object.</summary>
  [DNTypeName('System.Collections.Generic.HashSet`1+Enumerator')]
  DNHashSet_Enumerator<T> = interface(DDN.mscorlib.DNValueType)
  ['{384D3DA4-C78A-3C48-AAC0-F7FE6B14A095}']
  { getters & setters } 

    function get_Current: T;

  { methods } 

    ///<summary>Releases all resources used by a <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" />
    ///  object.</summary>
    procedure Dispose;
    ///<summary>Advances the enumerator to the next element of the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  collection.</summary>
    ///<returns><see langword="true" />
    ///  if the enumerator was successfully advanced to the next element; <see langword="false" />
    ///  if the enumerator has passed the end of the collection.</returns>
    ///<exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
    function MoveNext: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function ToString: string;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the element at the current position of the enumerator.</summary>
    ///<returns>The element in the <see cref="T:System.Collections.Generic.HashSet`1" />
    ///  collection at the current position of the enumerator.</returns>
    property Current: T read get_Current;
  end;

  TDNHashSet_Enumerator<T> = class(TDNGenericImport<DNHashSet_EnumeratorClass<T>, DNHashSet_Enumerator<T>>) end;

  //-------------namespace: System.Diagnostics.Eventing----------------
  DNEventDescriptorClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{059ED608-E84E-526C-803F-6BE8FE9AEDDF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventDescriptor" />
    ///  class.</summary>
    ///  <param name="id">The event identifier.</param>
    ///  <param name="version">Version of the event. The version indicates a revision to the event definition. You can use this member and the Id member to identify a unique event.</param>
    ///  <param name="channel">Defines a potential target for the event.</param>
    ///  <param name="level">Specifies the level of detail included in the event.</param>
    ///  <param name="opcode">Operation being performed at the time the event is written.</param>
    ///  <param name="task">Identifies a logical component of the application that is writing the event.</param>
    ///  <param name="keywords">Bit mask that specifies the event category. The keyword can contain one or more provider-defined keywords, standard keywords, or both.</param>
    {class} function init(id: Int32; version: Byte; channel: Byte; level: Byte; opcode: Byte; task: Int32; keywords: Int64): DNEventDescriptor;

  end;

  ///<summary>Contains the metadata that defines an event.</summary>
  [DNTypeName('System.Diagnostics.Eventing.EventDescriptor')]
  DNEventDescriptor = interface(DDN.mscorlib.DNValueType)
  ['{0A52E9D6-97AD-3E1D-9CF4-91AA9453A4BE}']
  { getters & setters } 

    function get_EventId: Int32;
    function get_Version: Byte;
    function get_Channel: Byte;
    function get_Level: Byte;
    function get_Opcode: Byte;
    function get_Task: Int32;
    function get_Keywords: Int64;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function ToString: string;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Retrieves the event identifier value from the event descriptor.</summary>
    ///<returns>The event identifier.</returns>
    property EventId: Int32 read get_EventId;
    ///<summary>Retrieves the version value from the event descriptor.</summary>
    ///<returns>The version of the event. </returns>
    property Version: Byte read get_Version;
    ///<summary>Retrieves the channel value from the event descriptor.</summary>
    ///<returns>The channel that defines a potential target for the event.</returns>
    property Channel: Byte read get_Channel;
    ///<summary>Retrieves the level value from the event descriptor.</summary>
    ///<returns>The level of detail included in the event.</returns>
    property Level: Byte read get_Level;
    ///<summary>Retrieves the operation code value from the event descriptor.</summary>
    ///<returns>The operation being performed at the time the event is written.</returns>
    property Opcode: Byte read get_Opcode;
    ///<summary>Retrieves the task value from the event descriptor.</summary>
    ///<returns>The task that identifies the logical component of the application that is writing the event.</returns>
    property Task: Int32 read get_Task;
    ///<summary>Retrieves the keyword value from the event descriptor.</summary>
    ///<returns>The keyword, which is a bit mask, that specifies the event category.</returns>
    property Keywords: Int64 read get_Keywords;
  end;

  TDNEventDescriptor = class(TDNGenericImport<DNEventDescriptorClass, DNEventDescriptor>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNCngPropertyClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{B48A998F-CE4B-5100-AC7D-50CDF2DD8E15}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  class.</summary>
    ///  <param name="name">The property name to initialize.</param>
    ///  <param name="value">The property value to initialize.</param>
    ///  <param name="options">A bitwise combination of the enumeration values that specify how the property is stored.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function init(name: string; value: TArray<Byte>; options: DNCngPropertyOptions): DNCngProperty;

  end;

  ///<summary>Encapsulates a property of a Cryptography Next Generation (CNG) key or provider.</summary>
  [DNTypeName('System.Security.Cryptography.CngProperty')]
  DNCngProperty = interface(DDN.mscorlib.DNValueType)
  ['{88674A81-0057-33D9-93D2-DCDCEDFF8D9D}']
  { getters & setters } 

    function get_Name: string;
    function get_Options: DNCngPropertyOptions;

  { methods } 

    ///<summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</summary>
    ///  <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="obj" />
    ///  parameter is a <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object that specifies the same property as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(obj: DDN.mscorlib.DNObject): Boolean; overload;
    ///<summary>Compares the specified <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object to the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</summary>
    ///  <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="other" />
    ///  parameter represents the same property as the current object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(other: DNCngProperty): Boolean; overload;
    ///<summary>Generates a hash value for the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</summary>
    ///<returns>The hash value of the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</returns>
    function GetHashCode: Int32;
    ///<summary>Gets the property value that the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object specifies.</summary>
    ///<returns>An array that represents the value stored in the property.</returns>
    function GetValue: TArray<Byte>;
    function ToString: string;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the property name that the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object specifies.</summary>
    ///<returns>The property name that is set in the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the property options that the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object specifies.</summary>
    ///<returns>An object that specifies the options that are set in the current <see cref="T:System.Security.Cryptography.CngProperty" />
    ///  object.</returns>
    property Options: DNCngPropertyOptions read get_Options;
  end;

  TDNCngProperty = class(TDNGenericImport<DNCngPropertyClass, DNCngProperty>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECCurveClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{10C66F62-8FB6-5866-A536-930689F446A0}']
  { static methods } 

    ///<summary>Creates a named curve using the specified <see cref="T:System.Security.Cryptography.Oid" />
    ///  object.</summary>
    ///  <param name="curveOid">The object identifier to use.</param>
    ///<returns>An object representing the named curve.</returns>
    {class} function CreateFromOid(curveOid: DDN.System.DNOid): DNECCurve;
    ///<summary>Creates a named curve using the specified friendly name of the identifier.</summary>
    ///  <param name="oidFriendlyName">The friendly name of the identifier.</param>
    ///<returns>An object representing the named curve.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="oidFriendlyName" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function CreateFromFriendlyName(oidFriendlyName: string): DNECCurve;
    ///<summary>Creates a named curve using the specified dotted-decimal representation of the identifier.</summary>
    ///  <param name="oidValue">The dotted number of the identifier.</param>
    ///<returns>An object representing the named curve.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="oidValue" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function CreateFromValue(oidValue: string): DNECCurve;

  end;

  ///<summary>Represents an elliptic curve.</summary>
  [DNTypeName('System.Security.Cryptography.ECCurve')]
  DNECCurve = interface(DDN.mscorlib.DNValueType)
  ['{3A216B9F-83C5-3DFB-A4ED-2795FD69F7B8}']
  { getters & setters } 

    function get_Oid: DDN.System.DNOid;
    function get_IsPrime: Boolean;
    function get_IsCharacteristic2: Boolean;
    function get_IsExplicit: Boolean;
    function get_IsNamed: Boolean;

  { fields getter & setter } 

   function __fakeFieldGet_A: TArray<Byte>;
   procedure __fakeFieldSet_A(value: TArray<Byte>);
   function __fakeFieldGet_B: TArray<Byte>;
   procedure __fakeFieldSet_B(value: TArray<Byte>);
   function __fakeFieldGet_G: DNECPoint;
   procedure __fakeFieldSet_G(value: DNECPoint);
   function __fakeFieldGet_Order: TArray<Byte>;
   procedure __fakeFieldSet_Order(value: TArray<Byte>);
   function __fakeFieldGet_Cofactor: TArray<Byte>;
   procedure __fakeFieldSet_Cofactor(value: TArray<Byte>);
   function __fakeFieldGet_Seed: TArray<Byte>;
   procedure __fakeFieldSet_Seed(value: TArray<Byte>);
   function __fakeFieldGet_CurveType: DNECCurve_ECCurveType;
   procedure __fakeFieldSet_CurveType(value: DNECCurve_ECCurveType);
   function __fakeFieldGet_Hash: DDN.mscorlib.DNNullable<DDN.mscorlib.DNHashAlgorithmName>;
   procedure __fakeFieldSet_Hash(value: DDN.mscorlib.DNNullable<DDN.mscorlib.DNHashAlgorithmName>);
   function __fakeFieldGet_Polynomial: TArray<Byte>;
   procedure __fakeFieldSet_Polynomial(value: TArray<Byte>);
   function __fakeFieldGet_Prime: TArray<Byte>;
   procedure __fakeFieldSet_Prime(value: TArray<Byte>);

  { fields } 

    ///<summary>The first coefficient for an explicit curve. A for short Weierstrass, Montgomery, and Twisted Edwards curves.</summary>
    ///<returns>Coefficient A.</returns>
   property A: TArray<Byte> read __fakeFieldGet_A write __fakeFieldSet_A;
    ///<summary>The second coefficient for an explicit curve. B for short Weierstrass and d for Twisted Edwards curves.</summary>
    ///<returns>Coefficient B.</returns>
   property B: TArray<Byte> read __fakeFieldGet_B write __fakeFieldSet_B;
    ///<summary>The generator, or base point, for operations on the curve.</summary>
    ///<returns>The base point.</returns>
   property G: DNECPoint read __fakeFieldGet_G write __fakeFieldSet_G;
    ///<summary>The order of the curve. Applies only to explicit curves.</summary>
    ///<returns>The order of the curve. </returns>
   property Order: TArray<Byte> read __fakeFieldGet_Order write __fakeFieldSet_Order;
    ///<summary>The cofactor of the curve.</summary>
    ///<returns>The cofactor of the curve.</returns>
   property Cofactor: TArray<Byte> read __fakeFieldGet_Cofactor write __fakeFieldSet_Cofactor;
    ///<summary>The seed value for coefficient generation under the ANSI X9.62 generation algorithm. Applies only to explicit curves.</summary>
    ///<returns>The seed value.</returns>
   property Seed: TArray<Byte> read __fakeFieldGet_Seed write __fakeFieldSet_Seed;
    ///<summary>Identifies the composition of the <see cref="T:System.Security.Cryptography.ECCurve" />
    ///  object.</summary>
    ///<returns>The curve type.</returns>
   property CurveType: DNECCurve_ECCurveType read __fakeFieldGet_CurveType write __fakeFieldSet_CurveType;
    ///<summary>The name of the hash algorithm which was used to generate the curve coefficients (<see cref="F:System.Security.Cryptography.ECCurve.A" />
    ///  and <see cref="F:System.Security.Cryptography.ECCurve.B" />
    ///  ) from the <see cref="F:System.Security.Cryptography.ECCurve.Seed" />
    ///  under the ANSI X9.62 generation algorithm. Applies only to explicit curves.</summary>
    ///<returns>The name of the hash algorithm used to generate the curve coefficients.</returns>
   property Hash: DDN.mscorlib.DNNullable<DDN.mscorlib.DNHashAlgorithmName> read __fakeFieldGet_Hash write __fakeFieldSet_Hash;
    ///<summary>The curve polynomial. Applies only to characteristic 2 curves.</summary>
    ///<returns>The curve polynomial.</returns>
   property Polynomial: TArray<Byte> read __fakeFieldGet_Polynomial write __fakeFieldSet_Polynomial;
    ///<summary>The prime specifying the base field. Applies only to prime curves.</summary>
    ///<returns>The prime P.</returns>
   property Prime: TArray<Byte> read __fakeFieldGet_Prime write __fakeFieldSet_Prime;

  { methods } 

    ///<summary>Validates the integrity of the current curve. Throws a <see cref="T:System.Security.Cryptography.CryptographicException" />
    ///  exception if the structure is not valid.</summary>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The curve parameters are not valid for the current curve type.</exception>
    procedure Validate;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function ToString: string;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the identifier of a named curve.</summary>
    ///<returns>The identifier of a named curve.</returns>
    property Oid: DDN.System.DNOid read get_Oid;
    ///<summary>Gets a value that indicates whether the curve type indicates an explicit prime curve.</summary>
    ///<returns><see langword="true" />
    ///  if the curve is an explicit prime curve; <see langword="false" />
    ///  if the curve is a named prime, characteristic 2 or implicit curves.</returns>
    property IsPrime: Boolean read get_IsPrime;
    ///<summary>Gets a value that indicates whether the curve type indicates an explicit characteristic 2 curve.</summary>
    ///<returns><see langword="true" />
    ///  if the curve is an explicit characteristic 2 curve; <see langword="false" />
    ///  if the curve is a named characteristic 2, prime, or implicit curve.</returns>
    property IsCharacteristic2: Boolean read get_IsCharacteristic2;
    ///<summary>Gets a value that indicates whether the curve type indicates an explicit curve (either prime or characteristic 2).</summary>
    ///<returns><see langword="true" />
    ///  if the curve is an explicit curve (either prime or characteristic 2); <see langword="false" />
    ///  if the curve is a named or implicit curve.</returns>
    property IsExplicit: Boolean read get_IsExplicit;
    ///<summary>Gets a value that indicates whether the curve type indicates a named curve.</summary>
    ///<returns><see langword="true" />
    ///  if the curve is a named curve; <see langword="false" />
    ///  if the curve is an implict or an  explicit curve (either prime or characteristic 2).</returns>
    property IsNamed: Boolean read get_IsNamed;
  end;

  TDNECCurve = class(TDNGenericImport<DNECCurveClass, DNECCurve>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECParametersClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{09469302-BA6B-572C-8CC7-7841B116DD65}']
  end;

  ///<summary>Represents the standard parameters for the elliptic curve cryptography (ECC) algorithm.</summary>
  [DNTypeName('System.Security.Cryptography.ECParameters')]
  DNECParameters = interface(DDN.mscorlib.DNValueType)
  ['{ADB113F9-AA87-3F23-9E11-BE120F21CDE6}']
  { fields getter & setter } 

   function __fakeFieldGet_Q: DNECPoint;
   procedure __fakeFieldSet_Q(value: DNECPoint);
   function __fakeFieldGet_D: TArray<Byte>;
   procedure __fakeFieldSet_D(value: TArray<Byte>);
   function __fakeFieldGet_Curve: DNECCurve;
   procedure __fakeFieldSet_Curve(value: DNECCurve);

  { fields } 

    ///<summary>Represents the public key <see langword="Q" />
    ///  for the elliptic curve cryptography (ECC) algorithm.</summary>
    ///<returns>The <see langword="Q" />
    ///  parameter for the elliptic curve cryptography (ECC) algorithm.</returns>
   property Q: DNECPoint read __fakeFieldGet_Q write __fakeFieldSet_Q;
    ///<summary>Represents the private key <see langword="D" />
    ///  for the elliptic curve cryptography (ECC) algorithm, stored in big-endian format.</summary>
    ///<returns>The <see langword="D" />
    ///  parameter for the elliptic curve cryptography (ECC) algorithm.</returns>
   property D: TArray<Byte> read __fakeFieldGet_D write __fakeFieldSet_D;
    ///<summary>Represents the curve associated with the public key (<see cref="F:System.Security.Cryptography.ECParameters.Q" />
    ///  ) and the optional private key (<see cref="F:System.Security.Cryptography.ECParameters.D" />
    ///  ).</summary>
    ///<returns>The curve.</returns>
   property Curve: DNECCurve read __fakeFieldGet_Curve write __fakeFieldSet_Curve;

  { methods } 

    ///<summary>Validates the current object.</summary>
    ///<exception cref="T:System.Security.Cryptography.CryptographicException">The key or curve parameters are not valid for the current curve type.</exception>
    procedure Validate;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function ToString: string;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  end;

  TDNECParameters = class(TDNGenericImport<DNECParametersClass, DNECParameters>) end;

  //-------------namespace: System.Security.Cryptography----------------
  DNECPointClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{CFB2BEE2-0C34-50EA-B147-CA152AC21D4E}']
  end;

  ///<summary>Represents a (X,Y) coordinate pair for elliptic curve cryptography (ECC) structures.</summary>
  [DNTypeName('System.Security.Cryptography.ECPoint')]
  DNECPoint = interface(DDN.mscorlib.DNValueType)
  ['{4492DBA8-1144-3F3E-81E8-C202B7F91305}']
  { fields getter & setter } 

   function __fakeFieldGet_X: TArray<Byte>;
   procedure __fakeFieldSet_X(value: TArray<Byte>);
   function __fakeFieldGet_Y: TArray<Byte>;
   procedure __fakeFieldSet_Y(value: TArray<Byte>);

  { fields } 

    ///<summary>Represents the X coordinate.</summary>
    ///<returns>The X coordinate.</returns>
   property X: TArray<Byte> read __fakeFieldGet_X write __fakeFieldSet_X;
    ///<summary>Represents the Y coordinate.</summary>
    ///<returns>The Y coordinate.</returns>
   property Y: TArray<Byte> read __fakeFieldGet_Y write __fakeFieldSet_Y;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function ToString: string;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  end;

  TDNECPoint = class(TDNGenericImport<DNECPointClass, DNECPoint>) end;


implementation


initialization
  LoadAssemblyModule('System.Core.dll', True);

finalization

end.
