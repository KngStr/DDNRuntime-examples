//----------------------------------------------------------------------------
//  System.Xml.dll: System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
//----------------------------------------------------------------------------
//  The code is automatically generated by the GenCodeNET tool.
//----------------------------------------------------------------------------
//  .NET Framework: 4.0
//----------------------------------------------------------------------------
//  UnitName: DDN.System.Xml
//  Author: ying32
//----------------------------------------------------------------------------

unit DDN.System.Xml;

{$IFDEF FPC}
  {$mode delphi}//{$H+}
  {$modeswitch advancedrecords}
  {$modeswitch prefixedattributes} // Custom attributes feature，fpc3.2.2+
{$ENDIF}

interface

uses
  DDN.Runtime,
  DDN.mscorlib,
  DDN.System;

type

{ enums }

  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the amount of input or output checking that <see cref="T:System.Xml.XmlReader" />
  ///  and <see cref="T:System.Xml.XmlWriter" />
  ///  objects perform.</summary>
  [DNTypeName('System.Xml.ConformanceLevel')]
  DNConformanceLevel = type Integer;
  DNConformanceLevelHelper = record helper for DNConformanceLevel
  public const
    ///<summary>The <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.Xml.XmlWriter" />
    ///  object automatically detects whether document-level or fragment-level checking should be performed, and does the appropriate checking. If you're wrapping another <see cref="T:System.Xml.XmlReader" />
    ///  or <see cref="T:System.Xml.XmlWriter" />
    ///  object, the outer object doesn't do any additional conformance checking. Conformance checking is left up to the underlying object.See the <see cref="P:System.Xml.XmlReaderSettings.ConformanceLevel" />
    ///  and <see cref="P:System.Xml.XmlWriterSettings.ConformanceLevel" />
    ///  properties for details on how the compliance level is determined.</summary>
    Auto = 0;
    ///<summary>The XML data is a well-formed XML fragment, as defined by the W3C.</summary>
    Fragment = 1;
    ///<summary>The XML data complies with the rules for a well-formed XML 1.0 document, as defined by the W3C.</summary>
    Document = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the options for processing DTDs. The <see cref="T:System.Xml.DtdProcessing" />
  ///  enumeration is used by the <see cref="T:System.Xml.XmlReaderSettings" />
  ///  class.</summary>
  [DNTypeName('System.Xml.DtdProcessing')]
  DNDtdProcessing = type Integer;
  DNDtdProcessingHelper = record helper for DNDtdProcessing
  public const
    ///<summary>Specifies that when a DTD is encountered, an <see cref="T:System.Xml.XmlException" />
    ///  is thrown with a message that states that DTDs are prohibited. This is the default behavior.</summary>
    Prohibit = 0;
    ///<summary>Causes the DOCTYPE element to be ignored. No DTD processing occurs. </summary>
    Ignore = 1;
    ///<summary>Used for parsing DTDs.</summary>
    Parse = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies how the <see cref="T:System.Xml.XmlTextReader" />
  ///  or <see cref="T:System.Xml.XmlValidatingReader" />
  ///  handle entities.</summary>
  [DNTypeName('System.Xml.EntityHandling')]
  DNEntityHandling = type Integer;
  DNEntityHandlingHelper = record helper for DNEntityHandling
  public const
    ///<summary>Expands all entities and returns the expanded nodes.</summary>
    ExpandEntities = 1;
    ///<summary>Expands character entities and returns general entities as <see cref="F:System.Xml.XmlNodeType.EntityReference" />
    ///  nodes. </summary>
    ExpandCharEntities = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies formatting options for the <see cref="T:System.Xml.XmlTextWriter" />
  ///  .</summary>
  [DNTypeName('System.Xml.Formatting')]
  DNFormatting = type Integer;
  DNFormattingHelper = record helper for DNFormatting
  public const
    ///<summary>No special formatting is applied. This is the default.</summary>
    None = 0;
    ///<summary>Causes child elements to be indented according to the <see cref="P:System.Xml.XmlTextWriter.Indentation" />
    ///  and <see cref="P:System.Xml.XmlTextWriter.IndentChar" />
    ///  settings. </summary>
    Indented = 1;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies whether to remove duplicate namespace declarations in the <see cref="T:System.Xml.XmlWriter" />
  ///  . </summary>
  [DNTypeName('System.Xml.NamespaceHandling')]
  DNNamespaceHandling = type Integer;
  DNNamespaceHandlingHelper = record helper for DNNamespaceHandling
  public const
    ///<summary>Specifies that duplicate namespace declarations will not be removed.</summary>
    Default_ = 0;
    ///<summary>Specifies that duplicate namespace declarations will be removed. For the duplicate namespace to be removed, the prefix and the namespace must match.</summary>
    OmitDuplicates = 1;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies how to handle line breaks.</summary>
  [DNTypeName('System.Xml.NewLineHandling')]
  DNNewLineHandling = type Integer;
  DNNewLineHandlingHelper = record helper for DNNewLineHandling
  public const
    ///<summary>New line characters are replaced to match the character specified in the <see cref="P:System.Xml.XmlWriterSettings.NewLineChars" />
    ///  property.</summary>
    Replace = 0;
    ///<summary>New line characters are entitized. This setting preserves all characters when the output is read by a normalizing <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    Entitize = 1;
    ///<summary>The new line characters are unchanged. The output is the same as the input.</summary>
    None = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the state of the reader.</summary>
  [DNTypeName('System.Xml.ReadState')]
  DNReadState = type Integer;
  DNReadStateHelper = record helper for DNReadState
  public const
    ///<summary>The <see langword="Read" />
    ///  method has not been called.</summary>
    Initial = 0;
    ///<summary>The <see langword="Read" />
    ///  method has been called. Additional methods may be called on the reader.</summary>
    Interactive = 1;
    ///<summary>An error occurred that prevents the read operation from continuing.</summary>
    Error = 2;
    ///<summary>The end of the file has been reached successfully.</summary>
    EndOfFile = 3;
    ///<summary>The <see cref="M:System.Xml.XmlReader.Close" />
    ///  method has been called.</summary>
    Closed = 4;
  end;


  //-------------namespace: System.Xml.Resolvers----------------
  ///<summary>The <see cref="T:System.Xml.Resolvers.XmlKnownDtds" />
  ///  enumeration is used by the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
  ///  and defines which well-known DTDs that the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
  ///  recognizes.</summary>
  [DNTypeName('System.Xml.Resolvers.XmlKnownDtds')]
  DNXmlKnownDtds = type Integer;
  DNXmlKnownDtdsHelper = record helper for DNXmlKnownDtds
  public const
    ///<summary>Specifies that the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  will not recognize any of the predefined DTDs.</summary>
    None = 0;
    ///<summary>Specifies that the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  will recognize DTDs and entities that are defined in XHTML 1.0. </summary>
    Xhtml10 = 1;
    ///<summary>Specifies that the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  will recognize DTDs and entities that are defined in RSS 0.91.</summary>
    Rss091 = 2;
    ///<summary>Specifies that the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  will recognize all currently supported DTDs. This is the default behavior.</summary>
    All = 65535;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Provides information about the validation mode of <see langword="any" />
  ///  and <see langword="anyAttribute" />
  ///  element replacements.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaContentProcessing')]
  DNXmlSchemaContentProcessing = type Integer;
  DNXmlSchemaContentProcessingHelper = record helper for DNXmlSchemaContentProcessing
  public const
    ///<summary>Document items are not validated.</summary>
    None = 0;
    ///<summary>Document items must consist of well-formed XML and are not validated by the schema.</summary>
    Skip = 1;
    ///<summary>If the associated schema is found, the document items will be validated. No errors will be thrown otherwise.</summary>
    Lax = 2;
    ///<summary>The schema processor must find a schema associated with the indicated namespace to validate the document items.</summary>
    Strict_ = 3;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Enumerations for the content model of the complex type. This represents the content in the post-schema-validation information set (infoset).</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaContentType')]
  DNXmlSchemaContentType = type Integer;
  DNXmlSchemaContentTypeHelper = record helper for DNXmlSchemaContentType
  public const
    ///<summary>Text-only content.</summary>
    TextOnly = 0;
    ///<summary>Empty content.</summary>
    Empty = 1;
    ///<summary>Element-only content.</summary>
    ElementOnly = 2;
    ///<summary>Mixed content.</summary>
    Mixed = 3;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Specifies the W3C XML schema data type variety of the type.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaDatatypeVariety')]
  DNXmlSchemaDatatypeVariety = type Integer;
  DNXmlSchemaDatatypeVarietyHelper = record helper for DNXmlSchemaDatatypeVariety
  public const
    ///<summary>A W3C XML schema atomic type.</summary>
    Atomic = 0;
    ///<summary>A W3C XML schema list type.</summary>
    List = 1;
    ///<summary>A W3C XML schema union type.</summary>
    Union = 2;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Provides different methods for preventing derivation.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaDerivationMethod')]
  DNXmlSchemaDerivationMethod = type Integer;
  DNXmlSchemaDerivationMethodHelper = record helper for DNXmlSchemaDerivationMethod
  public const
    ///<summary>Override default derivation method to allow any derivation.</summary>
    Empty = 0;
    ///<summary>Refers to derivations by <see langword="Substitution" />
    ///  .</summary>
    Substitution = 1;
    ///<summary>Refers to derivations by <see langword="Extension" />
    ///  .</summary>
    Extension = 2;
    ///<summary>Refers to derivations by <see langword="Restriction" />
    ///  .</summary>
    Restriction = 4;
    ///<summary>Refers to derivations by <see langword="List" />
    ///  .</summary>
    List = 8;
    ///<summary>Refers to derivations by <see langword="Union" />
    ///  .</summary>
    Union = 16;
    ///<summary><see langword="#all" />
    ///  . Refers to all derivation methods.</summary>
    All = 255;
    ///<summary>Accepts the default derivation method.</summary>
    None = 256;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Indicates if attributes or elements need to be qualified with a namespace prefix.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaForm')]
  DNXmlSchemaForm = type Integer;
  DNXmlSchemaFormHelper = record helper for DNXmlSchemaForm
  public const
    ///<summary>Element and attribute form is not specified in the schema.</summary>
    None = 0;
    ///<summary>Elements and attributes must be qualified with a namespace prefix.</summary>
    Qualified = 1;
    ///<summary>Elements and attributes are not required to be qualified with a namespace prefix.</summary>
    Unqualified = 2;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Affects occurrence and type information inferred by the <see cref="T:System.Xml.Schema.XmlSchemaInference" />
  ///  class for elements and attributes in an XML document. </summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaInference+InferenceOption')]
  DNXmlSchemaInference_InferenceOption = type Integer;
  DNXmlSchemaInference_InferenceOptionHelper = record helper for DNXmlSchemaInference_InferenceOption
  public const
    ///<summary>Indicates that a more restrictive schema declaration should be inferred for a particular element or attribute.</summary>
    Restricted = 0;
    ///<summary>Indicates that a less restrictive schema declaration should be inferred for a particular element or attribute.</summary>
    Relaxed = 1;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Indicator of how the attribute is used.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaUse')]
  DNXmlSchemaUse = type Integer;
  DNXmlSchemaUseHelper = record helper for DNXmlSchemaUse
  public const
    ///<summary>Attribute use not specified.</summary>
    None = 0;
    ///<summary>Attribute is optional.</summary>
    Optional = 1;
    ///<summary>Attribute cannot be used.</summary>
    Prohibited = 2;
    ///<summary>Attribute must appear once.</summary>
    Required = 3;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Specifies schema validation options used by the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
  ///  and <see cref="T:System.Xml.XmlReader" />
  ///  classes.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaValidationFlags')]
  DNXmlSchemaValidationFlags = type Integer;
  DNXmlSchemaValidationFlagsHelper = record helper for DNXmlSchemaValidationFlags
  public const
    ///<summary>Do not process identity constraints, inline schemas, schema location hints, or report schema validation warnings.</summary>
    None = 0;
    ///<summary>Process inline schemas encountered during validation.</summary>
    ProcessInlineSchema = 1;
    ///<summary>Process schema location hints (xsi:schemaLocation, xsi:noNamespaceSchemaLocation) encountered during validation.</summary>
    ProcessSchemaLocation = 2;
    ///<summary>Report schema validation warnings encountered during validation.</summary>
    ReportValidationWarnings = 4;
    ///<summary>Process identity constraints (xs:ID, xs:IDREF, xs:key, xs:keyref, xs:unique) encountered during validation.</summary>
    ProcessIdentityConstraints = 8;
    ///<summary>Allow xml:* attributes even if they are not defined in the schema. The attributes will be validated based on their data type.</summary>
    AllowXmlAttributes = 16;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Represents the validity of an XML item validated by the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
  ///  class.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaValidity')]
  DNXmlSchemaValidity = type Integer;
  DNXmlSchemaValidityHelper = record helper for DNXmlSchemaValidity
  public const
    ///<summary>The validity of the XML item is not known.</summary>
    NotKnown = 0;
    ///<summary>The XML item is valid.</summary>
    Valid = 1;
    ///<summary>The XML item is invalid.</summary>
    Invalid = 2;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Represents the severity of the validation event.</summary>
  [DNTypeName('System.Xml.Schema.XmlSeverityType')]
  DNXmlSeverityType = type Integer;
  DNXmlSeverityTypeHelper = record helper for DNXmlSeverityType
  public const
    ///<summary>Indicates a validation error occurred when validating the instance document. This applies to document type definitions (DTDs) and XML Schema definition language (XSD) schemas. The World Wide Web Consortium (W3C) validity constraints are considered errors. If no validation event handler has been created, errors throw an exception.</summary>
    Error = 0;
    ///<summary>Indicates that a validation event occurred that is not an error. A warning is typically issued when there is no DTD, or XML Schema to validate a particular element or attribute against. Unlike errors, warnings do not throw an exception if there is no validation event handler.</summary>
    Warning = 1;
  end;


  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Represents the W3C XML Schema Definition Language (XSD) schema types.</summary>
  [DNTypeName('System.Xml.Schema.XmlTypeCode')]
  DNXmlTypeCode = type Integer;
  DNXmlTypeCodeHelper = record helper for DNXmlTypeCode
  public const
    ///<summary>No type information.</summary>
    None = 0;
    ///<summary>An item such as a node or atomic value.</summary>
    Item = 1;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Node = 2;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Document = 3;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Element = 4;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Attribute = 5;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Namespace = 6;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    ProcessingInstruction = 7;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Comment = 8;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    Text = 9;
    ///<summary>Any atomic value of a union.</summary>
    AnyAtomicType = 10;
    ///<summary>An untyped atomic value.</summary>
    UntypedAtomic = 11;
    ///<summary>A W3C XML Schema <see langword="xs:string" />
    ///  type.</summary>
    String_ = 12;
    ///<summary>A W3C XML Schema <see langword="xs:boolean" />
    ///  type.</summary>
    Boolean = 13;
    ///<summary>A W3C XML Schema <see langword="xs:decimal" />
    ///  type.</summary>
    Decimal = 14;
    ///<summary>A W3C XML Schema <see langword="xs:float" />
    ///  type.</summary>
    Float = 15;
    ///<summary>A W3C XML Schema <see langword="xs:double" />
    ///  type.</summary>
    Double = 16;
    ///<summary>A W3C XML Schema <see langword="xs:Duration" />
    ///  type.</summary>
    Duration = 17;
    ///<summary>A W3C XML Schema <see langword="xs:dateTime" />
    ///  type.</summary>
    DateTime = 18;
    ///<summary>A W3C XML Schema <see langword="xs:time" />
    ///  type.</summary>
    Time = 19;
    ///<summary>A W3C XML Schema <see langword="xs:date" />
    ///  type.</summary>
    Date = 20;
    ///<summary>A W3C XML Schema <see langword="xs:gYearMonth" />
    ///  type.</summary>
    GYearMonth = 21;
    ///<summary>A W3C XML Schema <see langword="xs:gYear" />
    ///  type.</summary>
    GYear = 22;
    ///<summary>A W3C XML Schema <see langword="xs:gMonthDay" />
    ///  type.</summary>
    GMonthDay = 23;
    ///<summary>A W3C XML Schema <see langword="xs:gDay" />
    ///  type.</summary>
    GDay = 24;
    ///<summary>A W3C XML Schema <see langword="xs:gMonth" />
    ///  type.</summary>
    GMonth = 25;
    ///<summary>A W3C XML Schema <see langword="xs:hexBinary" />
    ///  type.</summary>
    HexBinary = 26;
    ///<summary>A W3C XML Schema <see langword="xs:base64Binary" />
    ///  type.</summary>
    Base64Binary = 27;
    ///<summary>A W3C XML Schema <see langword="xs:anyURI" />
    ///  type.</summary>
    AnyUri = 28;
    ///<summary>A W3C XML Schema <see langword="xs:QName" />
    ///  type.</summary>
    QName = 29;
    ///<summary>A W3C XML Schema <see langword="xs:NOTATION" />
    ///  type.</summary>
    Notation = 30;
    ///<summary>A W3C XML Schema <see langword="xs:normalizedString" />
    ///  type.</summary>
    NormalizedString = 31;
    ///<summary>A W3C XML Schema <see langword="xs:token" />
    ///  type.</summary>
    Token = 32;
    ///<summary>A W3C XML Schema <see langword="xs:language" />
    ///  type.</summary>
    Language = 33;
    ///<summary>A W3C XML Schema <see langword="xs:NMTOKEN" />
    ///  type.</summary>
    NmToken = 34;
    ///<summary>A W3C XML Schema <see langword="xs:Name" />
    ///  type.</summary>
    Name = 35;
    ///<summary>A W3C XML Schema <see langword="xs:NCName" />
    ///  type.</summary>
    NCName = 36;
    ///<summary>A W3C XML Schema <see langword="xs:ID" />
    ///  type.</summary>
    Id = 37;
    ///<summary>A W3C XML Schema <see langword="xs:IDREF" />
    ///  type.</summary>
    Idref = 38;
    ///<summary>A W3C XML Schema <see langword="xs:ENTITY" />
    ///  type.</summary>
    Entity = 39;
    ///<summary>A W3C XML Schema <see langword="xs:integer" />
    ///  type.</summary>
    Integer = 40;
    ///<summary>A W3C XML Schema <see langword="xs:nonPositiveInteger" />
    ///  type.</summary>
    NonPositiveInteger = 41;
    ///<summary>A W3C XML Schema <see langword="xs:negativeInteger" />
    ///  type.</summary>
    NegativeInteger = 42;
    ///<summary>A W3C XML Schema <see langword="xs:long" />
    ///  type.</summary>
    Long = 43;
    ///<summary>A W3C XML Schema <see langword="xs:int" />
    ///  type.</summary>
    Int = 44;
    ///<summary>A W3C XML Schema <see langword="xs:short" />
    ///  type.</summary>
    Short = 45;
    ///<summary>A W3C XML Schema <see langword="xs:byte" />
    ///  type.</summary>
    Byte = 46;
    ///<summary>A W3C XML Schema <see langword="xs:nonNegativeInteger" />
    ///  type.</summary>
    NonNegativeInteger = 47;
    ///<summary>A W3C XML Schema <see langword="xs:unsignedLong" />
    ///  type.</summary>
    UnsignedLong = 48;
    ///<summary>A W3C XML Schema <see langword="xs:unsignedInt" />
    ///  type.</summary>
    UnsignedInt = 49;
    ///<summary>A W3C XML Schema <see langword="xs:unsignedShort" />
    ///  type.</summary>
    UnsignedShort = 50;
    ///<summary>A W3C XML Schema <see langword="xs:unsignedByte" />
    ///  type.</summary>
    UnsignedByte = 51;
    ///<summary>A W3C XML Schema <see langword="xs:positiveInteger" />
    ///  type.</summary>
    PositiveInteger = 52;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    YearMonthDuration = 53;
    ///<summary>This value supports the .NET Framework infrastructure and is not intended to be used directly from your code.</summary>
    DayTimeDuration = 54;
  end;


  //-------------namespace: System.Xml.Serialization----------------
  ///<summary>Specifies various options to use when generating .NET Framework types for use with an XML Web Service.</summary>
  [DNTypeName('System.Xml.Serialization.CodeGenerationOptions')]
  DNCodeGenerationOptions = type Integer;
  DNCodeGenerationOptionsHelper = record helper for DNCodeGenerationOptions
  public const
    ///<summary>Represents primitive types by fields and primitive types by <see cref="N:System" />
    ///  namespace types.</summary>
    None = 0;
    ///<summary>Represents primitive types by properties.</summary>
    GenerateProperties = 1;
    ///<summary>Creates events for the asynchronous invocation of Web methods.</summary>
    GenerateNewAsync = 2;
    ///<summary>Creates Begin and End methods for the asynchronous invocation of Web methods.</summary>
    GenerateOldAsync = 4;
    ///<summary>Generates explicitly ordered serialization code as specified through the <see langword="Order" />
    ///  property of the <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  , <see cref="T:System.Xml.Serialization.XmlArrayAttribute" />
    ///  , and <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  attributes. </summary>
    GenerateOrder = 8;
    ///<summary>Enables data binding.</summary>
    EnableDataBinding = 16;
  end;


  //-------------namespace: System.Xml.Serialization----------------
  ///<summary>Specifies whether a mapping is read, write, or both.</summary>
  [DNTypeName('System.Xml.Serialization.XmlMappingAccess')]
  DNXmlMappingAccess = type Integer;
  DNXmlMappingAccessHelper = record helper for DNXmlMappingAccess
  public const
    ///<summary>Both read and write methods are generated.</summary>
    None = 0;
    ///<summary>Read methods are generated.</summary>
    Read = 1;
    ///<summary>Write methods are generated.</summary>
    Write = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the type of validation to perform.</summary>
  [DNTypeName('System.Xml.ValidationType')]
  DNValidationType = type Integer;
  DNValidationTypeHelper = record helper for DNValidationType
  public const
    ///<summary>No validation is performed. This setting creates an XML 1.0 compliant non-validating parser.</summary>
    None = 0;
    ///<summary>Validates if DTD or schema information is found.</summary>
    Auto = 1;
    ///<summary>Validates according to the DTD.</summary>
    DTD = 2;
    ///<summary>Validate according to XML-Data Reduced (XDR) schemas, including inline XDR schemas. XDR schemas are recognized using the <see langword="x-schema" />
    ///  namespace prefix or the <see cref="P:System.Xml.XmlValidatingReader.Schemas" />
    ///  property.</summary>
    XDR = 3;
    ///<summary>Validate according to XML Schema definition language (XSD) schemas, including inline XML Schemas. XML Schemas are associated with namespace URIs either by using the <see langword="schemaLocation" />
    ///  attribute or the provided <see langword="Schemas" />
    ///  property.</summary>
    Schema = 4;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies how white space is handled.</summary>
  [DNTypeName('System.Xml.WhitespaceHandling')]
  DNWhitespaceHandling = type Integer;
  DNWhitespaceHandlingHelper = record helper for DNWhitespaceHandling
  public const
    ///<summary>Return <see langword="Whitespace" />
    ///  and <see langword="SignificantWhitespace" />
    ///  nodes. This is the default.</summary>
    All = 0;
    ///<summary>Return <see langword="SignificantWhitespace" />
    ///  nodes only.</summary>
    Significant = 1;
    ///<summary>Return no <see langword="Whitespace" />
    ///  and no <see langword="SignificantWhitespace" />
    ///  nodes.</summary>
    None = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the state of the <see cref="T:System.Xml.XmlWriter" />
  ///  .</summary>
  [DNTypeName('System.Xml.WriteState')]
  DNWriteState = type Integer;
  DNWriteStateHelper = record helper for DNWriteState
  public const
    ///<summary>Indicates that a Write method has not yet been called.</summary>
    Start = 0;
    ///<summary>Indicates that the prolog is being written.</summary>
    Prolog = 1;
    ///<summary>Indicates that an element start tag is being written.</summary>
    Element = 2;
    ///<summary>Indicates that an attribute value is being written.</summary>
    Attribute = 3;
    ///<summary>Indicates that element content is being written.</summary>
    Content = 4;
    ///<summary>Indicates that the <see cref="M:System.Xml.XmlWriter.Close" />
    ///  method has been called.</summary>
    Closed = 5;
    ///<summary>An exception has been thrown, which has left the <see cref="T:System.Xml.XmlWriter" />
    ///  in an invalid state. You can call the <see cref="M:System.Xml.XmlWriter.Close" />
    ///  method to put the <see cref="T:System.Xml.XmlWriter" />
    ///  in the <see cref="F:System.Xml.WriteState.Closed" />
    ///  state. Any other <see cref="T:System.Xml.XmlWriter" />
    ///  method calls results in an <see cref="T:System.InvalidOperationException" />
    ///  .</summary>
    Error = 6;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies how to treat the time value when converting between string and <see cref="T:System.DateTime" />
  ///  .</summary>
  [DNTypeName('System.Xml.XmlDateTimeSerializationMode')]
  DNXmlDateTimeSerializationMode = type Integer;
  DNXmlDateTimeSerializationModeHelper = record helper for DNXmlDateTimeSerializationMode
  public const
    ///<summary>Treat as local time. If the <see cref="T:System.DateTime" />
    ///  object represents a Coordinated Universal Time (UTC), it is converted to the local time.</summary>
    Local = 0;
    ///<summary>Treat as a UTC. If the <see cref="T:System.DateTime" />
    ///  object represents a local time, it is converted to a UTC.</summary>
    Utc = 1;
    ///<summary>Treat as a local time if a <see cref="T:System.DateTime" />
    ///  is being converted to a string.</summary>
    Unspecified = 2;
    ///<summary>Time zone information should be preserved when converting.</summary>
    RoundtripKind = 3;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Defines the namespace scope.</summary>
  [DNTypeName('System.Xml.XmlNamespaceScope')]
  DNXmlNamespaceScope = type Integer;
  DNXmlNamespaceScopeHelper = record helper for DNXmlNamespaceScope
  public const
    ///<summary>All namespaces defined in the scope of the current node. This includes the xmlns:xml namespace which is always declared implicitly. The order of the namespaces returned is not defined.</summary>
    All = 0;
    ///<summary>All namespaces defined in the scope of the current node, excluding the xmlns:xml namespace, which is always declared implicitly. The order of the namespaces returned is not defined.</summary>
    ExcludeXml = 1;
    ///<summary>All namespaces that are defined locally at the current node.</summary>
    Local = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the type of node change.</summary>
  [DNTypeName('System.Xml.XmlNodeChangedAction')]
  DNXmlNodeChangedAction = type Integer;
  DNXmlNodeChangedActionHelper = record helper for DNXmlNodeChangedAction
  public const
    ///<summary>A node is being inserted in the tree.</summary>
    Insert = 0;
    ///<summary>A node is being removed from the tree.</summary>
    Remove = 1;
    ///<summary>A node value is being changed.</summary>
    Change = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Describes the document order of a node compared to a second node.</summary>
  [DNTypeName('System.Xml.XmlNodeOrder')]
  DNXmlNodeOrder = type Integer;
  DNXmlNodeOrderHelper = record helper for DNXmlNodeOrder
  public const
    ///<summary>The current node of this navigator is before the current node of the supplied navigator.</summary>
    Before = 0;
    ///<summary>The current node of this navigator is after the current node of the supplied navigator.</summary>
    After = 1;
    ///<summary>The two navigators are positioned on the same node.</summary>
    Same = 2;
    ///<summary>The node positions cannot be determined in document order, relative to each other. This could occur if the two nodes reside in different trees.</summary>
    Unknown = 3;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the type of node.</summary>
  [DNTypeName('System.Xml.XmlNodeType')]
  DNXmlNodeType = type Integer;
  DNXmlNodeTypeHelper = record helper for DNXmlNodeType
  public const
    ///<summary>This is returned by the <see cref="T:System.Xml.XmlReader" />
    ///  if a <see langword="Read" />
    ///  method has not been called.</summary>
    None = 0;
    ///<summary>An element (for example, &lt;item&gt; ).</summary>
    Element = 1;
    ///<summary>An attribute (for example, id='123' ).</summary>
    Attribute = 2;
    ///<summary>The text content of a node.</summary>
    Text = 3;
    ///<summary>A CDATA section (for example, &lt;![CDATA[my escaped text]]&gt; ).</summary>
    CDATA = 4;
    ///<summary>A reference to an entity (for example, &amp;num; ).</summary>
    EntityReference = 5;
    ///<summary>An entity declaration (for example, &lt;!ENTITY...&gt; ).</summary>
    Entity = 6;
    ///<summary>A processing instruction (for example, &lt;?pi test?&gt; ).</summary>
    ProcessingInstruction = 7;
    ///<summary>A comment (for example, &lt;!-- my comment --&gt; ).</summary>
    Comment = 8;
    ///<summary>A document object that, as the root of the document tree, provides access to the entire XML document.</summary>
    Document = 9;
    ///<summary>The document type declaration, indicated by the following tag (for example, &lt;!DOCTYPE...&gt; ).</summary>
    DocumentType = 10;
    ///<summary>A document fragment.</summary>
    DocumentFragment = 11;
    ///<summary>A notation in the document type declaration (for example, &lt;!NOTATION...&gt; ).</summary>
    Notation = 12;
    ///<summary>White space between markup.</summary>
    Whitespace = 13;
    ///<summary>White space between markup in a mixed content model or white space within the xml:space="preserve" scope.</summary>
    SignificantWhitespace = 14;
    ///<summary>An end element tag (for example, &lt;/item&gt; ).</summary>
    EndElement = 15;
    ///<summary>Returned when <see langword="XmlReader" />
    ///  gets to the end of the entity replacement as a result of a call to <see cref="M:System.Xml.XmlReader.ResolveEntity" />
    ///  .</summary>
    EndEntity = 16;
    ///<summary>The XML declaration (for example, &lt;?xml version='1.0'?&gt; ).</summary>
    XmlDeclaration = 17;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the method used to serialize the <see cref="T:System.Xml.XmlWriter" />
  ///  output. </summary>
  [DNTypeName('System.Xml.XmlOutputMethod')]
  DNXmlOutputMethod = type Integer;
  DNXmlOutputMethodHelper = record helper for DNXmlOutputMethod
  public const
    ///<summary>Serialize according to the XML 1.0 rules.</summary>
    Xml = 0;
    ///<summary>Serialize according to the HTML rules specified by XSLT.</summary>
    Html = 1;
    ///<summary>Serialize text blocks only.</summary>
    Text = 2;
    ///<summary>Use the XSLT rules to choose between the <see cref="F:System.Xml.XmlOutputMethod.Xml" />
    ///  and <see cref="F:System.Xml.XmlOutputMethod.Html" />
    ///  output methods at runtime.</summary>
    AutoDetect = 3;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Specifies the current <see langword="xml:space" />
  ///  scope.</summary>
  [DNTypeName('System.Xml.XmlSpace')]
  DNXmlSpace = type Integer;
  DNXmlSpaceHelper = record helper for DNXmlSpace
  public const
    ///<summary>No <see langword="xml:space" />
    ///  scope.</summary>
    None = 0;
    ///<summary>The <see langword="xml:space" />
    ///  scope equals <see langword="default" />
    ///  .</summary>
    Default_ = 1;
    ///<summary>The <see langword="xml:space" />
    ///  scope equals <see langword="preserve" />
    ///  .</summary>
    Preserve = 2;
  end;


  //-------------namespace: System.Xml----------------
  ///<summary>Represents the XML type for the string. This allows the string to be read as a particular XML type, for example a CDATA section type.</summary>
  [DNTypeName('System.Xml.XmlTokenizedType')]
  DNXmlTokenizedType = type Integer;
  DNXmlTokenizedTypeHelper = record helper for DNXmlTokenizedType
  public const
    ///<summary>CDATA type.</summary>
    CDATA = 0;
    ///<summary>ID type.</summary>
    ID = 1;
    ///<summary>IDREF type.</summary>
    IDREF = 2;
    ///<summary>IDREFS type.</summary>
    IDREFS = 3;
    ///<summary>ENTITY type.</summary>
    ENTITY = 4;
    ///<summary>ENTITIES type.</summary>
    ENTITIES = 5;
    ///<summary>NMTOKEN type.</summary>
    NMTOKEN = 6;
    ///<summary>NMTOKENS type.</summary>
    NMTOKENS = 7;
    ///<summary>NOTATION type.</summary>
    NOTATION = 8;
    ///<summary>ENUMERATION type.</summary>
    ENUMERATION = 9;
    ///<summary>QName type.</summary>
    QName = 10;
    ///<summary>NCName type.</summary>
    NCName = 11;
    ///<summary>No type.</summary>
    None = 12;
  end;


  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Specifies the sort order for uppercase and lowercase letters.</summary>
  [DNTypeName('System.Xml.XPath.XmlCaseOrder')]
  DNXmlCaseOrder = type Integer;
  DNXmlCaseOrderHelper = record helper for DNXmlCaseOrder
  public const
    ///<summary>Ignore the case.</summary>
    None = 0;
    ///<summary>Uppercase letters are sorted before lowercase letters.</summary>
    UpperFirst = 1;
    ///<summary>Lowercase letters are sorted before uppercase letters.</summary>
    LowerFirst = 2;
  end;


  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Specifies the data type used to determine sort order.</summary>
  [DNTypeName('System.Xml.XPath.XmlDataType')]
  DNXmlDataType = type Integer;
  DNXmlDataTypeHelper = record helper for DNXmlDataType
  public const
    ///<summary>Values are sorted alphabetically.</summary>
    Text = 1;
    ///<summary>Values are sorted numerically.</summary>
    Number = 2;
  end;


  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Specifies the sort order.</summary>
  [DNTypeName('System.Xml.XPath.XmlSortOrder')]
  DNXmlSortOrder = type Integer;
  DNXmlSortOrderHelper = record helper for DNXmlSortOrder
  public const
    ///<summary>Nodes are sorted in ascending order. For example, if the numbers 1,2,3, and 4 are sorted in ascending order, they appear as 1,2,3,4.</summary>
    Ascending = 1;
    ///<summary>Nodes are sorted in descending order. For example, if the numbers 1,2,3, and 4 are sorted in descending order, they appear as, 4,3,2,1. </summary>
    Descending = 2;
  end;


  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Defines the namespace scope.</summary>
  [DNTypeName('System.Xml.XPath.XPathNamespaceScope')]
  DNXPathNamespaceScope = type Integer;
  DNXPathNamespaceScopeHelper = record helper for DNXPathNamespaceScope
  public const
    ///<summary>Returns all namespaces defined in the scope of the current node. This includes the xmlns:xml namespace which is always declared implicitly. The order of the namespaces returned is not defined.</summary>
    All = 0;
    ///<summary>Returns all namespaces defined in the scope of the current node, excluding the xmlns:xml namespace. The xmlns:xml namespace is always declared implicitly. The order of the namespaces returned is not defined.</summary>
    ExcludeXml = 1;
    ///<summary>Returns all namespaces that are defined locally at the current node. </summary>
    Local = 2;
  end;


  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Defines the XPath node types that can be returned from the <see cref="T:System.Xml.XPath.XPathNavigator" />
  ///  class.</summary>
  [DNTypeName('System.Xml.XPath.XPathNodeType')]
  DNXPathNodeType = type Integer;
  DNXPathNodeTypeHelper = record helper for DNXPathNodeType
  public const
    ///<summary>The root node of the XML document or node tree.</summary>
    Root = 0;
    ///<summary>An element, such as &lt;element&gt;.</summary>
    Element = 1;
    ///<summary>An attribute, such as id='123'.</summary>
    Attribute = 2;
    ///<summary>A namespace, such as xmlns="namespace".</summary>
    Namespace = 3;
    ///<summary>The text content of a node. Equivalent to the Document Object Model (DOM) Text and CDATA node types. Contains at least one character.</summary>
    Text = 4;
    ///<summary>A node with white space characters and xml:space set to preserve.</summary>
    SignificantWhitespace = 5;
    ///<summary>A node with only white space characters and no significant white space. White space characters are #x20, #x9, #xD, or #xA.</summary>
    Whitespace = 6;
    ///<summary>A processing instruction, such as &lt;?pi test?&gt;. This does not include XML declarations, which are not visible to the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  class. </summary>
    ProcessingInstruction = 7;
    ///<summary>A comment, such as &lt;!-- my comment --&gt;</summary>
    Comment = 8;
    ///<summary>Any of the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  node types.</summary>
    All = 9;
  end;


  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Specifies the return type of the XPath expression.</summary>
  [DNTypeName('System.Xml.XPath.XPathResultType')]
  DNXPathResultType = type Integer;
  DNXPathResultTypeHelper = record helper for DNXPathResultType
  public const
    ///<summary>A numeric value.</summary>
    Number = 0;
    ///<summary>A <see cref="T:System.String" />
    ///  value.</summary>
    String_ = 1;
    ///<summary>A tree fragment.</summary>
    Navigator = 1;
    ///<summary>A <see cref="T:System.Boolean" />
    ///<see langword="true" />
    ///  or <see langword="false" />
    ///  value.</summary>
    Boolean = 2;
    ///<summary>A node collection.</summary>
    NodeSet = 3;
    ///<summary>Any of the XPath node types.</summary>
    Any = 5;
    ///<summary>The expression does not evaluate to the correct XPath type.</summary>
    Error = 6;
  end;




type


{ declares }

  DNIApplicationResourceStreamResolver = interface; // type: System.Xml.IApplicationResourceStreamResolver, namespace: System.Xml
  DNIHasXmlNode = interface; // type: System.Xml.IHasXmlNode, namespace: System.Xml
  DNIXmlLineInfo = interface; // type: System.Xml.IXmlLineInfo, namespace: System.Xml
  DNIXmlNamespaceResolver = interface; // type: System.Xml.IXmlNamespaceResolver, namespace: System.Xml
  DNIXmlSchemaInfo = interface; // type: System.Xml.Schema.IXmlSchemaInfo, namespace: System.Xml.Schema
  DNIXmlSerializable = interface; // type: System.Xml.Serialization.IXmlSerializable, namespace: System.Xml.Serialization
  DNIXmlTextParser = interface; // type: System.Xml.Serialization.IXmlTextParser, namespace: System.Xml.Serialization
  DNIXPathNavigable = interface; // type: System.Xml.XPath.IXPathNavigable, namespace: System.Xml.XPath
  DNIXsltContextFunction = interface; // type: System.Xml.Xsl.IXsltContextFunction, namespace: System.Xml.Xsl
  DNIXsltContextVariable = interface; // type: System.Xml.Xsl.IXsltContextVariable, namespace: System.Xml.Xsl
  DNSoapAttributeAttribute = interface; // type: System.Xml.Serialization.SoapAttributeAttribute, namespace: System.Xml.Serialization
  DNSoapElementAttribute = interface; // type: System.Xml.Serialization.SoapElementAttribute, namespace: System.Xml.Serialization
  DNSoapEnumAttribute = interface; // type: System.Xml.Serialization.SoapEnumAttribute, namespace: System.Xml.Serialization
  DNSoapIgnoreAttribute = interface; // type: System.Xml.Serialization.SoapIgnoreAttribute, namespace: System.Xml.Serialization
  DNSoapIncludeAttribute = interface; // type: System.Xml.Serialization.SoapIncludeAttribute, namespace: System.Xml.Serialization
  DNSoapTypeAttribute = interface; // type: System.Xml.Serialization.SoapTypeAttribute, namespace: System.Xml.Serialization
  DNXmlAnyAttributeAttribute = interface; // type: System.Xml.Serialization.XmlAnyAttributeAttribute, namespace: System.Xml.Serialization
  DNXmlAnyElementAttribute = interface; // type: System.Xml.Serialization.XmlAnyElementAttribute, namespace: System.Xml.Serialization
  DNXmlArrayAttribute = interface; // type: System.Xml.Serialization.XmlArrayAttribute, namespace: System.Xml.Serialization
  DNXmlArrayItemAttribute = interface; // type: System.Xml.Serialization.XmlArrayItemAttribute, namespace: System.Xml.Serialization
  DNXmlAttributeAttribute = interface; // type: System.Xml.Serialization.XmlAttributeAttribute, namespace: System.Xml.Serialization
  DNXmlChoiceIdentifierAttribute = interface; // type: System.Xml.Serialization.XmlChoiceIdentifierAttribute, namespace: System.Xml.Serialization
  DNXmlElementAttribute = interface; // type: System.Xml.Serialization.XmlElementAttribute, namespace: System.Xml.Serialization
  DNXmlEnumAttribute = interface; // type: System.Xml.Serialization.XmlEnumAttribute, namespace: System.Xml.Serialization
  DNXmlIgnoreAttribute = interface; // type: System.Xml.Serialization.XmlIgnoreAttribute, namespace: System.Xml.Serialization
  DNXmlIncludeAttribute = interface; // type: System.Xml.Serialization.XmlIncludeAttribute, namespace: System.Xml.Serialization
  DNXmlNamespaceDeclarationsAttribute = interface; // type: System.Xml.Serialization.XmlNamespaceDeclarationsAttribute, namespace: System.Xml.Serialization
  DNXmlRootAttribute = interface; // type: System.Xml.Serialization.XmlRootAttribute, namespace: System.Xml.Serialization
  DNXmlSchemaProviderAttribute = interface; // type: System.Xml.Serialization.XmlSchemaProviderAttribute, namespace: System.Xml.Serialization
  DNXmlSerializerAssemblyAttribute = interface; // type: System.Xml.Serialization.XmlSerializerAssemblyAttribute, namespace: System.Xml.Serialization
  DNXmlSerializerVersionAttribute = interface; // type: System.Xml.Serialization.XmlSerializerVersionAttribute, namespace: System.Xml.Serialization
  DNXmlTextAttribute = interface; // type: System.Xml.Serialization.XmlTextAttribute, namespace: System.Xml.Serialization
  DNXmlTypeAttribute = interface; // type: System.Xml.Serialization.XmlTypeAttribute, namespace: System.Xml.Serialization
  DNXmlSchemaObjectCollection = interface; // type: System.Xml.Schema.XmlSchemaObjectCollection, namespace: System.Xml.Schema
  DNSchemaImporterExtensionCollection = interface; // type: System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection, namespace: System.Xml.Serialization.Advanced
  DNXmlAnyElementAttributes = interface; // type: System.Xml.Serialization.XmlAnyElementAttributes, namespace: System.Xml.Serialization
  DNXmlArrayItemAttributes = interface; // type: System.Xml.Serialization.XmlArrayItemAttributes, namespace: System.Xml.Serialization
  DNXmlElementAttributes = interface; // type: System.Xml.Serialization.XmlElementAttributes, namespace: System.Xml.Serialization
  DNXmlSchemas = interface; // type: System.Xml.Serialization.XmlSchemas, namespace: System.Xml.Serialization
  DNValidationEventArgs = interface; // type: System.Xml.Schema.ValidationEventArgs, namespace: System.Xml.Schema
  DNUnreferencedObjectEventArgs = interface; // type: System.Xml.Serialization.UnreferencedObjectEventArgs, namespace: System.Xml.Serialization
  DNXmlAttributeEventArgs = interface; // type: System.Xml.Serialization.XmlAttributeEventArgs, namespace: System.Xml.Serialization
  DNXmlElementEventArgs = interface; // type: System.Xml.Serialization.XmlElementEventArgs, namespace: System.Xml.Serialization
  DNXmlNodeEventArgs = interface; // type: System.Xml.Serialization.XmlNodeEventArgs, namespace: System.Xml.Serialization
  DNXmlNodeChangedEventArgs = interface; // type: System.Xml.XmlNodeChangedEventArgs, namespace: System.Xml
  DNXsltMessageEncounteredEventArgs = interface; // type: System.Xml.Xsl.XsltMessageEncounteredEventArgs, namespace: System.Xml.Xsl
  DNXmlSchemaException = interface; // type: System.Xml.Schema.XmlSchemaException, namespace: System.Xml.Schema
  DNXmlSchemaInferenceException = interface; // type: System.Xml.Schema.XmlSchemaInferenceException, namespace: System.Xml.Schema
  DNXmlSchemaValidationException = interface; // type: System.Xml.Schema.XmlSchemaValidationException, namespace: System.Xml.Schema
  DNXmlException = interface; // type: System.Xml.XmlException, namespace: System.Xml
  DNXPathException = interface; // type: System.Xml.XPath.XPathException, namespace: System.Xml.XPath
  DNXsltException = interface; // type: System.Xml.Xsl.XsltException, namespace: System.Xml.Xsl
  DNXsltCompileException = interface; // type: System.Xml.Xsl.XsltCompileException, namespace: System.Xml.Xsl
  DNXmlDeserializationEvents = interface; // type: System.Xml.Serialization.XmlDeserializationEvents, namespace: System.Xml.Serialization
  DNXmlSchemaCollection = interface; // type: System.Xml.Schema.XmlSchemaCollection, namespace: System.Xml.Schema
  DNXmlSchemaCollectionEnumerator = interface; // type: System.Xml.Schema.XmlSchemaCollectionEnumerator, namespace: System.Xml.Schema
  DNXmlSchemaCompilationSettings = interface; // type: System.Xml.Schema.XmlSchemaCompilationSettings, namespace: System.Xml.Schema
  DNXmlSchemaDatatype = interface; // type: System.Xml.Schema.XmlSchemaDatatype, namespace: System.Xml.Schema
  DNXmlSchemaInference = interface; // type: System.Xml.Schema.XmlSchemaInference, namespace: System.Xml.Schema
  DNXmlSchemaInfo = interface; // type: System.Xml.Schema.XmlSchemaInfo, namespace: System.Xml.Schema
  DNXmlSchemaObject = interface; // type: System.Xml.Schema.XmlSchemaObject, namespace: System.Xml.Schema
  DNXmlSchema = interface; // type: System.Xml.Schema.XmlSchema, namespace: System.Xml.Schema
  DNXmlSchemaAnnotated = interface; // type: System.Xml.Schema.XmlSchemaAnnotated, namespace: System.Xml.Schema
  DNXmlSchemaAnyAttribute = interface; // type: System.Xml.Schema.XmlSchemaAnyAttribute, namespace: System.Xml.Schema
  DNXmlSchemaAttribute = interface; // type: System.Xml.Schema.XmlSchemaAttribute, namespace: System.Xml.Schema
  DNXmlSchemaAttributeGroup = interface; // type: System.Xml.Schema.XmlSchemaAttributeGroup, namespace: System.Xml.Schema
  DNXmlSchemaAttributeGroupRef = interface; // type: System.Xml.Schema.XmlSchemaAttributeGroupRef, namespace: System.Xml.Schema
  DNXmlSchemaContent = interface; // type: System.Xml.Schema.XmlSchemaContent, namespace: System.Xml.Schema
  DNXmlSchemaComplexContentExtension = interface; // type: System.Xml.Schema.XmlSchemaComplexContentExtension, namespace: System.Xml.Schema
  DNXmlSchemaComplexContentRestriction = interface; // type: System.Xml.Schema.XmlSchemaComplexContentRestriction, namespace: System.Xml.Schema
  DNXmlSchemaSimpleContentExtension = interface; // type: System.Xml.Schema.XmlSchemaSimpleContentExtension, namespace: System.Xml.Schema
  DNXmlSchemaSimpleContentRestriction = interface; // type: System.Xml.Schema.XmlSchemaSimpleContentRestriction, namespace: System.Xml.Schema
  DNXmlSchemaContentModel = interface; // type: System.Xml.Schema.XmlSchemaContentModel, namespace: System.Xml.Schema
  DNXmlSchemaComplexContent = interface; // type: System.Xml.Schema.XmlSchemaComplexContent, namespace: System.Xml.Schema
  DNXmlSchemaSimpleContent = interface; // type: System.Xml.Schema.XmlSchemaSimpleContent, namespace: System.Xml.Schema
  DNXmlSchemaFacet = interface; // type: System.Xml.Schema.XmlSchemaFacet, namespace: System.Xml.Schema
  DNXmlSchemaEnumerationFacet = interface; // type: System.Xml.Schema.XmlSchemaEnumerationFacet, namespace: System.Xml.Schema
  DNXmlSchemaMaxExclusiveFacet = interface; // type: System.Xml.Schema.XmlSchemaMaxExclusiveFacet, namespace: System.Xml.Schema
  DNXmlSchemaMaxInclusiveFacet = interface; // type: System.Xml.Schema.XmlSchemaMaxInclusiveFacet, namespace: System.Xml.Schema
  DNXmlSchemaMinExclusiveFacet = interface; // type: System.Xml.Schema.XmlSchemaMinExclusiveFacet, namespace: System.Xml.Schema
  DNXmlSchemaMinInclusiveFacet = interface; // type: System.Xml.Schema.XmlSchemaMinInclusiveFacet, namespace: System.Xml.Schema
  DNXmlSchemaNumericFacet = interface; // type: System.Xml.Schema.XmlSchemaNumericFacet, namespace: System.Xml.Schema
  DNXmlSchemaFractionDigitsFacet = interface; // type: System.Xml.Schema.XmlSchemaFractionDigitsFacet, namespace: System.Xml.Schema
  DNXmlSchemaLengthFacet = interface; // type: System.Xml.Schema.XmlSchemaLengthFacet, namespace: System.Xml.Schema
  DNXmlSchemaMaxLengthFacet = interface; // type: System.Xml.Schema.XmlSchemaMaxLengthFacet, namespace: System.Xml.Schema
  DNXmlSchemaMinLengthFacet = interface; // type: System.Xml.Schema.XmlSchemaMinLengthFacet, namespace: System.Xml.Schema
  DNXmlSchemaTotalDigitsFacet = interface; // type: System.Xml.Schema.XmlSchemaTotalDigitsFacet, namespace: System.Xml.Schema
  DNXmlSchemaPatternFacet = interface; // type: System.Xml.Schema.XmlSchemaPatternFacet, namespace: System.Xml.Schema
  DNXmlSchemaWhiteSpaceFacet = interface; // type: System.Xml.Schema.XmlSchemaWhiteSpaceFacet, namespace: System.Xml.Schema
  DNXmlSchemaGroup = interface; // type: System.Xml.Schema.XmlSchemaGroup, namespace: System.Xml.Schema
  DNXmlSchemaIdentityConstraint = interface; // type: System.Xml.Schema.XmlSchemaIdentityConstraint, namespace: System.Xml.Schema
  DNXmlSchemaKey = interface; // type: System.Xml.Schema.XmlSchemaKey, namespace: System.Xml.Schema
  DNXmlSchemaKeyref = interface; // type: System.Xml.Schema.XmlSchemaKeyref, namespace: System.Xml.Schema
  DNXmlSchemaUnique = interface; // type: System.Xml.Schema.XmlSchemaUnique, namespace: System.Xml.Schema
  DNXmlSchemaNotation = interface; // type: System.Xml.Schema.XmlSchemaNotation, namespace: System.Xml.Schema
  DNXmlSchemaParticle = interface; // type: System.Xml.Schema.XmlSchemaParticle, namespace: System.Xml.Schema
  DNXmlSchemaAny = interface; // type: System.Xml.Schema.XmlSchemaAny, namespace: System.Xml.Schema
  DNXmlSchemaElement = interface; // type: System.Xml.Schema.XmlSchemaElement, namespace: System.Xml.Schema
  DNXmlSchemaGroupBase = interface; // type: System.Xml.Schema.XmlSchemaGroupBase, namespace: System.Xml.Schema
  DNXmlSchemaAll = interface; // type: System.Xml.Schema.XmlSchemaAll, namespace: System.Xml.Schema
  DNXmlSchemaChoice = interface; // type: System.Xml.Schema.XmlSchemaChoice, namespace: System.Xml.Schema
  DNXmlSchemaSequence = interface; // type: System.Xml.Schema.XmlSchemaSequence, namespace: System.Xml.Schema
  DNXmlSchemaGroupRef = interface; // type: System.Xml.Schema.XmlSchemaGroupRef, namespace: System.Xml.Schema
  DNXmlSchemaSimpleTypeContent = interface; // type: System.Xml.Schema.XmlSchemaSimpleTypeContent, namespace: System.Xml.Schema
  DNXmlSchemaSimpleTypeList = interface; // type: System.Xml.Schema.XmlSchemaSimpleTypeList, namespace: System.Xml.Schema
  DNXmlSchemaSimpleTypeRestriction = interface; // type: System.Xml.Schema.XmlSchemaSimpleTypeRestriction, namespace: System.Xml.Schema
  DNXmlSchemaSimpleTypeUnion = interface; // type: System.Xml.Schema.XmlSchemaSimpleTypeUnion, namespace: System.Xml.Schema
  DNXmlSchemaType = interface; // type: System.Xml.Schema.XmlSchemaType, namespace: System.Xml.Schema
  DNXmlSchemaComplexType = interface; // type: System.Xml.Schema.XmlSchemaComplexType, namespace: System.Xml.Schema
  DNXmlSchemaSimpleType = interface; // type: System.Xml.Schema.XmlSchemaSimpleType, namespace: System.Xml.Schema
  DNXmlSchemaXPath = interface; // type: System.Xml.Schema.XmlSchemaXPath, namespace: System.Xml.Schema
  DNXmlSchemaAnnotation = interface; // type: System.Xml.Schema.XmlSchemaAnnotation, namespace: System.Xml.Schema
  DNXmlSchemaAppInfo = interface; // type: System.Xml.Schema.XmlSchemaAppInfo, namespace: System.Xml.Schema
  DNXmlSchemaDocumentation = interface; // type: System.Xml.Schema.XmlSchemaDocumentation, namespace: System.Xml.Schema
  DNXmlSchemaExternal = interface; // type: System.Xml.Schema.XmlSchemaExternal, namespace: System.Xml.Schema
  DNXmlSchemaImport = interface; // type: System.Xml.Schema.XmlSchemaImport, namespace: System.Xml.Schema
  DNXmlSchemaInclude = interface; // type: System.Xml.Schema.XmlSchemaInclude, namespace: System.Xml.Schema
  DNXmlSchemaRedefine = interface; // type: System.Xml.Schema.XmlSchemaRedefine, namespace: System.Xml.Schema
  DNXmlSchemaObjectEnumerator = interface; // type: System.Xml.Schema.XmlSchemaObjectEnumerator, namespace: System.Xml.Schema
  DNXmlSchemaObjectTable = interface; // type: System.Xml.Schema.XmlSchemaObjectTable, namespace: System.Xml.Schema
  DNXmlSchemaSet = interface; // type: System.Xml.Schema.XmlSchemaSet, namespace: System.Xml.Schema
  DNXmlSchemaValidator = interface; // type: System.Xml.Schema.XmlSchemaValidator, namespace: System.Xml.Schema
  DNSchemaImporterExtension = interface; // type: System.Xml.Serialization.Advanced.SchemaImporterExtension, namespace: System.Xml.Serialization.Advanced
  DNCodeExporter = interface; // type: System.Xml.Serialization.CodeExporter, namespace: System.Xml.Serialization
  DNSoapCodeExporter = interface; // type: System.Xml.Serialization.SoapCodeExporter, namespace: System.Xml.Serialization
  DNXmlCodeExporter = interface; // type: System.Xml.Serialization.XmlCodeExporter, namespace: System.Xml.Serialization
  DNCodeIdentifier = interface; // type: System.Xml.Serialization.CodeIdentifier, namespace: System.Xml.Serialization
  DNCodeIdentifiers = interface; // type: System.Xml.Serialization.CodeIdentifiers, namespace: System.Xml.Serialization
  DNImportContext = interface; // type: System.Xml.Serialization.ImportContext, namespace: System.Xml.Serialization
  DNSchemaImporter = interface; // type: System.Xml.Serialization.SchemaImporter, namespace: System.Xml.Serialization
  DNSoapSchemaImporter = interface; // type: System.Xml.Serialization.SoapSchemaImporter, namespace: System.Xml.Serialization
  DNXmlSchemaImporter = interface; // type: System.Xml.Serialization.XmlSchemaImporter, namespace: System.Xml.Serialization
  DNSoapAttributeOverrides = interface; // type: System.Xml.Serialization.SoapAttributeOverrides, namespace: System.Xml.Serialization
  DNSoapAttributes = interface; // type: System.Xml.Serialization.SoapAttributes, namespace: System.Xml.Serialization
  DNSoapReflectionImporter = interface; // type: System.Xml.Serialization.SoapReflectionImporter, namespace: System.Xml.Serialization
  DNSoapSchemaExporter = interface; // type: System.Xml.Serialization.SoapSchemaExporter, namespace: System.Xml.Serialization
  DNSoapSchemaMember = interface; // type: System.Xml.Serialization.SoapSchemaMember, namespace: System.Xml.Serialization
  DNXmlAttributeOverrides = interface; // type: System.Xml.Serialization.XmlAttributeOverrides, namespace: System.Xml.Serialization
  DNXmlAttributes = interface; // type: System.Xml.Serialization.XmlAttributes, namespace: System.Xml.Serialization
  DNXmlMapping = interface; // type: System.Xml.Serialization.XmlMapping, namespace: System.Xml.Serialization
  DNXmlMembersMapping = interface; // type: System.Xml.Serialization.XmlMembersMapping, namespace: System.Xml.Serialization
  DNXmlTypeMapping = interface; // type: System.Xml.Serialization.XmlTypeMapping, namespace: System.Xml.Serialization
  DNXmlMemberMapping = interface; // type: System.Xml.Serialization.XmlMemberMapping, namespace: System.Xml.Serialization
  DNXmlReflectionImporter = interface; // type: System.Xml.Serialization.XmlReflectionImporter, namespace: System.Xml.Serialization
  DNXmlReflectionMember = interface; // type: System.Xml.Serialization.XmlReflectionMember, namespace: System.Xml.Serialization
  DNXmlSchemaEnumerator = interface; // type: System.Xml.Serialization.XmlSchemaEnumerator, namespace: System.Xml.Serialization
  DNXmlSchemaExporter = interface; // type: System.Xml.Serialization.XmlSchemaExporter, namespace: System.Xml.Serialization
  DNXmlSerializationGeneratedCode = interface; // type: System.Xml.Serialization.XmlSerializationGeneratedCode, namespace: System.Xml.Serialization
  DNXmlSerializationReader = interface; // type: System.Xml.Serialization.XmlSerializationReader, namespace: System.Xml.Serialization
  DNXmlSerializationWriter = interface; // type: System.Xml.Serialization.XmlSerializationWriter, namespace: System.Xml.Serialization
  DNXmlSerializer = interface; // type: System.Xml.Serialization.XmlSerializer, namespace: System.Xml.Serialization
  DNXmlSerializerFactory = interface; // type: System.Xml.Serialization.XmlSerializerFactory, namespace: System.Xml.Serialization
  DNXmlSerializerImplementation = interface; // type: System.Xml.Serialization.XmlSerializerImplementation, namespace: System.Xml.Serialization
  DNXmlSerializerNamespaces = interface; // type: System.Xml.Serialization.XmlSerializerNamespaces, namespace: System.Xml.Serialization
  DNXmlConvert = interface; // type: System.Xml.XmlConvert, namespace: System.Xml
  DNXmlImplementation = interface; // type: System.Xml.XmlImplementation, namespace: System.Xml
  DNXmlNamedNodeMap = interface; // type: System.Xml.XmlNamedNodeMap, namespace: System.Xml
  DNXmlAttributeCollection = interface; // type: System.Xml.XmlAttributeCollection, namespace: System.Xml
  DNXmlNamespaceManager = interface; // type: System.Xml.XmlNamespaceManager, namespace: System.Xml
  DNXsltContext = interface; // type: System.Xml.Xsl.XsltContext, namespace: System.Xml.Xsl
  DNXmlNameTable = interface; // type: System.Xml.XmlNameTable, namespace: System.Xml
  DNNameTable = interface; // type: System.Xml.NameTable, namespace: System.Xml
  DNXmlNode = interface; // type: System.Xml.XmlNode, namespace: System.Xml
  DNXmlAttribute = interface; // type: System.Xml.XmlAttribute, namespace: System.Xml
  DNXmlDocument = interface; // type: System.Xml.XmlDocument, namespace: System.Xml
  DNXmlDocumentFragment = interface; // type: System.Xml.XmlDocumentFragment, namespace: System.Xml
  DNXmlEntity = interface; // type: System.Xml.XmlEntity, namespace: System.Xml
  DNXmlLinkedNode = interface; // type: System.Xml.XmlLinkedNode, namespace: System.Xml
  DNXmlCharacterData = interface; // type: System.Xml.XmlCharacterData, namespace: System.Xml
  DNXmlCDataSection = interface; // type: System.Xml.XmlCDataSection, namespace: System.Xml
  DNXmlComment = interface; // type: System.Xml.XmlComment, namespace: System.Xml
  DNXmlSignificantWhitespace = interface; // type: System.Xml.XmlSignificantWhitespace, namespace: System.Xml
  DNXmlText = interface; // type: System.Xml.XmlText, namespace: System.Xml
  DNXmlWhitespace = interface; // type: System.Xml.XmlWhitespace, namespace: System.Xml
  DNXmlDeclaration = interface; // type: System.Xml.XmlDeclaration, namespace: System.Xml
  DNXmlDocumentType = interface; // type: System.Xml.XmlDocumentType, namespace: System.Xml
  DNXmlElement = interface; // type: System.Xml.XmlElement, namespace: System.Xml
  DNXmlEntityReference = interface; // type: System.Xml.XmlEntityReference, namespace: System.Xml
  DNXmlProcessingInstruction = interface; // type: System.Xml.XmlProcessingInstruction, namespace: System.Xml
  DNXmlNotation = interface; // type: System.Xml.XmlNotation, namespace: System.Xml
  DNXmlNodeList = interface; // type: System.Xml.XmlNodeList, namespace: System.Xml
  DNXmlParserContext = interface; // type: System.Xml.XmlParserContext, namespace: System.Xml
  DNXmlQualifiedName = interface; // type: System.Xml.XmlQualifiedName, namespace: System.Xml
  DNXmlReader = interface; // type: System.Xml.XmlReader, namespace: System.Xml
  DNXmlNodeReader = interface; // type: System.Xml.XmlNodeReader, namespace: System.Xml
  DNXmlTextReader = interface; // type: System.Xml.XmlTextReader, namespace: System.Xml
  DNXmlValidatingReader = interface; // type: System.Xml.XmlValidatingReader, namespace: System.Xml
  DNXmlReaderSettings = interface; // type: System.Xml.XmlReaderSettings, namespace: System.Xml
  DNXmlResolver = interface; // type: System.Xml.XmlResolver, namespace: System.Xml
  DNXmlPreloadedResolver = interface; // type: System.Xml.Resolvers.XmlPreloadedResolver, namespace: System.Xml.Resolvers
  DNXmlSecureResolver = interface; // type: System.Xml.XmlSecureResolver, namespace: System.Xml
  DNXmlUrlResolver = interface; // type: System.Xml.XmlUrlResolver, namespace: System.Xml
  DNXmlXapResolver = interface; // type: System.Xml.XmlXapResolver, namespace: System.Xml
  DNXmlWriter = interface; // type: System.Xml.XmlWriter, namespace: System.Xml
  DNXmlTextWriter = interface; // type: System.Xml.XmlTextWriter, namespace: System.Xml
  DNXmlWriterSettings = interface; // type: System.Xml.XmlWriterSettings, namespace: System.Xml
  DNXPathDocument = interface; // type: System.Xml.XPath.XPathDocument, namespace: System.Xml.XPath
  DNXPathExpression = interface; // type: System.Xml.XPath.XPathExpression, namespace: System.Xml.XPath
  DNXPathItem = interface; // type: System.Xml.XPath.XPathItem, namespace: System.Xml.XPath
  DNXmlAtomicValue = interface; // type: System.Xml.Schema.XmlAtomicValue, namespace: System.Xml.Schema
  DNXPathNavigator = interface; // type: System.Xml.XPath.XPathNavigator, namespace: System.Xml.XPath
  DNXPathNodeIterator = interface; // type: System.Xml.XPath.XPathNodeIterator, namespace: System.Xml.XPath
  DNXslCompiledTransform = interface; // type: System.Xml.Xsl.XslCompiledTransform, namespace: System.Xml.Xsl
  DNXsltArgumentList = interface; // type: System.Xml.Xsl.XsltArgumentList, namespace: System.Xml.Xsl
  DNXslTransform = interface; // type: System.Xml.Xsl.XslTransform, namespace: System.Xml.Xsl
  DNXsltSettings = interface; // type: System.Xml.Xsl.XsltSettings, namespace: System.Xml.Xsl

{ delegates }

  ///<summary>Represents the callback method that will handle XML schema validation events and the <see cref="T:System.Xml.Schema.ValidationEventArgs" />
  ///  .</summary>
  ///  <param name="sender">The source of the event.
  ///  Note    Determine the type of a sender before using it in your code. You cannot assume that the sender is an instance of a particular type. The sender is also not guaranteed to not  be null. Always surround your casts with failure handling logic.</param>
  ///  <param name="e">The event data. </param>
  [DNTypeName('System.Xml.Schema.ValidationEventHandler')]
  DNValidationEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNValidationEventArgs) of object;

  ///<summary>A <see langword="delegate" />
  ///  used by the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
  ///  class to pass attribute, text, and white space values as a Common Language Runtime (CLR) type compatible with the XML Schema Definition Language (XSD) type of the attribute, text, or white space.</summary>
  ///<returns>An object containing the attribute, text, or white space value. The object is a CLR type that that corresponds to the XSD type of the attribute, text, or white space value.</returns>
  [DNTypeName('System.Xml.Schema.XmlValueGetter')]
  DNXmlValueGetter = function: DDN.mscorlib.DNObject of object;

  ///<summary>Represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnreferencedObject" />
  ///  event of an <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">An <see cref="T:System.Xml.Serialization.UnreferencedObjectEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Xml.Serialization.UnreferencedObjectEventHandler')]
  DNUnreferencedObjectEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNUnreferencedObjectEventArgs) of object;

  ///<summary>Represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
  ///</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">An <see cref="T:System.Xml.Serialization.XmlAttributeEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Xml.Serialization.XmlAttributeEventHandler')]
  DNXmlAttributeEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNXmlAttributeEventArgs) of object;

  ///<summary>Represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownElement" />
  ///  event of an <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">A <see cref="T:System.Xml.Serialization.XmlElementEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Xml.Serialization.XmlElementEventHandler')]
  DNXmlElementEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNXmlElementEventArgs) of object;

  ///<summary>Represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
  ///  event of an <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  .</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">An <see cref="T:System.Xml.Serialization.XmlNodeEventArgs" />
  ///  that contains the event data. </param>
  [DNTypeName('System.Xml.Serialization.XmlNodeEventHandler')]
  DNXmlNodeEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNXmlNodeEventArgs) of object;

  ///<summary>Delegate used by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  class for deserialization of SOAP-encoded XML data types that map to collections or enumerations. </summary>
  ///  <param name="collection">The collection into which the collection items array is copied.</param>
  ///  <param name="collectionItems">An array of items to be copied into the <paramref name="object collection" />
  ///  .</param>
  [DNTypeName('System.Xml.Serialization.XmlSerializationCollectionFixupCallback')]
  DNXmlSerializationCollectionFixupCallback = procedure(collection: DDN.mscorlib.DNObject; collectionItems: DDN.mscorlib.DNObject) of object;

  ///<summary>Delegate used by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  class for deserialization of SOAP-encoded XML data. </summary>
  ///  <param name="fixup">An instance of the <see cref="T:System.Xml.Serialization.XmlSerializationReader.Fixup" />
  ///  class that contains the object to be fixed and the array of string identifiers for the items to fill in.</param>
  [DNTypeName('System.Xml.Serialization.XmlSerializationFixupCallback')]
  DNXmlSerializationFixupCallback = procedure(fixup: DDN.mscorlib.DNObject) of object;

  ///<summary>Delegate used by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  class for deserialization of types from SOAP-encoded, non-root XML data. </summary>
  ///<returns>The object returned by the callback.</returns>
  [DNTypeName('System.Xml.Serialization.XmlSerializationReadCallback')]
  DNXmlSerializationReadCallback = function: DDN.mscorlib.DNObject of object;

  ///<summary>Delegate that is used by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  class for serialization of types from SOAP-encoded, non-root XML data. </summary>
  ///  <param name="o">The object being serialized.</param>
  [DNTypeName('System.Xml.Serialization.XmlSerializationWriteCallback')]
  DNXmlSerializationWriteCallback = procedure(o: DDN.mscorlib.DNObject) of object;

  ///<summary>Represents the method that handles <see cref="E:System.Xml.XmlDocument.NodeChanged" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeChanging" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeInserted" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeInserting" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeRemoved" />
  ///  and <see cref="E:System.Xml.XmlDocument.NodeRemoving" />
  ///  events.</summary>
  ///  <param name="sender">The source of the event. </param>
  ///  <param name="e">An <see cref="T:System.Xml.XmlNodeChangedEventArgs" />
  ///  containing the event data. </param>
  [DNTypeName('System.Xml.XmlNodeChangedEventHandler')]
  DNXmlNodeChangedEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNXmlNodeChangedEventArgs) of object;

  ///<summary>Represents the method that will handle the <see cref="E:System.Xml.Xsl.XsltArgumentList.XsltMessageEncountered" />
  ///  event.</summary>
  ///  <param name="sender">The source of the event.</param>
  ///  <param name="e">The <see cref="T:System.Xml.Xsl.XsltMessageEncounteredEventArgs" />
  ///  containing the event data.</param>
  [DNTypeName('System.Xml.Xsl.XsltMessageEncounteredEventHandler')]
  DNXsltMessageEncounteredEventHandler = procedure(sender: DDN.mscorlib.DNObject; e: DNXsltMessageEncounteredEventArgs) of object;




{ objects }

  //-------------namespace: System.Xml----------------
  ///<summary>Represents an application resource stream resolver.</summary>
  [DNTypeName('System.Xml.IApplicationResourceStreamResolver')]
  DNIApplicationResourceStreamResolver = interface(DDN.mscorlib.DNObject)
  ['{3E390847-46B4-3E7B-ABE8-6BABB33B8E1B}']
  { methods } 

    ///<summary>Returns an application resource stream from the specified URI.</summary>
    ///  <param name="relativeUri">The relative URI.</param>
    ///<returns>An application resource stream.</returns>
    function GetApplicationResourceStream(relativeUri: DDN.System.DNUri): DDN.mscorlib.DNStream;

  end;

  //-------------namespace: System.Xml----------------
  ///<summary>Enables a class to return an <see cref="T:System.Xml.XmlNode" />
  ///  from the current context or position.</summary>
  [DNTypeName('System.Xml.IHasXmlNode')]
  DNIHasXmlNode = interface(DDN.mscorlib.DNObject)
  ['{54637763-C9DB-3D10-BEA0-E110003DDE65}']
  { methods } 

    ///<summary>Returns the <see cref="T:System.Xml.XmlNode" />
    ///  for the current position.</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  for the current position.</returns>
    function GetNode: DNXmlNode;

  end;

  //-------------namespace: System.Xml----------------
  ///<summary>Provides an interface to enable a class to return line and position information.</summary>
  [DNTypeName('System.Xml.IXmlLineInfo')]
  DNIXmlLineInfo = interface(DDN.mscorlib.DNObject)
  ['{42FC7998-4F03-37C8-BEAA-3C23528E47CB}']
  { getters & setters } 

    function get_LineNumber: Int32;
    function get_LinePosition: Int32;

  { methods } 

    ///<summary>Gets a value indicating whether the class can return line information.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="P:System.Xml.IXmlLineInfo.LineNumber" />
    ///  and <see cref="P:System.Xml.IXmlLineInfo.LinePosition" />
    ///  can be provided; otherwise, <see langword="false" />
    ///  .</returns>
    function HasLineInfo: Boolean;

  { propertys } 

    ///<summary>Gets the current line number.</summary>
    ///<returns>The current line number or 0 if no line information is available (for example, <see cref="M:System.Xml.IXmlLineInfo.HasLineInfo" />
    ///  returns <see langword="false" />
    ///  ).</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the current line position.</summary>
    ///<returns>The current line position or 0 if no line information is available (for example, <see cref="M:System.Xml.IXmlLineInfo.HasLineInfo" />
    ///  returns <see langword="false" />
    ///  ).</returns>
    property LinePosition: Int32 read get_LinePosition;
  end;

  //-------------namespace: System.Xml----------------
  ///<summary>Provides read-only access to a set of prefix and namespace mappings.</summary>
  [DNTypeName('System.Xml.IXmlNamespaceResolver')]
  DNIXmlNamespaceResolver = interface(DDN.mscorlib.DNObject)
  ['{963A8E22-D935-3065-ACF5-220A8350C64F}']
  { methods } 

    ///<summary>Gets a collection of defined prefix-namespace mappings that are currently in scope.</summary>
    ///  <param name="scope">An <see cref="T:System.Xml.XmlNamespaceScope" />
    ///  value that specifies the type of namespace nodes to return.</param>
    ///<returns>An <see cref="T:System.Collections.IDictionary" />
    ///  that contains the current in-scope namespaces.</returns>
    function GetNamespacesInScope(scope: DNXmlNamespaceScope): DDN.mscorlib.DNIDictionary<string, string>;
    ///<summary>Gets the namespace URI mapped to the specified prefix.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you wish to find.</param>
    ///<returns>The namespace URI that is mapped to the prefix; <see langword="null" />
    ///  if the prefix is not mapped to a namespace URI.</returns>
    function LookupNamespace(prefix: string): string;
    ///<summary>Gets the prefix that is mapped to the specified namespace URI.</summary>
    ///  <param name="namespaceName">The namespace URI whose prefix you wish to find.</param>
    ///<returns>The prefix that is mapped to the namespace URI; <see langword="null" />
    ///  if the namespace URI is not mapped to a prefix.</returns>
    function LookupPrefix(namespaceName: string): string;

  end;

  //-------------namespace: System.Xml.Schema----------------
  ///<summary>Defines the post-schema-validation infoset of a validated XML node.</summary>
  [DNTypeName('System.Xml.Schema.IXmlSchemaInfo')]
  DNIXmlSchemaInfo = interface(DDN.mscorlib.DNObject)
  ['{B877D1C0-5915-310A-8B75-8937F127300C}']
  { getters & setters } 

    function get_Validity: DNXmlSchemaValidity;
    function get_IsDefault: Boolean;
    function get_IsNil: Boolean;
    function get_MemberType: DNXmlSchemaSimpleType;
    function get_SchemaType: DNXmlSchemaType;
    function get_SchemaElement: DNXmlSchemaElement;
    function get_SchemaAttribute: DNXmlSchemaAttribute;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaValidity" />
    ///  value of this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaValidity" />
    ///  value of this validated XML node.</returns>
    property Validity: DNXmlSchemaValidity read get_Validity;
    ///<summary>Gets a value indicating if this validated XML node was set as the result of a default being applied during XML Schema Definition Language (XSD) schema validation.</summary>
    ///<returns><see langword="true" />
    ///  if this validated XML node was set as the result of a default being applied during schema validation; otherwise, <see langword="false" />
    ///  .</returns>
    property IsDefault: Boolean read get_IsDefault;
    ///<summary>Gets a value indicating if the value for this validated XML node is nil.</summary>
    ///<returns><see langword="true" />
    ///  if the value for this validated XML node is nil; otherwise, <see langword="false" />
    ///  .</returns>
    property IsNil: Boolean read get_IsNil;
    ///<summary>Gets the dynamic schema type for this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  object that represents the dynamic schema type for this validated XML node.</returns>
    property MemberType: DNXmlSchemaSimpleType read get_MemberType;
    ///<summary>Gets the static XML Schema Definition Language (XSD) schema type of this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  of this validated XML node.</returns>
    property SchemaType: DNXmlSchemaType read get_SchemaType;
    ///<summary>Gets the compiled <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  that corresponds to this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  that corresponds to this validated XML node.</returns>
    property SchemaElement: DNXmlSchemaElement read get_SchemaElement;
    ///<summary>Gets the compiled <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  that corresponds to this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  that corresponds to this validated XML node.</returns>
    property SchemaAttribute: DNXmlSchemaAttribute read get_SchemaAttribute;
  end;

  //-------------namespace: System.Xml.Serialization----------------
  ///<summary>Provides custom formatting for XML serialization and deserialization.</summary>
  [DNTypeName('System.Xml.Serialization.IXmlSerializable')]
  DNIXmlSerializable = interface(DDN.mscorlib.DNObject)
  ['{45471A9D-DC65-3A9F-8C82-7539D6BE5419}']
  { methods } 

    ///<summary>This method is reserved and should not be used. When implementing the <see langword="IXmlSerializable" />
    ///  interface, you should return <see langword="null" />
    ///  (<see langword="Nothing" />
    ///  in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" />
    ///  to the class.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />
    ///  method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
    ///  method.</returns>
    function GetSchema: DNXmlSchema;
    ///<summary>Generates an object from its XML representation.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  stream from which the object is deserialized. </param>
    procedure ReadXml(reader: DNXmlReader);
    ///<summary>Converts an object into its XML representation.</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  stream to which the object is serialized. </param>
    procedure WriteXml(writer: DNXmlWriter);

  end;

  //-------------namespace: System.Xml.Serialization----------------
  ///<summary>Establishes a <see cref="P:System.Xml.Serialization.IXmlTextParser.Normalized" />
  ///  property for use by the .NET Framework infrastructure.</summary>
  [DNTypeName('System.Xml.Serialization.IXmlTextParser')]
  DNIXmlTextParser = interface(DDN.mscorlib.DNObject)
  ['{769A70FF-3974-369E-A95B-4FA2F28FDE95}']
  { getters & setters } 

    function get_Normalized: Boolean;
    procedure set_Normalized(value: Boolean);
    function get_WhitespaceHandling: DNWhitespaceHandling;
    procedure set_WhitespaceHandling(value: DNWhitespaceHandling);

  { propertys } 

    ///<summary>Gets or sets whether white space and attribute values are normalized.</summary>
    ///<returns><see langword="true" />
    ///  if white space attributes values are normalized; otherwise, <see langword="false" />
    ///  .</returns>
    property Normalized: Boolean read get_Normalized write set_Normalized;
    ///<summary>Gets or sets how white space is handled when parsing XML.</summary>
    ///<returns>A member of the <see cref="T:System.Xml.WhitespaceHandling" />
    ///  enumeration that describes how whites pace is handled when parsing XML.</returns>
    property WhitespaceHandling: DNWhitespaceHandling read get_WhitespaceHandling write set_WhitespaceHandling;
  end;

  //-------------namespace: System.Xml.XPath----------------
  ///<summary>Provides an accessor to the <see cref="T:System.Xml.XPath.XPathNavigator" />
  ///  class.</summary>
  [DNTypeName('System.Xml.XPath.IXPathNavigable')]
  DNIXPathNavigable = interface(DDN.mscorlib.DNObject)
  ['{075B8C9F-B06E-3269-BEB1-8CCBF38D96FA}']
  { methods } 

    ///<summary>Returns a new <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object. </summary>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object.</returns>
    function CreateNavigator: DNXPathNavigator;

  end;

  //-------------namespace: System.Xml.Xsl----------------
  ///<summary>Provides an interface to a given function defined in the Extensible Stylesheet Language for Transformations (XSLT) style sheet during runtime execution.</summary>
  [DNTypeName('System.Xml.Xsl.IXsltContextFunction')]
  DNIXsltContextFunction = interface(DDN.mscorlib.DNObject)
  ['{BC0FA391-C9DD-30BC-83AD-5CADCD9C03D3}']
  { getters & setters } 

    function get_Minargs: Int32;
    function get_Maxargs: Int32;
    function get_ReturnType: DNXPathResultType;
    function get_ArgTypes: TArray<DNXPathResultType>;

  { methods } 

    ///<summary>Provides the method to invoke the function with the given arguments in the given context.</summary>
    ///  <param name="xsltContext">The XSLT context for the function call. </param>
    ///  <param name="args">The arguments of the function call. Each argument is an element in the array. </param>
    ///  <param name="docContext">The context node for the function call. </param>
    ///<returns>An <see cref="T:System.Object" />
    ///  representing the return value of the function.</returns>
    function Invoke(xsltContext: DNXsltContext; args: TArray<DDN.mscorlib.DNObject>; docContext: DNXPathNavigator): DDN.mscorlib.DNObject;

  { propertys } 

    ///<summary>Gets the minimum number of arguments for the function. This enables the user to differentiate between overloaded functions.</summary>
    ///<returns>The minimum number of arguments for the function.</returns>
    property Minargs: Int32 read get_Minargs;
    ///<summary>Gets the maximum number of arguments for the function. This enables the user to differentiate between overloaded functions.</summary>
    ///<returns>The maximum number of arguments for the function.</returns>
    property Maxargs: Int32 read get_Maxargs;
    ///<summary>Gets the <see cref="T:System.Xml.XPath.XPathResultType" />
    ///  representing the XPath type returned by the function.</summary>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathResultType" />
    ///  representing the XPath type returned by the function </returns>
    property ReturnType: DNXPathResultType read get_ReturnType;
    ///<summary>Gets the supplied XML Path Language (XPath) types for the function's argument list. This information can be used to discover the signature of the function which allows you to differentiate between overloaded functions.</summary>
    ///<returns>An array of <see cref="T:System.Xml.XPath.XPathResultType" />
    ///  representing the types for the function's argument list.</returns>
    property ArgTypes: TArray<DNXPathResultType> read get_ArgTypes;
  end;

  //-------------namespace: System.Xml.Xsl----------------
  ///<summary>Provides an interface to a given variable that is defined in the style sheet during runtime execution.</summary>
  [DNTypeName('System.Xml.Xsl.IXsltContextVariable')]
  DNIXsltContextVariable = interface(DDN.mscorlib.DNObject)
  ['{B6D7D55A-2E94-3C3B-911E-6AF424E51A0C}']
  { getters & setters } 

    function get_IsLocal: Boolean;
    function get_IsParam: Boolean;
    function get_VariableType: DNXPathResultType;

  { methods } 

    ///<summary>Evaluates the variable at runtime and returns an object that represents the value of the variable.</summary>
    ///  <param name="xsltContext">An <see cref="T:System.Xml.Xsl.XsltContext" />
    ///  representing the execution context of the variable. </param>
    ///<returns>An <see cref="T:System.Object" />
    ///  representing the value of the variable. Possible return types include number, string, Boolean, document fragment, or node set.</returns>
    function Evaluate(xsltContext: DNXsltContext): DDN.mscorlib.DNObject;

  { propertys } 

    ///<summary>Gets a value indicating whether the variable is local.</summary>
    ///<returns><see langword="true" />
    ///  if the variable is a local variable in the current context; otherwise, <see langword="false" />
    ///  .</returns>
    property IsLocal: Boolean read get_IsLocal;
    ///<summary>Gets a value indicating whether the variable is an Extensible Stylesheet Language Transformations (XSLT) parameter. This can be a parameter to a style sheet or a template.</summary>
    ///<returns><see langword="true" />
    ///  if the variable is an XSLT parameter; otherwise, <see langword="false" />
    ///  .</returns>
    property IsParam: Boolean read get_IsParam;
    ///<summary>Gets the <see cref="T:System.Xml.XPath.XPathResultType" />
    ///  representing the XML Path Language (XPath) type of the variable.</summary>
    ///<returns>The <see cref="T:System.Xml.XPath.XPathResultType" />
    ///  representing the XPath type of the variable.</returns>
    property VariableType: DNXPathResultType read get_VariableType;
  end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapAttributeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{49DAF45A-402E-5EBB-B073-F39AA4C56D7B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapAttributeAttribute" />
    ///  class.</summary>
    {class} function init: DNSoapAttributeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapAttributeAttribute" />
    ///  class using the specified value as the name of the XML attribute.</summary>
    ///  <param name="attributeName">The name of the XML attribute. </param>
    {class} function init(attributeName: string): DNSoapAttributeAttribute; overload;

  end;

  ///<summary>Specifies that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  must serialize the class member as an encoded SOAP attribute.</summary>
  [DNTypeName('System.Xml.Serialization.SoapAttributeAttribute')]
  DNSoapAttributeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{4504B32E-EB22-3F27-BCA7-DB3B07F37237}']
  { getters & setters } 

    function get_AttributeName: string;
    procedure set_AttributeName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the XML attribute generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</summary>
    ///<returns>The name of the XML attribute. The default is the member identifier.</returns>
    property AttributeName: string read get_AttributeName write set_AttributeName;
    ///<summary>Gets or sets the XML namespace of the XML attribute.</summary>
    ///<returns>The XML namespace of the XML attribute.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the XML Schema definition language (XSD) data type of the SOAP attribute generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</summary>
    ///<returns>An XML Schema data type, as defined by the World Wide Web Consortium (www.w3.org) document named "XML Schema Part 2: Datatypes".</returns>
    ///<exception cref="T:System.Exception">The XML Schema data type you have specified cannot be mapped to the .NET data type. </exception>
    property DataType: string read get_DataType write set_DataType;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSoapAttributeAttribute = class(TDNGenericImport<DNSoapAttributeAttributeClass, DNSoapAttributeAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapElementAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{38E0F882-BE78-5D68-8BA7-550B81B6F109}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapElementAttribute" />
    ///  class.</summary>
    {class} function init: DNSoapElementAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapElementAttribute" />
    ///  class and specifies the name of the XML element.</summary>
    ///  <param name="elementName">The XML element name of the serialized member. </param>
    {class} function init(elementName: string): DNSoapElementAttribute; overload;

  end;

  ///<summary>Specifies that the public member value be serialized by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  as an encoded SOAP XML element.</summary>
  [DNTypeName('System.Xml.Serialization.SoapElementAttribute')]
  DNSoapElementAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{E57CD296-C34A-30C1-8317-75493E4CDF1D}']
  { getters & setters } 

    function get_ElementName: string;
    procedure set_ElementName(value: string);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the generated XML element.</summary>
    ///<returns>The name of the generated XML element. The default is the member identifier.</returns>
    property ElementName: string read get_ElementName write set_ElementName;
    ///<summary>Gets or sets the XML Schema definition language (XSD) data type of the generated XML element.</summary>
    ///<returns>One of the XML Schema data types.</returns>
    property DataType: string read get_DataType write set_DataType;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must serialize a member that has the <see langword="xsi:null" />
    ///  attribute set to "1".</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates the <see langword="xsi:null" />
    ///  attribute; otherwise, <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSoapElementAttribute = class(TDNGenericImport<DNSoapElementAttributeClass, DNSoapElementAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapEnumAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{253B998A-D5F1-5173-A4D2-58E4CB6511DF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapEnumAttribute" />
    ///  class.</summary>
    {class} function init: DNSoapEnumAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapEnumAttribute" />
    ///  class using the specified element name.</summary>
    ///  <param name="name">The XML element name generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  . </param>
    {class} function init(name: string): DNSoapEnumAttribute; overload;

  end;

  ///<summary>Controls how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  serializes an enumeration member.</summary>
  [DNTypeName('System.Xml.Serialization.SoapEnumAttribute')]
  DNSoapEnumAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{2B8628BC-D759-3440-A773-B56DAA1A5344}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the value generated in an XML document when the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes an enumeration, or the value recognized when it deserializes the enumeration member.</summary>
    ///<returns>The value generated in an XML document when the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes the enumeration, or the value recognized when it deserializes the enumeration member.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSoapEnumAttribute = class(TDNGenericImport<DNSoapEnumAttributeClass, DNSoapEnumAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapIgnoreAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{73F35492-D08D-5416-8F3C-D7F03ECFCD27}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapIgnoreAttribute" />
    ///  class.</summary>
    {class} function init: DNSoapIgnoreAttribute;

  end;

  ///<summary>Instructs the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  not to serialize the public field or public read/write property value.</summary>
  [DNTypeName('System.Xml.Serialization.SoapIgnoreAttribute')]
  DNSoapIgnoreAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{6EBBAEDA-51B8-3E37-8F26-671A153211F3}']
  { getters & setters } 

    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSoapIgnoreAttribute = class(TDNGenericImport<DNSoapIgnoreAttributeClass, DNSoapIgnoreAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapIncludeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{8D640C9D-2585-5990-BE8D-2630815B4451}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapIncludeAttribute" />
    ///  class using the specified type.</summary>
    ///  <param name="type">The type of the object to include. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNSoapIncludeAttribute;

  end;

  ///<summary>Allows the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  to recognize a type when it serializes or deserializes an object as encoded SOAP XML.</summary>
  [DNTypeName('System.Xml.Serialization.SoapIncludeAttribute')]
  DNSoapIncludeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{27FF1ADB-F484-3584-AD4D-CD449974379C}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the type of the object to use when serializing or deserializing an object.</summary>
    ///<returns>The type of the object to include.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSoapIncludeAttribute = class(TDNGenericImport<DNSoapIncludeAttributeClass, DNSoapIncludeAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapTypeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{9A73D6E1-E3D1-5B0E-BE49-C6A577656D8D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapTypeAttribute" />
    ///  class.</summary>
    {class} function init: DNSoapTypeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapTypeAttribute" />
    ///  class and specifies the name of the XML type.</summary>
    ///  <param name="typeName">The name of the XML type that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates when it serializes the class instance (and recognizes when it deserializes the class instance). </param>
    {class} function init(typeName: string): DNSoapTypeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapTypeAttribute" />
    ///  class and specifies the name and XML namespace of the type.</summary>
    ///  <param name="typeName">The name of the XML type that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates when it serializes the class instance (and recognizes when it deserializes the class instance). </param>
    ///  <param name="ns">The XML namespace of the type. </param>
    {class} function init(typeName: string; ns: string): DNSoapTypeAttribute; overload;

  end;

  ///<summary>Controls the schema generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  when a class instance is serialized as SOAP encoded XML.</summary>
  [DNTypeName('System.Xml.Serialization.SoapTypeAttribute')]
  DNSoapTypeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{9DC8944D-EDC6-34C8-8C55-C0970B79BAC2}']
  { getters & setters } 

    function get_IncludeInSchema: Boolean;
    procedure set_IncludeInSchema(value: Boolean);
    function get_TypeName: string;
    procedure set_TypeName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that indicates whether to include the type in SOAP-encoded XML Schema documents.</summary>
    ///<returns><see langword="true" />
    ///  to include the type in SOAP-encoded XML Schema documents; otherwise, <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property IncludeInSchema: Boolean read get_IncludeInSchema write set_IncludeInSchema;
    ///<summary>Gets or sets the name of the XML type.</summary>
    ///<returns>The name of the XML type. The default is the class name.</returns>
    property TypeName: string read get_TypeName write set_TypeName;
    ///<summary>Gets or sets the namespace of the XML type.</summary>
    ///<returns>The namespace of the XML type. The default is an empty string ("").</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNSoapTypeAttribute = class(TDNGenericImport<DNSoapTypeAttributeClass, DNSoapTypeAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAnyAttributeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{206F38EB-5C44-5294-A560-97878A664B28}']
  { constructors } 

    ///<summary>Constructs a new instance of the <see cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlAnyAttributeAttribute;

  end;

  ///<summary>Specifies that the member (a field that returns an array of <see cref="T:System.Xml.XmlAttribute" />
  ///  objects) can contain any XML attributes.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAnyAttributeAttribute')]
  DNXmlAnyAttributeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{1E962A37-A8A9-3189-9889-71B66F4DD5DA}']
  { getters & setters } 

    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlAnyAttributeAttribute = class(TDNGenericImport<DNXmlAnyAttributeAttributeClass, DNXmlAnyAttributeAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAnyElementAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{44BC4220-12AA-5AF7-A933-22EB33B52BDF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlAnyElementAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  class and specifies the XML element name generated in the XML document.</summary>
    ///  <param name="name">The name of the XML element that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates. </param>
    {class} function init(name: string): DNXmlAnyElementAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  class and specifies the XML element name generated in the XML document and its XML namespace.</summary>
    ///  <param name="name">The name of the XML element that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates. </param>
    ///  <param name="ns">The XML namespace of the XML element. </param>
    {class} function init(name: string; ns: string): DNXmlAnyElementAttribute; overload;

  end;

  ///<summary>Specifies that the member (a field that returns an array of <see cref="T:System.Xml.XmlElement" />
  ///  or <see cref="T:System.Xml.XmlNode" />
  ///  objects) contains objects that represent any XML element that has no corresponding member in the object being serialized or deserialized.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAnyElementAttribute')]
  DNXmlAnyElementAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{2C60A4E7-A0D0-3833-99EA-9A3E974A9A8E}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_Order: Int32;
    procedure set_Order(value: Int32);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the XML element name.</summary>
    ///<returns>The name of the XML element.</returns>
    ///<exception cref="T:System.InvalidOperationException">The element name of an array member does not match the element name specified by the <see cref="P:System.Xml.Serialization.XmlAnyElementAttribute.Name" />
    ///  property. </exception>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the XML namespace generated in the XML document.</summary>
    ///<returns>An XML namespace.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the explicit order in which the elements are serialized or deserialized.</summary>
    ///<returns>The order of the code generation.</returns>
    property Order: Int32 read get_Order write set_Order;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlAnyElementAttribute = class(TDNGenericImport<DNXmlAnyElementAttributeClass, DNXmlAnyElementAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlArrayAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{BECF040A-64C7-52F8-9BC3-03FA292F92CB}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlArrayAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayAttribute" />
    ///  class and specifies the XML element name generated in the XML document instance.</summary>
    ///  <param name="elementName">The name of the XML element that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates. </param>
    {class} function init(elementName: string): DNXmlArrayAttribute; overload;

  end;

  ///<summary>Specifies that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  must serialize a particular class member as an array of XML elements.</summary>
  [DNTypeName('System.Xml.Serialization.XmlArrayAttribute')]
  DNXmlArrayAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{DA6F4C82-1E35-3CEA-9E37-25239ACB4C00}']
  { getters & setters } 

    function get_ElementName: string;
    procedure set_ElementName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_Form: DNXmlSchemaForm;
    procedure set_Form(value: DNXmlSchemaForm);
    function get_Order: Int32;
    procedure set_Order(value: Int32);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the XML element name given to the serialized array.</summary>
    ///<returns>The XML element name of the serialized array. The default is the name of the member to which the <see cref="T:System.Xml.Serialization.XmlArrayAttribute" />
    ///  is assigned.</returns>
    property ElementName: string read get_ElementName write set_ElementName;
    ///<summary>Gets or sets the namespace of the XML element.</summary>
    ///<returns>The namespace of the XML element.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must serialize a member as an empty XML tag with the <see langword="xsi:nil" />
    ///  attribute set to <see langword="true" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates the <see langword="xsi:nil" />
    ///  attribute; otherwise, <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets a value that indicates whether the XML element name generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  is qualified or unqualified.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  values. The default is <see langword="XmlSchemaForm.None" />
    ///  .</returns>
    property Form: DNXmlSchemaForm read get_Form write set_Form;
    ///<summary>Gets or sets the explicit order in which the elements are serialized or deserialized.</summary>
    ///<returns>The order of the code generation.</returns>
    property Order: Int32 read get_Order write set_Order;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlArrayAttribute = class(TDNGenericImport<DNXmlArrayAttributeClass, DNXmlArrayAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlArrayItemAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{8D6F874C-B256-5E7B-A6B5-86933C305ADD}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlArrayItemAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  class and specifies the name of the XML element generated in the XML document.</summary>
    ///  <param name="elementName">The name of the XML element. </param>
    {class} function init(elementName: string): DNXmlArrayItemAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  class and specifies the <see cref="T:System.Type" />
    ///  that can be inserted into the serialized array.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object to serialize. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlArrayItemAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  class and specifies the name of the XML element generated in the XML document and the <see cref="T:System.Type" />
    ///  that can be inserted into the generated XML document.</summary>
    ///  <param name="elementName">The name of the XML element. </param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object to serialize. </param>
    {class} function init(elementName: string; &type: DDN.mscorlib.DNType): DNXmlArrayItemAttribute; overload;

  end;

  ///<summary>Represents an attribute that specifies the derived types that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  can place in a serialized array.</summary>
  [DNTypeName('System.Xml.Serialization.XmlArrayItemAttribute')]
  DNXmlArrayItemAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{51B3D87B-3CDC-3B38-A4A4-EE8A8417BC10}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_ElementName: string;
    procedure set_ElementName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_NestingLevel: Int32;
    procedure set_NestingLevel(value: Int32);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_Form: DNXmlSchemaForm;
    procedure set_Form(value: DNXmlSchemaForm);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the type allowed in an array.</summary>
    ///<returns>A <see cref="T:System.Type" />
    ///  that is allowed in the array.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    ///<summary>Gets or sets the name of the generated XML element.</summary>
    ///<returns>The name of the generated XML element. The default is the member identifier.</returns>
    property ElementName: string read get_ElementName write set_ElementName;
    ///<summary>Gets or sets the namespace of the generated XML element.</summary>
    ///<returns>The namespace of the generated XML element.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the level in a hierarchy of XML elements that the <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  affects.</summary>
    ///<returns>The zero-based index of a set of indexes in an array of arrays.</returns>
    property NestingLevel: Int32 read get_NestingLevel write set_NestingLevel;
    ///<summary>Gets or sets the XML data type of the generated XML element.</summary>
    ///<returns>An XML schema definition (XSD) data type, as defined by the World Wide Web Consortium (www.w3.org) document "XML Schema Part 2: DataTypes".</returns>
    property DataType: string read get_DataType write set_DataType;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must serialize a member as an empty XML tag with the <see langword="xsi:nil" />
    ///  attribute set to <see langword="true" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates the <see langword="xsi:nil" />
    ///  attribute; otherwise, <see langword="false" />
    ///  , and no instance is generated. The default is <see langword="true" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets a value that indicates whether the name of the generated XML element is qualified.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  values. The default is <see langword="XmlSchemaForm.None" />
    ///  .</returns>
    ///<exception cref="T:System.Exception">The <see cref="P:System.Xml.Serialization.XmlArrayItemAttribute.Form" />
    ///  property is set to <see langword="XmlSchemaForm.Unqualified" />
    ///  and a <see cref="P:System.Xml.Serialization.XmlArrayItemAttribute.Namespace" />
    ///  value is specified. </exception>
    property Form: DNXmlSchemaForm read get_Form write set_Form;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlArrayItemAttribute = class(TDNGenericImport<DNXmlArrayItemAttributeClass, DNXmlArrayItemAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAttributeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{6E618193-817A-5AC8-9D7E-D24A29109089}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributeAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlAttributeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributeAttribute" />
    ///  class and specifies the name of the generated XML attribute.</summary>
    ///  <param name="attributeName">The name of the XML attribute that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates. </param>
    {class} function init(attributeName: string): DNXmlAttributeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributeAttribute" />
    ///  class.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  used to store the attribute. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlAttributeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributeAttribute" />
    ///  class.</summary>
    ///  <param name="attributeName">The name of the XML attribute that is generated. </param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  used to store the attribute. </param>
    {class} function init(attributeName: string; &type: DDN.mscorlib.DNType): DNXmlAttributeAttribute; overload;

  end;

  ///<summary>Specifies that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  must serialize the class member as an XML attribute.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAttributeAttribute')]
  DNXmlAttributeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{88BCD0FE-C31B-3F59-ABF7-15216A462445}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_AttributeName: string;
    procedure set_AttributeName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_Form: DNXmlSchemaForm;
    procedure set_Form(value: DNXmlSchemaForm);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the complex type of the XML attribute.</summary>
    ///<returns>The type of the XML attribute.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    ///<summary>Gets or sets the name of the XML attribute.</summary>
    ///<returns>The name of the XML attribute. The default is the member name.</returns>
    property AttributeName: string read get_AttributeName write set_AttributeName;
    ///<summary>Gets or sets the XML namespace of the XML attribute.</summary>
    ///<returns>The XML namespace of the XML attribute.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the XSD data type of the XML attribute generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</summary>
    ///<returns>An XSD (XML Schema Document) data type, as defined by the World Wide Web Consortium (www.w3.org) document named "XML Schema: DataTypes".</returns>
    property DataType: string read get_DataType write set_DataType;
    ///<summary>Gets or sets a value that indicates whether the XML attribute name generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  is qualified.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  values. The default is <see langword="XmlForm.None" />
    ///  .</returns>
    property Form: DNXmlSchemaForm read get_Form write set_Form;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlAttributeAttribute = class(TDNGenericImport<DNXmlAttributeAttributeClass, DNXmlAttributeAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlChoiceIdentifierAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{9773F923-FD71-5DCD-BB10-91B0A399E9D9}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlChoiceIdentifierAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlChoiceIdentifierAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlChoiceIdentifierAttribute" />
    ///  class.</summary>
    ///  <param name="name">The member name that returns the enumeration used to detect a choice. </param>
    {class} function init(name: string): DNXmlChoiceIdentifierAttribute; overload;

  end;

  ///<summary>Specifies that the member can be further detected by using an enumeration.</summary>
  [DNTypeName('System.Xml.Serialization.XmlChoiceIdentifierAttribute')]
  DNXmlChoiceIdentifierAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{CAA8D190-572C-3A95-8180-1CC75EDC0BFD}']
  { getters & setters } 

    function get_MemberName: string;
    procedure set_MemberName(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the field that returns the enumeration to use when detecting types.</summary>
    ///<returns>The name of a field that returns an enumeration.</returns>
    property MemberName: string read get_MemberName write set_MemberName;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlChoiceIdentifierAttribute = class(TDNGenericImport<DNXmlChoiceIdentifierAttributeClass, DNXmlChoiceIdentifierAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlElementAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{C557DA8B-3C09-57EF-9A22-5E2E243D3CD0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlElementAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  class and specifies the name of the XML element.</summary>
    ///  <param name="elementName">The XML element name of the serialized member. </param>
    {class} function init(elementName: string): DNXmlElementAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  class and specifies a type for the member to which the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  is applied. This type is used by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  when serializing or deserializing object that contains it.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of an object derived from the member's type. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlElementAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  and specifies the name of the XML element and a derived type for the member to which the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  is applied. This member type is used when the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes the object that contains it.</summary>
    ///  <param name="elementName">The XML element name of the serialized member. </param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of an object derived from the member's type. </param>
    {class} function init(elementName: string; &type: DDN.mscorlib.DNType): DNXmlElementAttribute; overload;

  end;

  ///<summary>Indicates that a public field or property represents an XML element when the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  serializes or deserializes the object that contains it.</summary>
  [DNTypeName('System.Xml.Serialization.XmlElementAttribute')]
  DNXmlElementAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{5366E73D-B2AB-37EC-B1C4-8DA06442BF63}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_ElementName: string;
    procedure set_ElementName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_Form: DNXmlSchemaForm;
    procedure set_Form(value: DNXmlSchemaForm);
    function get_Order: Int32;
    procedure set_Order(value: Int32);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the object type used to represent the XML element.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  of the member.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    ///<summary>Gets or sets the name of the generated XML element.</summary>
    ///<returns>The name of the generated XML element. The default is the member identifier.</returns>
    property ElementName: string read get_ElementName write set_ElementName;
    ///<summary>Gets or sets the namespace assigned to the XML element that results when the class is serialized.</summary>
    ///<returns>The namespace of the XML element.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the XML Schema definition (XSD) data type of the XML element generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</summary>
    ///<returns>An XML Schema data type, as defined by the World Wide Web Consortium (www.w3.org) document named "XML Schema Part 2: Datatypes".</returns>
    ///<exception cref="T:System.Exception">The XML Schema data type you have specified cannot be mapped to the.NET data type. </exception>
    property DataType: string read get_DataType write set_DataType;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must serialize a member that is set to <see langword="null" />
    ///  as an empty tag with the <see langword="xsi:nil" />
    ///  attribute set to <see langword="true" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates the <see langword="xsi:nil" />
    ///  attribute; otherwise, <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    ///<summary>Gets or sets a value that indicates whether the element is qualified.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  values. The default is <see cref="F:System.Xml.Schema.XmlSchemaForm.None" />
    ///  .</returns>
    property Form: DNXmlSchemaForm read get_Form write set_Form;
    ///<summary>Gets or sets the explicit order in which the elements are serialized or deserialized.</summary>
    ///<returns>The order of the code generation.</returns>
    property Order: Int32 read get_Order write set_Order;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlElementAttribute = class(TDNGenericImport<DNXmlElementAttributeClass, DNXmlElementAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlEnumAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{1DD057D0-F133-5177-833E-F283C33629F1}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlEnumAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlEnumAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlEnumAttribute" />
    ///  class, and specifies the XML value that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates or recognizes (when it serializes or deserializes the enumeration, respectively).</summary>
    ///  <param name="name">The overriding name of the enumeration member. </param>
    {class} function init(name: string): DNXmlEnumAttribute; overload;

  end;

  ///<summary>Controls how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  serializes an enumeration member.</summary>
  [DNTypeName('System.Xml.Serialization.XmlEnumAttribute')]
  DNXmlEnumAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{90499D2E-9FB9-3642-8C14-49FD94B021EF}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the value generated in an XML-document instance when the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes an enumeration, or the value recognized when it deserializes the enumeration member.</summary>
    ///<returns>The value generated in an XML-document instance when the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes the enumeration, or the value recognized when it is deserializes the enumeration member.</returns>
    property Name: string read get_Name write set_Name;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlEnumAttribute = class(TDNGenericImport<DNXmlEnumAttributeClass, DNXmlEnumAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlIgnoreAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{4DEA8B18-9646-5BC2-AEA0-19AF6ED2DD01}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlIgnoreAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlIgnoreAttribute;

  end;

  ///<summary>Instructs the <see cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
  ///  method of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  not to serialize the public field or public read/write property value.</summary>
  [DNTypeName('System.Xml.Serialization.XmlIgnoreAttribute')]
  DNXmlIgnoreAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{54F4CE31-7920-32B4-8238-B75CA0A27504}']
  { getters & setters } 

    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlIgnoreAttribute = class(TDNGenericImport<DNXmlIgnoreAttributeClass, DNXmlIgnoreAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlIncludeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{C0846CA8-CD27-537F-ADCC-BF658F6FC6D8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlIncludeAttribute" />
    ///  class.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object to include. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlIncludeAttribute;

  end;

  ///<summary>Allows the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  to recognize a type when it serializes or deserializes an object.</summary>
  [DNTypeName('System.Xml.Serialization.XmlIncludeAttribute')]
  DNXmlIncludeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{AC1C99CC-6252-3C09-9A52-A7A38D118C20}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the type of the object to include.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  of the object to include.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlIncludeAttribute = class(TDNGenericImport<DNXmlIncludeAttributeClass, DNXmlIncludeAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlNamespaceDeclarationsAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{67B91508-5788-547F-920B-541A9D68AA41}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlNamespaceDeclarationsAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlNamespaceDeclarationsAttribute;

  end;

  ///<summary>Specifies that the target property, parameter, return value, or class member contains prefixes associated with namespaces that are used within an XML document.</summary>
  [DNTypeName('System.Xml.Serialization.XmlNamespaceDeclarationsAttribute')]
  DNXmlNamespaceDeclarationsAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{6CDE0118-0B6E-3BE8-AD16-CDC5E9B3A5E6}']
  { getters & setters } 

    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlNamespaceDeclarationsAttribute = class(TDNGenericImport<DNXmlNamespaceDeclarationsAttributeClass, DNXmlNamespaceDeclarationsAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlRootAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{FE12BAB6-1A85-587C-9D37-6804D0A96DAF}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlRootAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  class and specifies the name of the XML root element.</summary>
    ///  <param name="elementName">The name of the XML root element. </param>
    {class} function init(elementName: string): DNXmlRootAttribute; overload;

  end;

  ///<summary>Controls XML serialization of the attribute target as an XML root element.</summary>
  [DNTypeName('System.Xml.Serialization.XmlRootAttribute')]
  DNXmlRootAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{33F71924-FE4F-3AD0-A002-8B5573576CC4}']
  { getters & setters } 

    function get_ElementName: string;
    procedure set_ElementName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_IsNullable: Boolean;
    procedure set_IsNullable(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the XML element that is generated and recognized by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class's <see cref="M:System.Xml.Serialization.XmlSerializer.Serialize(System.IO.TextWriter,System.Object)" />
    ///  and <see cref="M:System.Xml.Serialization.XmlSerializer.Deserialize(System.IO.Stream)" />
    ///  methods, respectively.</summary>
    ///<returns>The name of the XML root element that is generated and recognized in an XML-document instance. The default is the name of the serialized class.</returns>
    property ElementName: string read get_ElementName write set_ElementName;
    ///<summary>Gets or sets the namespace for the XML root element.</summary>
    ///<returns>The namespace for the XML element.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the XSD data type of the XML root element.</summary>
    ///<returns>An XSD (XML Schema Document) data type, as defined by the World Wide Web Consortium (www.w3.org) document named "XML Schema: DataTypes".</returns>
    property DataType: string read get_DataType write set_DataType;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must serialize a member that is set to <see langword="null" />
    ///  into the <see langword="xsi:nil" />
    ///  attribute set to <see langword="true" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates the <see langword="xsi:nil" />
    ///  attribute; otherwise, <see langword="false" />
    ///  .</returns>
    property IsNullable: Boolean read get_IsNullable write set_IsNullable;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlRootAttribute = class(TDNGenericImport<DNXmlRootAttributeClass, DNXmlRootAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSchemaProviderAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{717D97CA-7345-52C6-A396-B6B44D2F8036}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" />
    ///  class, taking the name of the static method that supplies the type's XML schema.</summary>
    ///  <param name="methodName">The name of the static method that must be implemented.</param>
    {class} function init(methodName: string): DNXmlSchemaProviderAttribute;

  end;

  ///<summary>When applied to a type, stores the name of a static method of the type that returns an XML schema and a <see cref="T:System.Xml.XmlQualifiedName" />
  ///  (or <see cref="T:System.Xml.Schema.XmlSchemaType" />
  ///  for anonymous types) that controls the serialization of the type.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSchemaProviderAttribute')]
  DNXmlSchemaProviderAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{204D72A2-7500-31FC-A821-4468DF082FD0}']
  { getters & setters } 

    function get_MethodName: string;
    function get_IsAny: Boolean;
    procedure set_IsAny(value: Boolean);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the static method that supplies the type's XML schema and the name of its XML Schema data type.</summary>
    ///<returns>The name of the method that is invoked by the XML infrastructure to return an XML schema.</returns>
    property MethodName: string read get_MethodName;
    ///<summary>Gets or sets a value that determines whether the target class is a wildcard, or that the schema for the class has contains only an <see langword="xs:any" />
    ///  element.</summary>
    ///<returns><see langword="true" />
    ///  , if the class is a wildcard, or if the schema contains only the <see langword="xs:any" />
    ///  element; otherwise, <see langword="false" />
    ///  .</returns>
    property IsAny: Boolean read get_IsAny write set_IsAny;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlSchemaProviderAttribute = class(TDNGenericImport<DNXmlSchemaProviderAttributeClass, DNXmlSchemaProviderAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializerAssemblyAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{88CB88A1-0530-5FCA-8EEE-E69EE246679B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerAssemblyAttribute" />
    ///  class. </summary>
    {class} function init: DNXmlSerializerAssemblyAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerAssemblyAttribute" />
    ///  class with the specified assembly name.</summary>
    ///  <param name="assemblyName">The simple, unencrypted name of the assembly. </param>
    {class} function init(assemblyName: string): DNXmlSerializerAssemblyAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerAssemblyAttribute" />
    ///  class with the specified assembly name and location of the assembly.</summary>
    ///  <param name="assemblyName">The simple, unencrypted name of the assembly. </param>
    ///  <param name="codeBase">A string that is the URL location of the assembly.</param>
    {class} function init(assemblyName: string; codeBase: string): DNXmlSerializerAssemblyAttribute; overload;

  end;

  ///<summary>Applied to a Web service client proxy, enables you to specify an assembly that contains custom-made serializers. </summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializerAssemblyAttribute')]
  DNXmlSerializerAssemblyAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{B00E3011-10AE-3FEB-A5D9-244D5A098F97}']
  { getters & setters } 

    function get_CodeBase: string;
    procedure set_CodeBase(value: string);
    function get_AssemblyName: string;
    procedure set_AssemblyName(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the location of the assembly that contains the serializers.</summary>
    ///<returns>A location, such as a path or URI, that points to the assembly.</returns>
    property CodeBase: string read get_CodeBase write set_CodeBase;
    ///<summary>Gets or sets the name of the assembly that contains serializers for a specific set of types.</summary>
    ///<returns>The simple, unencrypted name of the assembly. </returns>
    property AssemblyName: string read get_AssemblyName write set_AssemblyName;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlSerializerAssemblyAttribute = class(TDNGenericImport<DNXmlSerializerAssemblyAttributeClass, DNXmlSerializerAssemblyAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializerVersionAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{3402FBB1-BFBD-59C6-8F91-2816F1EACEF9}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerVersionAttribute" />
    ///  class. </summary>
    {class} function init: DNXmlSerializerVersionAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerVersionAttribute" />
    ///  class for the specified type.</summary>
    ///  <param name="type">The type that is being serialized.</param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlSerializerVersionAttribute; overload;

  end;

  ///<summary>Signifies that the code was generated by the serialization infrastructure and can be reused for increased performance, when this attribute is applied to an assembly.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializerVersionAttribute')]
  DNXmlSerializerVersionAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{C6CC4642-93E7-384A-BF52-BB899D0EA879}']
  { getters & setters } 

    function get_ParentAssemblyId: string;
    procedure set_ParentAssemblyId(value: string);
    function get_Version: string;
    procedure set_Version(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the identity of the parent assembly.</summary>
    ///<returns>The version of the parent assembly.</returns>
    property ParentAssemblyId: string read get_ParentAssemblyId write set_ParentAssemblyId;
    ///<summary>Gets or sets the assembly's version number.</summary>
    ///<returns>The version of the assembly.</returns>
    property Version: string read get_Version write set_Version;
    ///<summary>Gets or sets the common language runtime (CLR) namespace of the assembly.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  containing the common language runtime (CLR) namespace of the assembly.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the type that the serializer operates on.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  to be serialized.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlSerializerVersionAttribute = class(TDNGenericImport<DNXmlSerializerVersionAttributeClass, DNXmlSerializerVersionAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlTextAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{80F995E0-F5A9-55A8-B4EE-C352D10CAD6F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlTextAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlTextAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlTextAttribute" />
    ///  class.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the member to be serialized. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlTextAttribute; overload;

  end;

  ///<summary>Indicates to the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  that the member must be treated as XML text when the class that contains it is serialized or deserialized.</summary>
  [DNTypeName('System.Xml.Serialization.XmlTextAttribute')]
  DNXmlTextAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{27A1026B-067E-387B-8334-BDA5FD2753C8}']
  { getters & setters } 

    function get_Type: DDN.mscorlib.DNType;
    procedure set_Type(value: DDN.mscorlib.DNType);
    function get_DataType: string;
    procedure set_DataType(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the type of the member.</summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  of the member.</returns>
    property &Type: DDN.mscorlib.DNType read get_Type write set_Type;
    ///<summary>Gets or sets the XML Schema definition language (XSD) data type of the text generated by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</summary>
    ///<returns>An XML Schema (XSD) data type, as defined by the World Wide Web Consortium (www.w3.org) document "XML Schema Part 2: Datatypes".</returns>
    ///<exception cref="T:System.Exception">The XML Schema data type you have specified cannot be mapped to the .NET data type. </exception><exception cref="T:System.InvalidOperationException">The XML Schema data type you have specified is invalid for the property and cannot be converted to the member type. </exception>
    property DataType: string read get_DataType write set_DataType;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlTextAttribute = class(TDNGenericImport<DNXmlTextAttributeClass, DNXmlTextAttribute>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlTypeAttributeClass = interface(DDN.mscorlib.DNAttributeClass)
  ['{63CD88E5-BB13-59C2-BB8E-01B59BCC1A18}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlTypeAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlTypeAttribute; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlTypeAttribute" />
    ///  class and specifies the name of the XML type.</summary>
    ///  <param name="typeName">The name of the XML type that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  generates when it serializes the class instance (and recognizes when it deserializes the class instance). </param>
    {class} function init(typeName: string): DNXmlTypeAttribute; overload;

  end;

  ///<summary>Controls the XML schema that is generated when the attribute target is serialized by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  .</summary>
  [DNTypeName('System.Xml.Serialization.XmlTypeAttribute')]
  DNXmlTypeAttribute = interface(DDN.mscorlib.DNAttribute)
  ['{C309FF1D-96BE-3811-B0CD-391ACC257CEF}']
  { getters & setters } 

    function get_AnonymousType: Boolean;
    procedure set_AnonymousType(value: Boolean);
    function get_IncludeInSchema: Boolean;
    procedure set_IncludeInSchema(value: Boolean);
    function get_TypeName: string;
    procedure set_TypeName(value: string);
    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_TypeId: DDN.mscorlib.DNObject;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function Match(obj: DDN.mscorlib.DNObject): Boolean;
    function IsDefaultAttribute: Boolean;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that determines whether the resulting schema type is an XSD anonymous type.</summary>
    ///<returns><see langword="true" />
    ///  , if the resulting schema type is an XSD anonymous type; otherwise, <see langword="false" />
    ///  .</returns>
    property AnonymousType: Boolean read get_AnonymousType write set_AnonymousType;
    ///<summary>Gets or sets a value that indicates whether to include the type in XML schema documents.</summary>
    ///<returns><see langword="true" />
    ///  to include the type in XML schema documents; otherwise, <see langword="false" />
    ///  .</returns>
    property IncludeInSchema: Boolean read get_IncludeInSchema write set_IncludeInSchema;
    ///<summary>Gets or sets the name of the XML type.</summary>
    ///<returns>The name of the XML type.</returns>
    property TypeName: string read get_TypeName write set_TypeName;
    ///<summary>Gets or sets the namespace of the XML type.</summary>
    ///<returns>The namespace of the XML type.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    property TypeId: DDN.mscorlib.DNObject read get_TypeId;
  end;

  TDNXmlTypeAttribute = class(TDNGenericImport<DNXmlTypeAttributeClass, DNXmlTypeAttribute>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaObjectCollectionClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{D5C3C4A3-9DFD-54C7-AD9D-4639E2276E59}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see langword="XmlSchemaObjectCollection" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaObjectCollection; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlSchemaObjectCollection" />
    ///  class that takes an <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///  <param name="parent">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  . </param>
    {class} function init(parent: DNXmlSchemaObject): DNXmlSchemaObjectCollection; overload;

  end;

  ///<summary>A collection of <see cref="T:System.Xml.Schema.XmlSchemaObject" />
  ///  s.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaObjectCollection')]
  DNXmlSchemaObjectCollection = interface(DDN.mscorlib.DNCollectionBase)
  ['{596E0E99-AE45-3841-A593-3BC7DF11D333}']
  { getters & setters } 

    function get_Item(index: Int32): DNXmlSchemaObject;
    procedure set_Item(index: Int32; value: DNXmlSchemaObject);
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Returns an enumerator for iterating through the <see langword="XmlSchemaObjects" />
    ///  contained in the <see langword="XmlSchemaObjectCollection" />
    ///  .</summary>
    ///<returns>The iterator returns <see cref="T:System.Xml.Schema.XmlSchemaObjectEnumerator" />
    ///  .</returns>
    function GetEnumerator: DNXmlSchemaObjectEnumerator;
    ///<summary>Adds an <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  to the <see langword="XmlSchemaObjectCollection" />
    ///  .</summary>
    ///  <param name="item">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  . </param>
    ///<returns>The index at which the item has been added.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  is less than zero.-or-
    ///  <paramref name="index" />
    ///  is greater than <see langword="Count" />
    ///  . </exception><exception cref="T:System.InvalidCastException">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  parameter specified is not of type <see cref="T:System.Xml.Schema.XmlSchemaExternal" />
    ///  or its derived types <see cref="T:System.Xml.Schema.XmlSchemaImport" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaInclude" />
    ///  , and <see cref="T:System.Xml.Schema.XmlSchemaRedefine" />
    ///  .</exception>
    function Add(item: DNXmlSchemaObject): Int32;
    ///<summary>Inserts an <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  to the <see langword="XmlSchemaObjectCollection" />
    ///  .</summary>
    ///  <param name="index">The zero-based index at which an item should be inserted. </param>
    ///  <param name="item">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  to insert. </param>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  is less than zero.-or-
    ///  <paramref name="index" />
    ///  is greater than <see langword="Count" />
    ///  . </exception>
    procedure Insert(index: Int32; item: DNXmlSchemaObject);
    ///<summary>Gets the collection index corresponding to the specified <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///  <param name="item">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  whose index you want to return. </param>
    ///<returns>The index corresponding to the specified <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    function IndexOf(item: DNXmlSchemaObject): Int32;
    ///<summary>Indicates if the specified <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  is in the <see langword="XmlSchemaObjectCollection" />
    ///  .</summary>
    ///  <param name="item">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if the specified qualified name is in the collection; otherwise, returns <see langword="false" />
    ///  . If null is supplied, <see langword="false" />
    ///  is returned because there is no qualified name with a null name.</returns>
    function &Contains(item: DNXmlSchemaObject): Boolean;
    ///<summary>Removes an <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  from the <see langword="XmlSchemaObjectCollection" />
    ///  .</summary>
    ///  <param name="item">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  to remove. </param>
    procedure Remove(item: DNXmlSchemaObject);
    ///<summary>Copies all the <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  s from the collection into the given array, starting at the given index.</summary>
    ///  <param name="array">The one-dimensional array that is the destination of the elements copied from the <see langword="XmlSchemaObjectCollection" />
    ///  . The array must have zero-based indexing. </param>
    ///  <param name="index">The zero-based index in the array at which copying begins. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="array" />
    ///  is a null reference (<see langword="Nothing" />
    ///  in Visual Basic). </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  is less than zero. </exception><exception cref="T:System.ArgumentException"><paramref name="array" />
    ///  is multi-dimensional.- or -
    ///  <paramref name="index" />
    ///  is equal to or greater than the length of <paramref name="array" />
    ///  .- or - The number of elements in the source <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  is greater than the available space from index to the end of the destination array. </exception><exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  cannot be cast automatically to the type of the destination array. </exception>
    procedure CopyTo(&array: TArray<DNXmlSchemaObject>; index: Int32);
    procedure RemoveAt(index: Int32);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNXmlSchemaObject read get_Item write set_Item; default;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNXmlSchemaObjectCollection = class(TDNGenericImport<DNXmlSchemaObjectCollectionClass, DNXmlSchemaObjectCollection>) end;

  //-------------namespace: System.Xml.Serialization.Advanced----------------
  DNSchemaImporterExtensionCollectionClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{7799DB0A-F760-5ED0-A35F-2DFB8ECF2F26}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection" />
    ///  class. </summary>
    {class} function init: DNSchemaImporterExtensionCollection;

  end;

  ///<summary>Represents a collection of <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
  ///  objects.</summary>
  [DNTypeName('System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection')]
  DNSchemaImporterExtensionCollection = interface(DDN.mscorlib.DNCollectionBase)
  ['{91A8EB3D-084B-359D-B02C-2EAA9E5C3B20}']
  { getters & setters } 

    function get_Item(index: Int32): DNSchemaImporterExtension;
    procedure set_Item(index: Int32; value: DNSchemaImporterExtension);
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Adds the specified importer extension to the collection.</summary>
    ///  <param name="extension">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection" />
    ///  to add.</param>
    ///<returns>The index of the added extension.</returns>
    function Add(extension: DNSchemaImporterExtension): Int32; overload;
    ///<summary>Removes the <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  , specified by name, from the collection.</summary>
    ///  <param name="name">The name of the <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  to remove. The name is set using the <see cref="M:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection.Add(System.String,System.Type)" />
    ///  method.</param>
    procedure Remove(name: string); overload;
    ///<summary>Clears the collection of importer extensions.</summary>
    procedure Clear;
    ///<summary>Inserts the specified <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  into the collection at the specified index.</summary>
    ///  <param name="index">The zero-base index at which the <paramref name="extension" />
    ///  should be inserted.</param>
    ///  <param name="extension">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  to insert.</param>
    procedure Insert(index: Int32; extension: DNSchemaImporterExtension);
    ///<summary>Searches for the specified item and returns the zero-based index of the first occurrence within the collection.</summary>
    ///  <param name="extension">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  to search for.</param>
    ///<returns>The index of the found item.</returns>
    function IndexOf(extension: DNSchemaImporterExtension): Int32;
    ///<summary>Gets a value that indicates whether the specified importer extension exists in the collection.</summary>
    ///  <param name="extension">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection" />
    ///  to search for.</param>
    ///<returns><see langword="true" />
    ///  if the extension is found; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(extension: DNSchemaImporterExtension): Boolean;
    ///<summary>Removes the specified <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  from the collection.</summary>
    ///  <param name="extension">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  to remove. </param>
    procedure Remove(extension: DNSchemaImporterExtension); overload;
    ///<summary>Copies all the elements of the current <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection" />
    ///  to the specified array of <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  objects at the specified index. </summary>
    ///  <param name="array">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtension" />
    ///  to copy the current collection to.</param>
    ///  <param name="index">The zero-based index at which the collection is added.</param>
    procedure CopyTo(&array: TArray<DNSchemaImporterExtension>; index: Int32);
    ///<summary>Adds the specified importer extension to the collection. The name parameter allows you to supply a custom name for the extension.</summary>
    ///  <param name="name">A custom name for the extension.</param>
    ///  <param name="type">The <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection" />
    ///  to add.</param>
    ///<returns>The index of the newly added item.</returns>
    ///<exception cref="T:System.ArgumentException">The value of type does not inherit from <see cref="T:System.Xml.Serialization.Advanced.SchemaImporterExtensionCollection" />
    ///  .</exception>
    function Add(name: string; &type: DDN.mscorlib.DNType): Int32; overload;
    procedure RemoveAt(index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNSchemaImporterExtension read get_Item write set_Item; default;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNSchemaImporterExtensionCollection = class(TDNGenericImport<DNSchemaImporterExtensionCollectionClass, DNSchemaImporterExtensionCollection>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAnyElementAttributesClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{9B8E8740-3F89-54AB-8C57-AA3D2861CB2F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAnyElementAttributes" />
    ///  class. </summary>
    {class} function init: DNXmlAnyElementAttributes;

  end;

  ///<summary>Represents a collection of <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
  ///  objects.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAnyElementAttributes')]
  DNXmlAnyElementAttributes = interface(DDN.mscorlib.DNCollectionBase)
  ['{7573313D-5C10-3E5A-A8DC-1552B0605CE5}']
  { getters & setters } 

    function get_Item(index: Int32): DNXmlAnyElementAttribute;
    procedure set_Item(index: Int32; value: DNXmlAnyElementAttribute);
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  to the collection.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  to add. </param>
    ///<returns>The index of the newly added <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  .</returns>
    function Add(attribute: DNXmlAnyElementAttribute): Int32;
    ///<summary>Inserts an <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  into the collection at the specified index.</summary>
    ///  <param name="index">The index where the <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  is inserted. </param>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  to insert. </param>
    procedure Insert(index: Int32; attribute: DNXmlAnyElementAttribute);
    ///<summary>Gets the index of the specified <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  .</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  whose index you want. </param>
    ///<returns>The index of the specified <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  .</returns>
    function IndexOf(attribute: DNXmlAnyElementAttribute): Int32;
    ///<summary>Gets a value that indicates whether the specified <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  exists in the collection.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  you are interested in. </param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  exists in the collection; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(attribute: DNXmlAnyElementAttribute): Boolean;
    ///<summary>Removes the specified <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  from the collection.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  to remove. </param>
    procedure Remove(attribute: DNXmlAnyElementAttribute);
    ///<summary>Copies the entire collection to a compatible one-dimensional array of <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  objects, starting at the specified index of the target array. </summary>
    ///  <param name="array">The one-dimensional array of <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  objects that is the destination of the elements copied from the collection. The array must have zero-based indexing.</param>
    ///  <param name="index">The zero-based index in <paramref name="array" />
    ///  at which copying begins.</param>
    procedure CopyTo(&array: TArray<DNXmlAnyElementAttribute>; index: Int32);
    procedure RemoveAt(index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNXmlAnyElementAttribute read get_Item write set_Item; default;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNXmlAnyElementAttributes = class(TDNGenericImport<DNXmlAnyElementAttributesClass, DNXmlAnyElementAttributes>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlArrayItemAttributesClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{1502C14A-1A8E-5E6B-9DEF-B11AAA64421A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlArrayItemAttributes" />
    ///  class. </summary>
    {class} function init: DNXmlArrayItemAttributes;

  end;

  ///<summary>Represents a collection of <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
  ///  objects.</summary>
  [DNTypeName('System.Xml.Serialization.XmlArrayItemAttributes')]
  DNXmlArrayItemAttributes = interface(DDN.mscorlib.DNCollectionBase)
  ['{38B4E5B9-F563-311F-B7F9-59C041092790}']
  { getters & setters } 

    function get_Item(index: Int32): DNXmlArrayItemAttribute;
    procedure set_Item(index: Int32; value: DNXmlArrayItemAttribute);
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  to the collection.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  to add to the collection. </param>
    ///<returns>The index of the added item.</returns>
    function Add(attribute: DNXmlArrayItemAttribute): Int32;
    ///<summary>Inserts an <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  into the collection at the specified index. </summary>
    ///  <param name="index">The index at which the attribute is inserted.</param>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  to insert.</param>
    procedure Insert(index: Int32; attribute: DNXmlArrayItemAttribute);
    ///<summary>Returns the zero-based index of the first occurrence of the specified <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  in the collection or -1 if the attribute is not found in the collection. </summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  to locate in the collection.</param>
    ///<returns>The first index of the <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  in the collection or -1 if the attribute is not found in the collection.</returns>
    function IndexOf(attribute: DNXmlArrayItemAttribute): Int32;
    ///<summary>Determines whether the collection contains the specified <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  . </summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  to check for.</param>
    ///<returns><see langword="true" />
    ///  if the collection contains the specified <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(attribute: DNXmlArrayItemAttribute): Boolean;
    ///<summary>Removes an <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  from the collection, if it is present. </summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  to remove.</param>
    procedure Remove(attribute: DNXmlArrayItemAttribute);
    ///<summary>Copies an <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  array to the collection, starting at a specified target index. </summary>
    ///  <param name="array">The array of <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  objects to copy to the collection.</param>
    ///  <param name="index">The index at which the copied attributes begin.</param>
    procedure CopyTo(&array: TArray<DNXmlArrayItemAttribute>; index: Int32);
    procedure RemoveAt(index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNXmlArrayItemAttribute read get_Item write set_Item; default;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNXmlArrayItemAttributes = class(TDNGenericImport<DNXmlArrayItemAttributesClass, DNXmlArrayItemAttributes>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlElementAttributesClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{F8F22478-879B-5627-B9C6-0A1F51F290C2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlElementAttributes" />
    ///  class. </summary>
    {class} function init: DNXmlElementAttributes;

  end;

  ///<summary>Represents a collection of <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
  ///  objects used by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  to override the default way it serializes a class.</summary>
  [DNTypeName('System.Xml.Serialization.XmlElementAttributes')]
  DNXmlElementAttributes = interface(DDN.mscorlib.DNCollectionBase)
  ['{5928E3D2-6501-3262-BC01-7B36866FDF37}']
  { getters & setters } 

    function get_Item(index: Int32): DNXmlElementAttribute;
    procedure set_Item(index: Int32; value: DNXmlElementAttribute);
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  to the collection.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  to add. </param>
    ///<returns>The zero-based index of the newly added item.</returns>
    function Add(attribute: DNXmlElementAttribute): Int32;
    ///<summary>Inserts an <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  into the collection.</summary>
    ///  <param name="index">The zero-based index where the member is inserted. </param>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  to insert. </param>
    procedure Insert(index: Int32; attribute: DNXmlElementAttribute);
    ///<summary>Gets the index of the specified <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  .</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  whose index is being retrieved.</param>
    ///<returns>The zero-based index of the <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  .</returns>
    function IndexOf(attribute: DNXmlElementAttribute): Int32;
    ///<summary>Determines whether the collection contains the specified object.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  to look for. </param>
    ///<returns><see langword="true" />
    ///  if the object exists in the collection; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(attribute: DNXmlElementAttribute): Boolean;
    ///<summary>Removes the specified object from the collection.</summary>
    ///  <param name="attribute">The <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  to remove from the collection. </param>
    procedure Remove(attribute: DNXmlElementAttribute);
    ///<summary>Copies the <see cref="T:System.Xml.Serialization.XmlElementAttributes" />
    ///  , or a portion of it to a one-dimensional array.</summary>
    ///  <param name="array">The <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  array to hold the copied elements. </param>
    ///  <param name="index">The zero-based index in <paramref name="array" />
    ///  at which copying begins. </param>
    procedure CopyTo(&array: TArray<DNXmlElementAttribute>; index: Int32);
    procedure RemoveAt(index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNXmlElementAttribute read get_Item write set_Item; default;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNXmlElementAttributes = class(TDNGenericImport<DNXmlElementAttributesClass, DNXmlElementAttributes>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSchemasClass = interface(DDN.mscorlib.DNCollectionBaseClass)
  ['{1F11517E-6391-5280-AA42-0F31A3AE13AB}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  class. </summary>
    {class} function init: DNXmlSchemas;

  { static methods } 

    ///<summary>Static method that determines whether the specified XML schema contains a custom <see langword="IsDataSet" />
    ///  attribute set to <see langword="true" />
    ///  , or its equivalent. </summary>
    ///  <param name="schema">The XML schema to check for an <see langword="IsDataSet" />
    ///  attribute with a <see langword="true" />
    ///  value.</param>
    ///<returns><see langword="true" />
    ///  if the specified schema exists; otherwise, <see langword="false" />
    ///  .</returns>
    {class} function IsDataSet(schema: DNXmlSchema): Boolean;

  end;

  ///<summary>Represents the collection of XML schemas.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSchemas')]
  DNXmlSchemas = interface(DDN.mscorlib.DNCollectionBase)
  ['{CAA46B12-3C51-3B6B-9832-0F9E5372C47C}']
  { getters & setters } 

    function get_Item(index: Int32): DNXmlSchema; overload;
    procedure set_Item(index: Int32; value: DNXmlSchema);
    function get_Item(ns: string): DNXmlSchema; overload;
    function get_IsCompiled: Boolean;
    function get_Capacity: Int32;
    procedure set_Capacity(value: Int32);
    function get_Count: Int32;

  { methods } 

    ///<summary>Gets a collection of schemas that belong to the same namespace.</summary>
    ///  <param name="ns">The namespace of the schemas to retrieve.</param>
    ///<returns>An <see cref="T:System.Collections.IList" />
    ///  implementation that contains the schemas.</returns>
    function GetSchemas(ns: string): DDN.mscorlib.DNIList;
    ///<summary>Adds an object to the end of the collection.</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to be added to the collection of objects. </param>
    ///<returns>The index at which the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  is added.</returns>
    function Add(schema: DNXmlSchema): Int32; overload;
    ///<summary>Adds an <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object that represents an assembly reference to the collection.</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to add.</param>
    ///  <param name="baseUri">The <see cref="T:System.Uri" />
    ///  of the schema object.</param>
    ///<returns>The index at which the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  is added.</returns>
    function Add(schema: DNXmlSchema; baseUri: DDN.System.DNUri): Int32; overload;
    ///<summary>Adds an instance of the <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  class to the end of the collection.</summary>
    ///  <param name="schemas">The <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  object to be added to the end of the collection. </param>
    procedure Add(schemas: DNXmlSchemas); overload;
    ///<summary>Adds an <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object that represents an assembly reference to the collection.</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to add.</param>
    procedure AddReference(schema: DNXmlSchema);
    ///<summary>Inserts a schema into the <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  at the specified index.</summary>
    ///  <param name="index">The zero-based index at which <paramref name="schema" />
    ///  should be inserted. </param>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to be inserted. </param>
    procedure Insert(index: Int32; schema: DNXmlSchema);
    ///<summary>Searches for the specified schema and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  .</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to locate. </param>
    ///<returns>The zero-based index of the first occurrence of the value within the entire <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  , if found; otherwise, -1.</returns>
    function IndexOf(schema: DNXmlSchema): Int32;
    ///<summary>Determines whether the <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  contains a specific schema.</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to locate. </param>
    ///<returns><see langword="true" />
    ///  , if the collection contains the specified item; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(schema: DNXmlSchema): Boolean; overload;
    ///<summary>Returns a value that indicates whether the collection contains an <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object that belongs to the specified namespace.</summary>
    ///  <param name="targetNamespace">The namespace of the item to check for.</param>
    ///<returns><see langword="true" />
    ///  if the item is found; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(targetNamespace: string): Boolean; overload;
    ///<summary>Removes the first occurrence of a specific schema from the <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  .</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to remove. </param>
    procedure Remove(schema: DNXmlSchema);
    ///<summary>Copies the entire <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  to a compatible one-dimensional <see cref="T:System.Array" />
    ///  , which starts at the specified index of the target array.</summary>
    ///  <param name="array">The one-dimensional <see cref="T:System.Array" />
    ///  that is the destination of the schemas copied from <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  . The <see cref="T:System.Array" />
    ///  must have zero-based indexing. </param>
    ///  <param name="index">A 32-bit integer that represents the index in the array where copying begins.</param>
    procedure CopyTo(&array: TArray<DNXmlSchema>; index: Int32);
    ///<summary>Locates in one of the XML schemas an <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of the specified name and type. </summary>
    ///  <param name="name">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies a fully qualified name with a namespace used to locate an <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object in the collection.</param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object to find. Possible types include: <see cref="T:System.Xml.Schema.XmlSchemaGroup" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroup" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  , and <see cref="T:System.Xml.Schema.XmlSchemaNotation" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  instance, such as an <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  or <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  .</returns>
    function Find(name: DNXmlQualifiedName; &type: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    ///<summary>Processes the element and attribute names in the XML schemas and, optionally, validates the XML schemas. </summary>
    ///  <param name="handler">A <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  that specifies the callback method that handles errors and warnings during XML Schema validation, if the strict parameter is set to <see langword="true" />
    ///  .</param>
    ///  <param name="fullCompile"><see langword="true" />
    ///  to validate the XML schemas in the collection using the <see cref="M:System.Xml.Serialization.XmlSchemas.Compile(System.Xml.Schema.ValidationEventHandler,System.Boolean)" />
    ///  method of the <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  class; otherwise, <see langword="false" />
    ///  .</param>
    procedure Compile(handler: DNValidationEventHandler; fullCompile: Boolean);
    procedure RemoveAt(index: Int32);
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[index: Int32]: DNXmlSchema read get_Item write set_Item; default;
    property Item[ns: string]: DNXmlSchema read get_Item; default;
    ///<summary>Gets a value that indicates whether the schemas have been compiled.</summary>
    ///<returns><see langword="true" />
    ///  , if the schemas have been compiled; otherwise, <see langword="false" />
    ///  .</returns>
    property IsCompiled: Boolean read get_IsCompiled;
    property Capacity: Int32 read get_Capacity write set_Capacity;
    property Count: Int32 read get_Count;
  end;

  TDNXmlSchemas = class(TDNGenericImport<DNXmlSchemasClass, DNXmlSchemas>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNValidationEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{FD89FE6F-3039-5078-BA46-B00CE55AACA1}']
  end;

  ///<summary>Returns detailed information related to the <see langword="ValidationEventHandler" />
  ///  .</summary>
  [DNTypeName('System.Xml.Schema.ValidationEventArgs')]
  DNValidationEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{49138DCC-3D4B-3D96-AF44-350EF4295AB3}']
  { getters & setters } 

    function get_Severity: DNXmlSeverityType;
    function get_Exception: DNXmlSchemaException;
    function get_Message: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the severity of the validation event.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSeverityType" />
    ///  value representing the severity of the validation event.</returns>
    property Severity: DNXmlSeverityType read get_Severity;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  associated with the validation event.</summary>
    ///<returns>The <see langword="XmlSchemaException" />
    ///  associated with the validation event.</returns>
    property Exception: DNXmlSchemaException read get_Exception;
    ///<summary>Gets the text description corresponding to the validation event.</summary>
    ///<returns>The text description.</returns>
    property Message: string read get_Message;
  end;

  TDNValidationEventArgs = class(TDNGenericImport<DNValidationEventArgsClass, DNValidationEventArgs>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNUnreferencedObjectEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{7617BC02-6B99-5146-A719-F16FDE6B486F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.UnreferencedObjectEventArgs" />
    ///  class.</summary>
    ///  <param name="o">The unreferenced object. </param>
    ///  <param name="id">A unique string used to identify the unreferenced object. </param>
    {class} function init(o: DDN.mscorlib.DNObject; id: string): DNUnreferencedObjectEventArgs;

  end;

  ///<summary>Provides data for the known, but unreferenced, object found in an encoded SOAP XML stream during deserialization.</summary>
  [DNTypeName('System.Xml.Serialization.UnreferencedObjectEventArgs')]
  DNUnreferencedObjectEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{CFC824D5-B349-3ADE-9231-EB95E797D4F2}']
  { getters & setters } 

    function get_UnreferencedObject: DDN.mscorlib.DNObject;
    function get_UnreferencedId: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the deserialized, but unreferenced, object.</summary>
    ///<returns>The deserialized, but unreferenced, object.</returns>
    property UnreferencedObject: DDN.mscorlib.DNObject read get_UnreferencedObject;
    ///<summary>Gets the ID of the object.</summary>
    ///<returns>The ID of the object.</returns>
    property UnreferencedId: string read get_UnreferencedId;
  end;

  TDNUnreferencedObjectEventArgs = class(TDNGenericImport<DNUnreferencedObjectEventArgsClass, DNUnreferencedObjectEventArgs>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAttributeEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{997820B5-29F5-571C-9886-4457238350D8}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
  ///  event.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAttributeEventArgs')]
  DNXmlAttributeEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{651D1E7C-E0A0-390F-8AD9-FDDE2A67ECAC}']
  { getters & setters } 

    function get_ObjectBeingDeserialized: DDN.mscorlib.DNObject;
    function get_Attr: DNXmlAttribute;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_ExpectedAttributes: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the object being deserialized.</summary>
    ///<returns>The object being deserialized.</returns>
    property ObjectBeingDeserialized: DDN.mscorlib.DNObject read get_ObjectBeingDeserialized;
    ///<summary>Gets an object that represents the unknown XML attribute.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlAttribute" />
    ///  that represents the unknown XML attribute.</returns>
    property Attr: DNXmlAttribute read get_Attr;
    ///<summary>Gets the line number of the unknown XML attribute.</summary>
    ///<returns>The line number of the unknown XML attribute.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the position in the line of the unknown XML attribute.</summary>
    ///<returns>The position number of the unknown XML attribute.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets a comma-delimited list of XML attribute names expected to be in an XML document instance.</summary>
    ///<returns>A comma-delimited list of XML attribute names. Each name is in the following format: <paramref name="namespace" />
    ///  :<paramref name="name" />
    ///  .</returns>
    property ExpectedAttributes: string read get_ExpectedAttributes;
  end;

  TDNXmlAttributeEventArgs = class(TDNGenericImport<DNXmlAttributeEventArgsClass, DNXmlAttributeEventArgs>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlElementEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{D95F4725-AEF4-5C6D-BE60-62E075E231D2}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownElement" />
  ///  event.</summary>
  [DNTypeName('System.Xml.Serialization.XmlElementEventArgs')]
  DNXmlElementEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{61E0F174-1182-374D-9E3A-8D9866B8561D}']
  { getters & setters } 

    function get_ObjectBeingDeserialized: DDN.mscorlib.DNObject;
    function get_Element: DNXmlElement;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_ExpectedElements: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the object the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  is deserializing.</summary>
    ///<returns>The object that is being deserialized by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    property ObjectBeingDeserialized: DDN.mscorlib.DNObject read get_ObjectBeingDeserialized;
    ///<summary>Gets the object that represents the unknown XML element.</summary>
    ///<returns>The object that represents the unknown XML element.</returns>
    property Element: DNXmlElement read get_Element;
    ///<summary>Gets the line number where the unknown element was encountered if the XML reader is an <see cref="T:System.Xml.XmlTextReader" />
    ///  .</summary>
    ///<returns>The line number where the unknown element was encountered if the XML reader is an <see cref="T:System.Xml.XmlTextReader" />
    ///  ; otherwise, -1.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the place in the line where the unknown element occurs if the XML reader is an <see cref="T:System.Xml.XmlTextReader" />
    ///  .</summary>
    ///<returns>The number in the line where the unknown element occurs if the XML reader is an <see cref="T:System.Xml.XmlTextReader" />
    ///  ; otherwise, -1.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets a comma-delimited list of XML element names expected to be in an XML document instance.</summary>
    ///<returns>A comma-delimited list of XML element names. Each name is in the following format: <paramref name="namespace" />
    ///  :<paramref name="name" />
    ///  .</returns>
    property ExpectedElements: string read get_ExpectedElements;
  end;

  TDNXmlElementEventArgs = class(TDNGenericImport<DNXmlElementEventArgsClass, DNXmlElementEventArgs>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlNodeEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{FC43EE19-62C8-59F5-8D96-F5D73A9B02BE}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
  ///  event.</summary>
  [DNTypeName('System.Xml.Serialization.XmlNodeEventArgs')]
  DNXmlNodeEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{6015482F-C16B-3157-9314-1EC423F32215}']
  { getters & setters } 

    function get_ObjectBeingDeserialized: DDN.mscorlib.DNObject;
    function get_NodeType: DNXmlNodeType;
    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Text: string;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the object being deserialized.</summary>
    ///<returns>The <see cref="T:System.Object" />
    ///  being deserialized.</returns>
    property ObjectBeingDeserialized: DDN.mscorlib.DNObject read get_ObjectBeingDeserialized;
    ///<summary>Gets the type of the XML node being deserialized.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNodeType" />
    ///  that represents the XML node being deserialized.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the name of the XML node being deserialized.</summary>
    ///<returns>The name of the node being deserialized.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the XML local name of the XML node being deserialized.</summary>
    ///<returns>The XML local name of the node being deserialized.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the namespace URI that is associated with the XML node being deserialized.</summary>
    ///<returns>The namespace URI that is associated with the XML node being deserialized.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets the text of the XML node being deserialized.</summary>
    ///<returns>The text of the XML node being deserialized.</returns>
    property Text: string read get_Text;
    ///<summary>Gets the line number of the unknown XML node.</summary>
    ///<returns>The line number of the unknown XML node.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the position in the line of the unknown XML node.</summary>
    ///<returns>The position number of the unknown XML node.</returns>
    property LinePosition: Int32 read get_LinePosition;
  end;

  TDNXmlNodeEventArgs = class(TDNGenericImport<DNXmlNodeEventArgsClass, DNXmlNodeEventArgs>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNodeChangedEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{A5830A41-9A45-5E8D-BC73-144AE5DF513F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlNodeChangedEventArgs" />
    ///  class.</summary>
    ///  <param name="node">The <see cref="T:System.Xml.XmlNode" />
    ///  that generated the event.</param>
    ///  <param name="oldParent">The old parent <see cref="T:System.Xml.XmlNode" />
    ///  of the <see cref="T:System.Xml.XmlNode" />
    ///  that generated the event.</param>
    ///  <param name="newParent">The new parent <see cref="T:System.Xml.XmlNode" />
    ///  of the <see cref="T:System.Xml.XmlNode" />
    ///  that generated the event.</param>
    ///  <param name="oldValue">The old value of the <see cref="T:System.Xml.XmlNode" />
    ///  that generated the event.</param>
    ///  <param name="newValue">The new value of the <see cref="T:System.Xml.XmlNode" />
    ///  that generated the event.</param>
    ///  <param name="action">The <see cref="T:System.Xml.XmlNodeChangedAction" />
    ///  .</param>
    {class} function init(node: DNXmlNode; oldParent: DNXmlNode; newParent: DNXmlNode; oldValue: string; newValue: string; action: DNXmlNodeChangedAction): DNXmlNodeChangedEventArgs;

  end;

  ///<summary>Provides data for the <see cref="E:System.Xml.XmlDocument.NodeChanged" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeChanging" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeInserted" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeInserting" />
  ///  , <see cref="E:System.Xml.XmlDocument.NodeRemoved" />
  ///  and <see cref="E:System.Xml.XmlDocument.NodeRemoving" />
  ///  events.</summary>
  [DNTypeName('System.Xml.XmlNodeChangedEventArgs')]
  DNXmlNodeChangedEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{6F33740C-B2E1-3A44-A063-8F78C5C6CD1B}']
  { getters & setters } 

    function get_Action: DNXmlNodeChangedAction;
    function get_Node: DNXmlNode;
    function get_OldParent: DNXmlNode;
    function get_NewParent: DNXmlNode;
    function get_OldValue: string;
    function get_NewValue: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value indicating what type of node change event is occurring.</summary>
    ///<returns>An <see langword="XmlNodeChangedAction" />
    ///  value describing the node change event.XmlNodeChangedAction Value Description Insert A node has been or will be inserted. Remove A node has been or will be removed. Change A node has been or will be changed. The <see langword="Action" />
    ///  value does not differentiate between when the event occurred (before or after). You can create separate event handlers to handle both instances.</returns>
    property Action: DNXmlNodeChangedAction read get_Action;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNode" />
    ///  that is being added, removed or changed.</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is being added, removed or changed; this property never returns <see langword="null" />
    ///  .</returns>
    property Node: DNXmlNode read get_Node;
    ///<summary>Gets the value of the <see cref="P:System.Xml.XmlNode.ParentNode" />
    ///  before the operation began.</summary>
    ///<returns>The value of the <see langword="ParentNode" />
    ///  before the operation began. This property returns <see langword="null" />
    ///  if the node did not have a parent.For attribute nodes this property returns the <see cref="P:System.Xml.XmlAttribute.OwnerElement" />
    ///  .</returns>
    property OldParent: DNXmlNode read get_OldParent;
    ///<summary>Gets the value of the <see cref="P:System.Xml.XmlNode.ParentNode" />
    ///  after the operation completes.</summary>
    ///<returns>The value of the <see langword="ParentNode" />
    ///  after the operation completes. This property returns <see langword="null" />
    ///  if the node is being removed.For attribute nodes this property returns the <see cref="P:System.Xml.XmlAttribute.OwnerElement" />
    ///  .</returns>
    property NewParent: DNXmlNode read get_NewParent;
    ///<summary>Gets the original value of the node.</summary>
    ///<returns>The original value of the node. This property returns <see langword="null" />
    ///  if the node is neither an attribute nor a text node, or if the node is being inserted.If called in a <see cref="E:System.Xml.XmlDocument.NodeChanging" />
    ///  event, <see langword="OldValue" />
    ///  returns the current value of the node that will be replaced if the change is successful. If called in a <see cref="E:System.Xml.XmlDocument.NodeChanged" />
    ///  event, <see langword="OldValue" />
    ///  returns the value of node prior to the change.</returns>
    property OldValue: string read get_OldValue;
    ///<summary>Gets the new value of the node.</summary>
    ///<returns>The new value of the node. This property returns <see langword="null" />
    ///  if the node is neither an attribute nor a text node, or if the node is being removed.If called in a <see cref="E:System.Xml.XmlDocument.NodeChanging" />
    ///  event, <see langword="NewValue" />
    ///  returns the value of the node if the change is successful. If called in a <see cref="E:System.Xml.XmlDocument.NodeChanged" />
    ///  event, <see langword="NewValue" />
    ///  returns the current value of the node.</returns>
    property NewValue: string read get_NewValue;
  end;

  TDNXmlNodeChangedEventArgs = class(TDNGenericImport<DNXmlNodeChangedEventArgsClass, DNXmlNodeChangedEventArgs>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXsltMessageEncounteredEventArgsClass = interface(DDN.mscorlib.DNEventArgsClass)
  ['{5EAFE3C8-A99D-586C-A368-212AB818D2E4}']
  end;

  ///<summary>Provides data for the <see cref="E:System.Xml.Xsl.XsltArgumentList.XsltMessageEncountered" />
  ///  event.</summary>
  [DNTypeName('System.Xml.Xsl.XsltMessageEncounteredEventArgs')]
  DNXsltMessageEncounteredEventArgs = interface(DDN.mscorlib.DNEventArgs)
  ['{D64C2CC0-AC0D-3BED-8304-F97565C2AC47}']
  { getters & setters } 

    function get_Message: string;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the contents of the xsl:message element.</summary>
    ///<returns>The contents of the xsl:message element.</returns>
    property Message: string read get_Message;
  end;

  TDNXsltMessageEncounteredEventArgs = class(TDNGenericImport<DNXsltMessageEncounteredEventArgsClass, DNXsltMessageEncounteredEventArgs>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{4B8E330C-085D-5126-AF56-589AA8D96746}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  class with the exception message specified.</summary>
    ///  <param name="message">A <see langword="string" />
    ///  description of the error condition.</param>
    {class} function init(message: string): DNXmlSchemaException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  class with the exception message and original <see cref="T:System.Exception" />
    ///  object that caused this exception specified.</summary>
    ///  <param name="message">A <see langword="string" />
    ///  description of the error condition.</param>
    ///  <param name="innerException">The original T:System.Exception object that caused this exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXmlSchemaException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  class with the exception message specified, and the original <see cref="T:System.Exception" />
    ///  object, line number, and line position of the XML that cause this exception specified.</summary>
    ///  <param name="message">A <see langword="string" />
    ///  description of the error condition.</param>
    ///  <param name="innerException">The original T:System.Exception object that caused this exception.</param>
    ///  <param name="lineNumber">The line number of the XML that caused this exception.</param>
    ///  <param name="linePosition">The line position of the XML that caused this exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException; lineNumber: Int32; linePosition: Int32): DNXmlSchemaException; overload;

  end;

  ///<summary>Returns detailed information about the schema exception.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaException')]
  DNXmlSchemaException = interface(DDN.mscorlib.DNSystemException)
  ['{8AABB69F-6F59-302E-86A1-437E6B0CA7EC}']
  { getters & setters } 

    function get_SourceUri: string;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_SourceSchemaObject: DNXmlSchemaObject;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see langword="XmlSchemaException" />
    ///  properties into the <see langword="SerializationInfo" />
    ///  class for the given <see langword="StreamingContext" />
    ///  .</summary>
    ///  <param name="info">The <see langword="SerializationInfo" />
    ///  . </param>
    ///  <param name="context">The <see langword="StreamingContext" />
    ///  information. </param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the Uniform Resource Identifier (URI) location of the schema that caused the exception.</summary>
    ///<returns>The URI location of the schema that caused the exception.</returns>
    property SourceUri: string read get_SourceUri;
    ///<summary>Gets the line number indicating where the error occurred.</summary>
    ///<returns>The line number indicating where the error occurred.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the line position indicating where the error occurred.</summary>
    ///<returns>The line position indicating where the error occurred.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>The <see langword="XmlSchemaObject" />
    ///  that produced the <see langword="XmlSchemaException" />
    ///  .</summary>
    ///<returns>A valid object instance represents a structural validation error in the XML Schema Object Model (SOM).</returns>
    property SourceSchemaObject: DNXmlSchemaObject read get_SourceSchemaObject;
    ///<summary>Gets the description of the error condition of this exception.</summary>
    ///<returns>The description of the error condition of this exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXmlSchemaException = class(TDNGenericImport<DNXmlSchemaExceptionClass, DNXmlSchemaException>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaInferenceExceptionClass = interface(DNXmlSchemaExceptionClass)
  ['{E355BADA-A926-59B3-A686-91612EC07F77}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaInferenceException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  class with the error message specified.</summary>
    ///  <param name="message">A description of the error.</param>
    {class} function init(message: string): DNXmlSchemaInferenceException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  class with the error message specified and the original <see cref="T:System.Exception" />
    ///  that caused the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  specified.</summary>
    ///  <param name="message">A description of the error.</param>
    ///  <param name="innerException">An <see cref="T:System.Exception" />
    ///  object containing the original exception that caused the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  .</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXmlSchemaInferenceException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  class with the error message specified, the original <see cref="T:System.Exception" />
    ///  that caused the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  specified, and the line number and line position of the error in the XML document specified.</summary>
    ///  <param name="message">A description of the error.</param>
    ///  <param name="innerException">An <see cref="T:System.Exception" />
    ///  object containing the original exception that caused the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  .</param>
    ///  <param name="lineNumber">The line number in the XML document that caused the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  .</param>
    ///  <param name="linePosition">The line position in the XML document that caused the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  .</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException; lineNumber: Int32; linePosition: Int32): DNXmlSchemaInferenceException; overload;

  end;

  ///<summary>Returns information about errors encountered by the <see cref="T:System.Xml.Schema.XmlSchemaInference" />
  ///  class while inferring a schema from an XML document.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaInferenceException')]
  DNXmlSchemaInferenceException = interface(DNXmlSchemaException)
  ['{305ED301-6C6D-3D89-9A24-680D177D7152}']
  { getters & setters } 

    function get_SourceUri: string;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_SourceSchemaObject: DNXmlSchemaObject;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see cref="T:System.Xml.Schema.XmlSchemaInferenceException" />
    ///  object properties into the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object specified for the <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object specified.</summary>
    ///  <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object.</param>
    ///  <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the Uniform Resource Identifier (URI) location of the schema that caused the exception.</summary>
    ///<returns>The URI location of the schema that caused the exception.</returns>
    property SourceUri: string read get_SourceUri;
    ///<summary>Gets the line number indicating where the error occurred.</summary>
    ///<returns>The line number indicating where the error occurred.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the line position indicating where the error occurred.</summary>
    ///<returns>The line position indicating where the error occurred.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>The <see langword="XmlSchemaObject" />
    ///  that produced the <see langword="XmlSchemaException" />
    ///  .</summary>
    ///<returns>A valid object instance represents a structural validation error in the XML Schema Object Model (SOM).</returns>
    property SourceSchemaObject: DNXmlSchemaObject read get_SourceSchemaObject;
    ///<summary>Gets the description of the error condition of this exception.</summary>
    ///<returns>The description of the error condition of this exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXmlSchemaInferenceException = class(TDNGenericImport<DNXmlSchemaInferenceExceptionClass, DNXmlSchemaInferenceException>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaValidationExceptionClass = interface(DNXmlSchemaExceptionClass)
  ['{24E28276-CCFA-5DAD-87F7-F068F084D0F6}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaValidationException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  class with the exception message specified.</summary>
    ///  <param name="message">A <see langword="string" />
    ///  description of the error condition.</param>
    {class} function init(message: string): DNXmlSchemaValidationException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  class with the exception message and original <see cref="T:System.Exception" />
    ///  object that caused this exception specified.</summary>
    ///  <param name="message">A <see langword="string" />
    ///  description of the error condition.</param>
    ///  <param name="innerException">The original <see cref="T:System.Exception" />
    ///  object that caused this exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXmlSchemaValidationException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  class with the exception message specified, and the original <see cref="T:System.Exception" />
    ///  object, line number, and line position of the XML that cause this exception specified.</summary>
    ///  <param name="message">A <see langword="string" />
    ///  description of the error condition.</param>
    ///  <param name="innerException">The original <see cref="T:System.Exception" />
    ///  object that caused this exception.</param>
    ///  <param name="lineNumber">The line number of the XML that caused this exception.</param>
    ///  <param name="linePosition">The line position of the XML that caused this exception.</param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException; lineNumber: Int32; linePosition: Int32): DNXmlSchemaValidationException; overload;

  end;

  ///<summary>Represents the exception thrown when XML Schema Definition Language (XSD) schema validation errors and warnings are encountered in an XML document being validated. </summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaValidationException')]
  DNXmlSchemaValidationException = interface(DNXmlSchemaException)
  ['{8E6EF0C5-0160-3931-B20C-576F8CC26C01}']
  { getters & setters } 

    function get_SourceObject: DDN.mscorlib.DNObject;
    function get_SourceUri: string;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_SourceSchemaObject: DNXmlSchemaObject;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Constructs a new <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  object with the given <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  and <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  information that contains all the properties of the <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  .</summary>
    ///  <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///</param>
    ///  <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the XML node that caused this <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  .</summary>
    ///<returns>The XML node that caused this <see cref="T:System.Xml.Schema.XmlSchemaValidationException" />
    ///  .</returns>
    property SourceObject: DDN.mscorlib.DNObject read get_SourceObject;
    ///<summary>Gets the Uniform Resource Identifier (URI) location of the schema that caused the exception.</summary>
    ///<returns>The URI location of the schema that caused the exception.</returns>
    property SourceUri: string read get_SourceUri;
    ///<summary>Gets the line number indicating where the error occurred.</summary>
    ///<returns>The line number indicating where the error occurred.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the line position indicating where the error occurred.</summary>
    ///<returns>The line position indicating where the error occurred.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>The <see langword="XmlSchemaObject" />
    ///  that produced the <see langword="XmlSchemaException" />
    ///  .</summary>
    ///<returns>A valid object instance represents a structural validation error in the XML Schema Object Model (SOM).</returns>
    property SourceSchemaObject: DNXmlSchemaObject read get_SourceSchemaObject;
    ///<summary>Gets the description of the error condition of this exception.</summary>
    ///<returns>The description of the error condition of this exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXmlSchemaValidationException = class(TDNGenericImport<DNXmlSchemaValidationExceptionClass, DNXmlSchemaValidationException>) end;

  //-------------namespace: System.Xml----------------
  DNXmlExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{C3490C0B-EFEB-50A4-9DF8-B40B0CBD5FB4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see langword="XmlException" />
    ///  class.</summary>
    {class} function init: DNXmlException; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlException" />
    ///  class with a specified error message.</summary>
    ///  <param name="message">The error description. </param>
    {class} function init(message: string): DNXmlException; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlException" />
    ///  class.</summary>
    ///  <param name="message">The description of the error condition. </param>
    ///  <param name="innerException">The <see cref="T:System.Exception" />
    ///  that threw the <see langword="XmlException" />
    ///  , if any. This value can be <see langword="null" />
    ///  . </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXmlException; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlException" />
    ///  class with the specified message, inner exception, line number, and line position.</summary>
    ///  <param name="message">The error description. </param>
    ///  <param name="innerException">The exception that is the cause of the current exception. This value can be <see langword="null" />
    ///  . </param>
    ///  <param name="lineNumber">The line number indicating where the error occurred. </param>
    ///  <param name="linePosition">The line position indicating where the error occurred. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException; lineNumber: Int32; linePosition: Int32): DNXmlException; overload;

  end;

  ///<summary>Returns detailed information about the last exception.</summary>
  [DNTypeName('System.Xml.XmlException')]
  DNXmlException = interface(DDN.mscorlib.DNSystemException)
  ['{30F748F0-C290-3CA0-98B6-E8F24430EB9F}']
  { getters & setters } 

    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_SourceUri: string;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see langword="XmlException" />
    ///  properties into the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  class for the given <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  .</summary>
    ///  <param name="info">The <see langword="SerializationInfo" />
    ///  object. </param>
    ///  <param name="context">The <see langword="StreamingContext" />
    ///  object. </param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the line number indicating where the error occurred.</summary>
    ///<returns>The line number indicating where the error occurred.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the line position indicating where the error occurred.</summary>
    ///<returns>The line position indicating where the error occurred.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets the location of the XML file.</summary>
    ///<returns>The source URI for the XML data. If there is no source URI, this property returns <see langword="null" />
    ///  .</returns>
    property SourceUri: string read get_SourceUri;
    ///<summary>Gets a message describing the current exception.</summary>
    ///<returns>The error message that explains the reason for the exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXmlException = class(TDNGenericImport<DNXmlExceptionClass, DNXmlException>) end;

  //-------------namespace: System.Xml.XPath----------------
  DNXPathExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{5C4D129F-CBDD-5B69-A9C0-1AFDDD429D3B}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathException" />
    ///  class.</summary>
    {class} function init: DNXPathException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathException" />
    ///  class with the specified exception message.</summary>
    ///  <param name="message">The description of the error condition.</param>
    {class} function init(message: string): DNXPathException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathException" />
    ///  class using the specified exception message and <see cref="T:System.Exception" />
    ///  object.</summary>
    ///  <param name="message">The description of the error condition. </param>
    ///  <param name="innerException">The <see cref="T:System.Exception" />
    ///  that threw the <see cref="T:System.Xml.XPath.XPathException" />
    ///  , if any. This value can be <see langword="null" />
    ///  . </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXPathException; overload;

  end;

  ///<summary>Provides the exception thrown when an error occurs while processing an XPath expression. </summary>
  [DNTypeName('System.Xml.XPath.XPathException')]
  DNXPathException = interface(DDN.mscorlib.DNSystemException)
  ['{6004C074-5837-3698-9136-E2C7D87699E0}']
  { getters & setters } 

    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see cref="T:System.Xml.XPath.XPathException" />
    ///  properties into the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  class for the specified <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  .</summary>
    ///  <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  object.</param>
    ///  <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  object.</param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the description of the error condition for this exception.</summary>
    ///<returns>The <see langword="string" />
    ///  description of the error condition for this exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXPathException = class(TDNGenericImport<DNXPathExceptionClass, DNXPathException>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXsltExceptionClass = interface(DDN.mscorlib.DNSystemExceptionClass)
  ['{0383D815-3766-5C40-86C0-57F7522614CD}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltException" />
    ///  class.</summary>
    {class} function init: DNXsltException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltException" />
    ///  class with a specified error message. </summary>
    ///  <param name="message">The message that describes the error.</param>
    {class} function init(message: string): DNXsltException; overload;
    ///<summary>Initializes a new instance of the <see langword="XsltException" />
    ///  class.</summary>
    ///  <param name="message">The description of the error condition. </param>
    ///  <param name="innerException">The <see cref="T:System.Exception" />
    ///  which threw the <see langword="XsltException" />
    ///  , if any. This value can be <see langword="null" />
    ///  . </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXsltException; overload;

  end;

  ///<summary>The exception that is thrown when an error occurs while processing an XSLT transformation.</summary>
  [DNTypeName('System.Xml.Xsl.XsltException')]
  DNXsltException = interface(DDN.mscorlib.DNSystemException)
  ['{12D02992-1EAD-31E9-8AC8-3F6D034A0BEC}']
  { getters & setters } 

    function get_SourceUri: string;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see langword="XsltException" />
    ///  properties into the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  class for the given <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  .</summary>
    ///  <param name="info">The <see langword="SerializationInfo" />
    ///  object. </param>
    ///  <param name="context">The <see langword="StreamingContext" />
    ///  object. </param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the location path of the style sheet.</summary>
    ///<returns>The location path of the style sheet.</returns>
    property SourceUri: string read get_SourceUri;
    ///<summary>Gets the line number indicating where the error occurred in the style sheet.</summary>
    ///<returns>The line number indicating where the error occurred in the style sheet.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the line position indicating where the error occurred in the style sheet.</summary>
    ///<returns>The line position indicating where the error occurred in the style sheet.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets the formatted error message describing the current exception.</summary>
    ///<returns>The formatted error message describing the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXsltException = class(TDNGenericImport<DNXsltExceptionClass, DNXsltException>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXsltCompileExceptionClass = interface(DNXsltExceptionClass)
  ['{8DB20846-5093-53A4-948B-B06CBC38CE68}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltCompileException" />
    ///  class.</summary>
    {class} function init: DNXsltCompileException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltCompileException" />
    ///  class with a specified error message.</summary>
    ///  <param name="message">The message that describes the error.</param>
    {class} function init(message: string): DNXsltCompileException; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltCompileException" />
    ///  class specified error message and a reference to the inner exception that is the cause of this exception.</summary>
    ///  <param name="message">The message that describes the error.</param>
    ///  <param name="innerException">The exception that is the cause of the current exception, or <see langword="null" />
    ///  if no inner exception is specified. </param>
    {class} function init(message: string; innerException: DDN.mscorlib.DNException): DNXsltCompileException; overload;
    ///<summary>Initializes a new instance of the <see langword="XsltCompileException" />
    ///  class.</summary>
    ///  <param name="inner">The <see cref="T:System.Exception" />
    ///  that threw the <see langword="XsltCompileException" />
    ///  . </param>
    ///  <param name="sourceUri">The location path of the style sheet. </param>
    ///  <param name="lineNumber">The line number indicating where the error occurred in the style sheet. </param>
    ///  <param name="linePosition">The line position indicating where the error occurred in the style sheet. </param>
    {class} function init(inner: DDN.mscorlib.DNException; sourceUri: string; lineNumber: Int32; linePosition: Int32): DNXsltCompileException; overload;

  end;

  ///<summary>The exception that is thrown by the Load method when an error is found in the XSLT style sheet.</summary>
  [DNTypeName('System.Xml.Xsl.XsltCompileException')]
  DNXsltCompileException = interface(DNXsltException)
  ['{707BE9AA-4FED-3490-8C33-EF4FE145ED64}']
  { getters & setters } 

    function get_SourceUri: string;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_Message: string;
    function get_Data: DDN.mscorlib.DNIDictionary;
    function get_InnerException: DDN.mscorlib.DNException;
    function get_TargetSite: DDN.mscorlib.DNMethodBase;
    function get_StackTrace: string;
    function get_HelpLink: string;
    procedure set_HelpLink(value: string);
    function get_Source: string;
    procedure set_Source(value: string);
    function get_HResult: Int32;

  { methods } 

    ///<summary>Streams all the <see langword="XsltCompileException" />
    ///  properties into the <see cref="T:System.Runtime.Serialization.SerializationInfo" />
    ///  class for the given <see cref="T:System.Runtime.Serialization.StreamingContext" />
    ///  .</summary>
    ///  <param name="info">The <see langword="SerializationInfo" />
    ///  object. </param>
    ///  <param name="context">The <see langword="StreamingContext" />
    ///  object. </param>
    procedure GetObjectData(info: DDN.mscorlib.DNSerializationInfo; context: DDN.mscorlib.DNStreamingContext);
    function GetBaseException: DDN.mscorlib.DNException;
    function ToString: string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets the location path of the style sheet.</summary>
    ///<returns>The location path of the style sheet.</returns>
    property SourceUri: string read get_SourceUri;
    ///<summary>Gets the line number indicating where the error occurred in the style sheet.</summary>
    ///<returns>The line number indicating where the error occurred in the style sheet.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the line position indicating where the error occurred in the style sheet.</summary>
    ///<returns>The line position indicating where the error occurred in the style sheet.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets the formatted error message describing the current exception.</summary>
    ///<returns>The formatted error message describing the current exception.</returns>
    property Message: string read get_Message;
    property Data: DDN.mscorlib.DNIDictionary read get_Data;
    property InnerException: DDN.mscorlib.DNException read get_InnerException;
    property TargetSite: DDN.mscorlib.DNMethodBase read get_TargetSite;
    property StackTrace: string read get_StackTrace;
    property HelpLink: string read get_HelpLink write set_HelpLink;
    property Source: string read get_Source write set_Source;
    property HResult: Int32 read get_HResult;
  end;

  TDNXsltCompileException = class(TDNGenericImport<DNXsltCompileExceptionClass, DNXsltCompileException>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlDeserializationEventsClass = interface(DDN.mscorlib.DNValueTypeClass)
  ['{1E3AD3F0-8C17-5012-B8B6-8083974C1A6D}']
  end;

  ///<summary>Contains fields that can be used to pass event delegates to a thread-safe <see cref="Overload:System.Xml.Serialization.XmlSerializer.Deserialize" />
  ///  method of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  .</summary>
  [DNTypeName('System.Xml.Serialization.XmlDeserializationEvents')]
  DNXmlDeserializationEvents = interface(DDN.mscorlib.DNValueType)
  ['{F43B6678-EEDE-3EC6-9E8D-54F7ABE697FF}']
  { getters & setters } 

    function get_OnUnknownNode: DNXmlNodeEventHandler;
    procedure set_OnUnknownNode(value: DNXmlNodeEventHandler);
    function get_OnUnknownAttribute: DNXmlAttributeEventHandler;
    procedure set_OnUnknownAttribute(value: DNXmlAttributeEventHandler);
    function get_OnUnknownElement: DNXmlElementEventHandler;
    procedure set_OnUnknownElement(value: DNXmlElementEventHandler);
    function get_OnUnreferencedObject: DNUnreferencedObjectEventHandler;
    procedure set_OnUnreferencedObject(value: DNUnreferencedObjectEventHandler);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function ToString: string;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets or sets an object that represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownNode" />
    ///  event.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlNodeEventHandler" />
    ///  that points to the event handler.</returns>
    property OnUnknownNode: DNXmlNodeEventHandler read get_OnUnknownNode write set_OnUnknownNode;
    ///<summary>Gets or sets an object that represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownAttribute" />
    ///  event.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlAttributeEventHandler" />
    ///  that points to the event handler.</returns>
    property OnUnknownAttribute: DNXmlAttributeEventHandler read get_OnUnknownAttribute write set_OnUnknownAttribute;
    ///<summary>Gets or sets an object that represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnknownElement" />
    ///  event.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlElementEventHandler" />
    ///  that points to the event handler.</returns>
    property OnUnknownElement: DNXmlElementEventHandler read get_OnUnknownElement write set_OnUnknownElement;
    ///<summary>Gets or sets an object that represents the method that handles the <see cref="E:System.Xml.Serialization.XmlSerializer.UnreferencedObject" />
    ///  event.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.UnreferencedObjectEventHandler" />
    ///  that points to the event handler.</returns>
    property OnUnreferencedObject: DNUnreferencedObjectEventHandler read get_OnUnreferencedObject write set_OnUnreferencedObject;
  end;

  TDNXmlDeserializationEvents = class(TDNGenericImport<DNXmlDeserializationEventsClass, DNXmlDeserializationEvents>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaCollectionClass = interface(DNObjectClass)
  ['{B466F60F-7412-5C08-98BC-E0DEF0883D89}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see langword="XmlSchemaCollection" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaCollection; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlSchemaCollection" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  . The <see langword="XmlNameTable" />
    ///  is used when loading schemas.</summary>
    ///  <param name="nametable">The <see langword="XmlNameTable" />
    ///  to use. </param>
    {class} function init(nametable: DNXmlNameTable): DNXmlSchemaCollection; overload;

  end;

  ///<summary>Contains a cache of XML Schema definition language (XSD) and XML-Data Reduced (XDR) schemas. The <see cref="T:System.Xml.Schema.XmlSchemaCollection" />
  ///  class class is obsolete. Use <see cref="T:System.Xml.Schema.XmlSchemaSet" />
  ///  instead.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaCollection')]
  DNXmlSchemaCollection = interface(DDN.mscorlib.DNICollection)
  ['{07C2EA08-5030-372B-8B74-B250123E74E4}']
  { getters & setters } 

    function get_Count: Int32;
    function get_NameTable: DNXmlNameTable;
    function get_Item(ns: string): DNXmlSchema;

  { events } 

    procedure add_ValidationEventHandler(value: DNValidationEventHandler);
    procedure remove_ValidationEventHandler(value: DNValidationEventHandler);

  { methods } 

    ///<summary>Adds the schema located by the given URL into the schema collection.</summary>
    ///  <param name="ns">The namespace URI associated with the schema. For XML Schemas, this will typically be the <see langword="targetNamespace" />
    ///  . </param>
    ///  <param name="uri">The URL that specifies the schema to load. </param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  added to the schema collection; <see langword="null" />
    ///  if the schema being added is an XDR schema or if there are compilation errors in the schema. </returns>
    ///<exception cref="T:System.Xml.XmlException">The schema is not a valid schema. </exception>
    function Add(ns: string; uri: string): DNXmlSchema; overload;
    ///<summary>Adds the schema contained in the <see cref="T:System.Xml.XmlReader" />
    ///  to the schema collection.</summary>
    ///  <param name="ns">The namespace URI associated with the schema. For XML Schemas, this will typically be the <see langword="targetNamespace" />
    ///  . </param>
    ///  <param name="reader"><see cref="T:System.Xml.XmlReader" />
    ///  containing the schema to add. </param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  added to the schema collection; <see langword="null" />
    ///  if the schema being added is an XDR schema or if there are compilation errors in the schema.</returns>
    ///<exception cref="T:System.Xml.XmlException">The schema is not a valid schema. </exception>
    function Add(ns: string; reader: DNXmlReader): DNXmlSchema; overload;
    ///<summary>Adds the schema contained in the <see cref="T:System.Xml.XmlReader" />
    ///  to the schema collection. The specified <see cref="T:System.Xml.XmlResolver" />
    ///  is used to resolve any external resources.</summary>
    ///  <param name="ns">The namespace URI associated with the schema. For XML Schemas, this will typically be the <see langword="targetNamespace" />
    ///  . </param>
    ///  <param name="reader"><see cref="T:System.Xml.XmlReader" />
    ///  containing the schema to add. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve namespaces referenced in <see langword="include" />
    ///  and <see langword="import" />
    ///  elements or <see langword="x-schema" />
    ///  attribute (XDR schemas). If this is <see langword="null" />
    ///  , external references are not resolved. </param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  added to the schema collection; <see langword="null" />
    ///  if the schema being added is an XDR schema or if there are compilation errors in the schema.</returns>
    ///<exception cref="T:System.Xml.XmlException">The schema is not a valid schema. </exception>
    function Add(ns: string; reader: DNXmlReader; resolver: DNXmlResolver): DNXmlSchema; overload;
    ///<summary>Adds the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to the collection.</summary>
    ///  <param name="schema">The <see langword="XmlSchema" />
    ///  to add to the collection. </param>
    ///<returns>The <see langword="XmlSchema" />
    ///  object.</returns>
    function Add(schema: DNXmlSchema): DNXmlSchema; overload;
    ///<summary>Adds the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to the collection. The specified <see cref="T:System.Xml.XmlResolver" />
    ///  is used to resolve any external references.</summary>
    ///  <param name="schema">The <see langword="XmlSchema" />
    ///  to add to the collection. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve namespaces referenced in <see langword="include" />
    ///  and <see langword="import" />
    ///  elements. If this is <see langword="null" />
    ///  , external references are not resolved. </param>
    ///<returns>The <see langword="XmlSchema" />
    ///  added to the schema collection.</returns>
    ///<exception cref="T:System.Xml.XmlException">The schema is not a valid schema. </exception>
    function Add(schema: DNXmlSchema; resolver: DNXmlResolver): DNXmlSchema; overload;
    ///<summary>Adds all the namespaces defined in the given collection (including their associated schemas) to this collection.</summary>
    ///  <param name="schema">The <see langword="XmlSchemaCollection" />
    ///  you want to add to this collection. </param>
    procedure Add(schema: DNXmlSchemaCollection); overload;
    ///<summary>Gets a value indicating whether the <see langword="targetNamespace" />
    ///  of the specified <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  is in the collection.</summary>
    ///  <param name="schema">The <see langword="XmlSchema" />
    ///  object. </param>
    ///<returns><see langword="true" />
    ///  if there is a schema in the collection with the same <see langword="targetNamespace" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(schema: DNXmlSchema): Boolean; overload;
    ///<summary>Gets a value indicating whether a schema with the specified namespace is in the collection.</summary>
    ///  <param name="ns">The namespace URI associated with the schema. For XML Schemas, this will typically be the target namespace. </param>
    ///<returns><see langword="true" />
    ///  if a schema with the specified namespace is in the collection; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(ns: string): Boolean; overload;
    ///<summary>Provides support for the "for each" style iteration over the collection of schemas.</summary>
    ///<returns>An enumerator for iterating over all schemas in the current collection.</returns>
    function GetEnumerator: DNXmlSchemaCollectionEnumerator;
    ///<summary>Copies all the <see langword="XmlSchema" />
    ///  objects from this collection into the given array starting at the given index.</summary>
    ///  <param name="array">The array to copy the objects to. </param>
    ///  <param name="index">The index in <paramref name="array" />
    ///  where copying will begin. </param>
    procedure CopyTo(&array: TArray<DNXmlSchema>; index: Int32);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of namespaces defined in this collection.</summary>
    ///<returns>The number of namespaces defined in this collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets the default <see langword="XmlNameTable" />
    ///  used by the <see langword="XmlSchemaCollection" />
    ///  when loading new schemas.</summary>
    ///<returns>An <see langword="XmlNameTable" />
    ///  .</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    property Item[ns: string]: DNXmlSchema read get_Item; default;
  end;

  TDNXmlSchemaCollection = class(TDNGenericImport<DNXmlSchemaCollectionClass, DNXmlSchemaCollection>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaCollectionEnumeratorClass = interface(DNObjectClass)
  ['{9CFC4530-B83B-5D91-B879-039B03C1C6B7}']
  end;

  ///<summary>Supports a simple iteration over a collection. This class cannot be inherited. </summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaCollectionEnumerator')]
  DNXmlSchemaCollectionEnumerator = interface(DDN.mscorlib.DNIEnumerator)
  ['{67511776-E360-33B6-B6CF-F5D50EDD940F}']
  { getters & setters } 

    function get_Current: DNXmlSchema;

  { methods } 

    ///<summary>Advances the enumerator to the next schema in the collection.</summary>
    ///<returns><see langword="true" />
    ///  if the move was successful; <see langword="false" />
    ///  if the enumerator has passed the end of the collection.</returns>
    function MoveNext: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the current <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  in the collection.</summary>
    ///<returns>The current <see langword="XmlSchema" />
    ///  in the collection.</returns>
    property Current: DNXmlSchema read get_Current;
  end;

  TDNXmlSchemaCollectionEnumerator = class(TDNGenericImport<DNXmlSchemaCollectionEnumeratorClass, DNXmlSchemaCollectionEnumerator>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaCompilationSettingsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{BC03EB50-C5AF-5D01-B23B-153DCDBC4324}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" />
    ///  class. </summary>
    {class} function init: DNXmlSchemaCompilationSettings;

  end;

  ///<summary>Provides schema compilation options for the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
  ///  class This class cannot be inherited.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaCompilationSettings')]
  DNXmlSchemaCompilationSettings = interface(DDN.mscorlib.DNObject)
  ['{97EE4B70-692A-3087-8C45-C10098A42C8A}']
  { getters & setters } 

    function get_EnableUpaCheck: Boolean;
    procedure set_EnableUpaCheck(value: Boolean);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  should check for Unique Particle Attribution (UPA) violations.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  should check for Unique Particle Attribution (UPA) violations; otherwise, <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property EnableUpaCheck: Boolean read get_EnableUpaCheck write set_EnableUpaCheck;
  end;

  TDNXmlSchemaCompilationSettings = class(TDNGenericImport<DNXmlSchemaCompilationSettingsClass, DNXmlSchemaCompilationSettings>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaDatatypeClass = interface(DDN.mscorlib.DNObjectClass)
  ['{69D9537D-424E-5F19-8DA5-EDBFCB8ED738}']
  end;

  ///<summary>The <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
  ///  class is an abstract class for mapping XML Schema definition language (XSD) types to Common Language Runtime (CLR) types.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaDatatype')]
  DNXmlSchemaDatatype = interface(DDN.mscorlib.DNObject)
  ['{8EE63134-3EA0-3773-A886-3AB9AEF07C8B}']
  { getters & setters } 

    function get_ValueType: DDN.mscorlib.DNType;
    function get_TokenizedType: DNXmlTokenizedType;
    function get_Variety: DNXmlSchemaDatatypeVariety;
    function get_TypeCode: DNXmlTypeCode;

  { methods } 

    ///<summary>Converts the value specified, whose type is one of the valid Common Language Runtime (CLR) representations of the XML schema type represented by the <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  , to the CLR type specified.</summary>
    ///  <param name="value">The input value to convert to the specified type.</param>
    ///  <param name="targetType">The target type to convert the input value to.</param>
    ///<returns>The converted input value.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Object" />
    ///  or <see cref="T:System.Type" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The type represented by the <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  does not support a conversion from type of the value specified to the type specified.</exception>
    function ChangeType(value: DDN.mscorlib.DNObject; targetType: DDN.mscorlib.DNType): DDN.mscorlib.DNObject; overload;
    ///<summary>Converts the value specified, whose type is one of the valid Common Language Runtime (CLR) representations of the XML schema type represented by the <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  , to the CLR type specified using the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  if the <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  represents the xs:QName type or a type derived from it.</summary>
    ///  <param name="value">The input value to convert to the specified type.</param>
    ///  <param name="targetType">The target type to convert the input value to.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  used for resolving namespace prefixes. This is only of use if the <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  represents the xs:QName type or a type derived from it.</param>
    ///<returns>The converted input value.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Object" />
    ///  or <see cref="T:System.Type" />
    ///  parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The type represented by the <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  does not support a conversion from type of the value specified to the type specified.</exception>
    function ChangeType(value: DDN.mscorlib.DNObject; targetType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>The <see cref="M:System.Xml.Schema.XmlSchemaDatatype.IsDerivedFrom(System.Xml.Schema.XmlSchemaDatatype)" />
    ///  method always returns <see langword="false" />
    ///  .</summary>
    ///  <param name="datatype">The <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  .</param>
    ///<returns>Always returns <see langword="false" />
    ///  .</returns>
    function IsDerivedFrom(datatype: DNXmlSchemaDatatype): Boolean;
    ///<summary>When overridden in a derived class, validates the <see langword="string" />
    ///  specified against a built-in or user-defined simple type.</summary>
    ///  <param name="s">The <see langword="string" />
    ///  to validate against the simple type.</param>
    ///  <param name="nameTable">The <see cref="T:System.Xml.XmlNameTable" />
    ///  to use for atomization while parsing the <see langword="string" />
    ///  if this <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  object represents the xs:NCName type. </param>
    ///  <param name="nsmgr">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object to use while parsing the <see langword="string" />
    ///  if this <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  object represents the xs:QName type.</param>
    ///<returns>An <see cref="T:System.Object" />
    ///  that can be cast safely to the type returned by the <see cref="P:System.Xml.Schema.XmlSchemaDatatype.ValueType" />
    ///  property.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The input value is not a valid instance of this W3C XML Schema type.</exception><exception cref="T:System.ArgumentNullException">The value to parse cannot be <see langword="null" />
    ///  .</exception>
    function ParseValue(s: string; nameTable: DNXmlNameTable; nsmgr: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, gets the Common Language Runtime (CLR) type of the item.</summary>
    ///<returns>The Common Language Runtime (CLR) type of the item.</returns>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    ///<summary>When overridden in a derived class, gets the type for the <see langword="string" />
    ///  as specified in the World Wide Web Consortium (W3C) XML 1.0 specification.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlTokenizedType" />
    ///  value for the <see langword="string" />
    ///  .</returns>
    property TokenizedType: DNXmlTokenizedType read get_TokenizedType;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaDatatypeVariety" />
    ///  value for the simple type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaDatatypeVariety" />
    ///  value for the simple type.</returns>
    property Variety: DNXmlSchemaDatatypeVariety read get_Variety;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  value for the simple type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  value for the simple type.</returns>
    property TypeCode: DNXmlTypeCode read get_TypeCode;
  end;

  TDNXmlSchemaDatatype = class(TDNGenericImport<DNXmlSchemaDatatypeClass, DNXmlSchemaDatatype>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaInferenceClass = interface(DDN.mscorlib.DNObjectClass)
  ['{8A85A5E3-6630-5B85-AF7F-3E2E27BD183C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInference" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaInference;

  end;

  ///<summary>Infers an XML Schema Definition Language (XSD) schema from an XML document. The <see cref="T:System.Xml.Schema.XmlSchemaInference" />
  ///  class cannot be inherited.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaInference')]
  DNXmlSchemaInference = interface(DDN.mscorlib.DNObject)
  ['{0D32CCEE-AA40-3A11-A8B2-DE2E4B9632F3}']
  { getters & setters } 

    function get_Occurrence: DNXmlSchemaInference_InferenceOption;
    procedure set_Occurrence(value: DNXmlSchemaInference_InferenceOption);
    function get_TypeInference: DNXmlSchemaInference_InferenceOption;
    procedure set_TypeInference(value: DNXmlSchemaInference_InferenceOption);

  { methods } 

    ///<summary>Infers an XML Schema Definition Language (XSD) schema from the XML document contained in the <see cref="T:System.Xml.XmlReader" />
    ///  object specified.</summary>
    ///  <param name="instanceDocument">An <see cref="T:System.Xml.XmlReader" />
    ///  object containing the XML document to infer a schema from.</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object containing the inferred schemas.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML document is not well-formed.</exception><exception cref="T:System.Xml.Schema.XmlSchemaInferenceException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is not positioned on the root node or on an element. An error occurs during the schema inference process.</exception>
    function InferSchema(instanceDocument: DNXmlReader): DNXmlSchemaSet; overload;
    ///<summary>Infers an XML Schema Definition Language (XSD) schema from the XML document contained in the <see cref="T:System.Xml.XmlReader" />
    ///  object specified, and refines the inferred schema using an existing schema in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object specified with the same target namespace.</summary>
    ///  <param name="instanceDocument">An <see cref="T:System.Xml.XmlReader" />
    ///  object containing the XML document to infer a schema from.</param>
    ///  <param name="schemas">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object containing an existing schema used to refine the inferred schema.</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object containing the inferred schemas.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML document is not well-formed.</exception><exception cref="T:System.Xml.Schema.XmlSchemaInferenceException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is not positioned on the root node or on an element. An error occurs during the schema inference process.</exception>
    function InferSchema(instanceDocument: DNXmlReader; schemas: DNXmlSchemaSet): DNXmlSchemaSet; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaInference.InferenceOption" />
    ///  value that affects schema occurrence declarations inferred from the XML document.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaInference.InferenceOption" />
    ///  object.</returns>
    property Occurrence: DNXmlSchemaInference_InferenceOption read get_Occurrence write set_Occurrence;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaInference.InferenceOption" />
    ///  value that affects types inferred from the XML document.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaInference.InferenceOption" />
    ///  object.</returns>
    property TypeInference: DNXmlSchemaInference_InferenceOption read get_TypeInference write set_TypeInference;
  end;

  TDNXmlSchemaInference = class(TDNGenericImport<DNXmlSchemaInferenceClass, DNXmlSchemaInference>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaInfoClass = interface(DNObjectClass)
  ['{80FF2DD1-35AC-5A22-B795-D99E466BCF96}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaInfo;

  end;

  ///<summary>Represents the post-schema-validation infoset of a validated XML node.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaInfo')]
  DNXmlSchemaInfo = interface(DNIXmlSchemaInfo)
  ['{7D360325-9956-3DD6-A123-74B4772BDB4E}']
  { getters & setters } 

    function get_Validity: DNXmlSchemaValidity;
    procedure set_Validity(value: DNXmlSchemaValidity);
    function get_IsDefault: Boolean;
    procedure set_IsDefault(value: Boolean);
    function get_IsNil: Boolean;
    procedure set_IsNil(value: Boolean);
    function get_MemberType: DNXmlSchemaSimpleType;
    procedure set_MemberType(value: DNXmlSchemaSimpleType);
    function get_SchemaType: DNXmlSchemaType;
    procedure set_SchemaType(value: DNXmlSchemaType);
    function get_SchemaElement: DNXmlSchemaElement;
    procedure set_SchemaElement(value: DNXmlSchemaElement);
    function get_SchemaAttribute: DNXmlSchemaAttribute;
    procedure set_SchemaAttribute(value: DNXmlSchemaAttribute);
    function get_ContentType: DNXmlSchemaContentType;
    procedure set_ContentType(value: DNXmlSchemaContentType);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaValidity" />
    ///  value of this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaValidity" />
    ///  value.</returns>
    property Validity: DNXmlSchemaValidity read get_Validity write set_Validity;
    ///<summary>Gets or sets a value indicating if this validated XML node was set as the result of a default being applied during XML Schema Definition Language (XSD) schema validation.</summary>
    ///<returns>A <see langword="bool" />
    ///  value.</returns>
    property IsDefault: Boolean read get_IsDefault write set_IsDefault;
    ///<summary>Gets or sets a value indicating if the value for this validated XML node is nil.</summary>
    ///<returns>A <see langword="bool" />
    ///  value.</returns>
    property IsNil: Boolean read get_IsNil write set_IsNil;
    ///<summary>Gets or sets the dynamic schema type for this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  object.</returns>
    property MemberType: DNXmlSchemaSimpleType read get_MemberType write set_MemberType;
    ///<summary>Gets or sets the static XML Schema Definition Language (XSD) schema type of this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object.</returns>
    property SchemaType: DNXmlSchemaType read get_SchemaType write set_SchemaType;
    ///<summary>Gets or sets the compiled <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  object that corresponds to this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  object.</returns>
    property SchemaElement: DNXmlSchemaElement read get_SchemaElement write set_SchemaElement;
    ///<summary>Gets or sets the compiled <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  object that corresponds to this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  object.</returns>
    property SchemaAttribute: DNXmlSchemaAttribute read get_SchemaAttribute write set_SchemaAttribute;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaContentType" />
    ///  object that corresponds to the content type of this validated XML node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaContentType" />
    ///  object.</returns>
    property ContentType: DNXmlSchemaContentType read get_ContentType write set_ContentType;
  end;

  TDNXmlSchemaInfo = class(TDNGenericImport<DNXmlSchemaInfoClass, DNXmlSchemaInfo>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaObjectClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0250456E-EBEA-5583-AA0A-B9F54DAB734E}']
  end;

  ///<summary>Represents the root class for the Xml schema object model hierarchy and serves as a base class for classes such as the <see cref="T:System.Xml.Schema.XmlSchema" />
  ///  class.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaObject')]
  DNXmlSchemaObject = interface(DDN.mscorlib.DNObject)
  ['{83E9E35E-8F9E-3F9F-A9E9-B1999304E6FD}']
  { getters & setters } 

    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaObject = class(TDNGenericImport<DNXmlSchemaObjectClass, DNXmlSchemaObject>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaClass = interface(DNXmlSchemaObjectClass)
  ['{7248DFD9-39DA-5D4C-8B98-25C3608AEEE2}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  class.</summary>
    {class} function init: DNXmlSchema;

  { static methods } 

    ///<summary>Reads an XML Schema from the supplied <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="TextReader" />
    ///  containing the XML Schema to read. </param>
    ///  <param name="validationEventHandler">The validation event handler that receives information about the XML Schema syntax errors. </param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object representing the XML Schema.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">An <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is raised if no <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified.</exception>
    {class} function Read(reader: DDN.mscorlib.DNTextReader; validationEventHandler: DNValidationEventHandler): DNXmlSchema; overload;
    ///<summary>Reads an XML Schema  from the supplied stream.</summary>
    ///  <param name="stream">The supplied data stream. </param>
    ///  <param name="validationEventHandler">The validation event handler that receives information about XML Schema syntax errors. </param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object representing the XML Schema.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">An <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is raised if no <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified.</exception>
    {class} function Read(stream: DDN.mscorlib.DNStream; validationEventHandler: DNValidationEventHandler): DNXmlSchema; overload;
    ///<summary>Reads an XML Schema from the supplied <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  containing the XML Schema to read. </param>
    ///  <param name="validationEventHandler">The validation event handler that receives information about the XML Schema syntax errors. </param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object representing the XML Schema.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">An <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is raised if no <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified.</exception>
    {class} function Read(reader: DNXmlReader; validationEventHandler: DNValidationEventHandler): DNXmlSchema; overload;

  end;

  ///<summary>An in-memory representation of an XML Schema, as specified in the World Wide Web Consortium (W3C) XML Schema Part 1: Structures and XML Schema Part 2: Datatypes specifications.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchema')]
  DNXmlSchema = interface(DNXmlSchemaObject)
  ['{C6EC789B-76E3-3FC4-B6C0-383D1AB66E1E}']
  { getters & setters } 

    function get_AttributeFormDefault: DNXmlSchemaForm;
    procedure set_AttributeFormDefault(value: DNXmlSchemaForm);
    function get_BlockDefault: DNXmlSchemaDerivationMethod;
    procedure set_BlockDefault(value: DNXmlSchemaDerivationMethod);
    function get_FinalDefault: DNXmlSchemaDerivationMethod;
    procedure set_FinalDefault(value: DNXmlSchemaDerivationMethod);
    function get_ElementFormDefault: DNXmlSchemaForm;
    procedure set_ElementFormDefault(value: DNXmlSchemaForm);
    function get_TargetNamespace: string;
    procedure set_TargetNamespace(value: string);
    function get_Version: string;
    procedure set_Version(value: string);
    function get_Includes: DNXmlSchemaObjectCollection;
    function get_Items: DNXmlSchemaObjectCollection;
    function get_IsCompiled: Boolean;
    function get_Attributes: DNXmlSchemaObjectTable;
    function get_AttributeGroups: DNXmlSchemaObjectTable;
    function get_SchemaTypes: DNXmlSchemaObjectTable;
    function get_Elements: DNXmlSchemaObjectTable;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_Groups: DNXmlSchemaObjectTable;
    function get_Notations: DNXmlSchemaObjectTable;
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    ///<summary>Writes the XML Schema to the supplied data stream.</summary>
    ///  <param name="stream">The supplied data stream. </param>
    procedure Write(stream: DDN.mscorlib.DNStream); overload;
    ///<summary>Writes the XML Schema to the supplied <see cref="T:System.IO.Stream" />
    ///  using the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  specified.</summary>
    ///  <param name="stream">The supplied data stream. </param>
    ///  <param name="namespaceManager">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</param>
    procedure Write(stream: DDN.mscorlib.DNStream; namespaceManager: DNXmlNamespaceManager); overload;
    ///<summary>Writes the XML Schema to the supplied <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  to write to.</param>
    procedure Write(writer: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Writes the XML Schema to the supplied <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.IO.TextWriter" />
    ///  to write to.</param>
    ///  <param name="namespaceManager">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  . </param>
    procedure Write(writer: DDN.mscorlib.DNTextWriter; namespaceManager: DNXmlNamespaceManager); overload;
    ///<summary>Writes the XML Schema to the supplied <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  to write to. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="writer" />
    ///  parameter is null.</exception>
    procedure Write(writer: DNXmlWriter); overload;
    ///<summary>Compiles the XML Schema Object Model (SOM) into schema information for validation. Used to check the syntactic and semantic structure of the programmatically built SOM. Semantic validation checking is performed during compilation.</summary>
    ///  <param name="validationEventHandler">The validation event handler that receives information about the XML Schema validation errors. </param>
    ///  <param name="resolver">The <see langword="XmlResolver" />
    ///  used to resolve namespaces referenced in <see langword="include" />
    ///  and <see langword="import" />
    ///  elements. </param>
    procedure Compile(validationEventHandler: DNValidationEventHandler; resolver: DNXmlResolver); overload;
    ///<summary>Writes the XML Schema to the supplied <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  to write to.</param>
    ///  <param name="namespaceManager">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  . </param>
    procedure Write(writer: DNXmlWriter; namespaceManager: DNXmlNamespaceManager); overload;
    ///<summary>Compiles the XML Schema Object Model (SOM) into schema information for validation. Used to check the syntactic and semantic structure of the programmatically built SOM. Semantic validation checking is performed during compilation.</summary>
    ///  <param name="validationEventHandler">The validation event handler that receives information about XML Schema validation errors. </param>
    procedure Compile(validationEventHandler: DNValidationEventHandler); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the form for attributes declared in the target namespace of the schema.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  value that indicates if attributes from the target namespace are required to be qualified with the namespace prefix. The default is <see cref="F:System.Xml.Schema.XmlSchemaForm.None" />
    ///  .</returns>
    property AttributeFormDefault: DNXmlSchemaForm read get_AttributeFormDefault write set_AttributeFormDefault;
    ///<summary>Gets or sets the <see langword="blockDefault" />
    ///  attribute which sets the default value of the <see langword="block" />
    ///  attribute on element and complex types in the <see langword="targetNamespace" />
    ///  of the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  value representing the different methods for preventing derivation. The default value is <see langword="XmlSchemaDerivationMethod.None" />
    ///  .</returns>
    property BlockDefault: DNXmlSchemaDerivationMethod read get_BlockDefault write set_BlockDefault;
    ///<summary>Gets or sets the <see langword="finalDefault" />
    ///  attribute which sets the default value of the <see langword="final" />
    ///  attribute on elements and complex types in the target namespace of the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  value representing the different methods for preventing derivation. The default value is <see langword="XmlSchemaDerivationMethod.None" />
    ///  .</returns>
    property FinalDefault: DNXmlSchemaDerivationMethod read get_FinalDefault write set_FinalDefault;
    ///<summary>Gets or sets the form for elements declared in the target namespace of the schema.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  value that indicates if elements from the target namespace are required to be qualified with the namespace prefix. The default is <see cref="F:System.Xml.Schema.XmlSchemaForm.None" />
    ///  .</returns>
    property ElementFormDefault: DNXmlSchemaForm read get_ElementFormDefault write set_ElementFormDefault;
    ///<summary>Gets or sets the Uniform Resource Identifier (URI) of the schema target namespace.</summary>
    ///<returns>The schema target namespace.</returns>
    property TargetNamespace: string read get_TargetNamespace write set_TargetNamespace;
    ///<summary>Gets or sets the version of the schema.</summary>
    ///<returns>The version of the schema. The default value is <see langword="String.Empty" />
    ///  .</returns>
    property Version: string read get_Version write set_Version;
    ///<summary>Gets the collection of included and imported schemas.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectCollection" />
    ///  of the included and imported schemas.</returns>
    property Includes: DNXmlSchemaObjectCollection read get_Includes;
    ///<summary>Gets the collection of schema elements in the schema and is used to add new element types at the <see langword="schema" />
    ///  element level.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectCollection" />
    ///  of schema elements in the schema.</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    ///<summary>Indicates if the schema has been compiled.</summary>
    ///<returns><see langword="true" />
    ///  if schema has been compiled, otherwise, <see langword="false" />
    ///  . The default value is <see langword="false" />
    ///  .</returns>
    property IsCompiled: Boolean read get_IsCompiled;
    ///<summary>Gets the post-schema-compilation value for all the attributes in the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  collection of all the attributes in the schema.</returns>
    property Attributes: DNXmlSchemaObjectTable read get_Attributes;
    ///<summary>Gets the post-schema-compilation value of all the global attribute groups in the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  collection of all the global attribute groups in the schema.</returns>
    property AttributeGroups: DNXmlSchemaObjectTable read get_AttributeGroups;
    ///<summary>Gets the post-schema-compilation value of all schema types in the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectCollection" />
    ///  of all schema types in the schema.</returns>
    property SchemaTypes: DNXmlSchemaObjectTable read get_SchemaTypes;
    ///<summary>Gets the post-schema-compilation value for all the elements in the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  collection of all the elements in the schema.</returns>
    property Elements: DNXmlSchemaObjectTable read get_Elements;
    ///<summary>Gets or sets the string ID.</summary>
    ///<returns>The ID of the string. The default value is <see langword="String.Empty" />
    ///  .</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets and sets the qualified attributes which do not belong to the schema target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    ///<summary>Gets the post-schema-compilation value of all the groups in the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  collection of all the groups in the schema.</returns>
    property Groups: DNXmlSchemaObjectTable read get_Groups;
    ///<summary>Gets the post-schema-compilation value for all notations in the schema.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  collection of all notations in the schema.</returns>
    property Notations: DNXmlSchemaObjectTable read get_Notations;
    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchema = class(TDNGenericImport<DNXmlSchemaClass, DNXmlSchema>)
  public const
    ///<summary>The XML schema namespace. This field is constant.</summary>
   Namespace = 'http://www.w3.org/2001/XMLSchema';
    ///<summary>The XML schema instance namespace. This field is constant. </summary>
   InstanceNamespace = 'http://www.w3.org/2001/XMLSchema-instance';
  end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAnnotatedClass = interface(DNXmlSchemaObjectClass)
  ['{3216C5BF-5913-56B8-B0B0-5FB3E3A227A4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAnnotated" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAnnotated;

  end;

  ///<summary>The base class for any element that can contain annotation elements.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAnnotated')]
  DNXmlSchemaAnnotated = interface(DNXmlSchemaObject)
  ['{0DF3E834-EAC2-3865-A25E-59688BA0D688}']
  { getters & setters } 

    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAnnotated = class(TDNGenericImport<DNXmlSchemaAnnotatedClass, DNXmlSchemaAnnotated>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAnyAttributeClass = interface(DNXmlSchemaAnnotatedClass)
  ['{9CFB6250-AF0C-5AA0-B7D8-350EB7F732AE}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAnyAttribute;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="anyAttribute" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAnyAttribute')]
  DNXmlSchemaAnyAttribute = interface(DNXmlSchemaAnnotated)
  ['{40C424F4-9190-3790-8AD0-55CC187B217F}']
  { getters & setters } 

    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_ProcessContents: DNXmlSchemaContentProcessing;
    procedure set_ProcessContents(value: DNXmlSchemaContentProcessing);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the namespaces containing the attributes that can be used.</summary>
    ///<returns>Namespaces for attributes that are available for use. The default is <see langword="##any" />
    ///  .Optional.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets information about how an application or XML processor should handle the validation of XML documents for the attributes specified by the <see langword="anyAttribute" />
    ///  element.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaContentProcessing" />
    ///  values. If no <see langword="processContents" />
    ///  attribute is specified, the default is <see langword="Strict" />
    ///  .</returns>
    property ProcessContents: DNXmlSchemaContentProcessing read get_ProcessContents write set_ProcessContents;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAnyAttribute = class(TDNGenericImport<DNXmlSchemaAnyAttributeClass, DNXmlSchemaAnyAttribute>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAttributeClass = interface(DNXmlSchemaAnnotatedClass)
  ['{047C3279-9803-5740-9BDD-5599B358884C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAttribute;

  end;

  ///<summary>Represents the <see langword="attribute" />
  ///  element from the XML Schema as specified by the World Wide Web Consortium (W3C). Attributes provide additional information for other document elements. The attribute tag is nested between the tags of a document's element for the schema. The XML document displays attributes as named items in the opening tag of an element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAttribute')]
  DNXmlSchemaAttribute = interface(DNXmlSchemaAnnotated)
  ['{BC3ECB9B-06CE-3009-88C0-4148FBB2D47C}']
  { getters & setters } 

    function get_DefaultValue: string;
    procedure set_DefaultValue(value: string);
    function get_FixedValue: string;
    procedure set_FixedValue(value: string);
    function get_Form: DNXmlSchemaForm;
    procedure set_Form(value: DNXmlSchemaForm);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_RefName: DNXmlQualifiedName;
    procedure set_RefName(value: DNXmlQualifiedName);
    function get_SchemaTypeName: DNXmlQualifiedName;
    procedure set_SchemaTypeName(value: DNXmlQualifiedName);
    function get_SchemaType: DNXmlSchemaSimpleType;
    procedure set_SchemaType(value: DNXmlSchemaSimpleType);
    function get_Use: DNXmlSchemaUse;
    procedure set_Use(value: DNXmlSchemaUse);
    function get_QualifiedName: DNXmlQualifiedName;
    function get_AttributeType: DDN.mscorlib.DNObject;
    function get_AttributeSchemaType: DNXmlSchemaSimpleType;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the default value for the attribute.</summary>
    ///<returns>The default value for the attribute. The default is a null reference.Optional.</returns>
    property DefaultValue: string read get_DefaultValue write set_DefaultValue;
    ///<summary>Gets or sets the fixed value for the attribute.</summary>
    ///<returns>The fixed value for the attribute. The default is null.Optional.</returns>
    property FixedValue: string read get_FixedValue write set_FixedValue;
    ///<summary>Gets or sets the form for the attribute.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaForm" />
    ///  values. The default is the value of the <see cref="P:System.Xml.Schema.XmlSchema.AttributeFormDefault" />
    ///  of the schema element containing the attribute.Optional.</returns>
    property Form: DNXmlSchemaForm read get_Form write set_Form;
    ///<summary>Gets or sets the name of the attribute.</summary>
    ///<returns>The name of the attribute.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the name of an attribute declared in this schema (or another schema indicated by the specified namespace).</summary>
    ///<returns>The name of the attribute declared.</returns>
    property RefName: DNXmlQualifiedName read get_RefName write set_RefName;
    ///<summary>Gets or sets the name of the simple type defined in this schema (or another schema indicated by the specified namespace).</summary>
    ///<returns>The name of the simple type.</returns>
    property SchemaTypeName: DNXmlQualifiedName read get_SchemaTypeName write set_SchemaTypeName;
    ///<summary>Gets or sets the attribute type to a simple type.</summary>
    ///<returns>The simple type defined in this schema.</returns>
    property SchemaType: DNXmlSchemaSimpleType read get_SchemaType write set_SchemaType;
    ///<summary>Gets or sets information about how the attribute is used.</summary>
    ///<returns>One of the following values: None, Prohibited, Optional, or Required. The default is Optional.Optional.</returns>
    property Use: DNXmlSchemaUse read get_Use write set_Use;
    ///<summary>Gets the qualified name for the attribute.</summary>
    ///<returns>The post-compilation value of the <see langword="QualifiedName" />
    ///  property.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets the common language runtime (CLR) object based on the <see cref="P:System.Xml.Schema.XmlSchemaAttribute.SchemaType" />
    ///  or <see cref="P:System.Xml.Schema.XmlSchemaAttribute.SchemaTypeName" />
    ///  of the attribute that holds the post-compilation value of the <see langword="AttributeType" />
    ///  property.</summary>
    ///<returns>The common runtime library (CLR) object that holds the post-compilation value of the <see langword="AttributeType" />
    ///  property.</returns>
    property AttributeType: DDN.mscorlib.DNObject read get_AttributeType;
    ///<summary>Gets an <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  object representing the type of the attribute based on the <see cref="P:System.Xml.Schema.XmlSchemaAttribute.SchemaType" />
    ///  or <see cref="P:System.Xml.Schema.XmlSchemaAttribute.SchemaTypeName" />
    ///  of the attribute.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  object.</returns>
    property AttributeSchemaType: DNXmlSchemaSimpleType read get_AttributeSchemaType;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAttribute = class(TDNGenericImport<DNXmlSchemaAttributeClass, DNXmlSchemaAttribute>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAttributeGroupClass = interface(DNXmlSchemaAnnotatedClass)
  ['{2B7C70A0-EF92-5693-9746-5BF2129C1B94}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroup" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAttributeGroup;

  end;

  ///<summary>Represents the <see langword="attributeGroup" />
  ///  element from the XML Schema as specified by the World Wide Web Consortium (W3C). AttributesGroups provides a mechanism to group a set of attribute declarations so that they can be incorporated as a group into complex type definitions.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAttributeGroup')]
  DNXmlSchemaAttributeGroup = interface(DNXmlSchemaAnnotated)
  ['{35B10603-0991-3646-B2F1-9D2A3A9A0279}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Attributes: DNXmlSchemaObjectCollection;
    function get_AnyAttribute: DNXmlSchemaAnyAttribute;
    procedure set_AnyAttribute(value: DNXmlSchemaAnyAttribute);
    function get_QualifiedName: DNXmlQualifiedName;
    function get_RedefinedAttributeGroup: DNXmlSchemaAttributeGroup;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the attribute group.</summary>
    ///<returns>The name of the attribute group.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets the collection of attributes for the attribute group. Contains <see langword="XmlSchemaAttribute" />
    ///  and <see langword="XmlSchemaAttributeGroupRef" />
    ///  elements.</summary>
    ///<returns>The collection of attributes for the attribute group.</returns>
    property Attributes: DNXmlSchemaObjectCollection read get_Attributes;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the attribute group.</summary>
    ///<returns>The World Wide Web Consortium (W3C) <see langword="anyAttribute" />
    ///  element.</returns>
    property AnyAttribute: DNXmlSchemaAnyAttribute read get_AnyAttribute write set_AnyAttribute;
    ///<summary>Gets the qualified name of the attribute group.</summary>
    ///<returns>The qualified name of the attribute group.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets the redefined attribute group property from the XML Schema.</summary>
    ///<returns>The redefined attribute group property.</returns>
    property RedefinedAttributeGroup: DNXmlSchemaAttributeGroup read get_RedefinedAttributeGroup;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAttributeGroup = class(TDNGenericImport<DNXmlSchemaAttributeGroupClass, DNXmlSchemaAttributeGroup>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAttributeGroupRefClass = interface(DNXmlSchemaAnnotatedClass)
  ['{2E998C9E-B501-52C3-B5D9-6A3063D5B21D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroupRef" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAttributeGroupRef;

  end;

  ///<summary>Represents the <see langword="attributeGroup" />
  ///  element with the <see langword="ref" />
  ///  attribute from the XML Schema as specified by the World Wide Web Consortium (W3C). AttributesGroupRef is the reference for an attributeGroup, name property contains the attribute group being referenced. </summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAttributeGroupRef')]
  DNXmlSchemaAttributeGroupRef = interface(DNXmlSchemaAnnotated)
  ['{D6A224F8-7695-307E-9DDA-6B5A883A296B}']
  { getters & setters } 

    function get_RefName: DNXmlQualifiedName;
    procedure set_RefName(value: DNXmlQualifiedName);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the referenced <see langword="attributeGroup" />
    ///  element.</summary>
    ///<returns>The name of the referenced attribute group. The value must be a QName.</returns>
    property RefName: DNXmlQualifiedName read get_RefName write set_RefName;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAttributeGroupRef = class(TDNGenericImport<DNXmlSchemaAttributeGroupRefClass, DNXmlSchemaAttributeGroupRef>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaContentClass = interface(DNXmlSchemaAnnotatedClass)
  ['{CF8C2974-33B2-52C5-948F-35C36CF72365}']
  end;

  ///<summary>An abstract class for schema content.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaContent')]
  DNXmlSchemaContent = interface(DNXmlSchemaAnnotated)
  ['{9D9EE977-A3C6-3D61-8BB9-7336C0BF3836}']
  { getters & setters } 

    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaContent = class(TDNGenericImport<DNXmlSchemaContentClass, DNXmlSchemaContent>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaComplexContentExtensionClass = interface(DNXmlSchemaContentClass)
  ['{B07D050A-73F9-579D-BCD4-6E9D6CB66A78}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaComplexContentExtension" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaComplexContentExtension;

  end;

  ///<summary>Represents the <see langword="extension" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class is for complex types with complex content model derived by extension. It extends the complex type by adding attributes or elements.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaComplexContentExtension')]
  DNXmlSchemaComplexContentExtension = interface(DNXmlSchemaContent)
  ['{1526A89A-1CF2-393F-8C0D-8000E9588437}']
  { getters & setters } 

    function get_BaseTypeName: DNXmlQualifiedName;
    procedure set_BaseTypeName(value: DNXmlQualifiedName);
    function get_Particle: DNXmlSchemaParticle;
    procedure set_Particle(value: DNXmlSchemaParticle);
    function get_Attributes: DNXmlSchemaObjectCollection;
    function get_AnyAttribute: DNXmlSchemaAnyAttribute;
    procedure set_AnyAttribute(value: DNXmlSchemaAnyAttribute);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the complex type from which this type is derived by extension.</summary>
    ///<returns>The name of the complex type from which this type is derived by extension.</returns>
    property BaseTypeName: DNXmlQualifiedName read get_BaseTypeName write set_BaseTypeName;
    ///<summary>Gets or sets one of the <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</returns>
    property Particle: DNXmlSchemaParticle read get_Particle write set_Particle;
    ///<summary>Gets the collection of attributes for the complex content. Contains <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  and <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroupRef" />
    ///  elements.</summary>
    ///<returns>The collection of attributes for the complex content.</returns>
    property Attributes: DNXmlSchemaObjectCollection read get_Attributes;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the complex content model.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the complex content model.</returns>
    property AnyAttribute: DNXmlSchemaAnyAttribute read get_AnyAttribute write set_AnyAttribute;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaComplexContentExtension = class(TDNGenericImport<DNXmlSchemaComplexContentExtensionClass, DNXmlSchemaComplexContentExtension>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaComplexContentRestrictionClass = interface(DNXmlSchemaContentClass)
  ['{E30FF509-608C-500A-9A4F-981E166F4D69}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaComplexContentRestriction" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaComplexContentRestriction;

  end;

  ///<summary>Represents the <see langword="restriction" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class is for complex types with a complex content model derived by restriction. It restricts the contents of the complex type to a subset of the inherited complex type.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaComplexContentRestriction')]
  DNXmlSchemaComplexContentRestriction = interface(DNXmlSchemaContent)
  ['{4D19595C-ED72-346B-BBE6-38891A212A81}']
  { getters & setters } 

    function get_BaseTypeName: DNXmlQualifiedName;
    procedure set_BaseTypeName(value: DNXmlQualifiedName);
    function get_Particle: DNXmlSchemaParticle;
    procedure set_Particle(value: DNXmlSchemaParticle);
    function get_Attributes: DNXmlSchemaObjectCollection;
    function get_AnyAttribute: DNXmlSchemaAnyAttribute;
    procedure set_AnyAttribute(value: DNXmlSchemaAnyAttribute);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of a complex type from which this type is derived by restriction.</summary>
    ///<returns>The name of the complex type from which this type is derived by restriction.</returns>
    property BaseTypeName: DNXmlQualifiedName read get_BaseTypeName write set_BaseTypeName;
    ///<summary>Gets or sets one of the <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</returns>
    property Particle: DNXmlSchemaParticle read get_Particle write set_Particle;
    ///<summary>Gets the collection of attributes for the complex type. Contains the <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  and <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroupRef" />
    ///  elements.</summary>
    ///<returns>The collection of attributes for the complex type.</returns>
    property Attributes: DNXmlSchemaObjectCollection read get_Attributes;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the complex content model.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the complex content model.</returns>
    property AnyAttribute: DNXmlSchemaAnyAttribute read get_AnyAttribute write set_AnyAttribute;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaComplexContentRestriction = class(TDNGenericImport<DNXmlSchemaComplexContentRestrictionClass, DNXmlSchemaComplexContentRestriction>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleContentExtensionClass = interface(DNXmlSchemaContentClass)
  ['{CD975048-4D1D-5D13-B885-410BB0826C11}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleContentExtension" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleContentExtension;

  end;

  ///<summary>Represents the <see langword="extension" />
  ///  element for simple content from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to derive simple types by extension. Such derivations are used to extend the simple type content of the element by adding attributes.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleContentExtension')]
  DNXmlSchemaSimpleContentExtension = interface(DNXmlSchemaContent)
  ['{32708983-B0FF-3520-A8A3-30E534FADEFD}']
  { getters & setters } 

    function get_BaseTypeName: DNXmlQualifiedName;
    procedure set_BaseTypeName(value: DNXmlQualifiedName);
    function get_Attributes: DNXmlSchemaObjectCollection;
    function get_AnyAttribute: DNXmlSchemaAnyAttribute;
    procedure set_AnyAttribute(value: DNXmlSchemaAnyAttribute);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of a built-in data type or simple type from which this type is extended.</summary>
    ///<returns>The base type name.</returns>
    property BaseTypeName: DNXmlQualifiedName read get_BaseTypeName write set_BaseTypeName;
    ///<summary>Gets the collection of <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  and <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroupRef" />
    ///  .</summary>
    ///<returns>The collection of attributes for the <see langword="simpleType" />
    ///  element.</returns>
    property Attributes: DNXmlSchemaObjectCollection read get_Attributes;
    ///<summary>Gets or sets the <see langword="XmlSchemaAnyAttribute" />
    ///  to be used for the attribute value.</summary>
    ///<returns>The <see langword="XmlSchemaAnyAttribute" />
    ///  .Optional.</returns>
    property AnyAttribute: DNXmlSchemaAnyAttribute read get_AnyAttribute write set_AnyAttribute;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleContentExtension = class(TDNGenericImport<DNXmlSchemaSimpleContentExtensionClass, DNXmlSchemaSimpleContentExtension>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleContentRestrictionClass = interface(DNXmlSchemaContentClass)
  ['{46661E34-4839-5148-8C2A-8B1C449105EB}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleContentRestriction" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleContentRestriction;

  end;

  ///<summary>Represents the <see langword="restriction" />
  ///  element for simple content from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to derive simple types by restriction. Such derivations can be used to restrict the range of values for the element to a subset of the values specified in the inherited simple type.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleContentRestriction')]
  DNXmlSchemaSimpleContentRestriction = interface(DNXmlSchemaContent)
  ['{7243265D-820F-34F6-B86A-3B230DC16D26}']
  { getters & setters } 

    function get_BaseTypeName: DNXmlQualifiedName;
    procedure set_BaseTypeName(value: DNXmlQualifiedName);
    function get_BaseType: DNXmlSchemaSimpleType;
    procedure set_BaseType(value: DNXmlSchemaSimpleType);
    function get_Facets: DNXmlSchemaObjectCollection;
    function get_Attributes: DNXmlSchemaObjectCollection;
    function get_AnyAttribute: DNXmlSchemaAnyAttribute;
    procedure set_AnyAttribute(value: DNXmlSchemaAnyAttribute);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the built-in data type or simple type from which this type is derived.</summary>
    ///<returns>The name of the base type.</returns>
    property BaseTypeName: DNXmlQualifiedName read get_BaseTypeName write set_BaseTypeName;
    ///<summary>Gets or sets the simple type base value.</summary>
    ///<returns>The simple type base value.</returns>
    property BaseType: DNXmlSchemaSimpleType read get_BaseType write set_BaseType;
    ///<summary>Gets or sets an Xml Schema facet. </summary>
    ///<returns>One of the following facet classes:
    ///<see cref="T:System.Xml.Schema.XmlSchemaLengthFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMinLengthFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMaxLengthFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaPatternFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaEnumerationFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMaxInclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMaxExclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMinInclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMinExclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaFractionDigitsFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaTotalDigitsFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaWhiteSpaceFacet" />
    ///  .</returns>
    property Facets: DNXmlSchemaObjectCollection read get_Facets;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  and <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroupRef" />
    ///  collection of attributes for the simple type.</summary>
    ///<returns>The collection of attributes for a simple type.</returns>
    property Attributes: DNXmlSchemaObjectCollection read get_Attributes;
    ///<summary>Gets or sets an <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  to be used for the attribute value.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  for the attribute value.Optional.</returns>
    property AnyAttribute: DNXmlSchemaAnyAttribute read get_AnyAttribute write set_AnyAttribute;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleContentRestriction = class(TDNGenericImport<DNXmlSchemaSimpleContentRestrictionClass, DNXmlSchemaSimpleContentRestriction>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaContentModelClass = interface(DNXmlSchemaAnnotatedClass)
  ['{7FF05E65-54A1-5211-9A79-87BB9D514331}']
  end;

  ///<summary>Specifies the order and structure of the child elements of a type.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaContentModel')]
  DNXmlSchemaContentModel = interface(DNXmlSchemaAnnotated)
  ['{5321123C-01D3-39A8-A7BC-148F19620BAF}']
  { getters & setters } 

    function get_Content: DNXmlSchemaContent;
    procedure set_Content(value: DNXmlSchemaContent);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the content of the type.</summary>
    ///<returns>Provides the content of the type.</returns>
    property Content: DNXmlSchemaContent read get_Content write set_Content;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaContentModel = class(TDNGenericImport<DNXmlSchemaContentModelClass, DNXmlSchemaContentModel>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaComplexContentClass = interface(DNXmlSchemaContentModelClass)
  ['{0F0CC3A3-21A6-57D0-B0A7-B0169ED2330F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaComplexContent" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaComplexContent;

  end;

  ///<summary>Represents the <see langword="complexContent" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class represents the complex content model for complex types. It contains extensions or restrictions on a complex type that has either only elements or mixed content.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaComplexContent')]
  DNXmlSchemaComplexContent = interface(DNXmlSchemaContentModel)
  ['{4874A15E-EBD1-3EC1-BDD1-08FE68A8DA0C}']
  { getters & setters } 

    function get_IsMixed: Boolean;
    procedure set_IsMixed(value: Boolean);
    function get_Content: DNXmlSchemaContent;
    procedure set_Content(value: DNXmlSchemaContent);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets information that determines if the type has a mixed content model.</summary>
    ///<returns>If this property is <see langword="true" />
    ///  , character data is allowed to appear between the child elements of the complex type (mixed content model). The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsMixed: Boolean read get_IsMixed write set_IsMixed;
    ///<summary>Gets or sets the content.</summary>
    ///<returns>One of either the <see cref="T:System.Xml.Schema.XmlSchemaComplexContentRestriction" />
    ///  or <see cref="T:System.Xml.Schema.XmlSchemaComplexContentExtension" />
    ///  classes.</returns>
    property Content: DNXmlSchemaContent read get_Content write set_Content;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaComplexContent = class(TDNGenericImport<DNXmlSchemaComplexContentClass, DNXmlSchemaComplexContent>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleContentClass = interface(DNXmlSchemaContentModelClass)
  ['{F03ED66F-2E54-5AEB-8501-75008EE78C23}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleContent" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleContent;

  end;

  ///<summary>Represents the <see langword="simpleContent" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class is for simple and complex types with simple content model.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleContent')]
  DNXmlSchemaSimpleContent = interface(DNXmlSchemaContentModel)
  ['{9BCC3332-0A57-38C7-A257-C818878F3092}']
  { getters & setters } 

    function get_Content: DNXmlSchemaContent;
    procedure set_Content(value: DNXmlSchemaContent);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets one of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleContentRestriction" />
    ///  or <see cref="T:System.Xml.Schema.XmlSchemaSimpleContentExtension" />
    ///  .</summary>
    ///<returns>The content contained within the <see langword="XmlSchemaSimpleContentRestriction" />
    ///  or <see langword="XmlSchemaSimpleContentExtension" />
    ///  class.</returns>
    property Content: DNXmlSchemaContent read get_Content write set_Content;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleContent = class(TDNGenericImport<DNXmlSchemaSimpleContentClass, DNXmlSchemaSimpleContent>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaFacetClass = interface(DNXmlSchemaAnnotatedClass)
  ['{6EC693F0-E527-5444-92E7-11DBFCF15054}']
  end;

  ///<summary>Abstract class for all facets that are used when simple types are derived by restriction.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaFacet')]
  DNXmlSchemaFacet = interface(DNXmlSchemaAnnotated)
  ['{C7945853-D4C4-3A37-B593-BF9E57357120}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaFacet = class(TDNGenericImport<DNXmlSchemaFacetClass, DNXmlSchemaFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaEnumerationFacetClass = interface(DNXmlSchemaFacetClass)
  ['{7360714B-151E-5C94-8A30-AF9E976E3A67}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaEnumerationFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaEnumerationFacet;

  end;

  ///<summary>Represents the <see langword="enumeration" />
  ///  facet from XML Schema as specified by the World Wide Web Consortium (W3C). This class specifies a list of valid values for a simpleType element. Declaration is contained within a <see langword="restriction" />
  ///  declaration.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaEnumerationFacet')]
  DNXmlSchemaEnumerationFacet = interface(DNXmlSchemaFacet)
  ['{4AB63A76-2A1E-3158-ABA4-BFC3C7F29CFD}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaEnumerationFacet = class(TDNGenericImport<DNXmlSchemaEnumerationFacetClass, DNXmlSchemaEnumerationFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaMaxExclusiveFacetClass = interface(DNXmlSchemaFacetClass)
  ['{4BEB63B0-14ED-5D93-9D70-8EBE60BE438F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaMaxExclusiveFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaMaxExclusiveFacet;

  end;

  ///<summary>Represents the <see langword="maxExclusive" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the maximum value of a <see langword="simpleType" />
  ///  element. The element value must be less than the value of the <see langword="maxExclusive" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaMaxExclusiveFacet')]
  DNXmlSchemaMaxExclusiveFacet = interface(DNXmlSchemaFacet)
  ['{8C49E438-F8DB-331F-8A7C-3E7442A9ADD5}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaMaxExclusiveFacet = class(TDNGenericImport<DNXmlSchemaMaxExclusiveFacetClass, DNXmlSchemaMaxExclusiveFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaMaxInclusiveFacetClass = interface(DNXmlSchemaFacetClass)
  ['{3BBFBCF7-ACF4-57A3-8FFF-3E50BDEF1393}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaMaxInclusiveFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaMaxInclusiveFacet;

  end;

  ///<summary>Represents the <see langword="maxInclusive" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the maximum value of a <see langword="simpleType" />
  ///  element. The element value must be less than or equal to the value of the <see langword="maxInclusive" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaMaxInclusiveFacet')]
  DNXmlSchemaMaxInclusiveFacet = interface(DNXmlSchemaFacet)
  ['{C3B09BA9-9A27-3126-B14A-FEEF00BA736D}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaMaxInclusiveFacet = class(TDNGenericImport<DNXmlSchemaMaxInclusiveFacetClass, DNXmlSchemaMaxInclusiveFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaMinExclusiveFacetClass = interface(DNXmlSchemaFacetClass)
  ['{5F818AA6-71A5-5091-99F5-5E92C2646F21}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaMinExclusiveFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaMinExclusiveFacet;

  end;

  ///<summary>Represents the <see langword="minExclusive" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the minimum value of a <see langword="simpleType" />
  ///  element. The element value must be greater than the value of the <see langword="minExclusive" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaMinExclusiveFacet')]
  DNXmlSchemaMinExclusiveFacet = interface(DNXmlSchemaFacet)
  ['{624F30E4-C184-3CD7-980A-CC392785C99F}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaMinExclusiveFacet = class(TDNGenericImport<DNXmlSchemaMinExclusiveFacetClass, DNXmlSchemaMinExclusiveFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaMinInclusiveFacetClass = interface(DNXmlSchemaFacetClass)
  ['{2FF63ADB-93CF-5C45-B30E-83F433390EFB}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaMinInclusiveFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaMinInclusiveFacet;

  end;

  ///<summary>Represents the <see langword="minInclusive" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the minimum value of a simpleType element. The element value must be greater than or equal to the value of the <see langword="minInclusive" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaMinInclusiveFacet')]
  DNXmlSchemaMinInclusiveFacet = interface(DNXmlSchemaFacet)
  ['{63A6C351-761E-3B86-BF7F-C181FF120141}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaMinInclusiveFacet = class(TDNGenericImport<DNXmlSchemaMinInclusiveFacetClass, DNXmlSchemaMinInclusiveFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaNumericFacetClass = interface(DNXmlSchemaFacetClass)
  ['{404E0174-F7B5-57A7-AA36-3541B4498BBF}']
  end;

  ///<summary>Abstract class for defining <see langword="numeric" />
  ///  facets. This class is the base class for numeric facet classes such as <see cref="T:System.Xml.Schema.XmlSchemaMinLengthFacet" />
  ///</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaNumericFacet')]
  DNXmlSchemaNumericFacet = interface(DNXmlSchemaFacet)
  ['{DDF0F6BF-DDD5-30E8-AE2A-1091BCB7BAD1}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaNumericFacet = class(TDNGenericImport<DNXmlSchemaNumericFacetClass, DNXmlSchemaNumericFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaFractionDigitsFacetClass = interface(DNXmlSchemaNumericFacetClass)
  ['{A2A61D2D-52DA-5377-94FA-2BC942D9087A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaFractionDigitsFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaFractionDigitsFacet;

  end;

  ///<summary>Specifies a restriction on the number of digits that can be entered for the fraction value of a simpleType element. The value of fractionDigits must be a positive integer. Represents the World Wide Web Consortium (W3C) <see langword="fractionDigits" />
  ///  facet.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaFractionDigitsFacet')]
  DNXmlSchemaFractionDigitsFacet = interface(DNXmlSchemaNumericFacet)
  ['{98DFB338-5ED5-32E4-B2D9-4FB82AB7077F}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Value: string read get_Value write set_Value;
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaFractionDigitsFacet = class(TDNGenericImport<DNXmlSchemaFractionDigitsFacetClass, DNXmlSchemaFractionDigitsFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaLengthFacetClass = interface(DNXmlSchemaNumericFacetClass)
  ['{4F42A3F7-D411-534B-93C1-ACBA6548E307}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaLengthFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaLengthFacet;

  end;

  ///<summary>Represents the <see langword="length" />
  ///  facet from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the length of a <see langword="simpleType" />
  ///  element on the data type.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaLengthFacet')]
  DNXmlSchemaLengthFacet = interface(DNXmlSchemaNumericFacet)
  ['{82F8CF4C-2EE5-3E49-A6C9-6892EB860CAB}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Value: string read get_Value write set_Value;
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaLengthFacet = class(TDNGenericImport<DNXmlSchemaLengthFacetClass, DNXmlSchemaLengthFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaMaxLengthFacetClass = interface(DNXmlSchemaNumericFacetClass)
  ['{4730E68C-4448-5F95-A232-A6F5EBA9FB53}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaMaxLengthFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaMaxLengthFacet;

  end;

  ///<summary>Represents the <see langword="maxLength" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the maximum length of the data value of a <see langword="simpleType" />
  ///  element. The length must be less than the value of the <see langword="maxLength" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaMaxLengthFacet')]
  DNXmlSchemaMaxLengthFacet = interface(DNXmlSchemaNumericFacet)
  ['{EE630C3F-C9F2-3302-95F5-91A294AE75ED}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Value: string read get_Value write set_Value;
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaMaxLengthFacet = class(TDNGenericImport<DNXmlSchemaMaxLengthFacetClass, DNXmlSchemaMaxLengthFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaMinLengthFacetClass = interface(DNXmlSchemaNumericFacetClass)
  ['{AD79CD3D-EF0B-577B-B54D-2E123601B335}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaMinLengthFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaMinLengthFacet;

  end;

  ///<summary>Represents the <see langword="minLength" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the minimum length of the data value of a <see langword="simpleType" />
  ///  element. The length must be greater than the value of the <see langword="minLength" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaMinLengthFacet')]
  DNXmlSchemaMinLengthFacet = interface(DNXmlSchemaNumericFacet)
  ['{45DF0D38-9318-3B30-B625-8B774F90743F}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Value: string read get_Value write set_Value;
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaMinLengthFacet = class(TDNGenericImport<DNXmlSchemaMinLengthFacetClass, DNXmlSchemaMinLengthFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaTotalDigitsFacetClass = interface(DNXmlSchemaNumericFacetClass)
  ['{9E85B48F-7159-56D9-8889-F1963CD59C42}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaTotalDigitsFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaTotalDigitsFacet;

  end;

  ///<summary>Represents the <see langword="totalDigits" />
  ///  facet from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the number of digits that can be entered for the value of a <see langword="simpleType" />
  ///  element. That value of <see langword="totalDigits" />
  ///  must be a positive integer.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaTotalDigitsFacet')]
  DNXmlSchemaTotalDigitsFacet = interface(DNXmlSchemaNumericFacet)
  ['{354C6187-1002-31B3-8143-454E7553941D}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Value: string read get_Value write set_Value;
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaTotalDigitsFacet = class(TDNGenericImport<DNXmlSchemaTotalDigitsFacetClass, DNXmlSchemaTotalDigitsFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaPatternFacetClass = interface(DNXmlSchemaFacetClass)
  ['{0FA5195F-1E87-56E6-BEF4-0184363FBF55}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaPatternFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaPatternFacet;

  end;

  ///<summary>Represents the <see langword="pattern" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to specify a restriction on the value entered for a <see langword="simpleType" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaPatternFacet')]
  DNXmlSchemaPatternFacet = interface(DNXmlSchemaFacet)
  ['{1C329F10-F38E-3E4B-BD59-86DEE8AA38FF}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaPatternFacet = class(TDNGenericImport<DNXmlSchemaPatternFacetClass, DNXmlSchemaPatternFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaWhiteSpaceFacetClass = interface(DNXmlSchemaFacetClass)
  ['{C4C5C955-1540-5607-A12A-650029950E8A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaWhiteSpaceFacet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaWhiteSpaceFacet;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="whiteSpace" />
  ///  facet.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaWhiteSpaceFacet')]
  DNXmlSchemaWhiteSpaceFacet = interface(DNXmlSchemaFacet)
  ['{0E8BA914-FBF4-3A48-B892-88F9990256E8}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_IsFixed: Boolean;
    procedure set_IsFixed(value: Boolean);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="value" />
    ///  attribute of the facet.</summary>
    ///<returns>The value attribute.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets information that indicates that this facet is fixed.</summary>
    ///<returns>If <see langword="true" />
    ///  , value is fixed; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsFixed: Boolean read get_IsFixed write set_IsFixed;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaWhiteSpaceFacet = class(TDNGenericImport<DNXmlSchemaWhiteSpaceFacetClass, DNXmlSchemaWhiteSpaceFacet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaGroupClass = interface(DNXmlSchemaAnnotatedClass)
  ['{74CECBC7-1950-5F00-979A-32AA2E901552}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaGroup" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaGroup;

  end;

  ///<summary>Represents the <see langword="group" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class defines groups at the <see langword="schema" />
  ///  level that are referenced from the complex types. It groups a set of element declarations so that they can be incorporated as a group into complex type definitions.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaGroup')]
  DNXmlSchemaGroup = interface(DNXmlSchemaAnnotated)
  ['{BC37FBFA-BA80-30DA-A6BC-6BBA7BD2485F}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Particle: DNXmlSchemaGroupBase;
    procedure set_Particle(value: DNXmlSchemaGroupBase);
    function get_QualifiedName: DNXmlQualifiedName;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the schema group.</summary>
    ///<returns>The name of the schema group.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets one of the <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</returns>
    property Particle: DNXmlSchemaGroupBase read get_Particle write set_Particle;
    ///<summary>Gets the qualified name of the schema group.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object representing the qualified name of the schema group.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaGroup = class(TDNGenericImport<DNXmlSchemaGroupClass, DNXmlSchemaGroup>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaIdentityConstraintClass = interface(DNXmlSchemaAnnotatedClass)
  ['{5E67FC03-677B-5EA1-84E4-DD9E170BE074}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaIdentityConstraint" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaIdentityConstraint;

  end;

  ///<summary>Class for the identity constraints: <see langword="key" />
  ///  , <see langword="keyref" />
  ///  , and <see langword="unique" />
  ///  elements.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaIdentityConstraint')]
  DNXmlSchemaIdentityConstraint = interface(DNXmlSchemaAnnotated)
  ['{D4582488-78CA-342A-A924-BB041FD5A8DF}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Selector: DNXmlSchemaXPath;
    procedure set_Selector(value: DNXmlSchemaXPath);
    function get_Fields: DNXmlSchemaObjectCollection;
    function get_QualifiedName: DNXmlQualifiedName;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the identity constraint.</summary>
    ///<returns>The name of the identity constraint.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the XPath expression <see langword="selector" />
    ///  element.</summary>
    ///<returns>The XPath expression <see langword="selector" />
    ///  element.</returns>
    property Selector: DNXmlSchemaXPath read get_Selector write set_Selector;
    ///<summary>Gets the collection of fields that apply as children for the XML Path Language (XPath) expression selector.</summary>
    ///<returns>The collection of fields.</returns>
    property Fields: DNXmlSchemaObjectCollection read get_Fields;
    ///<summary>Gets the qualified name of the identity constraint, which holds the post-compilation value of the <see langword="QualifiedName" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="QualifiedName" />
    ///  property.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaIdentityConstraint = class(TDNGenericImport<DNXmlSchemaIdentityConstraintClass, DNXmlSchemaIdentityConstraint>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaKeyClass = interface(DNXmlSchemaIdentityConstraintClass)
  ['{C31CADFC-9A68-586E-8AC2-F46B334A0B6D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaKey" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaKey;

  end;

  ///<summary>This class represents the <see langword="key" />
  ///  element from XMLSchema as specified by the World Wide Web Consortium (W3C).</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaKey')]
  DNXmlSchemaKey = interface(DNXmlSchemaIdentityConstraint)
  ['{C3753BE0-3939-3C14-9628-62B3D820CC40}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Selector: DNXmlSchemaXPath;
    procedure set_Selector(value: DNXmlSchemaXPath);
    function get_Fields: DNXmlSchemaObjectCollection;
    function get_QualifiedName: DNXmlQualifiedName;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the identity constraint.</summary>
    ///<returns>The name of the identity constraint.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the XPath expression <see langword="selector" />
    ///  element.</summary>
    ///<returns>The XPath expression <see langword="selector" />
    ///  element.</returns>
    property Selector: DNXmlSchemaXPath read get_Selector write set_Selector;
    ///<summary>Gets the collection of fields that apply as children for the XML Path Language (XPath) expression selector.</summary>
    ///<returns>The collection of fields.</returns>
    property Fields: DNXmlSchemaObjectCollection read get_Fields;
    ///<summary>Gets the qualified name of the identity constraint, which holds the post-compilation value of the <see langword="QualifiedName" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="QualifiedName" />
    ///  property.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaKey = class(TDNGenericImport<DNXmlSchemaKeyClass, DNXmlSchemaKey>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaKeyrefClass = interface(DNXmlSchemaIdentityConstraintClass)
  ['{4E7CB961-D760-5695-9604-F34662A2AC75}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaKeyref" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaKeyref;

  end;

  ///<summary>This class represents the <see langword="keyref" />
  ///  element from XMLSchema as specified by the World Wide Web Consortium (W3C).</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaKeyref')]
  DNXmlSchemaKeyref = interface(DNXmlSchemaIdentityConstraint)
  ['{23E040BC-B402-358A-A5E3-0FEDF28EFA51}']
  { getters & setters } 

    function get_Refer: DNXmlQualifiedName;
    procedure set_Refer(value: DNXmlQualifiedName);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_Selector: DNXmlSchemaXPath;
    procedure set_Selector(value: DNXmlSchemaXPath);
    function get_Fields: DNXmlSchemaObjectCollection;
    function get_QualifiedName: DNXmlQualifiedName;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the key that this constraint refers to in another simple or complex type.</summary>
    ///<returns>The QName of the key that this constraint refers to.</returns>
    property Refer: DNXmlQualifiedName read get_Refer write set_Refer;
    ///<summary>Gets or sets the name of the identity constraint.</summary>
    ///<returns>The name of the identity constraint.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the XPath expression <see langword="selector" />
    ///  element.</summary>
    ///<returns>The XPath expression <see langword="selector" />
    ///  element.</returns>
    property Selector: DNXmlSchemaXPath read get_Selector write set_Selector;
    ///<summary>Gets the collection of fields that apply as children for the XML Path Language (XPath) expression selector.</summary>
    ///<returns>The collection of fields.</returns>
    property Fields: DNXmlSchemaObjectCollection read get_Fields;
    ///<summary>Gets the qualified name of the identity constraint, which holds the post-compilation value of the <see langword="QualifiedName" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="QualifiedName" />
    ///  property.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaKeyref = class(TDNGenericImport<DNXmlSchemaKeyrefClass, DNXmlSchemaKeyref>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaUniqueClass = interface(DNXmlSchemaIdentityConstraintClass)
  ['{446C4C18-8272-553F-8605-1A4F5E9827D8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaUnique" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaUnique;

  end;

  ///<summary>Represents the <see langword="unique" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to identify a unique constraint among a set of elements.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaUnique')]
  DNXmlSchemaUnique = interface(DNXmlSchemaIdentityConstraint)
  ['{03224C6D-7D3A-3B02-9BEF-668F59E225E0}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Selector: DNXmlSchemaXPath;
    procedure set_Selector(value: DNXmlSchemaXPath);
    function get_Fields: DNXmlSchemaObjectCollection;
    function get_QualifiedName: DNXmlQualifiedName;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the identity constraint.</summary>
    ///<returns>The name of the identity constraint.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the XPath expression <see langword="selector" />
    ///  element.</summary>
    ///<returns>The XPath expression <see langword="selector" />
    ///  element.</returns>
    property Selector: DNXmlSchemaXPath read get_Selector write set_Selector;
    ///<summary>Gets the collection of fields that apply as children for the XML Path Language (XPath) expression selector.</summary>
    ///<returns>The collection of fields.</returns>
    property Fields: DNXmlSchemaObjectCollection read get_Fields;
    ///<summary>Gets the qualified name of the identity constraint, which holds the post-compilation value of the <see langword="QualifiedName" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="QualifiedName" />
    ///  property.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaUnique = class(TDNGenericImport<DNXmlSchemaUniqueClass, DNXmlSchemaUnique>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaNotationClass = interface(DNXmlSchemaAnnotatedClass)
  ['{935CBA95-F902-50A4-B3B9-B74C91F18512}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaNotation" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaNotation;

  end;

  ///<summary>Represents the <see langword="notation" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). An XML Schema <see langword="notation" />
  ///  declaration is a reconstruction of <see langword="XML 1.0 NOTATION" />
  ///  declarations. The purpose of notations is to describe the format of non-XML data within an XML document.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaNotation')]
  DNXmlSchemaNotation = interface(DNXmlSchemaAnnotated)
  ['{55DAB099-DD0C-3BF5-A900-38AF16885B54}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Public: string;
    procedure set_Public(value: string);
    function get_System: string;
    procedure set_System(value: string);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the notation.</summary>
    ///<returns>The name of the notation.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the <see langword="public" />
    ///  identifier.</summary>
    ///<returns>The <see langword="public" />
    ///  identifier. The value must be a valid Uniform Resource Identifier (URI).</returns>
    property &Public: string read get_Public write set_Public;
    ///<summary>Gets or sets the <see langword="system" />
    ///  identifier.</summary>
    ///<returns>The <see langword="system" />
    ///  identifier. The value must be a valid URI.</returns>
    property System: string read get_System write set_System;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaNotation = class(TDNGenericImport<DNXmlSchemaNotationClass, DNXmlSchemaNotation>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaParticleClass = interface(DNXmlSchemaAnnotatedClass)
  ['{A0461EC1-C4D9-5D09-8FEF-1F69A8DAA165}']
  end;

  ///<summary>Abstract class for that is the base class for all particle types (e.g. <see cref="T:System.Xml.Schema.XmlSchemaAny" />
  ///  ).</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaParticle')]
  DNXmlSchemaParticle = interface(DNXmlSchemaAnnotated)
  ['{BBC2F95A-DB28-37A0-9714-4EEE0ECE12F8}']
  { getters & setters } 

    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the number as a string value. The minimum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MinOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    ///<summary>Gets or sets the number as a string value. Maximum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MaxOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    ///<summary>Gets or sets the minimum number of times the particle can occur.</summary>
    ///<returns>The minimum number of times the particle can occur. The default is 1.</returns>
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    ///<summary>Gets or sets the maximum number of times the particle can occur.</summary>
    ///<returns>The maximum number of times the particle can occur. The default is 1.</returns>
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaParticle = class(TDNGenericImport<DNXmlSchemaParticleClass, DNXmlSchemaParticle>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAnyClass = interface(DNXmlSchemaParticleClass)
  ['{E9B28038-819A-54F4-BE4A-250C53F0248A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAny" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAny;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="any" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAny')]
  DNXmlSchemaAny = interface(DNXmlSchemaParticle)
  ['{E2229971-F3A3-35BC-9FBD-4A8BA8973D8E}']
  { getters & setters } 

    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_ProcessContents: DNXmlSchemaContentProcessing;
    procedure set_ProcessContents(value: DNXmlSchemaContentProcessing);
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the namespaces containing the elements that can be used.</summary>
    ///<returns>Namespaces for elements that are available for use. The default is <see langword="##any" />
    ///  .Optional.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets information about how an application or XML processor should handle the validation of XML documents for the elements specified by the <see langword="any" />
    ///  element.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlSchemaContentProcessing" />
    ///  values. If no <see langword="processContents" />
    ///  attribute is specified, the default is <see langword="Strict" />
    ///  .</returns>
    property ProcessContents: DNXmlSchemaContentProcessing read get_ProcessContents write set_ProcessContents;
    ///<summary>Gets or sets the number as a string value. The minimum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MinOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    ///<summary>Gets or sets the number as a string value. Maximum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MaxOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    ///<summary>Gets or sets the minimum number of times the particle can occur.</summary>
    ///<returns>The minimum number of times the particle can occur. The default is 1.</returns>
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    ///<summary>Gets or sets the maximum number of times the particle can occur.</summary>
    ///<returns>The maximum number of times the particle can occur. The default is 1.</returns>
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAny = class(TDNGenericImport<DNXmlSchemaAnyClass, DNXmlSchemaAny>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaElementClass = interface(DNXmlSchemaParticleClass)
  ['{E37C444F-795F-54AD-9180-ABBA3F64F30C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaElement;

  end;

  ///<summary>Represents the <see langword="element" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class is the base class for all particle types and is used to describe an element in an XML document.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaElement')]
  DNXmlSchemaElement = interface(DNXmlSchemaParticle)
  ['{2FB0DA90-49F6-32E3-9B5F-C95E831179C8}']
  { getters & setters } 

    function get_IsAbstract: Boolean;
    procedure set_IsAbstract(value: Boolean);
    function get_Block: DNXmlSchemaDerivationMethod;
    procedure set_Block(value: DNXmlSchemaDerivationMethod);
    function get_DefaultValue: string;
    procedure set_DefaultValue(value: string);
    function get_Final: DNXmlSchemaDerivationMethod;
    procedure set_Final(value: DNXmlSchemaDerivationMethod);
    function get_FixedValue: string;
    procedure set_FixedValue(value: string);
    function get_Form: DNXmlSchemaForm;
    procedure set_Form(value: DNXmlSchemaForm);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_IsNillable: Boolean;
    procedure set_IsNillable(value: Boolean);
    function get_RefName: DNXmlQualifiedName;
    procedure set_RefName(value: DNXmlQualifiedName);
    function get_SubstitutionGroup: DNXmlQualifiedName;
    procedure set_SubstitutionGroup(value: DNXmlQualifiedName);
    function get_SchemaTypeName: DNXmlQualifiedName;
    procedure set_SchemaTypeName(value: DNXmlQualifiedName);
    function get_SchemaType: DNXmlSchemaType;
    procedure set_SchemaType(value: DNXmlSchemaType);
    function get_Constraints: DNXmlSchemaObjectCollection;
    function get_QualifiedName: DNXmlQualifiedName;
    function get_ElementType: DDN.mscorlib.DNObject;
    function get_ElementSchemaType: DNXmlSchemaType;
    function get_BlockResolved: DNXmlSchemaDerivationMethod;
    function get_FinalResolved: DNXmlSchemaDerivationMethod;
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets information to indicate if the element can be used in an instance document.</summary>
    ///<returns>If <see langword="true" />
    ///  , the element cannot appear in the instance document. The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsAbstract: Boolean read get_IsAbstract write set_IsAbstract;
    ///<summary>Gets or sets a <see langword="Block" />
    ///  derivation.</summary>
    ///<returns>The attribute used to block a type derivation. Default value is <see langword="XmlSchemaDerivationMethod.None" />
    ///  .Optional.</returns>
    property Block: DNXmlSchemaDerivationMethod read get_Block write set_Block;
    ///<summary>Gets or sets the default value of the element if its content is a simple type or content of the element is <see langword="textOnly" />
    ///  .</summary>
    ///<returns>The default value for the element. The default is a null reference.Optional.</returns>
    property DefaultValue: string read get_DefaultValue write set_DefaultValue;
    ///<summary>Gets or sets the <see langword="Final" />
    ///  property to indicate that no further derivations are allowed.</summary>
    ///<returns>The <see langword="Final" />
    ///  property. The default is <see langword="XmlSchemaDerivationMethod.None" />
    ///  .Optional.</returns>
    property &Final: DNXmlSchemaDerivationMethod read get_Final write set_Final;
    ///<summary>Gets or sets the fixed value.</summary>
    ///<returns>The fixed value that is predetermined and unchangeable. The default is a null reference.Optional.</returns>
    property FixedValue: string read get_FixedValue write set_FixedValue;
    ///<summary>Gets or sets the form for the element.</summary>
    ///<returns>The form for the element. The default is the <see cref="P:System.Xml.Schema.XmlSchema.ElementFormDefault" />
    ///  value.Optional.</returns>
    property Form: DNXmlSchemaForm read get_Form write set_Form;
    ///<summary>Gets or sets the name of the element.</summary>
    ///<returns>The name of the element. The default is <see langword="String.Empty" />
    ///  .</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets information that indicates if <see langword="xsi:nil" />
    ///  can occur in the instance data. Indicates if an explicit nil value can be assigned to the element.</summary>
    ///<returns>If nillable is <see langword="true" />
    ///  , this enables an instance of the element to have the <see langword="nil" />
    ///  attribute set to <see langword="true" />
    ///  . The <see langword="nil" />
    ///  attribute is defined as part of the XML Schema namespace for instances. The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsNillable: Boolean read get_IsNillable write set_IsNillable;
    ///<summary>Gets or sets the reference name of an element declared in this schema (or another schema indicated by the specified namespace).</summary>
    ///<returns>The reference name of the element.</returns>
    property RefName: DNXmlQualifiedName read get_RefName write set_RefName;
    ///<summary>Gets or sets the name of an element that is being substituted by this element.</summary>
    ///<returns>The qualified name of an element that is being substituted by this element.Optional.</returns>
    property SubstitutionGroup: DNXmlQualifiedName read get_SubstitutionGroup write set_SubstitutionGroup;
    ///<summary>Gets or sets the name of a built-in data type defined in this schema or another schema indicated by the specified namespace.</summary>
    ///<returns>The name of the built-in data type.</returns>
    property SchemaTypeName: DNXmlQualifiedName read get_SchemaTypeName write set_SchemaTypeName;
    ///<summary>Gets or sets the type of the element. This can either be a complex type or a simple type.</summary>
    ///<returns>The type of the element.</returns>
    property SchemaType: DNXmlSchemaType read get_SchemaType write set_SchemaType;
    ///<summary>Gets the collection of constraints on the element.</summary>
    ///<returns>The collection of constraints.</returns>
    property Constraints: DNXmlSchemaObjectCollection read get_Constraints;
    ///<summary>Gets the actual qualified name for the given element. </summary>
    ///<returns>The qualified name of the element. The post-compilation value of the <see langword="QualifiedName" />
    ///  property.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets a common language runtime (CLR) object based on the <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  or <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  of the element, which holds the post-compilation value of the <see langword="ElementType" />
    ///  property.</summary>
    ///<returns>The common language runtime object. The post-compilation value of the <see langword="ElementType" />
    ///  property.</returns>
    property ElementType: DDN.mscorlib.DNObject read get_ElementType;
    ///<summary>Gets an <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object representing the type of the element based on the <see cref="P:System.Xml.Schema.XmlSchemaElement.SchemaType" />
    ///  or <see cref="P:System.Xml.Schema.XmlSchemaElement.SchemaTypeName" />
    ///  values of the element.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object.</returns>
    property ElementSchemaType: DNXmlSchemaType read get_ElementSchemaType;
    ///<summary>Gets the post-compilation value of the <see langword="Block" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="Block" />
    ///  property. The default is the <see langword="BlockDefault" />
    ///  value on the <see langword="schema" />
    ///  element.</returns>
    property BlockResolved: DNXmlSchemaDerivationMethod read get_BlockResolved;
    ///<summary>Gets the post-compilation value of the <see langword="Final" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="Final" />
    ///  property. Default value is the <see langword="FinalDefault" />
    ///  value on the <see langword="schema" />
    ///  element.</returns>
    property FinalResolved: DNXmlSchemaDerivationMethod read get_FinalResolved;
    ///<summary>Gets or sets the number as a string value. The minimum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MinOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    ///<summary>Gets or sets the number as a string value. Maximum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MaxOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    ///<summary>Gets or sets the minimum number of times the particle can occur.</summary>
    ///<returns>The minimum number of times the particle can occur. The default is 1.</returns>
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    ///<summary>Gets or sets the maximum number of times the particle can occur.</summary>
    ///<returns>The maximum number of times the particle can occur. The default is 1.</returns>
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaElement = class(TDNGenericImport<DNXmlSchemaElementClass, DNXmlSchemaElement>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaGroupBaseClass = interface(DNXmlSchemaParticleClass)
  ['{A0D8D24D-ADCE-5941-92ED-A7F661EDAD53}']
  end;

  ///<summary>An abstract class for <see cref="T:System.Xml.Schema.XmlSchemaAll" />
  ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
  ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
  ///  .</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaGroupBase')]
  DNXmlSchemaGroupBase = interface(DNXmlSchemaParticle)
  ['{22B8F5D4-1EBA-37C2-A125-7E2D33D48968}']
  { getters & setters } 

    function get_Items: DNXmlSchemaObjectCollection;
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>This collection is used to add new elements to the compositor.</summary>
    ///<returns>An <see langword="XmlSchemaObjectCollection" />
    ///  .</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    ///<summary>Gets or sets the number as a string value. The minimum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MinOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    ///<summary>Gets or sets the number as a string value. Maximum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MaxOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    ///<summary>Gets or sets the minimum number of times the particle can occur.</summary>
    ///<returns>The minimum number of times the particle can occur. The default is 1.</returns>
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    ///<summary>Gets or sets the maximum number of times the particle can occur.</summary>
    ///<returns>The maximum number of times the particle can occur. The default is 1.</returns>
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaGroupBase = class(TDNGenericImport<DNXmlSchemaGroupBaseClass, DNXmlSchemaGroupBase>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAllClass = interface(DNXmlSchemaGroupBaseClass)
  ['{C028B505-5AD5-52B4-8ED1-E7DFC9C99DE7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAll;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="all" />
  ///  element (compositor).</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAll')]
  DNXmlSchemaAll = interface(DNXmlSchemaGroupBase)
  ['{FA8F492E-9886-344C-8E89-3524C27667A1}']
  { getters & setters } 

    function get_Items: DNXmlSchemaObjectCollection;
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the collection of <see langword="XmlSchemaElement" />
    ///  elements contained within the <see langword="all" />
    ///  compositor.</summary>
    ///<returns>The collection of elements contained in <see langword="XmlSchemaAll" />
    ///  .</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAll = class(TDNGenericImport<DNXmlSchemaAllClass, DNXmlSchemaAll>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaChoiceClass = interface(DNXmlSchemaGroupBaseClass)
  ['{66E5EA3A-5E2E-59EA-AC80-8E57177B02D4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaChoice;

  end;

  ///<summary>Represents the <see langword="choice" />
  ///  element (compositor) from the XML Schema as specified by the World Wide Web Consortium (W3C). The <see langword="choice" />
  ///  allows only one of its children to appear in an instance. </summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaChoice')]
  DNXmlSchemaChoice = interface(DNXmlSchemaGroupBase)
  ['{58A72699-53C7-37FA-9629-07F42F7C8159}']
  { getters & setters } 

    function get_Items: DNXmlSchemaObjectCollection;
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the collection of the elements contained with the compositor (<see langword="choice" />
    ///  ): <see langword="XmlSchemaElement" />
    ///  , <see langword="XmlSchemaGroupRef" />
    ///  , <see langword="XmlSchemaChoice" />
    ///  , <see langword="XmlSchemaSequence" />
    ///  , or <see langword="XmlSchemaAny" />
    ///  .</summary>
    ///<returns>The collection of elements contained within <see langword="XmlSchemaChoice" />
    ///  .</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaChoice = class(TDNGenericImport<DNXmlSchemaChoiceClass, DNXmlSchemaChoice>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSequenceClass = interface(DNXmlSchemaGroupBaseClass)
  ['{72B50BA4-FFD8-5115-A1F5-DC4C85C0C3BB}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSequence;

  end;

  ///<summary>Represents the <see langword="sequence" />
  ///  element (compositor) from the XML Schema as specified by the World Wide Web Consortium (W3C). The <see langword="sequence" />
  ///  requires the elements in the group to appear in the specified sequence within the containing element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSequence')]
  DNXmlSchemaSequence = interface(DNXmlSchemaGroupBase)
  ['{7AD5F37A-8B74-35EF-B491-09F500C63CF1}']
  { getters & setters } 

    function get_Items: DNXmlSchemaObjectCollection;
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>The elements contained within the compositor. Collection of <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaAny" />
    ///  .</summary>
    ///<returns>The elements contained within the compositor.</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSequence = class(TDNGenericImport<DNXmlSchemaSequenceClass, DNXmlSchemaSequence>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaGroupRefClass = interface(DNXmlSchemaParticleClass)
  ['{97E4CE92-BFD7-5C96-87E7-C9012E98A721}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaGroupRef;

  end;

  ///<summary>Represents the <see langword="group" />
  ///  element with <see langword="ref" />
  ///  attribute from the XML Schema as specified by the World Wide Web Consortium (W3C). This class is used within complex types that reference a <see langword="group" />
  ///  defined at the <see langword="schema" />
  ///  level.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaGroupRef')]
  DNXmlSchemaGroupRef = interface(DNXmlSchemaParticle)
  ['{1D89F049-7E99-338D-9FEB-3A2895F35236}']
  { getters & setters } 

    function get_RefName: DNXmlQualifiedName;
    procedure set_RefName(value: DNXmlQualifiedName);
    function get_Particle: DNXmlSchemaGroupBase;
    function get_MinOccursString: string;
    procedure set_MinOccursString(value: string);
    function get_MaxOccursString: string;
    procedure set_MaxOccursString(value: string);
    function get_MinOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MinOccurs(value: DDN.mscorlib.DNDecimal);
    function get_MaxOccurs: DDN.mscorlib.DNDecimal;
    procedure set_MaxOccurs(value: DDN.mscorlib.DNDecimal);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of a group defined in this schema (or another schema indicated by the specified namespace).</summary>
    ///<returns>The name of a group defined in this schema.</returns>
    property RefName: DNXmlQualifiedName read get_RefName write set_RefName;
    ///<summary>Gets one of the <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes, which holds the post-compilation value of the <see langword="Particle" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see langword="Particle" />
    ///  property, which is one of the <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</returns>
    property Particle: DNXmlSchemaGroupBase read get_Particle;
    ///<summary>Gets or sets the number as a string value. The minimum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MinOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MinOccursString: string read get_MinOccursString write set_MinOccursString;
    ///<summary>Gets or sets the number as a string value. Maximum number of times the particle can occur.</summary>
    ///<returns>The number as a string value. <see langword="String.Empty" />
    ///  indicates that <see langword="MaxOccurs" />
    ///  is equal to the default value. The default is a null reference.</returns>
    property MaxOccursString: string read get_MaxOccursString write set_MaxOccursString;
    ///<summary>Gets or sets the minimum number of times the particle can occur.</summary>
    ///<returns>The minimum number of times the particle can occur. The default is 1.</returns>
    property MinOccurs: DDN.mscorlib.DNDecimal read get_MinOccurs write set_MinOccurs;
    ///<summary>Gets or sets the maximum number of times the particle can occur.</summary>
    ///<returns>The maximum number of times the particle can occur. The default is 1.</returns>
    property MaxOccurs: DDN.mscorlib.DNDecimal read get_MaxOccurs write set_MaxOccurs;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaGroupRef = class(TDNGenericImport<DNXmlSchemaGroupRefClass, DNXmlSchemaGroupRef>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleTypeContentClass = interface(DNXmlSchemaAnnotatedClass)
  ['{1A6AC03E-72DE-5469-8B66-C7E332D5B386}']
  end;

  ///<summary>Abstract class for simple type content classes.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleTypeContent')]
  DNXmlSchemaSimpleTypeContent = interface(DNXmlSchemaAnnotated)
  ['{EA6621EC-B0D8-3069-A30C-B2595361BDD1}']
  { getters & setters } 

    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleTypeContent = class(TDNGenericImport<DNXmlSchemaSimpleTypeContentClass, DNXmlSchemaSimpleTypeContent>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleTypeListClass = interface(DNXmlSchemaSimpleTypeContentClass)
  ['{EFCAF439-EA35-53F2-9947-F65992082320}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleTypeList" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleTypeList;

  end;

  ///<summary>Represents the <see langword="list" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to define a <see langword="simpleType" />
  ///  element as a list of values of a specified data type.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleTypeList')]
  DNXmlSchemaSimpleTypeList = interface(DNXmlSchemaSimpleTypeContent)
  ['{245AF784-4B0F-3F7A-A46F-17C4E92DC411}']
  { getters & setters } 

    function get_ItemTypeName: DNXmlQualifiedName;
    procedure set_ItemTypeName(value: DNXmlQualifiedName);
    function get_ItemType: DNXmlSchemaSimpleType;
    procedure set_ItemType(value: DNXmlSchemaSimpleType);
    function get_BaseItemType: DNXmlSchemaSimpleType;
    procedure set_BaseItemType(value: DNXmlSchemaSimpleType);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of a built-in data type or <see langword="simpleType" />
    ///  element defined in this schema (or another schema indicated by the specified namespace).</summary>
    ///<returns>The type name of the simple type list.</returns>
    property ItemTypeName: DNXmlQualifiedName read get_ItemTypeName write set_ItemTypeName;
    ///<summary>Gets or sets the <see langword="simpleType" />
    ///  element that is derived from the type specified by the base value.</summary>
    ///<returns>The item type for the simple type element.</returns>
    property ItemType: DNXmlSchemaSimpleType read get_ItemType write set_ItemType;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  representing the type of the <see langword="simpleType" />
    ///  element based on the <see cref="P:System.Xml.Schema.XmlSchemaSimpleTypeList.ItemType" />
    ///  and <see cref="P:System.Xml.Schema.XmlSchemaSimpleTypeList.ItemTypeName" />
    ///  values of the simple type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  representing the type of the <see langword="simpleType" />
    ///  element.</returns>
    property BaseItemType: DNXmlSchemaSimpleType read get_BaseItemType write set_BaseItemType;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleTypeList = class(TDNGenericImport<DNXmlSchemaSimpleTypeListClass, DNXmlSchemaSimpleTypeList>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleTypeRestrictionClass = interface(DNXmlSchemaSimpleTypeContentClass)
  ['{4F0D69FE-2705-5657-AC29-82BA27EFC86D}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleTypeRestriction" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleTypeRestriction;

  end;

  ///<summary>Represents the <see langword="restriction" />
  ///  element for simple types from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used restricting <see langword="simpleType" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleTypeRestriction')]
  DNXmlSchemaSimpleTypeRestriction = interface(DNXmlSchemaSimpleTypeContent)
  ['{932C904B-6D2C-3EA8-9B68-76B0653D0907}']
  { getters & setters } 

    function get_BaseTypeName: DNXmlQualifiedName;
    procedure set_BaseTypeName(value: DNXmlQualifiedName);
    function get_BaseType: DNXmlSchemaSimpleType;
    procedure set_BaseType(value: DNXmlSchemaSimpleType);
    function get_Facets: DNXmlSchemaObjectCollection;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the qualified base type.</summary>
    ///<returns>The qualified name of the simple type restriction base type.</returns>
    property BaseTypeName: DNXmlQualifiedName read get_BaseTypeName write set_BaseTypeName;
    ///<summary>Gets or sets information on the base type.</summary>
    ///<returns>The base type for the <see langword="simpleType" />
    ///  element.</returns>
    property BaseType: DNXmlSchemaSimpleType read get_BaseType write set_BaseType;
    ///<summary>Gets or sets an Xml Schema facet. </summary>
    ///<returns>One of the following facet classes:
    ///<see cref="T:System.Xml.Schema.XmlSchemaLengthFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMinLengthFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMaxLengthFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaPatternFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaEnumerationFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMaxInclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMaxExclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMinInclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaMinExclusiveFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaFractionDigitsFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaTotalDigitsFacet" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaWhiteSpaceFacet" />
    ///  .</returns>
    property Facets: DNXmlSchemaObjectCollection read get_Facets;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleTypeRestriction = class(TDNGenericImport<DNXmlSchemaSimpleTypeRestrictionClass, DNXmlSchemaSimpleTypeRestriction>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleTypeUnionClass = interface(DNXmlSchemaSimpleTypeContentClass)
  ['{F6EBE348-DFCA-59AD-9E7E-6C1C3E27CFAC}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleTypeUnion" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleTypeUnion;

  end;

  ///<summary>Represents the <see langword="union" />
  ///  element for simple types from XML Schema as specified by the World Wide Web Consortium (W3C). A <see langword="union" />
  ///  datatype can be used to specify the content of a <see langword="simpleType" />
  ///  . The value of the <see langword="simpleType" />
  ///  element must be any one of a set of alternative datatypes specified in the union. Union types are always derived types and must comprise at least two alternative datatypes.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleTypeUnion')]
  DNXmlSchemaSimpleTypeUnion = interface(DNXmlSchemaSimpleTypeContent)
  ['{12FEEBF7-E17C-300D-98AB-E4B5A71B1332}']
  { getters & setters } 

    function get_BaseTypes: DNXmlSchemaObjectCollection;
    function get_MemberTypes: TArray<DNXmlQualifiedName>;
    procedure set_MemberTypes(value: TArray<DNXmlQualifiedName>);
    function get_BaseMemberTypes: TArray<DNXmlSchemaSimpleType>;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the collection of base types.</summary>
    ///<returns>The collection of simple type base values.</returns>
    property BaseTypes: DNXmlSchemaObjectCollection read get_BaseTypes;
    ///<summary>Gets or sets the array of qualified member names of built-in data types or <see langword="simpleType" />
    ///  elements defined in this schema (or another schema indicated by the specified namespace).</summary>
    ///<returns>An array that consists of a list of members of built-in data types or simple types.</returns>
    property MemberTypes: TArray<DNXmlQualifiedName> read get_MemberTypes write set_MemberTypes;
    ///<summary>Gets an array of <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  objects representing the type of the <see langword="simpleType" />
    ///  element based on the <see cref="P:System.Xml.Schema.XmlSchemaSimpleTypeUnion.BaseTypes" />
    ///  and <see cref="P:System.Xml.Schema.XmlSchemaSimpleTypeUnion.MemberTypes" />
    ///  values of the simple type.</summary>
    ///<returns>An array of <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  objects representing the type of the <see langword="simpleType" />
    ///  element.</returns>
    property BaseMemberTypes: TArray<DNXmlSchemaSimpleType> read get_BaseMemberTypes;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleTypeUnion = class(TDNGenericImport<DNXmlSchemaSimpleTypeUnionClass, DNXmlSchemaSimpleTypeUnion>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaTypeClass = interface(DNXmlSchemaAnnotatedClass)
  ['{8FDF1377-B093-5013-822E-311F8771F20E}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaType;

  { static methods } 

    ///<summary>Returns an <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  that represents the built-in simple type of the simple type that is specified by the qualified name.</summary>
    ///  <param name="qualifiedName">The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  of the simple type.</param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  that represents the built-in simple type.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    {class} function GetBuiltInSimpleType(qualifiedName: DNXmlQualifiedName): DNXmlSchemaSimpleType; overload;
    ///<summary>Returns an <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  that represents the built-in simple type of the specified simple type.</summary>
    ///  <param name="typeCode">One of the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  values representing the simple type.</param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  that represents the built-in simple type.</returns>
    {class} function GetBuiltInSimpleType(typeCode: DNXmlTypeCode): DNXmlSchemaSimpleType; overload;
    ///<summary>Returns an <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  that represents the built-in complex type of the complex type specified.</summary>
    ///  <param name="typeCode">One of the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  values representing the complex type.</param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  that represents the built-in complex type.</returns>
    {class} function GetBuiltInComplexType(typeCode: DNXmlTypeCode): DNXmlSchemaComplexType; overload;
    ///<summary>Returns an <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  that represents the built-in complex type of the complex type specified by qualified name.</summary>
    ///  <param name="qualifiedName">The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  of the complex type.</param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  that represents the built-in complex type.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  parameter is <see langword="null" />
    ///  .</exception>
    {class} function GetBuiltInComplexType(qualifiedName: DNXmlQualifiedName): DNXmlSchemaComplexType; overload;
    ///<summary>Returns a value indicating if the derived schema type specified is derived from the base schema type specified</summary>
    ///  <param name="derivedType">The derived <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  to test.</param>
    ///  <param name="baseType">The base <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  to test the derived <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  against.</param>
    ///  <param name="except">One of the <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values representing a type derivation method to exclude from testing.</param>
    ///<returns><see langword="true" />
    ///  if the derived type is derived from the base type; otherwise, <see langword="false" />
    ///  .</returns>
    {class} function IsDerivedFrom(derivedType: DNXmlSchemaType; baseType: DNXmlSchemaType; &except: DNXmlSchemaDerivationMethod): Boolean;

  end;

  ///<summary>The base class for all simple types and complex types.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaType')]
  DNXmlSchemaType = interface(DNXmlSchemaAnnotated)
  ['{034C6617-1C55-3EA2-8010-DFB0CD9A8FFE}']
  { getters & setters } 

    function get_Name: string;
    procedure set_Name(value: string);
    function get_Final: DNXmlSchemaDerivationMethod;
    procedure set_Final(value: DNXmlSchemaDerivationMethod);
    function get_QualifiedName: DNXmlQualifiedName;
    function get_FinalResolved: DNXmlSchemaDerivationMethod;
    function get_BaseSchemaType: DDN.mscorlib.DNObject;
    function get_BaseXmlSchemaType: DNXmlSchemaType;
    function get_DerivedBy: DNXmlSchemaDerivationMethod;
    function get_Datatype: DNXmlSchemaDatatype;
    function get_IsMixed: Boolean;
    procedure set_IsMixed(value: Boolean);
    function get_TypeCode: DNXmlTypeCode;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the name of the type.</summary>
    ///<returns>The name of the type.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the final attribute of the type derivation that indicates if further derivations are allowed.</summary>
    ///<returns>One of the valid <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values. The default is <see cref="F:System.Xml.Schema.XmlSchemaDerivationMethod.None" />
    ///  .</returns>
    property &Final: DNXmlSchemaDerivationMethod read get_Final write set_Final;
    ///<summary>Gets the qualified name for the type built from the <see langword="Name" />
    ///  attribute of this type. This is a post-schema-compilation property.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  for the type built from the <see langword="Name" />
    ///  attribute of this type.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets the post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaType.Final" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaType.Final" />
    ///  property. The default is the <see langword="finalDefault" />
    ///  attribute value of the <see langword="schema" />
    ///  element.</returns>
    property FinalResolved: DNXmlSchemaDerivationMethod read get_FinalResolved;
    ///<summary>Gets the post-compilation object type or the built-in XML Schema Definition Language (XSD) data type, simpleType element, or complexType element. This is a post-schema-compilation infoset property.</summary>
    ///<returns>The built-in XSD data type, simpleType element, or complexType element.</returns>
    property BaseSchemaType: DDN.mscorlib.DNObject read get_BaseSchemaType;
    ///<summary>Gets the post-compilation value for the base type of this schema type.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object representing the base type of this schema type.</returns>
    property BaseXmlSchemaType: DNXmlSchemaType read get_BaseXmlSchemaType;
    ///<summary>Gets the post-compilation information on how this element was derived from its base type.</summary>
    ///<returns>One of the valid <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values.</returns>
    property DerivedBy: DNXmlSchemaDerivationMethod read get_DerivedBy;
    ///<summary>Gets the post-compilation value for the data type of the complex type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  post-schema-compilation value.</returns>
    property Datatype: DNXmlSchemaDatatype read get_Datatype;
    ///<summary>Gets or sets a value indicating if this type has a mixed content model. This property is only valid in a complex type.</summary>
    ///<returns><see langword="true" />
    ///  if the type has a mixed content model; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsMixed: Boolean read get_IsMixed write set_IsMixed;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  of the type.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  values.</returns>
    property TypeCode: DNXmlTypeCode read get_TypeCode;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaType = class(TDNGenericImport<DNXmlSchemaTypeClass, DNXmlSchemaType>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaComplexTypeClass = interface(DNXmlSchemaTypeClass)
  ['{672EAADE-3AD2-5F7E-9611-4C1E00A4F003}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaComplexType;

  end;

  ///<summary>Represents the <see langword="complexType" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class defines a complex type that determines the set of attributes and content of an element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaComplexType')]
  DNXmlSchemaComplexType = interface(DNXmlSchemaType)
  ['{DD5B141E-1C22-39F2-9F27-2A12947759A9}']
  { getters & setters } 

    function get_IsAbstract: Boolean;
    procedure set_IsAbstract(value: Boolean);
    function get_Block: DNXmlSchemaDerivationMethod;
    procedure set_Block(value: DNXmlSchemaDerivationMethod);
    function get_IsMixed: Boolean;
    procedure set_IsMixed(value: Boolean);
    function get_ContentModel: DNXmlSchemaContentModel;
    procedure set_ContentModel(value: DNXmlSchemaContentModel);
    function get_Particle: DNXmlSchemaParticle;
    procedure set_Particle(value: DNXmlSchemaParticle);
    function get_Attributes: DNXmlSchemaObjectCollection;
    function get_AnyAttribute: DNXmlSchemaAnyAttribute;
    procedure set_AnyAttribute(value: DNXmlSchemaAnyAttribute);
    function get_ContentType: DNXmlSchemaContentType;
    function get_ContentTypeParticle: DNXmlSchemaParticle;
    function get_BlockResolved: DNXmlSchemaDerivationMethod;
    function get_AttributeUses: DNXmlSchemaObjectTable;
    function get_AttributeWildcard: DNXmlSchemaAnyAttribute;
    function get_Name: string;
    procedure set_Name(value: string);
    function get_Final: DNXmlSchemaDerivationMethod;
    procedure set_Final(value: DNXmlSchemaDerivationMethod);
    function get_QualifiedName: DNXmlQualifiedName;
    function get_FinalResolved: DNXmlSchemaDerivationMethod;
    function get_BaseSchemaType: DDN.mscorlib.DNObject;
    function get_BaseXmlSchemaType: DNXmlSchemaType;
    function get_DerivedBy: DNXmlSchemaDerivationMethod;
    function get_Datatype: DNXmlSchemaDatatype;
    function get_TypeCode: DNXmlTypeCode;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the information that determines if the <see langword="complexType" />
    ///  element can be used in the instance document.</summary>
    ///<returns>If <see langword="true" />
    ///  , an element cannot use this <see langword="complexType" />
    ///  element directly and must use a complex type that is derived from this <see langword="complexType" />
    ///  element. The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsAbstract: Boolean read get_IsAbstract write set_IsAbstract;
    ///<summary>Gets or sets the <see langword="block" />
    ///  attribute.</summary>
    ///<returns>The <see langword="block" />
    ///  attribute prevents a complex type from being used in the specified type of derivation. The default is <see langword="XmlSchemaDerivationMethod.None" />
    ///  .Optional.</returns>
    property Block: DNXmlSchemaDerivationMethod read get_Block write set_Block;
    ///<summary>Gets or sets information that determines if the complex type has a mixed content model (markup within the content).</summary>
    ///<returns><see langword="true" />
    ///  , if character data can appear between child elements of this complex type; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .Optional.</returns>
    property IsMixed: Boolean read get_IsMixed write set_IsMixed;
    ///<summary>Gets or sets the post-compilation <see cref="T:System.Xml.Schema.XmlSchemaContentModel" />
    ///  of this complex type.</summary>
    ///<returns>The content model type that is one of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleContent" />
    ///  or <see cref="T:System.Xml.Schema.XmlSchemaComplexContent" />
    ///  classes.</returns>
    property ContentModel: DNXmlSchemaContentModel read get_ContentModel write set_ContentModel;
    ///<summary>Gets or sets the compositor type as one of the <see cref="T:System.Xml.Schema.XmlSchemaGroupRef" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaChoice" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAll" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSequence" />
    ///  classes.</summary>
    ///<returns>The compositor type.</returns>
    property Particle: DNXmlSchemaParticle read get_Particle write set_Particle;
    ///<summary>Gets the collection of attributes for the complex type.</summary>
    ///<returns>Contains <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  and <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroupRef" />
    ///  classes.</returns>
    property Attributes: DNXmlSchemaObjectCollection read get_Attributes;
    ///<summary>Gets or sets the value for the <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the complex type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaAnyAttribute" />
    ///  component of the complex type.</returns>
    property AnyAttribute: DNXmlSchemaAnyAttribute read get_AnyAttribute write set_AnyAttribute;
    ///<summary>Gets the content model of the complex type which holds the post-compilation value.</summary>
    ///<returns>The post-compilation value of the content model for the complex type.</returns>
    property ContentType: DNXmlSchemaContentType read get_ContentType;
    ///<summary>Gets the particle that holds the post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaComplexType.ContentType" />
    ///  particle.</summary>
    ///<returns>The particle for the content type. The post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaComplexType.ContentType" />
    ///  particle.</returns>
    property ContentTypeParticle: DNXmlSchemaParticle read get_ContentTypeParticle;
    ///<summary>Gets the value after the type has been compiled to the post-schema-validation information set (infoset). This value indicates how the type is enforced when <see langword="xsi:type" />
    ///  is used in the instance document.</summary>
    ///<returns>The post-schema-validated infoset value. The default is <see langword="BlockDefault" />
    ///  value on the <see langword="schema" />
    ///  element.</returns>
    property BlockResolved: DNXmlSchemaDerivationMethod read get_BlockResolved;
    ///<summary>Gets the collection of all the complied attributes of this complex type and its base types.</summary>
    ///<returns>The collection of all the attributes from this complex type and its base types. The post-compilation value of the <see langword="AttributeUses" />
    ///  property.</returns>
    property AttributeUses: DNXmlSchemaObjectTable read get_AttributeUses;
    ///<summary>Gets the post-compilation value for <see langword="anyAttribute" />
    ///  for this complex type and its base type(s).</summary>
    ///<returns>The post-compilation value of the <see langword="anyAttribute" />
    ///  element.</returns>
    property AttributeWildcard: DNXmlSchemaAnyAttribute read get_AttributeWildcard;
    ///<summary>Gets or sets the name of the type.</summary>
    ///<returns>The name of the type.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the final attribute of the type derivation that indicates if further derivations are allowed.</summary>
    ///<returns>One of the valid <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values. The default is <see cref="F:System.Xml.Schema.XmlSchemaDerivationMethod.None" />
    ///  .</returns>
    property &Final: DNXmlSchemaDerivationMethod read get_Final write set_Final;
    ///<summary>Gets the qualified name for the type built from the <see langword="Name" />
    ///  attribute of this type. This is a post-schema-compilation property.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  for the type built from the <see langword="Name" />
    ///  attribute of this type.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets the post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaType.Final" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaType.Final" />
    ///  property. The default is the <see langword="finalDefault" />
    ///  attribute value of the <see langword="schema" />
    ///  element.</returns>
    property FinalResolved: DNXmlSchemaDerivationMethod read get_FinalResolved;
    ///<summary>Gets the post-compilation object type or the built-in XML Schema Definition Language (XSD) data type, simpleType element, or complexType element. This is a post-schema-compilation infoset property.</summary>
    ///<returns>The built-in XSD data type, simpleType element, or complexType element.</returns>
    property BaseSchemaType: DDN.mscorlib.DNObject read get_BaseSchemaType;
    ///<summary>Gets the post-compilation value for the base type of this schema type.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object representing the base type of this schema type.</returns>
    property BaseXmlSchemaType: DNXmlSchemaType read get_BaseXmlSchemaType;
    ///<summary>Gets the post-compilation information on how this element was derived from its base type.</summary>
    ///<returns>One of the valid <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values.</returns>
    property DerivedBy: DNXmlSchemaDerivationMethod read get_DerivedBy;
    ///<summary>Gets the post-compilation value for the data type of the complex type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  post-schema-compilation value.</returns>
    property Datatype: DNXmlSchemaDatatype read get_Datatype;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  of the type.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  values.</returns>
    property TypeCode: DNXmlTypeCode read get_TypeCode;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaComplexType = class(TDNGenericImport<DNXmlSchemaComplexTypeClass, DNXmlSchemaComplexType>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSimpleTypeClass = interface(DNXmlSchemaTypeClass)
  ['{C2B52D2F-718D-53B4-8C9A-186C5A646571}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSimpleType;

  end;

  ///<summary>Represents the <see langword="simpleType" />
  ///  element for simple content from XML Schema as specified by the World Wide Web Consortium (W3C). This class defines a simple type. Simple types can specify information and constraints for the value of attributes or elements with text-only content.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSimpleType')]
  DNXmlSchemaSimpleType = interface(DNXmlSchemaType)
  ['{5CF951C1-5287-3510-9277-FD30287ECB0F}']
  { getters & setters } 

    function get_Content: DNXmlSchemaSimpleTypeContent;
    procedure set_Content(value: DNXmlSchemaSimpleTypeContent);
    function get_Name: string;
    procedure set_Name(value: string);
    function get_Final: DNXmlSchemaDerivationMethod;
    procedure set_Final(value: DNXmlSchemaDerivationMethod);
    function get_QualifiedName: DNXmlQualifiedName;
    function get_FinalResolved: DNXmlSchemaDerivationMethod;
    function get_BaseSchemaType: DDN.mscorlib.DNObject;
    function get_BaseXmlSchemaType: DNXmlSchemaType;
    function get_DerivedBy: DNXmlSchemaDerivationMethod;
    function get_Datatype: DNXmlSchemaDatatype;
    function get_IsMixed: Boolean;
    procedure set_IsMixed(value: Boolean);
    function get_TypeCode: DNXmlTypeCode;
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets one of <see cref="T:System.Xml.Schema.XmlSchemaSimpleTypeUnion" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaSimpleTypeList" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaSimpleTypeRestriction" />
    ///  .</summary>
    ///<returns>One of <see langword="XmlSchemaSimpleTypeUnion" />
    ///  , <see langword="XmlSchemaSimpleTypeList" />
    ///  , or <see langword="XmlSchemaSimpleTypeRestriction" />
    ///  .</returns>
    property Content: DNXmlSchemaSimpleTypeContent read get_Content write set_Content;
    ///<summary>Gets or sets the name of the type.</summary>
    ///<returns>The name of the type.</returns>
    property Name: string read get_Name write set_Name;
    ///<summary>Gets or sets the final attribute of the type derivation that indicates if further derivations are allowed.</summary>
    ///<returns>One of the valid <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values. The default is <see cref="F:System.Xml.Schema.XmlSchemaDerivationMethod.None" />
    ///  .</returns>
    property &Final: DNXmlSchemaDerivationMethod read get_Final write set_Final;
    ///<summary>Gets the qualified name for the type built from the <see langword="Name" />
    ///  attribute of this type. This is a post-schema-compilation property.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  for the type built from the <see langword="Name" />
    ///  attribute of this type.</returns>
    property QualifiedName: DNXmlQualifiedName read get_QualifiedName;
    ///<summary>Gets the post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaType.Final" />
    ///  property.</summary>
    ///<returns>The post-compilation value of the <see cref="P:System.Xml.Schema.XmlSchemaType.Final" />
    ///  property. The default is the <see langword="finalDefault" />
    ///  attribute value of the <see langword="schema" />
    ///  element.</returns>
    property FinalResolved: DNXmlSchemaDerivationMethod read get_FinalResolved;
    ///<summary>Gets the post-compilation object type or the built-in XML Schema Definition Language (XSD) data type, simpleType element, or complexType element. This is a post-schema-compilation infoset property.</summary>
    ///<returns>The built-in XSD data type, simpleType element, or complexType element.</returns>
    property BaseSchemaType: DDN.mscorlib.DNObject read get_BaseSchemaType;
    ///<summary>Gets the post-compilation value for the base type of this schema type.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object representing the base type of this schema type.</returns>
    property BaseXmlSchemaType: DNXmlSchemaType read get_BaseXmlSchemaType;
    ///<summary>Gets the post-compilation information on how this element was derived from its base type.</summary>
    ///<returns>One of the valid <see cref="T:System.Xml.Schema.XmlSchemaDerivationMethod" />
    ///  values.</returns>
    property DerivedBy: DNXmlSchemaDerivationMethod read get_DerivedBy;
    ///<summary>Gets the post-compilation value for the data type of the complex type.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  post-schema-compilation value.</returns>
    property Datatype: DNXmlSchemaDatatype read get_Datatype;
    ///<summary>Gets or sets a value indicating if this type has a mixed content model. This property is only valid in a complex type.</summary>
    ///<returns><see langword="true" />
    ///  if the type has a mixed content model; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IsMixed: Boolean read get_IsMixed write set_IsMixed;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  of the type.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Schema.XmlTypeCode" />
    ///  values.</returns>
    property TypeCode: DNXmlTypeCode read get_TypeCode;
    property Id: string read get_Id write set_Id;
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaSimpleType = class(TDNGenericImport<DNXmlSchemaSimpleTypeClass, DNXmlSchemaSimpleType>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaXPathClass = interface(DNXmlSchemaAnnotatedClass)
  ['{A37BC35E-9B84-536D-8BB7-DB84FA0C41E8}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaXPath" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaXPath;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="selector" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaXPath')]
  DNXmlSchemaXPath = interface(DNXmlSchemaAnnotated)
  ['{FD9FF2B1-928E-33F7-915C-ED9AB1AB7D50}']
  { getters & setters } 

    function get_XPath: string;
    procedure set_XPath(value: string);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the attribute for the XPath expression.</summary>
    ///<returns>The string attribute value for the XPath expression.</returns>
    property XPath: string read get_XPath write set_XPath;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  representing the <see langword="annotation" />
    ///  property.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the qualified attributes that do not belong to the current schema's target namespace.</summary>
    ///<returns>An array of qualified <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaXPath = class(TDNGenericImport<DNXmlSchemaXPathClass, DNXmlSchemaXPath>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAnnotationClass = interface(DNXmlSchemaObjectClass)
  ['{2FE9A18A-1D68-5848-904C-F390D137E1F4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAnnotation;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="annotation" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAnnotation')]
  DNXmlSchemaAnnotation = interface(DNXmlSchemaObject)
  ['{49BDD231-79E7-3A56-B297-A343DF715747}']
  { getters & setters } 

    function get_Id: string;
    procedure set_Id(value: string);
    function get_Items: DNXmlSchemaObjectCollection;
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets the <see langword="Items" />
    ///  collection that is used to store the <see langword="appinfo" />
    ///  and <see langword="documentation" />
    ///  child elements.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaObjectCollection" />
    ///  of <see langword="appinfo" />
    ///  and <see langword="documentation" />
    ///  child elements.</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    ///<summary>Gets or sets the qualified attributes that do not belong to the schema's target namespace.</summary>
    ///<returns>An array of <see cref="T:System.Xml.XmlAttribute" />
    ///  objects that do not belong to the schema's target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAnnotation = class(TDNGenericImport<DNXmlSchemaAnnotationClass, DNXmlSchemaAnnotation>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaAppInfoClass = interface(DNXmlSchemaObjectClass)
  ['{CA13D1DE-A448-5039-8B57-0FC60DEBFB28}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaAppInfo" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaAppInfo;

  end;

  ///<summary>Represents the World Wide Web Consortium (W3C) <see langword="appinfo" />
  ///  element.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaAppInfo')]
  DNXmlSchemaAppInfo = interface(DNXmlSchemaObject)
  ['{8683860B-0619-30F9-BCDE-A4CB7E4F61E7}']
  { getters & setters } 

    function get_Source: string;
    procedure set_Source(value: string);
    function get_Markup: TArray<DNXmlNode>;
    procedure set_Markup(value: TArray<DNXmlNode>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the source of the application information.</summary>
    ///<returns>A Uniform Resource Identifier (URI) reference. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Source: string read get_Source write set_Source;
    ///<summary>Gets or sets an array of <see cref="T:System.Xml.XmlNode" />
    ///  objects that represents the <see langword="appinfo" />
    ///  child nodes.</summary>
    ///<returns>An array of <see cref="T:System.Xml.XmlNode" />
    ///  objects that represents the <see langword="appinfo" />
    ///  child nodes.</returns>
    property Markup: TArray<DNXmlNode> read get_Markup write set_Markup;
    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaAppInfo = class(TDNGenericImport<DNXmlSchemaAppInfoClass, DNXmlSchemaAppInfo>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaDocumentationClass = interface(DNXmlSchemaObjectClass)
  ['{80679780-E56A-5917-96C0-0AF891D68E5C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaDocumentation" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaDocumentation;

  end;

  ///<summary>Represents the <see langword="documentation" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class specifies information to be read or used by humans within an <see langword="annotation" />
  ///  .</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaDocumentation')]
  DNXmlSchemaDocumentation = interface(DNXmlSchemaObject)
  ['{D43BD4BE-569F-3D2B-9966-FD07F6231581}']
  { getters & setters } 

    function get_Source: string;
    procedure set_Source(value: string);
    function get_Language: string;
    procedure set_Language(value: string);
    function get_Markup: TArray<DNXmlNode>;
    procedure set_Markup(value: TArray<DNXmlNode>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the Uniform Resource Identifier (URI) source of the information.</summary>
    ///<returns>A URI reference. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Source: string read get_Source write set_Source;
    ///<summary>Gets or sets the <see langword="xml:lang" />
    ///  attribute. This serves as an indicator of the language used in the contents.</summary>
    ///<returns>The <see langword="xml:lang" />
    ///  attribute.Optional.</returns>
    property Language: string read get_Language write set_Language;
    ///<summary>Gets or sets an array of <see langword="XmlNodes" />
    ///  that represents the documentation child nodes.</summary>
    ///<returns>The array that represents the documentation child nodes.</returns>
    property Markup: TArray<DNXmlNode> read get_Markup write set_Markup;
    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaDocumentation = class(TDNGenericImport<DNXmlSchemaDocumentationClass, DNXmlSchemaDocumentation>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaExternalClass = interface(DNXmlSchemaObjectClass)
  ['{042C852D-45F1-5226-BE62-CAC2FF74BF8D}']
  end;

  ///<summary>An abstract class. Provides information about the included schema.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaExternal')]
  DNXmlSchemaExternal = interface(DNXmlSchemaObject)
  ['{2140C659-30AF-305C-AE76-DA8E408DDBD0}']
  { getters & setters } 

    function get_SchemaLocation: string;
    procedure set_SchemaLocation(value: string);
    function get_Schema: DNXmlSchema;
    procedure set_Schema(value: DNXmlSchema);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the Uniform Resource Identifier (URI) location for the schema, which tells the schema processor where the schema physically resides.</summary>
    ///<returns>The URI location for the schema.Optional for imported schemas.</returns>
    property SchemaLocation: string read get_SchemaLocation write set_SchemaLocation;
    ///<summary>Gets or sets the <see langword="XmlSchema" />
    ///  for the referenced schema.</summary>
    ///<returns>The <see langword="XmlSchema" />
    ///  for the referenced schema.</returns>
    property Schema: DNXmlSchema read get_Schema write set_Schema;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets and sets the qualified attributes, which do not belong to the schema target namespace.</summary>
    ///<returns>Qualified attributes that belong to another target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    ///<summary>Gets or sets the line number in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line number.</returns>
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    ///<summary>Gets or sets the line position in the file to which the <see langword="schema" />
    ///  element refers.</summary>
    ///<returns>The line position.</returns>
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    ///<summary>Gets or sets the source location for the file that loaded the schema.</summary>
    ///<returns>The source location (URI) for the file.</returns>
    property SourceUri: string read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the parent of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</summary>
    ///<returns>The parent <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  of this <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  to use with this schema object.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  property for the schema object.</returns>
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaExternal = class(TDNGenericImport<DNXmlSchemaExternalClass, DNXmlSchemaExternal>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaImportClass = interface(DNXmlSchemaExternalClass)
  ['{5C57ACBD-AD2B-5EDF-BE09-3ABFC46D13CE}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaImport" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaImport;

  end;

  ///<summary>Represents the <see langword="import" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class is used to import schema components from other schemas.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaImport')]
  DNXmlSchemaImport = interface(DNXmlSchemaExternal)
  ['{FF7FC38A-2EC5-3322-BB85-238380171C5A}']
  { getters & setters } 

    function get_Namespace: string;
    procedure set_Namespace(value: string);
    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_SchemaLocation: string;
    procedure set_SchemaLocation(value: string);
    function get_Schema: DNXmlSchema;
    procedure set_Schema(value: DNXmlSchema);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the target namespace for the imported schema as a Uniform Resource Identifier (URI) reference.</summary>
    ///<returns>The target namespace for the imported schema as a URI reference.Optional.</returns>
    property Namespace: string read get_Namespace write set_Namespace;
    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>The annotation.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the Uniform Resource Identifier (URI) location for the schema, which tells the schema processor where the schema physically resides.</summary>
    ///<returns>The URI location for the schema.Optional for imported schemas.</returns>
    property SchemaLocation: string read get_SchemaLocation write set_SchemaLocation;
    ///<summary>Gets or sets the <see langword="XmlSchema" />
    ///  for the referenced schema.</summary>
    ///<returns>The <see langword="XmlSchema" />
    ///  for the referenced schema.</returns>
    property Schema: DNXmlSchema read get_Schema write set_Schema;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets and sets the qualified attributes, which do not belong to the schema target namespace.</summary>
    ///<returns>Qualified attributes that belong to another target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaImport = class(TDNGenericImport<DNXmlSchemaImportClass, DNXmlSchemaImport>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaIncludeClass = interface(DNXmlSchemaExternalClass)
  ['{83DA6F85-D5C2-593E-A755-349F81E1AA93}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaInclude" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaInclude;

  end;

  ///<summary>Represents the <see langword="include" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class is used to include declarations and definitions from an external schema. The included declarations and definitions are then available for processing in the containing schema.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaInclude')]
  DNXmlSchemaInclude = interface(DNXmlSchemaExternal)
  ['{8D0930C2-FF47-35B0-A7D5-73D42206502A}']
  { getters & setters } 

    function get_Annotation: DNXmlSchemaAnnotation;
    procedure set_Annotation(value: DNXmlSchemaAnnotation);
    function get_SchemaLocation: string;
    procedure set_SchemaLocation(value: string);
    function get_Schema: DNXmlSchema;
    procedure set_Schema(value: DNXmlSchema);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the <see langword="annotation" />
    ///  property.</summary>
    ///<returns>The annotation.</returns>
    property Annotation: DNXmlSchemaAnnotation read get_Annotation write set_Annotation;
    ///<summary>Gets or sets the Uniform Resource Identifier (URI) location for the schema, which tells the schema processor where the schema physically resides.</summary>
    ///<returns>The URI location for the schema.Optional for imported schemas.</returns>
    property SchemaLocation: string read get_SchemaLocation write set_SchemaLocation;
    ///<summary>Gets or sets the <see langword="XmlSchema" />
    ///  for the referenced schema.</summary>
    ///<returns>The <see langword="XmlSchema" />
    ///  for the referenced schema.</returns>
    property Schema: DNXmlSchema read get_Schema write set_Schema;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets and sets the qualified attributes, which do not belong to the schema target namespace.</summary>
    ///<returns>Qualified attributes that belong to another target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaInclude = class(TDNGenericImport<DNXmlSchemaIncludeClass, DNXmlSchemaInclude>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaRedefineClass = interface(DNXmlSchemaExternalClass)
  ['{B4182246-8C70-50E1-9170-3D51E38EE322}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaRedefine" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaRedefine;

  end;

  ///<summary>Represents the <see langword="redefine" />
  ///  element from XML Schema as specified by the World Wide Web Consortium (W3C). This class can be used to allow simple and complex types, groups and attribute groups from external schema files to be redefined in the current schema. This class can also be used to provide versioning for the schema elements.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaRedefine')]
  DNXmlSchemaRedefine = interface(DNXmlSchemaExternal)
  ['{10563095-EB2F-3F5C-B4E8-12F6338EC5D5}']
  { getters & setters } 

    function get_Items: DNXmlSchemaObjectCollection;
    function get_AttributeGroups: DNXmlSchemaObjectTable;
    function get_SchemaTypes: DNXmlSchemaObjectTable;
    function get_Groups: DNXmlSchemaObjectTable;
    function get_SchemaLocation: string;
    procedure set_SchemaLocation(value: string);
    function get_Schema: DNXmlSchema;
    procedure set_Schema(value: DNXmlSchema);
    function get_Id: string;
    procedure set_Id(value: string);
    function get_UnhandledAttributes: TArray<DNXmlAttribute>;
    procedure set_UnhandledAttributes(value: TArray<DNXmlAttribute>);
    function get_LineNumber: Int32;
    procedure set_LineNumber(value: Int32);
    function get_LinePosition: Int32;
    procedure set_LinePosition(value: Int32);
    function get_SourceUri: string;
    procedure set_SourceUri(value: string);
    function get_Parent: DNXmlSchemaObject;
    procedure set_Parent(value: DNXmlSchemaObject);
    function get_Namespaces: DNXmlSerializerNamespaces;
    procedure set_Namespaces(value: DNXmlSerializerNamespaces);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the collection of the following classes: <see cref="T:System.Xml.Schema.XmlSchemaAnnotation" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAttributeGroup" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  , and <see cref="T:System.Xml.Schema.XmlSchemaGroup" />
    ///  .</summary>
    ///<returns>The elements contained within the redefine element.</returns>
    property Items: DNXmlSchemaObjectCollection read get_Items;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  , for all attributes in the schema, which holds the post-compilation value of the <see langword="AttributeGroups" />
    ///  property.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  for all attributes in the schema. The post-compilation value of the <see langword="AttributeGroups" />
    ///  property.</returns>
    property AttributeGroups: DNXmlSchemaObjectTable read get_AttributeGroups;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  , for all simple and complex types in the schema, which holds the post-compilation value of the <see langword="SchemaTypes" />
    ///  property.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  for all schema types in the schema. The post-compilation value of the <see langword="SchemaTypes" />
    ///  property.</returns>
    property SchemaTypes: DNXmlSchemaObjectTable read get_SchemaTypes;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  , for all groups in the schema, which holds the post-compilation value of the <see langword="Groups" />
    ///  property.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  for all groups in the schema. The post-compilation value of the <see langword="Groups" />
    ///  property.</returns>
    property Groups: DNXmlSchemaObjectTable read get_Groups;
    ///<summary>Gets or sets the Uniform Resource Identifier (URI) location for the schema, which tells the schema processor where the schema physically resides.</summary>
    ///<returns>The URI location for the schema.Optional for imported schemas.</returns>
    property SchemaLocation: string read get_SchemaLocation write set_SchemaLocation;
    ///<summary>Gets or sets the <see langword="XmlSchema" />
    ///  for the referenced schema.</summary>
    ///<returns>The <see langword="XmlSchema" />
    ///  for the referenced schema.</returns>
    property Schema: DNXmlSchema read get_Schema write set_Schema;
    ///<summary>Gets or sets the string id.</summary>
    ///<returns>The string id. The default is <see langword="String.Empty" />
    ///  .Optional.</returns>
    property Id: string read get_Id write set_Id;
    ///<summary>Gets and sets the qualified attributes, which do not belong to the schema target namespace.</summary>
    ///<returns>Qualified attributes that belong to another target namespace.</returns>
    property UnhandledAttributes: TArray<DNXmlAttribute> read get_UnhandledAttributes write set_UnhandledAttributes;
    property LineNumber: Int32 read get_LineNumber write set_LineNumber;
    property LinePosition: Int32 read get_LinePosition write set_LinePosition;
    property SourceUri: string read get_SourceUri write set_SourceUri;
    property Parent: DNXmlSchemaObject read get_Parent write set_Parent;
    property Namespaces: DNXmlSerializerNamespaces read get_Namespaces write set_Namespaces;
  end;

  TDNXmlSchemaRedefine = class(TDNGenericImport<DNXmlSchemaRedefineClass, DNXmlSchemaRedefine>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaObjectEnumeratorClass = interface(DNObjectClass)
  ['{4B2DAAD9-F874-58AE-B3B1-70298168859C}']
  end;

  ///<summary>Represents the enumerator for the <see cref="T:System.Xml.Schema.XmlSchemaObjectCollection" />
  ///  .</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaObjectEnumerator')]
  DNXmlSchemaObjectEnumerator = interface(DDN.mscorlib.DNIEnumerator)
  ['{C3B71B25-84A5-3735-A28D-8ED030EAB9B9}']
  { getters & setters } 

    function get_Current: DNXmlSchemaObject;

  { methods } 

    ///<summary>Resets the enumerator to the start of the collection.</summary>
    procedure Reset;
    ///<summary>Moves to the next item in the collection.</summary>
    ///<returns><see langword="false" />
    ///  at the end of the collection.</returns>
    function MoveNext: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the current <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  in the collection.</summary>
    ///<returns>The current <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  .</returns>
    property Current: DNXmlSchemaObject read get_Current;
  end;

  TDNXmlSchemaObjectEnumerator = class(TDNGenericImport<DNXmlSchemaObjectEnumeratorClass, DNXmlSchemaObjectEnumerator>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaObjectTableClass = interface(DDN.mscorlib.DNObjectClass)
  ['{07F2185B-B6D2-58A1-B8D9-F2C0C4DF0645}']
  end;

  ///<summary>Provides the collections for contained elements in the <see cref="T:System.Xml.Schema.XmlSchema" />
  ///  class (for example, Attributes, AttributeGroups, Elements, and so on).</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaObjectTable')]
  DNXmlSchemaObjectTable = interface(DDN.mscorlib.DNObject)
  ['{46B8059C-7719-33A6-AA9C-070DB3D6F7F5}']
  { getters & setters } 

    function get_Count: Int32;
    function get_Item(name: DNXmlQualifiedName): DNXmlSchemaObject;
    function get_Names: DDN.mscorlib.DNICollection;
    function get_Values: DDN.mscorlib.DNICollection;

  { methods } 

    ///<summary>Determines if the qualified name specified exists in the collection.</summary>
    ///  <param name="name">The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the qualified name specified exists in the collection; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(name: DNXmlQualifiedName): Boolean;
    ///<summary>Returns an enumerator that can iterate through the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.IDictionaryEnumerator" />
    ///  that can iterate through <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIDictionaryEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of items contained in the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</summary>
    ///<returns>The number of items contained in the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</returns>
    property Count: Int32 read get_Count;
    property Item[name: DNXmlQualifiedName]: DNXmlSchemaObject read get_Item; default;
    ///<summary>Returns a collection of all the named elements in the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</summary>
    ///<returns>A collection of all the named elements in the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</returns>
    property Names: DDN.mscorlib.DNICollection read get_Names;
    ///<summary>Returns a collection of all the values for all the elements in the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</summary>
    ///<returns>A collection of all the values for all the elements in the <see cref="T:System.Xml.Schema.XmlSchemaObjectTable" />
    ///  .</returns>
    property Values: DDN.mscorlib.DNICollection read get_Values;
  end;

  TDNXmlSchemaObjectTable = class(TDNGenericImport<DNXmlSchemaObjectTableClass, DNXmlSchemaObjectTable>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaSetClass = interface(DDN.mscorlib.DNObjectClass)
  ['{80051FF8-3AEB-56C0-919B-ECBEFDC42875}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  class.</summary>
    {class} function init: DNXmlSchemaSet; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="nameTable">The <see cref="T:System.Xml.XmlNameTable" />
    ///  object to use.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlNameTable" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(nameTable: DNXmlNameTable): DNXmlSchemaSet; overload;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve namespaces or locations referenced in include and import elements of a schema.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve namespaces or locations referenced in include and import elements of a schema.</returns>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  ///<summary>Contains a cache of XML Schema definition language (XSD) schemas.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaSet')]
  DNXmlSchemaSet = interface(DDN.mscorlib.DNObject)
  ['{2EECF1F1-E906-338D-AA1A-21E3F90E6E8D}']
  { getters & setters } 

    function get_NameTable: DNXmlNameTable;
    function get_IsCompiled: Boolean;
    procedure set_XmlResolver(value: DNXmlResolver);
    function get_CompilationSettings: DNXmlSchemaCompilationSettings;
    procedure set_CompilationSettings(value: DNXmlSchemaCompilationSettings);
    function get_Count: Int32;
    function get_GlobalElements: DNXmlSchemaObjectTable;
    function get_GlobalAttributes: DNXmlSchemaObjectTable;
    function get_GlobalTypes: DNXmlSchemaObjectTable;

  { events } 

    procedure add_ValidationEventHandler(value: DNValidationEventHandler);
    procedure remove_ValidationEventHandler(value: DNValidationEventHandler);

  { methods } 

    ///<summary>Adds the XML Schema definition language (XSD) schema at the URL specified to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="targetNamespace">The schema targetNamespace property, or <see langword="null" />
    ///  to use the targetNamespace specified in the schema.</param>
    ///  <param name="schemaUri">The URL that specifies the schema to load.</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object if the schema is valid. If the schema is not valid and a <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified, then <see langword="null" />
    ///  is returned and the appropriate validation event is raised. Otherwise, an <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is thrown.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">The schema is not valid.</exception><exception cref="T:System.ArgumentNullException">The URL passed as a parameter is <see langword="null" />
    ///  or <see cref="F:System.String.Empty" />
    ///  .</exception>
    function Add(targetNamespace: string; schemaUri: string): DNXmlSchema; overload;
    ///<summary>Adds the XML Schema definition language (XSD) schema contained in the <see cref="T:System.Xml.XmlReader" />
    ///  to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="targetNamespace">The schema targetNamespace property, or <see langword="null" />
    ///  to use the targetNamespace specified in the schema.</param>
    ///  <param name="schemaDocument">The <see cref="T:System.Xml.XmlReader" />
    ///  object.</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object if the schema is valid. If the schema is not valid and a <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified, then <see langword="null" />
    ///  is returned and the appropriate validation event is raised. Otherwise, an <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is thrown.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">The schema is not valid.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    function Add(targetNamespace: string; schemaDocument: DNXmlReader): DNXmlSchema; overload;
    ///<summary>Adds all the XML Schema definition language (XSD) schemas in the given <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemas">The <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object.</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">A schema in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  is not valid.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    procedure Add(schemas: DNXmlSchemaSet); overload;
    ///<summary>Adds the given <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to add to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object if the schema is valid. If the schema is not valid and a <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified, then <see langword="null" />
    ///  is returned and the appropriate validation event is raised. Otherwise, an <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is thrown.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">The schema is not valid.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    function Add(schema: DNXmlSchema): DNXmlSchema; overload;
    ///<summary>Removes the specified XML Schema definition language (XSD) schema from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to remove from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object removed from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  or <see langword="null" />
    ///  if the schema was not found in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">The schema is not a valid schema.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  passed as a parameter is <see langword="null" />
    ///  .</exception>
    function Remove(schema: DNXmlSchema): DNXmlSchema;
    ///<summary>Indicates whether an XML Schema definition language (XSD) schema with the specified target namespace URI is in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="targetNamespace">The schema targetNamespace property.</param>
    ///<returns><see langword="true" />
    ///  if a schema with the specified target namespace URI is in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    function &Contains(targetNamespace: string): Boolean; overload;
    ///<summary>Indicates whether the specified XML Schema definition language (XSD) <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object is in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schema">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object is in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  passed as a parameter is <see langword="null" />
    ///  .</exception>
    function &Contains(schema: DNXmlSchema): Boolean; overload;
    ///<summary>Copies all the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  to the given array, starting at the given index.</summary>
    ///  <param name="schemas">The array to copy the objects to.</param>
    ///  <param name="index">The index in the array where copying will begin.</param>
    procedure CopyTo(schemas: TArray<DNXmlSchema>; index: Int32);
    ///<summary>Returns a collection of all the XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  object containing all the schemas that have been added to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  . If no schemas have been added to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  , an empty <see cref="T:System.Collections.ICollection" />
    ///  object is returned.</returns>
    function Schemas: DDN.mscorlib.DNICollection; overload;
    ///<summary>Returns a collection of all the XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  that belong to the given namespace.</summary>
    ///  <param name="targetNamespace">The schema targetNamespace property.</param>
    ///<returns>An <see cref="T:System.Collections.ICollection" />
    ///  object containing all the schemas that have been added to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  that belong to the given namespace. If no schemas have been added to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  , an empty <see cref="T:System.Collections.ICollection" />
    ///  object is returned.</returns>
    function Schemas(targetNamespace: string): DDN.mscorlib.DNICollection; overload;
    ///<summary>Removes the specified XML Schema definition language (XSD) schema and all the schemas it imports from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schemaToRemove">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to remove from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object and all its imports were successfully removed; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  passed as a parameter is <see langword="null" />
    ///  .</exception>
    function RemoveRecursive(schemaToRemove: DNXmlSchema): Boolean;
    ///<summary>Reprocesses an XML Schema definition language (XSD) schema that already exists in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///  <param name="schema">The schema to reprocess.</param>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object if the schema is a valid schema. If the schema is not valid and a <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  is specified, <see langword="null" />
    ///  is returned and the appropriate validation event is raised. Otherwise, an <see cref="T:System.Xml.Schema.XmlSchemaException" />
    ///  is thrown.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">The schema is not valid.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object passed as a parameter does not already exist in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</exception>
    function Reprocess(schema: DNXmlSchema): DNXmlSchema;
    ///<summary>Compiles the XML Schema definition language (XSD) schemas added to the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  into one logical schema.</summary>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaException">An error occurred when validating and compiling the schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</exception>
    procedure Compile;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the default <see cref="T:System.Xml.XmlNameTable" />
    ///  used by the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  when loading new XML Schema definition language (XSD) schemas.</summary>
    ///<returns>A table of atomized string objects.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets a value that indicates whether the XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  have been compiled.</summary>
    ///<returns><see langword="true" />
    ///  if the schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  have been compiled since the last time a schema was added or removed from the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property IsCompiled: Boolean read get_IsCompiled;
    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve namespaces or locations referenced in include and import elements of a schema.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve namespaces or locations referenced in include and import elements of a schema.</returns>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" />
    ///  for the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" />
    ///  for the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  . The default is an <see cref="T:System.Xml.Schema.XmlSchemaCompilationSettings" />
    ///  instance with the <see cref="P:System.Xml.Schema.XmlSchemaCompilationSettings.EnableUpaCheck" />
    ///  property set to <see langword="true" />
    ///  .</returns>
    property CompilationSettings: DNXmlSchemaCompilationSettings read get_CompilationSettings write set_CompilationSettings;
    ///<summary>Gets the number of logical XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///<returns>The number of logical schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</returns>
    property Count: Int32 read get_Count;
    ///<summary>Gets all the global elements in all the XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///<returns>The collection of global elements.</returns>
    property GlobalElements: DNXmlSchemaObjectTable read get_GlobalElements;
    ///<summary>Gets all the global attributes in all the XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///<returns>The collection of global attributes.</returns>
    property GlobalAttributes: DNXmlSchemaObjectTable read get_GlobalAttributes;
    ///<summary>Gets all of the global simple and complex types in all the XML Schema definition language (XSD) schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  .</summary>
    ///<returns>The collection of global simple and complex types.</returns>
    property GlobalTypes: DNXmlSchemaObjectTable read get_GlobalTypes;
  end;

  TDNXmlSchemaSet = class(TDNGenericImport<DNXmlSchemaSetClass, DNXmlSchemaSet>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlSchemaValidatorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D720AA83-BC50-5E48-B2C0-5C56EB18CB1B}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  class.</summary>
    ///  <param name="nameTable">An <see cref="T:System.Xml.XmlNameTable" />
    ///  object containing element and attribute names as atomized strings.</param>
    ///  <param name="schemas">An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object containing the XML Schema Definition Language (XSD) schemas used for validation.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used for resolving namespaces encountered during validation.</param>
    ///  <param name="validationFlags">An <see cref="T:System.Xml.Schema.XmlSchemaValidationFlags" />
    ///  value specifying schema validation options.</param>
    ///<exception cref="T:System.ArgumentNullException">One or more of the parameters specified are <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Schema.XmlSchemaException">An error occurred while compiling schemas in the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  parameter.</exception>
    {class} function init(nameTable: DNXmlNameTable; schemas: DNXmlSchemaSet; namespaceResolver: DNIXmlNamespaceResolver; validationFlags: DNXmlSchemaValidationFlags): DNXmlSchemaValidator;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  object used to resolve xs:import and xs:include elements as well as xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlResolver" />
    ///  object; the default is an <see cref="T:System.Xml.XmlUrlResolver" />
    ///  object.</returns>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  ///<summary>Represents an XML Schema Definition Language (XSD) Schema validation engine. The <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
  ///  class cannot be inherited.</summary>
  [DNTypeName('System.Xml.Schema.XmlSchemaValidator')]
  DNXmlSchemaValidator = interface(DDN.mscorlib.DNObject)
  ['{43A9070E-DD35-317A-914B-8055C37FA049}']
  { getters & setters } 

    procedure set_XmlResolver(value: DNXmlResolver);
    function get_LineInfoProvider: DNIXmlLineInfo;
    procedure set_LineInfoProvider(value: DNIXmlLineInfo);
    function get_SourceUri: DDN.System.DNUri;
    procedure set_SourceUri(value: DDN.System.DNUri);
    function get_ValidationEventSender: DDN.mscorlib.DNObject;
    procedure set_ValidationEventSender(value: DDN.mscorlib.DNObject);

  { events } 

    procedure add_ValidationEventHandler(value: DNValidationEventHandler);
    procedure remove_ValidationEventHandler(value: DNValidationEventHandler);

  { methods } 

    ///<summary>Initializes the state of the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object.</summary>
    ///<exception cref="T:System.InvalidOperationException">Calling the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.Initialize" />
    ///  method is valid immediately after the construction of an <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object or after a call to <see cref="M:System.Xml.Schema.XmlSchemaValidator.EndValidation" />
    ///  only.</exception>
    procedure Initialize; overload;
    ///<summary>Validates the element in the current context.</summary>
    ///  <param name="localName">The local name of the element to validate.</param>
    ///  <param name="namespaceUri">The namespace URI of the element to validate.</param>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful validation of the element's name. This parameter can be <see langword="null" />
    ///  .</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The element's name is not valid in the current context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateElement" />
    ///  method was not called in the correct sequence. For example, the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateElement" />
    ///  method is called after calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  .</exception>
    procedure ValidateElement(localName: string; namespaceUri: string; schemaInfo: DNXmlSchemaInfo); overload;
    ///<summary>Validates the element in the current context with the xsi:Type, xsi:Nil, xsi:SchemaLocation, and xsi:NoNamespaceSchemaLocation attribute values specified.</summary>
    ///  <param name="localName">The local name of the element to validate.</param>
    ///  <param name="namespaceUri">The namespace URI of the element to validate.</param>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful validation of the element's name. This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="xsiType">The xsi:Type attribute value of the element. This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="xsiNil">The xsi:Nil attribute value of the element. This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="xsiSchemaLocation">The xsi:SchemaLocation attribute value of the element. This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="xsiNoNamespaceSchemaLocation">The xsi:NoNamespaceSchemaLocation attribute value of the element. This parameter can be <see langword="null" />
    ///  .</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The element's name is not valid in the current context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateElement" />
    ///  method was not called in the correct sequence. For example, the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateElement" />
    ///  method is called after calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  .</exception>
    procedure ValidateElement(localName: string; namespaceUri: string; schemaInfo: DNXmlSchemaInfo; xsiType: string; xsiNil: string; xsiSchemaLocation: string; xsiNoNamespaceSchemaLocation: string); overload;
    ///<summary>Validates the attribute name, namespace URI, and value in the current element context.</summary>
    ///  <param name="localName">The local name of the attribute to validate.</param>
    ///  <param name="namespaceUri">The namespace URI of the attribute to validate.</param>
    ///  <param name="attributeValue">The value of the attribute to validate.</param>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful validation of the attribute. This parameter can be <see langword="null" />
    ///  .</param>
    ///<returns>The validated attribute's value.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The attribute is not valid in the current element context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  method was not called in the correct sequence. For example, calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  after calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.ValidateEndOfAttributes(System.Xml.Schema.XmlSchemaInfo)" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">One or more of the parameters specified are <see langword="null" />
    ///  .</exception>
    function ValidateAttribute(localName: string; namespaceUri: string; attributeValue: string; schemaInfo: DNXmlSchemaInfo): DDN.mscorlib.DNObject; overload;
    ///<summary>Validates the attribute name, namespace URI, and value in the current element context.</summary>
    ///  <param name="localName">The local name of the attribute to validate.</param>
    ///  <param name="namespaceUri">The namespace URI of the attribute to validate.</param>
    ///  <param name="attributeValue">An <see cref="T:System.Xml.Schema.XmlValueGetter" />
    ///<see langword="delegate" />
    ///  used to pass the attribute's value as a Common Language Runtime (CLR) type compatible with the XML Schema Definition Language (XSD) type of the attribute.</param>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful validation of the attribute. This parameter and can be <see langword="null" />
    ///  .</param>
    ///<returns>The validated attribute's value.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The attribute is not valid in the current element context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  method was not called in the correct sequence. For example, calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  after calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.ValidateEndOfAttributes(System.Xml.Schema.XmlSchemaInfo)" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">One or more of the parameters specified are <see langword="null" />
    ///  .</exception>
    function ValidateAttribute(localName: string; namespaceUri: string; attributeValue: DNXmlValueGetter; schemaInfo: DNXmlSchemaInfo): DDN.mscorlib.DNObject; overload;
    ///<summary>Verifies whether all the required attributes in the element context are present and prepares the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object to validate the child content of the element.</summary>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful verification that all the required attributes in the element context are present. This parameter can be <see langword="null" />
    ///  .</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">One or more of the required attributes in the current element context were not found.</exception><exception cref="T:System.InvalidOperationException">The <see cref="M:System.Xml.Schema.XmlSchemaValidator.ValidateEndOfAttributes(System.Xml.Schema.XmlSchemaInfo)" />
    ///  method was not called in the correct sequence. For example, calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.ValidateEndOfAttributes(System.Xml.Schema.XmlSchemaInfo)" />
    ///  after calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.SkipToEndElement(System.Xml.Schema.XmlSchemaInfo)" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">One or more of the parameters specified are <see langword="null" />
    ///  .</exception>
    procedure ValidateEndOfAttributes(schemaInfo: DNXmlSchemaInfo);
    ///<summary>Validates whether the text <see langword="string" />
    ///  specified is allowed in the current element context, and accumulates the text for validation if the current element has simple content.</summary>
    ///  <param name="elementValue">A text <see langword="string" />
    ///  to validate in the current element context.</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The text <see langword="string" />
    ///  specified is not allowed in the current element context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateText" />
    ///  method was not called in the correct sequence. For example, the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateText" />
    ///  method is called after calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The text <see langword="string" />
    ///  parameter cannot be <see langword="null" />
    ///  .</exception>
    procedure ValidateText(elementValue: string); overload;
    ///<summary>Validates whether the text returned by the <see cref="T:System.Xml.Schema.XmlValueGetter" />
    ///  object specified is allowed in the current element context, and accumulates the text for validation if the current element has simple content.</summary>
    ///  <param name="elementValue">An <see cref="T:System.Xml.Schema.XmlValueGetter" />
    ///<see langword="delegate" />
    ///  used to pass the text value as a Common Language Runtime (CLR) type compatible with the XML Schema Definition Language (XSD) type of the attribute.</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The text <see langword="string" />
    ///  specified is not allowed in the current element context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateText" />
    ///  method was not called in the correct sequence. For example, the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateText" />
    ///  method is called after calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The text <see langword="string" />
    ///  parameter cannot be <see langword="null" />
    ///  .</exception>
    procedure ValidateText(elementValue: DNXmlValueGetter); overload;
    ///<summary>Validates whether the white space in the <see langword="string" />
    ///  specified is allowed in the current element context, and accumulates the white space for validation if the current element has simple content.</summary>
    ///  <param name="elementValue">A white space <see langword="string" />
    ///  to validate in the current element context.</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">White space is not allowed in the current element context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateWhitespace" />
    ///  method was not called in the correct sequence. For example, if the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateWhitespace" />
    ///  method is called after calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  .</exception>
    procedure ValidateWhitespace(elementValue: string); overload;
    ///<summary>Validates whether the white space returned by the <see cref="T:System.Xml.Schema.XmlValueGetter" />
    ///  object specified is allowed in the current element context, and accumulates the white space for validation if the current element has simple content.</summary>
    ///  <param name="elementValue">An <see cref="T:System.Xml.Schema.XmlValueGetter" />
    ///<see langword="delegate" />
    ///  used to pass the white space value as a Common Language Runtime (CLR) type compatible with the XML Schema Definition Language (XSD) type of the attribute.</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">White space is not allowed in the current element context.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateWhitespace" />
    ///  method was not called in the correct sequence. For example, if the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateWhitespace" />
    ///  method is called after calling <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  .</exception>
    procedure ValidateWhitespace(elementValue: DNXmlValueGetter); overload;
    ///<summary>Verifies if the text content of the element is valid according to its data type for elements with simple content, and verifies if the content of the current element is complete for elements with complex content.</summary>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful validation of the element. This parameter can be <see langword="null" />
    ///  .</param>
    ///<returns>The parsed, typed text value of the element if the element has simple content.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The element's content is not valid.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateEndElement" />
    ///  method was not called in the correct sequence. For example, if the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateEndElement" />
    ///  method is called after calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.SkipToEndElement(System.Xml.Schema.XmlSchemaInfo)" />
    ///  .</exception>
    function ValidateEndElement(schemaInfo: DNXmlSchemaInfo): DDN.mscorlib.DNObject; overload;
    ///<summary>Verifies if the text content of the element specified is valid according to its data type.</summary>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set on successful validation of the text content of the element. This parameter can be <see langword="null" />
    ///  .</param>
    ///  <param name="typedValue">The typed text content of the element.</param>
    ///<returns>The parsed, typed simple content of the element.</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The element's text content is not valid.</exception><exception cref="T:System.InvalidOperationException">The <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateEndElement" />
    ///  method was not called in the correct sequence (for example, if the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateEndElement" />
    ///  method is called after calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.SkipToEndElement(System.Xml.Schema.XmlSchemaInfo)" />
    ///  ), calls to the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateText" />
    ///  method have been previously made, or the element has complex content.</exception><exception cref="T:System.ArgumentNullException">The typed text content parameter cannot be <see langword="null" />
    ///  .</exception>
    function ValidateEndElement(schemaInfo: DNXmlSchemaInfo; typedValue: DDN.mscorlib.DNObject): DDN.mscorlib.DNObject; overload;
    ///<summary>Ends validation and checks identity constraints for the entire XML document.</summary>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">An identity constraint error was found in the XML document.</exception>
    procedure EndValidation;
    ///<summary>Adds an XML Schema Definition Language (XSD) schema to the set of schemas used for validation.</summary>
    ///  <param name="schema">An <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object to add to the set of schemas used for validation.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  parameter specified is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Schema.XmlSchemaValidationException">The target namespace of the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  parameter matches that of any element or attribute already encountered by the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object.</exception><exception cref="T:System.Xml.Schema.XmlSchemaException">The <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  parameter is invalid.</exception>
    procedure AddSchema(schema: DNXmlSchema);
    ///<summary>Initializes the state of the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object using the <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  specified for partial validation.</summary>
    ///  <param name="partialValidationType">An <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object used to initialize the validation context of the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object for partial validation.</param>
    ///<exception cref="T:System.InvalidOperationException">Calling the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.Initialize" />
    ///  method is valid immediately after the construction of an <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object or after a call to <see cref="M:System.Xml.Schema.XmlSchemaValidator.EndValidation" />
    ///  only.</exception><exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  parameter is not an <see cref="T:System.Xml.Schema.XmlSchemaElement" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  parameter cannot be <see langword="null" />
    ///  .</exception>
    procedure Initialize(partialValidationType: DNXmlSchemaObject); overload;
    ///<summary>Validates identity constraints on the default attributes and populates the <see cref="T:System.Collections.ArrayList" />
    ///  specified with <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  objects for any attributes with default values that have not been previously validated using the <see cref="Overload:System.Xml.Schema.XmlSchemaValidator.ValidateAttribute" />
    ///  method in the element context. </summary>
    ///  <param name="defaultAttributes">An <see cref="T:System.Collections.ArrayList" />
    ///  to populate with <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  objects for any attributes not yet encountered during validation in the element context.</param>
    procedure GetUnspecifiedDefaultAttributes(defaultAttributes: DDN.mscorlib.DNArrayList);
    ///<summary>Skips validation of the current element content and prepares the <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object to validate content in the parent element's context.</summary>
    ///  <param name="schemaInfo">An <see cref="T:System.Xml.Schema.XmlSchemaInfo" />
    ///  object whose properties are set if the current element content is successfully skipped. This parameter can be <see langword="null" />
    ///  .</param>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="M:System.Xml.Schema.XmlSchemaValidator.SkipToEndElement(System.Xml.Schema.XmlSchemaInfo)" />
    ///  method was not called in the correct sequence. For example, calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.SkipToEndElement(System.Xml.Schema.XmlSchemaInfo)" />
    ///  after calling <see cref="M:System.Xml.Schema.XmlSchemaValidator.SkipToEndElement(System.Xml.Schema.XmlSchemaInfo)" />
    ///  .</exception>
    procedure SkipToEndElement(schemaInfo: DNXmlSchemaInfo);
    ///<summary>Returns the expected particles in the current element context.</summary>
    ///<returns>An array of <see cref="T:System.Xml.Schema.XmlSchemaParticle" />
    ///  objects or an empty array if there are no expected particles.</returns>
    function GetExpectedParticles: TArray<DNXmlSchemaParticle>;
    ///<summary>Returns the expected attributes for the current element context.</summary>
    ///<returns>An array of <see cref="T:System.Xml.Schema.XmlSchemaAttribute" />
    ///  objects or an empty array if there are no expected attributes.</returns>
    function GetExpectedAttributes: TArray<DNXmlSchemaAttribute>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  object used to resolve xs:import and xs:include elements as well as xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlResolver" />
    ///  object; the default is an <see cref="T:System.Xml.XmlUrlResolver" />
    ///  object.</returns>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>Gets or sets the line number information for the XML node being validated.</summary>
    ///<returns>An <see cref="T:System.Xml.IXmlLineInfo" />
    ///  object.</returns>
    property LineInfoProvider: DNIXmlLineInfo read get_LineInfoProvider write set_LineInfoProvider;
    ///<summary>Gets or sets the source URI for the XML node being validated.</summary>
    ///<returns>A <see cref="T:System.Uri" />
    ///  object representing the source URI for the XML node being validated; the default is <see langword="null" />
    ///  .</returns>
    property SourceUri: DDN.System.DNUri read get_SourceUri write set_SourceUri;
    ///<summary>Gets or sets the object sent as the sender object of a validation event.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  ; the default is this <see cref="T:System.Xml.Schema.XmlSchemaValidator" />
    ///  object.</returns>
    property ValidationEventSender: DDN.mscorlib.DNObject read get_ValidationEventSender write set_ValidationEventSender;
  end;

  TDNXmlSchemaValidator = class(TDNGenericImport<DNXmlSchemaValidatorClass, DNXmlSchemaValidator>) end;

  //-------------namespace: System.Xml.Serialization.Advanced----------------
  DNSchemaImporterExtensionClass = interface(DDN.mscorlib.DNObjectClass)
  ['{84B1B8C7-363E-519C-81DA-A2D00C6A6D87}']
  end;

  ///<summary>Allows you to customize the code generated from a Web Services Description Language (WSDL) document when using automated query tools.</summary>
  [DNTypeName('System.Xml.Serialization.Advanced.SchemaImporterExtension')]
  DNSchemaImporterExtension = interface(DDN.mscorlib.DNObject)
  ['{39527C14-C3E3-31E1-AE79-C8C7E4093F42}']
  { methods } 

    ///<summary>Allows you to manipulate the code generated by examining the imported schema and specifying the CLR type that it maps to.</summary>
    ///  <param name="name">The name of the element.</param>
    ///  <param name="ns">The namespace of the element.</param>
    ///  <param name="context">An <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  that represents schema information, such as the line number of the XML element.</param>
    ///  <param name="schemas">An <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  that contains the collection of schemas in the document.</param>
    ///  <param name="importer">The <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  that is the importer being used.</param>
    ///  <param name="compileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  to which you can add CodeDOM structures to generate alternative code for the XSD.</param>
    ///  <param name="mainNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that represents the current namespace for the element.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  for the setting options on the code compiler.</param>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  that is used to generate the new code.</param>
    ///<returns>The name of the CLR type that this maps to.</returns>
    function ImportSchemaType(name: string; ns: string; context: DNXmlSchemaObject; schemas: DNXmlSchemas; importer: DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>Allows you to manipulate the code generated by examining the imported schema and specifying the CLR type that it maps to.</summary>
    ///  <param name="type">An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  that represents the XSD type.</param>
    ///  <param name="context">An <see cref="T:System.Xml.Schema.XmlSchemaObject" />
    ///  that represents schema information, such as the line number of the XML element.</param>
    ///  <param name="schemas">An <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  that contains the collection of schemas in the document.</param>
    ///  <param name="importer">The <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  that is the importer being used.</param>
    ///  <param name="compileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  to which you can add CodeDOM structures to generate alternative code for the XSD.</param>
    ///  <param name="mainNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that represents the current namespace for the element.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  for the setting options on the code compiler.</param>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  that is used to generate the new code.</param>
    ///<returns>The name of the CLR type that this maps to.</returns>
    function ImportSchemaType(&type: DNXmlSchemaType; context: DNXmlSchemaObject; schemas: DNXmlSchemas; importer: DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string; overload;
    ///<summary>Handles the importation of the &lt;xsd:any&gt; elements in the schema.</summary>
    ///  <param name="any">An <see cref="T:System.Xml.Schema.XmlSchemaAny" />
    ///  that represents the <see langword="xsd:any" />
    ///  element found in the XML Schema Document (XSD).</param>
    ///  <param name="mixed">A <see cref="T:System.Boolean" />
    ///  that indicates whether the XSD <see langword="complex" />
    ///  attribute has been set to "mixed". <see langword="true" />
    ///  , if the attribute has been set to mixed, otherwise <see langword="false" />
    ///  . </param>
    ///  <param name="schemas">An <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  that contains the collection of schemas found in the XSD.</param>
    ///  <param name="importer">The <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  that is the importer being used.</param>
    ///  <param name="compileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  to which you can add CodeDOM structures to generate alternative code for the XSD. </param>
    ///  <param name="mainNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that represents the current namespace for the element.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  for the setting options on the code compiler.</param>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  that is the CodeDOM provider used to generate the new code. </param>
    ///<returns>The name of the CLR type that the element maps to. </returns>
    function ImportAnyElement(any: DNXmlSchemaAny; mixed: Boolean; schemas: DNXmlSchemas; importer: DNXmlSchemaImporter; compileUnit: DDN.System.DNCodeCompileUnit; mainNamespace: DDN.System.DNCodeNamespace; options: DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider): string;
    ///<summary>Allows you to specify the default value for the XSD type being imported.</summary>
    ///  <param name="value">The value found in the original XSD.</param>
    ///  <param name="type">The XSD type name.</param>
    ///<returns>A <see cref="T:System.CodeDom.CodeExpression" />
    ///  setting the new default value.</returns>
    function ImportDefaultValue(value: string; &type: string): DDN.System.DNCodeExpression;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSchemaImporterExtension = class(TDNGenericImport<DNSchemaImporterExtensionClass, DNSchemaImporterExtension>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNCodeExporterClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0335C91D-2A31-522C-8305-7A3FF61597AB}']
  end;

  ///<summary>Represents a class that can generate proxy code from an XML representation of a data structure.</summary>
  [DNTypeName('System.Xml.Serialization.CodeExporter')]
  DNCodeExporter = interface(DDN.mscorlib.DNObject)
  ['{58980885-AB07-3408-B0DA-A1F804A75F85}']
  { getters & setters } 

    function get_IncludeMetadata: DDN.System.DNCodeAttributeDeclarationCollection;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of code attribute metadata that is included when the code is exported.</summary>
    ///<returns>A collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects that represent metadata that is included when the code is exported.</returns>
    property IncludeMetadata: DDN.System.DNCodeAttributeDeclarationCollection read get_IncludeMetadata;
  end;

  TDNCodeExporter = class(TDNGenericImport<DNCodeExporterClass, DNCodeExporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapCodeExporterClass = interface(DNCodeExporterClass)
  ['{C399D90E-DA52-5466-A82B-CFB56D8D7BE0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapCodeExporter" />
    ///  class, assuming no code compile unit. </summary>
    ///  <param name="codeNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that specifies the namespace of the types to generate.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace): DNSoapCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapCodeExporter" />
    ///  class, specifying a code compile unit parameter in addition to a namespace parameter.</summary>
    ///  <param name="codeNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that specifies the namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  that identifies the program graph container to which used assembly references are automatically added.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit): DNSoapCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapCodeExporter" />
    ///  class, specifying a code namespace, a code compile unit, and code generation options.</summary>
    ///  <param name="codeNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that specifies the namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  that identifies the program graph container to which used assembly references are automatically added.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  enumeration that specifies the options with which exported code is generated.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit; options: DNCodeGenerationOptions): DNSoapCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapCodeExporter" />
    ///  class, specifying a code namespace, a code compile unit, code generation options, and mappings.</summary>
    ///  <param name="codeNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that specifies the namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  that identifies the program graph container to which used assembly references are automatically added.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  enumeration that specifies the options with which exported code is generated.</param>
    ///  <param name="mappings">A <see cref="T:System.Collections.Hashtable" />
    ///  that contains <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit; options: DNCodeGenerationOptions; mappings: DDN.mscorlib.DNHashtable): DNSoapCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapCodeExporter" />
    ///  class, specifying a code namespace, a code compile unit, a code generator, code generation options, and mappings.</summary>
    ///  <param name="codeNamespace">A <see cref="T:System.CodeDom.CodeNamespace" />
    ///  that specifies the namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  that identifies the program graph container to which used assembly references are automatically added.</param>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  that is used to create the code.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  enumeration that specifies the options with which exported code is generated.</param>
    ///  <param name="mappings">A <see cref="T:System.Collections.Hashtable" />
    ///  that contains <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit; codeProvider: DDN.System.DNCodeDomProvider; options: DNCodeGenerationOptions; mappings: DDN.mscorlib.DNHashtable): DNSoapCodeExporter; overload;

  end;

  ///<summary>Generates types and attribute declarations from internal type mapping information for SOAP-encoded message parts defined in a WSDL document. </summary>
  [DNTypeName('System.Xml.Serialization.SoapCodeExporter')]
  DNSoapCodeExporter = interface(DNCodeExporter)
  ['{8ED80F9A-1628-3366-8861-5316E25A64F8}']
  { getters & setters } 

    function get_IncludeMetadata: DDN.System.DNCodeAttributeDeclarationCollection;

  { methods } 

    ///<summary>Generates a .NET Framework type, plus attribute declarations, for a SOAP header. </summary>
    ///  <param name="xmlTypeMapping">Internal .NET Framework type mapping information for a SOAP header element.</param>
    procedure ExportTypeMapping(xmlTypeMapping: DNXmlTypeMapping);
    ///<summary>Generates a .NET Framework type, plus attribute declarations, for each of the parts that belong to a SOAP message definition in a WSDL document. </summary>
    ///  <param name="xmlMembersMapping">Internal .NET Framework type mappings for the element parts of a WSDL message definition.</param>
    procedure ExportMembersMapping(xmlMembersMapping: DNXmlMembersMapping);
    ///<summary>Adds a <see cref="T:System.Xml.Serialization.SoapElementAttribute" />
    ///  declaration to a method parameter or return value that corresponds to a part element of a SOAP message definition in a WSDL document. </summary>
    ///  <param name="metadata">The collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects for the generated type to which the method adds an attribute declaration.</param>
    ///  <param name="member">An internal .NET Framework type mapping for a single part of a WSDL message definition.</param>
    ///  <param name="forceUseMemberName"><see langword="true" />
    ///  to add an initial argument that contains the XML element name for the attribute declaration that is being generated; otherwise, <see langword="false" />
    ///  .</param>
    procedure AddMappingMetadata(metadata: DDN.System.DNCodeAttributeDeclarationCollection; member: DNXmlMemberMapping; forceUseMemberName: Boolean); overload;
    ///<summary>Add a <see cref="T:System.Xml.Serialization.SoapElementAttribute" />
    ///  declaration to a method parameter or return value corresponding to a part element of a SOAP message definition in a WSDL document. </summary>
    ///  <param name="metadata">The collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects for the generated type, to which the method adds an attribute declaration.</param>
    ///  <param name="member">An internal .NET Framework type mapping for a single part of a WSDL message definition.</param>
    procedure AddMappingMetadata(metadata: DDN.System.DNCodeAttributeDeclarationCollection; member: DNXmlMemberMapping); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of code attribute metadata that is included when the code is exported.</summary>
    ///<returns>A collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects that represent metadata that is included when the code is exported.</returns>
    property IncludeMetadata: DDN.System.DNCodeAttributeDeclarationCollection read get_IncludeMetadata;
  end;

  TDNSoapCodeExporter = class(TDNGenericImport<DNSoapCodeExporterClass, DNSoapCodeExporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlCodeExporterClass = interface(DNCodeExporterClass)
  ['{373D545C-1597-5E22-8691-E47BBFC8768C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlCodeExporter" />
    ///  class using the specified namespace. </summary>
    ///  <param name="codeNamespace">The namespace of the types to generate.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace): DNXmlCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlCodeExporter" />
    ///  class using the specified namespace and code compile unit.</summary>
    ///  <param name="codeNamespace">The namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A CodeDOM graph container to which used assembly references are automatically added.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit): DNXmlCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlCodeExporter" />
    ///  class using the specified namespace, code compile unit, and code generation options.</summary>
    ///  <param name="codeNamespace">The namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  program graph container to which used assembly references are automatically added.</param>
    ///  <param name="options">An enumeration value that provides options for generating .NET Framework types from XML schema custom data types.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit; options: DNCodeGenerationOptions): DNXmlCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlCodeExporter" />
    ///  class using the specified .NET Framework namespace, code compile unit containing the graph of the objects, an object representing code generation options, and a collection of mapping objects.</summary>
    ///  <param name="codeNamespace">The namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  program graph container to which used assembly references are automatically added.</param>
    ///  <param name="options">An enumeration value that provides options for generating .NET Framework types from XML schema custom data types.</param>
    ///  <param name="mappings">A <see cref="T:System.Collections.Hashtable" />
    ///  that contains <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit; options: DNCodeGenerationOptions; mappings: DDN.mscorlib.DNHashtable): DNXmlCodeExporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlCodeExporter" />
    ///  class using the specified .NET Framework namespace, code compile unit containing the graph of the objects, an enumeration specifying code options, and a collection of mapping objects.</summary>
    ///  <param name="codeNamespace">The namespace of the types to generate.</param>
    ///  <param name="codeCompileUnit">A <see cref="T:System.CodeDom.CodeCompileUnit" />
    ///  program graph container to which used assembly references are automatically added.</param>
    ///  <param name="codeProvider">An enumeration value that provides options for generating .NET Framework types from XML schema custom data types.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  that contains special instructions for code creation.</param>
    ///  <param name="mappings">A <see cref="T:System.Collections.Hashtable" />
    ///  that contains <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects.</param>
    {class} function init(codeNamespace: DDN.System.DNCodeNamespace; codeCompileUnit: DDN.System.DNCodeCompileUnit; codeProvider: DDN.System.DNCodeDomProvider; options: DNCodeGenerationOptions; mappings: DDN.mscorlib.DNHashtable): DNXmlCodeExporter; overload;

  end;

  ///<summary>Generates types and attribute declarations from internal type mapping information for XML schema element declarations.</summary>
  [DNTypeName('System.Xml.Serialization.XmlCodeExporter')]
  DNXmlCodeExporter = interface(DNCodeExporter)
  ['{9AF1261D-D0F6-3C58-A06A-2957418A2C43}']
  { getters & setters } 

    function get_IncludeMetadata: DDN.System.DNCodeAttributeDeclarationCollection;

  { methods } 

    ///<summary>Generates a .NET Framework type, plus attribute declarations, for an XML schema element. </summary>
    ///  <param name="xmlTypeMapping">The internal .NET Framework type mapping information for an XML schema element.</param>
    procedure ExportTypeMapping(xmlTypeMapping: DNXmlTypeMapping);
    ///<summary>Generates a .NET Framework type, plus attribute declarations, for each of the parts that belong to a SOAP message definition in a Web Services Description Language (WSDL) document. </summary>
    ///  <param name="xmlMembersMapping">The internal .NET Framework type mappings for the element parts of a WSDL message definition.</param>
    procedure ExportMembersMapping(xmlMembersMapping: DNXmlMembersMapping);
    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  declaration to a method return value that corresponds to a <see langword="&lt;part&gt;" />
    ///  element of a non-SOAP message definition in a Web Services Description Language (WSDL) document. </summary>
    ///  <param name="metadata">The collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects for the generated type to which the method adds an attribute declaration.</param>
    ///  <param name="mapping">The internal .NET Framework type mapping information for an XML schema element.</param>
    ///  <param name="ns">The XML namespace of the SOAP message part for which the type mapping information in the member parameter has been generated.</param>
    procedure AddMappingMetadata(metadata: DDN.System.DNCodeAttributeDeclarationCollection; mapping: DNXmlTypeMapping; ns: string); overload;
    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  declaration to a method parameter or return value that corresponds to a <see langword="&lt;part&gt;" />
    ///  element of a SOAP message definition in a Web Services Description Language (WSDL) document. </summary>
    ///  <param name="metadata">The collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects for the generated type to which the method adds an attribute declaration.</param>
    ///  <param name="member">An internal .NET Framework type mapping for a single element part of a WSDL message definition.</param>
    ///  <param name="ns">The XML namespace of the SOAP message part for which the type mapping information in the member parameter has been generated.</param>
    ///  <param name="forceUseMemberName">Flag that helps determine whether to add an initial argument containing the XML element name for the attribute declaration being generated.</param>
    procedure AddMappingMetadata(metadata: DDN.System.DNCodeAttributeDeclarationCollection; member: DNXmlMemberMapping; ns: string; forceUseMemberName: Boolean); overload;
    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  declaration to a method parameter or return value that corresponds to a <see langword="&lt;part&gt;" />
    ///  element of a SOAP message definition in a Web Services Description Language (WSDL) document. </summary>
    ///  <param name="metadata">The collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects for the generated type to which the method adds an attribute declaration.</param>
    ///  <param name="member">An internal .NET Framework type mapping for a single element part of a WSDL message definition.</param>
    ///  <param name="ns">The XML namespace of the SOAP message part for which the type mapping information in the member parameter has been generated.</param>
    procedure AddMappingMetadata(metadata: DDN.System.DNCodeAttributeDeclarationCollection; member: DNXmlMemberMapping; ns: string); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of code attribute metadata that is included when the code is exported.</summary>
    ///<returns>A collection of <see cref="T:System.CodeDom.CodeAttributeDeclaration" />
    ///  objects that represent metadata that is included when the code is exported.</returns>
    property IncludeMetadata: DDN.System.DNCodeAttributeDeclarationCollection read get_IncludeMetadata;
  end;

  TDNXmlCodeExporter = class(TDNGenericImport<DNXmlCodeExporterClass, DNXmlCodeExporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNCodeIdentifierClass = interface(DDN.mscorlib.DNObjectClass)
  ['{16C095AA-4C2C-5EAA-88E4-F5A7BBA06269}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.CodeIdentifier" />
    ///  class. </summary>
    {class} function init: DNCodeIdentifier;

  { static methods } 

    ///<summary>Produces a valid code entity name from an input string. </summary>
    ///  <param name="identifier">The name of a code entity, such as a method parameter, typically taken from an XML element or attribute name.</param>
    ///<returns>A string that can be used as a code identifier, such as the name of a method parameter.</returns>
    {class} function MakeValid(identifier: string): string;
    ///<summary>Produces a Pascal-case string from an input string. </summary>
    ///  <param name="identifier">The name of a code entity, such as a method parameter, typically taken from an XML element or attribute name.</param>
    ///<returns>A Pascal-case version of the parameter string.</returns>
    {class} function MakePascal(identifier: string): string;
    ///<summary>Produces a camel-case string from an input string. </summary>
    ///  <param name="identifier">The name of a code entity, such as a method parameter, typically taken from an XML element or attribute name.</param>
    ///<returns>A camel-case version of the parameter string.</returns>
    {class} function MakeCamel(identifier: string): string;

  end;

  ///<summary>Provides static methods to convert input text into names for code entities.</summary>
  [DNTypeName('System.Xml.Serialization.CodeIdentifier')]
  DNCodeIdentifier = interface(DDN.mscorlib.DNObject)
  ['{BA6E74E4-6403-3B14-BE73-3C2B1A094495}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNCodeIdentifier = class(TDNGenericImport<DNCodeIdentifierClass, DNCodeIdentifier>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNCodeIdentifiersClass = interface(DDN.mscorlib.DNObjectClass)
  ['{7469FE37-04CC-5E5F-876A-03DAE7F55B9F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  class. </summary>
    {class} function init: DNCodeIdentifiers; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  class and determines whether code identifiers are case sensitive.</summary>
    ///  <param name="caseSensitive"><see langword="true" />
    ///  if identifiers are case sensitive; otherwise, <see langword="false" />
    ///  . </param>
    {class} function init(caseSensitive: Boolean): DNCodeIdentifiers; overload;

  end;

  ///<summary>Maintains a group of names for related code entities or type mappings that are generated by the .NET Framework's XML serialization infrastructure.</summary>
  [DNTypeName('System.Xml.Serialization.CodeIdentifiers')]
  DNCodeIdentifiers = interface(DDN.mscorlib.DNObject)
  ['{664CA9B6-046C-3A37-BA89-44B11A5F015A}']
  { getters & setters } 

    function get_UseCamelCasing: Boolean;
    procedure set_UseCamelCasing(value: Boolean);

  { methods } 

    ///<summary>Determines whether the input name conflicts with another name within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope and, if it does, generates a modified string. </summary>
    ///  <param name="identifier">The name to modify if it is not already unique.</param>
    ///<returns>The identifier parameter value or a modified string if there is a name collision.</returns>
    function MakeUnique(identifier: string): string;
    ///<summary>Removes all code entities or type mappings, including their names, from the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope. </summary>
    procedure Clear;
    ///<summary>Ensures that the input is of the correct case by modifying the name according to the value of the <see cref="P:System.Xml.Serialization.CodeIdentifiers.UseCamelCasing" />
    ///  property. </summary>
    ///  <param name="identifier">The name to possibly modify.</param>
    ///<returns>A string that is the same as the input identifier or has the first letter's case modified.</returns>
    function MakeRightCase(identifier: string): string;
    ///<summary>Prevents a specified name from being used within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope. </summary>
    ///  <param name="identifier">A name that will not be available within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope.</param>
    procedure AddReserved(identifier: string);
    ///<summary>Removes the input name from the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's reserved names. </summary>
    ///  <param name="identifier">A name that will be made available within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope.</param>
    procedure RemoveReserved(identifier: string);
    ///<summary>Adds a named code entity or type mapping to the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope, ensuring that the name is unique within the scope. </summary>
    ///  <param name="identifier">A candidate name that is used to index the code entity.</param>
    ///  <param name="value">The code entity or type mapping information.</param>
    ///<returns>The identifier parameter value or a modified string if there is a name collision.</returns>
    function AddUnique(identifier: string; value: DDN.mscorlib.DNObject): string;
    ///<summary>Determines whether a specified name is already being used within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope. </summary>
    ///  <param name="identifier">The name to check for use within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope.</param>
    ///<returns><see langword="true" />
    ///  if the name is already in use; otherwise, <see langword="false" />
    ///  .</returns>
    function IsInUse(identifier: string): Boolean;
    ///<summary>Adds a named code entity or type mapping to the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope. </summary>
    ///  <param name="identifier">A name that is used to index the code entity.</param>
    ///  <param name="value">The code entity or type mapping information.</param>
    procedure Add(identifier: string; value: DDN.mscorlib.DNObject);
    ///<summary>Removes from the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope the code entity or type mapping identified by the input name. </summary>
    ///  <param name="identifier">The name of the code entity or type mapping information to remove.</param>
    procedure Remove(identifier: string);
    ///<summary>Returns an array of the code entities or type mappings within the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  instance's scope. </summary>
    ///  <param name="type">The type of all the code entities or type mappings for the instance.</param>
    ///<returns>An array of the code entities or type mappings that is stored by the <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  object.</returns>
    function ToArray(&type: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that indicates whether the instance uses camel case. </summary>
    ///<returns><see langword="true" />
    ///  to indicate that the instance uses camel case; <see langword="false" />
    ///  to indicate that the instance uses Pascal case.</returns>
    property UseCamelCasing: Boolean read get_UseCamelCasing write set_UseCamelCasing;
  end;

  TDNCodeIdentifiers = class(TDNGenericImport<DNCodeIdentifiersClass, DNCodeIdentifiers>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNImportContextClass = interface(DDN.mscorlib.DNObjectClass)
  ['{425D69F8-37B6-59DC-8C75-22F4DC87AAA4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.ImportContext" />
    ///  class for the given code identifiers, with the given type-sharing option.</summary>
    ///  <param name="identifiers">The code entities to which the context applies.</param>
    ///  <param name="shareTypes">A <see cref="T:System.Boolean" />
    ///  value that determines whether custom types are shared among schema.</param>
    {class} function init(identifiers: DNCodeIdentifiers; shareTypes: Boolean): DNImportContext;

  end;

  ///<summary>Describes the context in which a set of schema is bound to .NET Framework code entities.</summary>
  [DNTypeName('System.Xml.Serialization.ImportContext')]
  DNImportContext = interface(DDN.mscorlib.DNObject)
  ['{95274F7A-0A71-3D35-AF1F-E44F3A3686F6}']
  { getters & setters } 

    function get_TypeIdentifiers: DNCodeIdentifiers;
    function get_ShareTypes: Boolean;
    function get_Warnings: DDN.System.DNStringCollection;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a set of code entities to which the context applies.</summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  that specifies the code entities to which the context applies.</returns>
    property TypeIdentifiers: DNCodeIdentifiers read get_TypeIdentifiers;
    ///<summary>Gets a value that determines whether custom types are shared.</summary>
    ///<returns><see langword="true" />
    ///  , if custom types are shared among schema; otherwise, <see langword="false" />
    ///  .</returns>
    property ShareTypes: Boolean read get_ShareTypes;
    ///<summary>Gets a collection of warnings that are generated when importing the code entity descriptions.</summary>
    ///<returns>A <see cref="T:System.Collections.Specialized.StringCollection" />
    ///  that contains warnings that were generated when importing the code entity descriptions.</returns>
    property Warnings: DDN.System.DNStringCollection read get_Warnings;
  end;

  TDNImportContext = class(TDNGenericImport<DNImportContextClass, DNImportContext>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSchemaImporterClass = interface(DDN.mscorlib.DNObjectClass)
  ['{1C35753F-FEAE-5CD2-997F-017AEEED8B11}']
  end;

  ///<summary>Describes a schema importer.</summary>
  [DNTypeName('System.Xml.Serialization.SchemaImporter')]
  DNSchemaImporter = interface(DDN.mscorlib.DNObject)
  ['{07185328-8ECA-34AA-AC0A-513BD857677A}']
  { getters & setters } 

    function get_Extensions: DNSchemaImporterExtensionCollection;

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of schema importer extensions.</summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.Configuration.SchemaImporterExtensionElementCollection" />
    ///  containing a collection of schema importer extensions.</returns>
    property Extensions: DNSchemaImporterExtensionCollection read get_Extensions;
  end;

  TDNSchemaImporter = class(TDNGenericImport<DNSchemaImporterClass, DNSchemaImporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapSchemaImporterClass = interface(DNSchemaImporterClass)
  ['{B5D1E8AB-12D7-56CA-96AA-9096EB8726D7}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaImporter" />
    ///  class, specifying <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects representing the XML schemas used by SOAP encoded messages defined in a WSDL document. </summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    {class} function init(schemas: DNXmlSchemas): DNSoapSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaImporter" />
    ///  class, specifying <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects representing the XML schemas used by SOAP encoded messages, plus classes being generated for bindings defined in a WSDL document. </summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="typeIdentifiers">A <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  object that specifies a collection of classes being generated for bindings defined in a WSDL document.</param>
    {class} function init(schemas: DNXmlSchemas; typeIdentifiers: DNCodeIdentifiers): DNSoapSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaImporter" />
    ///  class specifying the schemas, compiler options, and names of related code entities.</summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="typeIdentifiers">A <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  that maintains a group of names for related code entities or type mappings that are generated by the .NET Framework's XML serialization infrastructure.</param>
    ///  <param name="options">One of the <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  that specifies various options for generating a .NET Framework type.</param>
    {class} function init(schemas: DNXmlSchemas; typeIdentifiers: DNCodeIdentifiers; options: DNCodeGenerationOptions): DNSoapSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaImporter" />
    ///  class specifying the schemas, compiler options, and the context of the schemas.</summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="options">One of the <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  that specifies various options for generating a .NET Framework type.</param>
    ///  <param name="context">An <see cref="T:System.Xml.Serialization.ImportContext" />
    ///  that describes the context in which a set of schema are bound to .NET Framework code entities. </param>
    {class} function init(schemas: DNXmlSchemas; options: DNCodeGenerationOptions; context: DNImportContext): DNSoapSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaImporter" />
    ///  class specifying the schemas, compiler options, and names of related code entities.</summary>
    ///  <param name="schemas">An <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  containing a collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="options">One of the <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  that specifies various options for generating a .NET Framework type.</param>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  used to generate the serialization code.</param>
    ///  <param name="context">An <see cref="T:System.Xml.Serialization.ImportContext" />
    ///  that describes the context in which a set of schema are bound to .NET Framework code entities.</param>
    {class} function init(schemas: DNXmlSchemas; options: DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider; context: DNImportContext): DNSoapSchemaImporter; overload;

  end;

  ///<summary>Used within the .NET Framework to generate internal mappings to .NET Framework types for SOAP-encoded message parts in a WSDL document. </summary>
  [DNTypeName('System.Xml.Serialization.SoapSchemaImporter')]
  DNSoapSchemaImporter = interface(DNSchemaImporter)
  ['{1D6EE53D-B4EC-3832-A0CC-B401E2150E58}']
  { getters & setters } 

    function get_Extensions: DNSchemaImporterExtensionCollection;

  { methods } 

    ///<summary>Generates internal type mapping information for the element parts of a SOAP-encoded message defined in a WSDL document. </summary>
    ///  <param name="name">The message name.</param>
    ///  <param name="ns">The message namespace.</param>
    ///  <param name="members">An array of type <see cref="T:System.Xml.Serialization.SoapSchemaMember" />
    ///  that provides information about the part elements.</param>
    ///<returns>The .NET Framework type mappings for the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(name: string; ns: string; members: TArray<DNSoapSchemaMember>): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mapping information for the element parts of a SOAP-encoded message defined in a WSDL document. </summary>
    ///  <param name="name">The message name.</param>
    ///  <param name="ns">The message namespace.</param>
    ///  <param name="members">An array of type <see cref="T:System.Xml.Serialization.SoapSchemaMember" />
    ///  that provides information about the part elements.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  to have elements defined by the parts enclosed in an extra, wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The .NET Framework type mappings for the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(name: string; ns: string; members: TArray<DNSoapSchemaMember>; hasWrapperElement: Boolean): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mapping information for the type of a SOAP-encoded element part defined in a WSDL document where a base type is specified. </summary>
    ///  <param name="name">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the name of an element's type for which a .NET Framework type is being generated.</param>
    ///  <param name="baseType">A base type for the .NET Framework type being generated.</param>
    ///  <param name="baseTypeCanBeIndirect"><see langword="true" />
    ///  to indicate that the type being generated may indirectly inherit from the base type; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The .NET Framework type mapping information for a derived type corresponding to a WSDL message part.</returns>
    function ImportDerivedTypeMapping(name: DNXmlQualifiedName; baseType: DDN.mscorlib.DNType; baseTypeCanBeIndirect: Boolean): DNXmlTypeMapping;
    ///<summary>Generates internal type mapping information for a single SOAP-encoded element part defined in a WSDL document. </summary>
    ///  <param name="name">The message name.</param>
    ///  <param name="ns">The message namespace.</param>
    ///  <param name="member">A <see cref="T:System.Xml.Serialization.SoapSchemaMember" />
    ///  object that provides information about the part element.</param>
    ///<returns>The .NET Framework type mapping for a single element part of a WSDL message definition.</returns>
    function ImportMembersMapping(name: string; ns: string; member: DNSoapSchemaMember): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mapping information for the element parts of a SOAP-encoded message defined in a WSDL document.</summary>
    ///  <param name="name">The message name.</param>
    ///  <param name="ns">The message namespace.</param>
    ///  <param name="members">An array of type <see cref="T:System.Xml.Serialization.SoapSchemaMember" />
    ///  that provides information about the part elements.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  to have elements defined by the parts enclosed in an extra, wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="baseType">A base type for all .NET Framework types that are generated to correspond to message parts.</param>
    ///  <param name="baseTypeCanBeIndirect"><see langword="true" />
    ///  to indicate that types corresponding to message parts can indirectly inherit from the base type; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The .NET Framework type mappings for the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(name: string; ns: string; members: TArray<DNSoapSchemaMember>; hasWrapperElement: Boolean; baseType: DDN.mscorlib.DNType; baseTypeCanBeIndirect: Boolean): DNXmlMembersMapping; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of schema importer extensions.</summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.Configuration.SchemaImporterExtensionElementCollection" />
    ///  containing a collection of schema importer extensions.</returns>
    property Extensions: DNSchemaImporterExtensionCollection read get_Extensions;
  end;

  TDNSoapSchemaImporter = class(TDNGenericImport<DNSoapSchemaImporterClass, DNSoapSchemaImporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSchemaImporterClass = interface(DNSchemaImporterClass)
  ['{66095863-7C38-583E-96E6-09E5FF901035}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  class, taking a collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects representing the XML schemas used by SOAP literal messages defined in a WSDL document. </summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    {class} function init(schemas: DNXmlSchemas): DNXmlSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  class, taking a collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects that represents the XML schemas used by SOAP literal messages, plus classes being generated for bindings defined in a Web Services Description Language (WSDL) document. </summary>
    ///  <param name="schemas">An <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  object.</param>
    ///  <param name="typeIdentifiers">A <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  object that specifies a collection of classes being generated for bindings defined in a WSDL document.</param>
    {class} function init(schemas: DNXmlSchemas; typeIdentifiers: DNCodeIdentifiers): DNXmlSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  class, taking a collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects that represents the XML schemas used by SOAP literal messages, plus classes being generated for bindings defined in a WSDL document, and a <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  enumeration value.</summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="typeIdentifiers">A <see cref="T:System.Xml.Serialization.CodeIdentifiers" />
    ///  object that specifies a collection of classes being generated for bindings defined in a WSDL document.</param>
    ///  <param name="options">A bitwise combination of the <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  values that specifies the options to use when generating .NET Framework types for a Web service.</param>
    {class} function init(schemas: DNXmlSchemas; typeIdentifiers: DNCodeIdentifiers; options: DNCodeGenerationOptions): DNXmlSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  class for a collection of XML schemas, using the specified code generation options and import context.</summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="options">A <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  enumeration that specifies code generation options.</param>
    ///  <param name="context">A <see cref="T:System.Xml.Serialization.ImportContext" />
    ///  instance that specifies the import context.</param>
    {class} function init(schemas: DNXmlSchemas; options: DNCodeGenerationOptions; context: DNImportContext): DNXmlSchemaImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaImporter" />
    ///  class. </summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects.</param>
    ///  <param name="options">A bitwise combination of the <see cref="T:System.Xml.Serialization.CodeGenerationOptions" />
    ///  values that specifies the options to use when generating .NET Framework types for a Web service.</param>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  used to generate the serialization code.</param>
    ///  <param name="context">A <see cref="T:System.Xml.Serialization.ImportContext" />
    ///  instance that specifies the import context.</param>
    {class} function init(schemas: DNXmlSchemas; options: DNCodeGenerationOptions; codeProvider: DDN.System.DNCodeDomProvider; context: DNImportContext): DNXmlSchemaImporter; overload;

  end;

  ///<summary>Generates internal mappings to .NET Framework types for XML schema element declarations, including literal XSD message parts in a WSDL document. </summary>
  [DNTypeName('System.Xml.Serialization.XmlSchemaImporter')]
  DNXmlSchemaImporter = interface(DNSchemaImporter)
  ['{C97E7E2E-AC97-35E4-918A-6057F2957031}']
  { getters & setters } 

    function get_Extensions: DNSchemaImporterExtensionCollection;

  { methods } 

    ///<summary>Generates internal type mapping information for an element defined in an XML schema document. </summary>
    ///  <param name="name">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the name of an element defined in an XML schema document.</param>
    ///  <param name="baseType">A base type for the .NET Framework type that is generated to correspond to an XSD element's type.</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  representing the.NET Framework type mapping information for an XML schema element.</returns>
    function ImportDerivedTypeMapping(name: DNXmlQualifiedName; baseType: DDN.mscorlib.DNType): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mapping information for an element defined in an XML schema document. </summary>
    ///  <param name="typeName">A <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies an XML element.</param>
    ///<returns>A <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  object that describes a type mapping.</returns>
    function ImportSchemaType(typeName: DNXmlQualifiedName): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mapping information for an element defined in an XML schema document. </summary>
    ///  <param name="typeName">A <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies an XML element.</param>
    ///  <param name="baseType">A <see cref="T:System.Type" />
    ///  object that specifies a base type.</param>
    ///<returns>A <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  object that describes a type mapping.</returns>
    function ImportSchemaType(typeName: DNXmlQualifiedName; baseType: DDN.mscorlib.DNType): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mapping information for an element defined in an XML schema document. </summary>
    ///  <param name="name">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the name of an element defined in an XML schema document.</param>
    ///<returns>The .NET Framework type mapping information for an XML schema element.</returns>
    function ImportTypeMapping(name: DNXmlQualifiedName): DNXmlTypeMapping;
    ///<summary>Generates internal type mapping information for a single element part of a literal-use SOAP message defined in a WSDL document. </summary>
    ///  <param name="name">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the name of the message part.</param>
    ///<returns>The .NET Framework type mapping for a WSDL message definition containing a single element part.</returns>
    function ImportMembersMapping(name: DNXmlQualifiedName): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mapping information for a single, (SOAP) literal element part defined in a WSDL document.</summary>
    ///  <param name="typeName">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the name of an element's type for which a .NET Framework type is generated.</param>
    ///  <param name="elementName">The name of the part element in the WSDL document.</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  representing the .NET Framework type mapping for a single element part of a WSDL message definition.</returns>
    function ImportAnyType(typeName: DNXmlQualifiedName; elementName: string): DNXmlMembersMapping;
    ///<summary>Generates internal type mapping information for the element parts of a literal-use SOAP message defined in a WSDL document. </summary>
    ///  <param name="names">An array of type <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the names of the message parts.</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  that represents the .NET Framework type mappings for the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(names: TArray<DNXmlQualifiedName>): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mapping information for the element parts of a literal-use SOAP message defined in a WSDL document.</summary>
    ///  <param name="name">The name of the element for which to generate a mapping.</param>
    ///  <param name="ns">The namespace of the element for which to generate a mapping.</param>
    ///  <param name="members">An array of <see cref="T:System.Xml.Serialization.SoapSchemaMember" />
    ///  instances that specifies the members of the element for which to generate a mapping.</param>
    ///<returns>A <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  that contains type mapping information.</returns>
    function ImportMembersMapping(name: string; ns: string; members: TArray<DNSoapSchemaMember>): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mapping information for an element defined in an XML schema document or as a part in a WSDL document.</summary>
    ///  <param name="name">An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the name of an element defined in an XML schema document.</param>
    ///  <param name="baseType">A base type for the .NET Framework type that is generated to correspond to an XSD element's type.</param>
    ///  <param name="baseTypeCanBeIndirect"><see langword="true" />
    ///  to indicate that the type corresponding to an XSD element can indirectly inherit from the base type; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The .NET Framework type mapping information for an XML schema element.</returns>
    function ImportDerivedTypeMapping(name: DNXmlQualifiedName; baseType: DDN.mscorlib.DNType; baseTypeCanBeIndirect: Boolean): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mapping information for an element defined in an XML schema document. </summary>
    ///  <param name="typeName">A <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies an XML element.</param>
    ///  <param name="baseType">A <see cref="T:System.Type" />
    ///  object that specifies a base type.</param>
    ///  <param name="baseTypeCanBeIndirect">A <see cref="T:System.Boolean" />
    ///  value that specifies whether the generated type can indirectly inherit the <paramref name="baseType" />
    ///  .</param>
    ///<returns>A <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  object that describes a type mapping.</returns>
    function ImportSchemaType(typeName: DNXmlQualifiedName; baseType: DDN.mscorlib.DNType; baseTypeCanBeIndirect: Boolean): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mapping information for the element parts of a literal-use SOAP message defined in a WSDL document.</summary>
    ///  <param name="names">An array of type <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that specifies the names of the message parts.</param>
    ///  <param name="baseType">A base type for all .NET Framework types that are generated to correspond to message parts.</param>
    ///  <param name="baseTypeCanBeIndirect"><see langword="true" />
    ///  to indicate that the types corresponding to message parts can indirectly inherit from the base type; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The .NET Framework type mappings for the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(names: TArray<DNXmlQualifiedName>; baseType: DDN.mscorlib.DNType; baseTypeCanBeIndirect: Boolean): DNXmlMembersMapping; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of schema importer extensions.</summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.Configuration.SchemaImporterExtensionElementCollection" />
    ///  containing a collection of schema importer extensions.</returns>
    property Extensions: DNSchemaImporterExtensionCollection read get_Extensions;
  end;

  TDNXmlSchemaImporter = class(TDNGenericImport<DNXmlSchemaImporterClass, DNXmlSchemaImporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapAttributeOverridesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{C242A9E6-FE8C-55F7-8049-4DA2CC71A393}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapAttributeOverrides" />
    ///  class. </summary>
    {class} function init: DNSoapAttributeOverrides;

  end;

  ///<summary>Allows you to override attributes applied to properties, fields, and classes when you use an <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  to serialize or deserialize an object as encoded SOAP.</summary>
  [DNTypeName('System.Xml.Serialization.SoapAttributeOverrides')]
  DNSoapAttributeOverrides = interface(DDN.mscorlib.DNObject)
  ['{6F45712D-36F9-3F4B-8859-636CC8C3A7BB}']
  { getters & setters } 

    function get_Item(&type: DDN.mscorlib.DNType): DNSoapAttributes; overload;
    function get_Item(&type: DDN.mscorlib.DNType; member: string): DNSoapAttributes; overload;

  { methods } 

    ///<summary>Adds a <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  to a collection of <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  objects. The <paramref name="type" />
    ///  parameter specifies an object to be overridden by the <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  .</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object that is overridden. </param>
    ///  <param name="attributes">A <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  that represents the overriding attributes. </param>
    procedure Add(&type: DDN.mscorlib.DNType; attributes: DNSoapAttributes); overload;
    ///<summary>Adds a <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  to the collection of <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  objects contained by the <see cref="T:System.Xml.Serialization.SoapAttributeOverrides" />
    ///  . The <paramref name="type" />
    ///  parameter specifies the object to be overridden by the <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  . The <paramref name="member" />
    ///  parameter specifies the name of a member that is overridden.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object to override. </param>
    ///  <param name="member">The name of the member to override. </param>
    ///  <param name="attributes">A <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  that represents the overriding attributes. </param>
    procedure Add(&type: DDN.mscorlib.DNType; member: string; attributes: DNSoapAttributes); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[&type: DDN.mscorlib.DNType]: DNSoapAttributes read get_Item; default;
    property Item[&type: DDN.mscorlib.DNType; member: string]: DNSoapAttributes read get_Item; default;
  end;

  TDNSoapAttributeOverrides = class(TDNGenericImport<DNSoapAttributeOverridesClass, DNSoapAttributeOverrides>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapAttributesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{DBF2589C-3D4F-506D-B9E6-B218017B166A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  class.</summary>
    {class} function init: DNSoapAttributes; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  class using the specified custom type.</summary>
    ///  <param name="provider">Any object that implements the <see cref="T:System.Reflection.ICustomAttributeProvider" />
    ///  interface, such as the <see cref="T:System.Type" />
    ///  class.</param>
    {class} function init(provider: DDN.mscorlib.DNICustomAttributeProvider): DNSoapAttributes; overload;

  end;

  ///<summary>Represents a collection of attribute objects that control how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  serializes and deserializes SOAP methods.</summary>
  [DNTypeName('System.Xml.Serialization.SoapAttributes')]
  DNSoapAttributes = interface(DDN.mscorlib.DNObject)
  ['{A7C91ED3-8A88-3EC0-A7B9-3B3C2FCAB71D}']
  { getters & setters } 

    function get_SoapType: DNSoapTypeAttribute;
    procedure set_SoapType(value: DNSoapTypeAttribute);
    function get_SoapEnum: DNSoapEnumAttribute;
    procedure set_SoapEnum(value: DNSoapEnumAttribute);
    function get_SoapIgnore: Boolean;
    procedure set_SoapIgnore(value: Boolean);
    function get_SoapElement: DNSoapElementAttribute;
    procedure set_SoapElement(value: DNSoapElementAttribute);
    function get_SoapAttribute: DNSoapAttributeAttribute;
    procedure set_SoapAttribute(value: DNSoapAttributeAttribute);
    function get_SoapDefaultValue: DDN.mscorlib.DNObject;
    procedure set_SoapDefaultValue(value: DDN.mscorlib.DNObject);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets an object that instructs the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  how to serialize an object type into encoded SOAP XML.</summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.SoapTypeAttribute" />
    ///  that either overrides a <see cref="T:System.Xml.Serialization.SoapTypeAttribute" />
    ///  applied to a class declaration, or is applied to a class declaration.</returns>
    property SoapType: DNSoapTypeAttribute read get_SoapType write set_SoapType;
    ///<summary>Gets or sets an object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a SOAP enumeration.</summary>
    ///<returns>An object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes an enumeration member.</returns>
    property SoapEnum: DNSoapEnumAttribute read get_SoapEnum write set_SoapEnum;
    ///<summary>Gets or sets a value that specifies whether the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a public field or property as encoded SOAP XML.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must not serialize the field or property; otherwise, <see langword="false" />
    ///  .</returns>
    property SoapIgnore: Boolean read get_SoapIgnore write set_SoapIgnore;
    ///<summary>Gets or sets a <see cref="T:System.Xml.Serialization.SoapElementAttribute" />
    ///  to override.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.SoapElementAttribute" />
    ///  to override.</returns>
    property SoapElement: DNSoapElementAttribute read get_SoapElement write set_SoapElement;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.SoapAttributeAttribute" />
    ///  to override.</summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.SoapAttributeAttribute" />
    ///  that overrides the behavior of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  when the member is serialized.</returns>
    property SoapAttribute: DNSoapAttributeAttribute read get_SoapAttribute write set_SoapAttribute;
    ///<summary>Gets or sets the default value of an XML element or attribute.</summary>
    ///<returns>An object that represents the default value of an XML element or attribute.</returns>
    property SoapDefaultValue: DDN.mscorlib.DNObject read get_SoapDefaultValue write set_SoapDefaultValue;
  end;

  TDNSoapAttributes = class(TDNGenericImport<DNSoapAttributesClass, DNSoapAttributes>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapReflectionImporterClass = interface(DDN.mscorlib.DNObjectClass)
  ['{5E3AF124-3EBD-54E2-8270-A5704886C48A}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapReflectionImporter" />
    ///  class. </summary>
    {class} function init: DNSoapReflectionImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapReflectionImporter" />
    ///  class, specifying a default XML namespace for imported type mappings. </summary>
    ///  <param name="defaultNamespace">The default XML namespace to use for imported type mappings.</param>
    {class} function init(defaultNamespace: string): DNSoapReflectionImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapReflectionImporter" />
    ///  class, specifying overrides for XML serialization. </summary>
    ///  <param name="attributeOverrides">A <see cref="T:System.Xml.Serialization.SoapAttributeOverrides" />
    ///  object that overrides how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class serializes mapped types using SOAP encoding.</param>
    {class} function init(attributeOverrides: DNSoapAttributeOverrides): DNSoapReflectionImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapReflectionImporter" />
    ///  class, specifying XML serialization overrides and a default XML namespace. </summary>
    ///  <param name="attributeOverrides">A <see cref="T:System.Xml.Serialization.SoapAttributeOverrides" />
    ///  object that overrides how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class serializes mapped types using SOAP encoding.</param>
    ///  <param name="defaultNamespace">The default XML namespace to use for imported type mappings.</param>
    {class} function init(attributeOverrides: DNSoapAttributeOverrides; defaultNamespace: string): DNSoapReflectionImporter; overload;

  end;

  ///<summary>Generates mappings to SOAP-encoded messages from .NET Framework types or Web service method information. </summary>
  [DNTypeName('System.Xml.Serialization.SoapReflectionImporter')]
  DNSoapReflectionImporter = interface(DDN.mscorlib.DNObject)
  ['{B73DB4BF-E6EA-36ED-BAB0-DBFFA646E0BA}']
  { methods } 

    ///<summary>Places mappings for derived types in the <see cref="T:System.Xml.Serialization.SoapReflectionImporter" />
    ///  instance's context for later use when import methods are invoked. </summary>
    ///  <param name="provider">An <see cref="T:System.Reflection.ICustomAttributeProvider" />
    ///  reflection object that contains custom attributes that are derived from the <see cref="T:System.Xml.Serialization.SoapIncludeAttribute" />
    ///  attribute.</param>
    procedure IncludeTypes(provider: DDN.mscorlib.DNICustomAttributeProvider);
    ///<summary>Places mappings for a type in the <see cref="T:System.Xml.Serialization.SoapReflectionImporter" />
    ///  instance's context for later use when import methods are invoked. </summary>
    ///  <param name="type">The .NET Framework type for which to save type mapping information.</param>
    procedure IncludeType(&type: DDN.mscorlib.DNType);
    ///<summary>Generates a mapping to an XML Schema element for a .NET Framework type.</summary>
    ///  <param name="type">The .NET Framework type for which to generate a type mapping. </param>
    ///<returns>Internal .NET Framework mapping of a type to an XML Schema element. </returns>
    function ImportTypeMapping(&type: DDN.mscorlib.DNType): DNXmlTypeMapping; overload;
    ///<summary>Generates a mapping to an XML Schema element for a .NET Framework type.</summary>
    ///  <param name="type">The .NET Framework type for which to generate a type mapping. </param>
    ///  <param name="defaultNamespace">The default XML namespace to use.</param>
    ///<returns>Internal .NET Framework mapping of a type to an XML Schema element.</returns>
    function ImportTypeMapping(&type: DDN.mscorlib.DNType; defaultNamespace: string): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mappings for information that is gathered from a Web service method. </summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of .NET Framework code entities that belong to a Web service method.</param>
    ///<returns>Internal .NET Framework type mappings to the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mappings for information that is gathered from a Web service method. </summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  to indicate that elements that correspond to WSDL message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="writeAccessors"><see langword="true" />
    ///  to indicate an RPC-style Web service binding; <see langword="false" />
    ///  to indicate a document-style Web service binding or a SOAP header.</param>
    ///<returns>Internal .NET Framework type mappings to the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean; writeAccessors: Boolean): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mappings for information that is gathered from a Web service method. </summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  to indicate that elements that correspond to WSDL message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="writeAccessors"><see langword="true" />
    ///  to indicate an RPC-style Web service binding; <see langword="false" />
    ///  to indicate a document-style Web service binding or a SOAP header.</param>
    ///  <param name="validate"><see langword="true" />
    ///  to indicate that a generated deserializer should check for the expected qualified name of the wrapper element; otherwise, <see langword="false" />
    ///  . This parameter's value is relevant only if the <paramref name="hasWrapperElement" />
    ///  parameter's value is <see langword="true" />
    ///  .</param>
    ///<returns>Internal .NET Framework type mappings to the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean; writeAccessors: Boolean; validate: Boolean): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mappings for information that is gathered from a Web service method.</summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  to indicate that elements that correspond to WSDL message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="writeAccessors"><see langword="true" />
    ///  to indicate an RPC-style Web service binding; <see langword="false" />
    ///  to indicate a document-style Web service binding or a SOAP header.</param>
    ///  <param name="validate"><see langword="true" />
    ///  to indicate that a generated deserializer should check for the expected qualified name of the wrapper element; otherwise, <see langword="false" />
    ///  . This parameter's value is relevant only if the <paramref name="hasWrapperElement" />
    ///  parameter's value is <see langword="true" />
    ///  .</param>
    ///  <param name="access">One of the <see cref="T:System.Xml.Serialization.XmlMappingAccess" />
    ///  values.</param>
    ///<returns>Internal .NET Framework type mappings to the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean; writeAccessors: Boolean; validate: Boolean; access: DNXmlMappingAccess): DNXmlMembersMapping; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSoapReflectionImporter = class(TDNGenericImport<DNSoapReflectionImporterClass, DNSoapReflectionImporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapSchemaExporterClass = interface(DDN.mscorlib.DNObjectClass)
  ['{5248EBF8-BFA2-5A66-8222-4A01DF423522}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaExporter" />
    ///  class, which supplies the collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects to which XML Schema element declarations are to be added.</summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects to which element declarations obtained from type mappings are to be added.</param>
    {class} function init(schemas: DNXmlSchemas): DNSoapSchemaExporter;

  end;

  ///<summary>Populates <see cref="T:System.Xml.Schema.XmlSchema" />
  ///  objects with XML Schema data type definitions for .NET Framework types that are serialized using SOAP encoding.</summary>
  [DNTypeName('System.Xml.Serialization.SoapSchemaExporter')]
  DNSoapSchemaExporter = interface(DDN.mscorlib.DNObject)
  ['{61AD9AC2-5DD4-35EB-A765-E8EF2E2A2A90}']
  { methods } 

    ///<summary>Adds to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object a data type definition for a .NET Framework type.</summary>
    ///  <param name="xmlTypeMapping">An internal mapping between a .NET Framework type and an XML Schema element.</param>
    procedure ExportTypeMapping(xmlTypeMapping: DNXmlTypeMapping);
    ///<summary>Adds to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object a data type definition for each of the element parts of a SOAP-encoded message definition.</summary>
    ///  <param name="xmlMembersMapping">Internal .NET Framework type mappings for the element parts of a WSDL message definition.</param>
    procedure ExportMembersMapping(xmlMembersMapping: DNXmlMembersMapping); overload;
    ///<summary>Adds to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object a data type definition for each of the element parts of a SOAP-encoded message definition.</summary>
    ///  <param name="xmlMembersMapping">Internal .NET Framework type mappings for the element parts of a WSDL message definition.</param>
    ///  <param name="exportEnclosingType"><see langword="true" />
    ///  to export a type definition for the parent element of the WSDL parts; otherwise, <see langword="false" />
    ///  .</param>
    procedure ExportMembersMapping(xmlMembersMapping: DNXmlMembersMapping; exportEnclosingType: Boolean); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNSoapSchemaExporter = class(TDNGenericImport<DNSoapSchemaExporterClass, DNSoapSchemaExporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNSoapSchemaMemberClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0D5B7FD1-A279-58A0-85B0-065A36B010D4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.SoapSchemaMember" />
    ///  class. </summary>
    {class} function init: DNSoapSchemaMember;

  end;

  ///<summary>Represents certain attributes of a XSD &lt;<see langword="part" />
  ///  &gt; element in a WSDL document for generating classes from the document. </summary>
  [DNTypeName('System.Xml.Serialization.SoapSchemaMember')]
  DNSoapSchemaMember = interface(DDN.mscorlib.DNObject)
  ['{338F0B4E-16CB-301A-8A9F-7164C76D50D7}']
  { getters & setters } 

    function get_MemberType: DNXmlQualifiedName;
    procedure set_MemberType(value: DNXmlQualifiedName);
    function get_MemberName: string;
    procedure set_MemberName(value: string);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that corresponds to the type attribute of the WSDL part element.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that corresponds to the XML type.</returns>
    property MemberType: DNXmlQualifiedName read get_MemberType write set_MemberType;
    ///<summary>Gets or sets a value that corresponds to the name attribute of the WSDL part element. </summary>
    ///<returns>The element name.</returns>
    property MemberName: string read get_MemberName write set_MemberName;
  end;

  TDNSoapSchemaMember = class(TDNGenericImport<DNSoapSchemaMemberClass, DNSoapSchemaMember>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAttributeOverridesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{7C2F6EF2-C5F8-5B3C-9728-DBA72A837F78}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  class. </summary>
    {class} function init: DNXmlAttributeOverrides;

  end;

  ///<summary>Allows you to override property, field, and class attributes when you use the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  to serialize or deserialize an object.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAttributeOverrides')]
  DNXmlAttributeOverrides = interface(DDN.mscorlib.DNObject)
  ['{A058A976-DF7D-3F5E-9145-E972A8A17A85}']
  { getters & setters } 

    function get_Item(&type: DDN.mscorlib.DNType): DNXmlAttributes; overload;
    function get_Item(&type: DDN.mscorlib.DNType; member: string): DNXmlAttributes; overload;

  { methods } 

    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  object to the collection of <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  objects. The <paramref name="type" />
    ///  parameter specifies an object to be overridden by the <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  object.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object that is overridden. </param>
    ///  <param name="attributes">An <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  object that represents the overriding attributes. </param>
    procedure Add(&type: DDN.mscorlib.DNType; attributes: DNXmlAttributes); overload;
    ///<summary>Adds an <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  object to the collection of <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  objects. The <paramref name="type" />
    ///  parameter specifies an object to be overridden. The <paramref name="member" />
    ///  parameter specifies the name of a member that is overridden.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object to override. </param>
    ///  <param name="member">The name of the member to override. </param>
    ///  <param name="attributes">An <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  object that represents the overriding attributes. </param>
    procedure Add(&type: DDN.mscorlib.DNType; member: string; attributes: DNXmlAttributes); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property Item[&type: DDN.mscorlib.DNType]: DNXmlAttributes read get_Item; default;
    property Item[&type: DDN.mscorlib.DNType; member: string]: DNXmlAttributes read get_Item; default;
  end;

  TDNXmlAttributeOverrides = class(TDNGenericImport<DNXmlAttributeOverridesClass, DNXmlAttributeOverrides>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlAttributesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{077C1F76-9043-5E7B-825D-0973EBF07720}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  class.</summary>
    {class} function init: DNXmlAttributes; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  class and customizes how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes and deserializes an object. </summary>
    ///  <param name="provider">A class that can provide alternative implementations of attributes that control XML serialization.</param>
    {class} function init(provider: DDN.mscorlib.DNICustomAttributeProvider): DNXmlAttributes; overload;

  end;

  ///<summary>Represents a collection of attribute objects that control how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  serializes and deserializes an object.</summary>
  [DNTypeName('System.Xml.Serialization.XmlAttributes')]
  DNXmlAttributes = interface(DDN.mscorlib.DNObject)
  ['{12195E33-E0FC-38E3-8303-BE44201719E9}']
  { getters & setters } 

    function get_XmlElements: DNXmlElementAttributes;
    function get_XmlAttribute: DNXmlAttributeAttribute;
    procedure set_XmlAttribute(value: DNXmlAttributeAttribute);
    function get_XmlEnum: DNXmlEnumAttribute;
    procedure set_XmlEnum(value: DNXmlEnumAttribute);
    function get_XmlText: DNXmlTextAttribute;
    procedure set_XmlText(value: DNXmlTextAttribute);
    function get_XmlArray: DNXmlArrayAttribute;
    procedure set_XmlArray(value: DNXmlArrayAttribute);
    function get_XmlArrayItems: DNXmlArrayItemAttributes;
    function get_XmlDefaultValue: DDN.mscorlib.DNObject;
    procedure set_XmlDefaultValue(value: DDN.mscorlib.DNObject);
    function get_XmlIgnore: Boolean;
    procedure set_XmlIgnore(value: Boolean);
    function get_XmlType: DNXmlTypeAttribute;
    procedure set_XmlType(value: DNXmlTypeAttribute);
    function get_XmlRoot: DNXmlRootAttribute;
    procedure set_XmlRoot(value: DNXmlRootAttribute);
    function get_XmlAnyElements: DNXmlAnyElementAttributes;
    function get_XmlAnyAttribute: DNXmlAnyAttributeAttribute;
    procedure set_XmlAnyAttribute(value: DNXmlAnyAttributeAttribute);
    function get_XmlChoiceIdentifier: DNXmlChoiceIdentifierAttribute;
    function get_Xmlns: Boolean;
    procedure set_Xmlns(value: Boolean);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a collection of objects that specify how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a public field or read/write property as an XML element.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlElementAttributes" />
    ///  that contains a collection of <see cref="T:System.Xml.Serialization.XmlElementAttribute" />
    ///  objects.</returns>
    property XmlElements: DNXmlElementAttributes read get_XmlElements;
    ///<summary>Gets or sets an object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a public field or public read/write property as an XML attribute.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlAttributeAttribute" />
    ///  that controls the serialization of a public field or read/write property as an XML attribute.</returns>
    property XmlAttribute: DNXmlAttributeAttribute read get_XmlAttribute write set_XmlAttribute;
    ///<summary>Gets or sets an object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes an enumeration member.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlEnumAttribute" />
    ///  that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes an enumeration member.</returns>
    property XmlEnum: DNXmlEnumAttribute read get_XmlEnum write set_XmlEnum;
    ///<summary>Gets or sets an object that instructs the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  to serialize a public field or public read/write property as XML text.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlTextAttribute" />
    ///  that overrides the default serialization of a public property or field.</returns>
    property XmlText: DNXmlTextAttribute read get_XmlText write set_XmlText;
    ///<summary>Gets or sets an object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a public field or read/write property that returns an array.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlArrayAttribute" />
    ///  that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a public field or read/write property that returns an array.</returns>
    property XmlArray: DNXmlArrayAttribute read get_XmlArray write set_XmlArray;
    ///<summary>Gets or sets a collection of objects that specify how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes items inserted into an array returned by a public field or read/write property.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlArrayItemAttributes" />
    ///  object that contains a collection of <see cref="T:System.Xml.Serialization.XmlArrayItemAttribute" />
    ///  objects.</returns>
    property XmlArrayItems: DNXmlArrayItemAttributes read get_XmlArrayItems;
    ///<summary>Gets or sets the default value of an XML element or attribute.</summary>
    ///<returns>An <see cref="T:System.Object" />
    ///  that represents the default value of an XML element or attribute.</returns>
    property XmlDefaultValue: DDN.mscorlib.DNObject read get_XmlDefaultValue write set_XmlDefaultValue;
    ///<summary>Gets or sets a value that specifies whether or not the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a public field or public read/write property.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  must not serialize the field or property; otherwise, <see langword="false" />
    ///  .</returns>
    property XmlIgnore: Boolean read get_XmlIgnore write set_XmlIgnore;
    ///<summary>Gets or sets an object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a class to which the <see cref="T:System.Xml.Serialization.XmlTypeAttribute" />
    ///  has been applied.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlTypeAttribute" />
    ///  that overrides an <see cref="T:System.Xml.Serialization.XmlTypeAttribute" />
    ///  applied to a class declaration.</returns>
    property XmlType: DNXmlTypeAttribute read get_XmlType write set_XmlType;
    ///<summary>Gets or sets an object that specifies how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  serializes a class as an XML root element.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that overrides a class attributed as an XML root element.</returns>
    property XmlRoot: DNXmlRootAttribute read get_XmlRoot write set_XmlRoot;
    ///<summary>Gets the collection of <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  objects to override.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlAnyElementAttributes" />
    ///  object that represents the collection of <see cref="T:System.Xml.Serialization.XmlAnyElementAttribute" />
    ///  objects.</returns>
    property XmlAnyElements: DNXmlAnyElementAttributes read get_XmlAnyElements;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
    ///  to override.</summary>
    ///<returns>The <see cref="T:System.Xml.Serialization.XmlAnyAttributeAttribute" />
    ///  to override.</returns>
    property XmlAnyAttribute: DNXmlAnyAttributeAttribute read get_XmlAnyAttribute write set_XmlAnyAttribute;
    ///<summary>Gets or sets an object that allows you to distinguish between a set of choices.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlChoiceIdentifierAttribute" />
    ///  that can be applied to a class member that is serialized as an <see langword="xsi:choice" />
    ///  element.</returns>
    property XmlChoiceIdentifier: DNXmlChoiceIdentifierAttribute read get_XmlChoiceIdentifier;
    ///<summary>Gets or sets a value that specifies whether to keep all namespace declarations when an object containing a member that returns an <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  object is overridden.</summary>
    ///<returns><see langword="true" />
    ///  if the namespace declarations should be kept; otherwise, <see langword="false" />
    ///  .</returns>
    property Xmlns: Boolean read get_Xmlns write set_Xmlns;
  end;

  TDNXmlAttributes = class(TDNGenericImport<DNXmlAttributesClass, DNXmlAttributes>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlMappingClass = interface(DDN.mscorlib.DNObjectClass)
  ['{94C75695-6656-509B-AA6F-42E1BB20DB48}']
  end;

  ///<summary>Supports mappings between .NET Framework types and XML Schema data types. </summary>
  [DNTypeName('System.Xml.Serialization.XmlMapping')]
  DNXmlMapping = interface(DDN.mscorlib.DNObject)
  ['{237EB3E9-153B-3AD5-8AB2-5B2D4A13ACAE}']
  { getters & setters } 

    function get_ElementName: string;
    function get_XsdElementName: string;
    function get_Namespace: string;

  { methods } 

    ///<summary>Sets the key used to look up the mapping.</summary>
    ///  <param name="key">A <see cref="T:System.String" />
    ///  that contains the lookup key.</param>
    procedure SetKey(key: string);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Get the name of the mapped element.</summary>
    ///<returns>The name of the mapped element.</returns>
    property ElementName: string read get_ElementName;
    ///<summary>Gets the name of the XSD element of the mapping.</summary>
    ///<returns>The XSD element name.</returns>
    property XsdElementName: string read get_XsdElementName;
    ///<summary>Gets the namespace of the mapped element.</summary>
    ///<returns>The namespace of the mapped element.</returns>
    property Namespace: string read get_Namespace;
  end;

  TDNXmlMapping = class(TDNGenericImport<DNXmlMappingClass, DNXmlMapping>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlMembersMappingClass = interface(DNXmlMappingClass)
  ['{E979AC34-5732-5CD6-B668-10CE467B7B05}']
  end;

  ///<summary>Provides mappings between .NET Framework Web service methods and Web Services Description Language (WSDL) messages that are defined for SOAP Web services. </summary>
  [DNTypeName('System.Xml.Serialization.XmlMembersMapping')]
  DNXmlMembersMapping = interface(DNXmlMapping)
  ['{CF624D8C-2146-3393-9F95-60738B91180D}']
  { getters & setters } 

    function get_TypeName: string;
    function get_TypeNamespace: string;
    function get_Item(index: Int32): DNXmlMemberMapping;
    function get_Count: Int32;
    function get_ElementName: string;
    function get_XsdElementName: string;
    function get_Namespace: string;

  { methods } 

    ///<summary>Sets the key used to look up the mapping.</summary>
    ///  <param name="key">A <see cref="T:System.String" />
    ///  that contains the lookup key.</param>
    procedure SetKey(key: string);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the .NET Framework type being mapped to the data type of an XML Schema element that represents a SOAP message.</summary>
    ///<returns>The name of the .NET Framework type.</returns>
    property TypeName: string read get_TypeName;
    ///<summary>Gets the namespace of the .NET Framework type being mapped to the data type of an XML Schema element that represents a SOAP message.</summary>
    ///<returns>The .NET Framework namespace of the mapping.</returns>
    property TypeNamespace: string read get_TypeNamespace;
    property Item[index: Int32]: DNXmlMemberMapping read get_Item; default;
    ///<summary>Gets the number of .NET Framework code entities that belong to a Web service method to which a SOAP message is being mapped. </summary>
    ///<returns>The number of mappings in the collection.</returns>
    property Count: Int32 read get_Count;
    ///<summary>Get the name of the mapped element.</summary>
    ///<returns>The name of the mapped element.</returns>
    property ElementName: string read get_ElementName;
    ///<summary>Gets the name of the XSD element of the mapping.</summary>
    ///<returns>The XSD element name.</returns>
    property XsdElementName: string read get_XsdElementName;
    ///<summary>Gets the namespace of the mapped element.</summary>
    ///<returns>The namespace of the mapped element.</returns>
    property Namespace: string read get_Namespace;
  end;

  TDNXmlMembersMapping = class(TDNGenericImport<DNXmlMembersMappingClass, DNXmlMembersMapping>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlTypeMappingClass = interface(DNXmlMappingClass)
  ['{3C8A32B7-6A53-5383-A850-CB3AA65FBFEA}']
  end;

  ///<summary>Contains a mapping of one type to another.</summary>
  [DNTypeName('System.Xml.Serialization.XmlTypeMapping')]
  DNXmlTypeMapping = interface(DNXmlMapping)
  ['{B3188B0A-C0E1-33C2-B929-8BE861DB96DC}']
  { getters & setters } 

    function get_TypeName: string;
    function get_TypeFullName: string;
    function get_XsdTypeName: string;
    function get_XsdTypeNamespace: string;
    function get_ElementName: string;
    function get_XsdElementName: string;
    function get_Namespace: string;

  { methods } 

    ///<summary>Sets the key used to look up the mapping.</summary>
    ///  <param name="key">A <see cref="T:System.String" />
    ///  that contains the lookup key.</param>
    procedure SetKey(key: string);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the type name of the mapped object.</summary>
    ///<returns>The type name of the mapped object.</returns>
    property TypeName: string read get_TypeName;
    ///<summary>The fully qualified type name that includes the namespace (or namespaces) and type.</summary>
    ///<returns>The fully qualified type name.</returns>
    property TypeFullName: string read get_TypeFullName;
    ///<summary>Gets the XML element name of the mapped object.</summary>
    ///<returns>The XML element name of the mapped object. The default is the class name of the object.</returns>
    property XsdTypeName: string read get_XsdTypeName;
    ///<summary>Gets the XML namespace of the mapped object.</summary>
    ///<returns>The XML namespace of the mapped object. The default is an empty string ("").</returns>
    property XsdTypeNamespace: string read get_XsdTypeNamespace;
    ///<summary>Get the name of the mapped element.</summary>
    ///<returns>The name of the mapped element.</returns>
    property ElementName: string read get_ElementName;
    ///<summary>Gets the name of the XSD element of the mapping.</summary>
    ///<returns>The XSD element name.</returns>
    property XsdElementName: string read get_XsdElementName;
    ///<summary>Gets the namespace of the mapped element.</summary>
    ///<returns>The namespace of the mapped element.</returns>
    property Namespace: string read get_Namespace;
  end;

  TDNXmlTypeMapping = class(TDNGenericImport<DNXmlTypeMappingClass, DNXmlTypeMapping>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlMemberMappingClass = interface(DDN.mscorlib.DNObjectClass)
  ['{E8CC3CBE-3B43-540A-B242-403D1198DDB6}']
  end;

  ///<summary>Maps a code entity in a .NET Framework Web service method to an element in a Web Services Description Language (WSDL) message.</summary>
  [DNTypeName('System.Xml.Serialization.XmlMemberMapping')]
  DNXmlMemberMapping = interface(DDN.mscorlib.DNObject)
  ['{9BA5211C-C504-3CBD-9A74-F9640FC44F05}']
  { getters & setters } 

    function get_Any: Boolean;
    function get_ElementName: string;
    function get_XsdElementName: string;
    function get_Namespace: string;
    function get_MemberName: string;
    function get_TypeName: string;
    function get_TypeNamespace: string;
    function get_TypeFullName: string;
    function get_CheckSpecified: Boolean;

  { methods } 

    ///<summary>Returns the name of the type associated with the specified <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  .</summary>
    ///  <param name="codeProvider">A <see cref="T:System.CodeDom.Compiler.CodeDomProvider" />
    ///  that contains the name of the type.</param>
    ///<returns>The name of the type.</returns>
    function GenerateTypeName(codeProvider: DDN.System.DNCodeDomProvider): string;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that indicates whether the .NET Framework type maps to an XML element or attribute of any type. </summary>
    ///<returns><see langword="true" />
    ///  , if the type maps to an XML any element or attribute; otherwise, <see langword="false" />
    ///  .</returns>
    property Any: Boolean read get_Any;
    ///<summary>Gets the unqualified name of the XML element declaration that applies to this mapping. </summary>
    ///<returns>The unqualified name of the XML element declaration that applies to this mapping.</returns>
    property ElementName: string read get_ElementName;
    ///<summary>Gets the XML element name as it appears in the service description document.</summary>
    ///<returns>The XML element name.</returns>
    property XsdElementName: string read get_XsdElementName;
    ///<summary>Gets the XML namespace that applies to this mapping. </summary>
    ///<returns>The XML namespace that applies to this mapping.</returns>
    property Namespace: string read get_Namespace;
    ///<summary>Gets the name of the Web service method member that is represented by this mapping. </summary>
    ///<returns>The name of the Web service method member represented by this mapping.</returns>
    property MemberName: string read get_MemberName;
    ///<summary>Gets the type name of the .NET Framework type for this mapping. </summary>
    ///<returns>The type name of the .NET Framework type for this mapping.</returns>
    property TypeName: string read get_TypeName;
    ///<summary>Gets the namespace of the .NET Framework type for this mapping.</summary>
    ///<returns>The namespace of the .NET Framework type for this mapping.</returns>
    property TypeNamespace: string read get_TypeNamespace;
    ///<summary>Gets the fully qualified type name of the .NET Framework type for this mapping. </summary>
    ///<returns>The fully qualified type name of the .NET Framework type for this mapping.</returns>
    property TypeFullName: string read get_TypeFullName;
    ///<summary>Gets a value that indicates whether the accompanying field in the .NET Framework type has a value specified.</summary>
    ///<returns><see langword="true" />
    ///  , if the accompanying field has a value specified; otherwise, <see langword="false" />
    ///  .</returns>
    property CheckSpecified: Boolean read get_CheckSpecified;
  end;

  TDNXmlMemberMapping = class(TDNGenericImport<DNXmlMemberMappingClass, DNXmlMemberMapping>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlReflectionImporterClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6646D5B5-B944-5060-91A4-566AA86DEEC0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlReflectionImporter" />
    ///  class. </summary>
    {class} function init: DNXmlReflectionImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlReflectionImporter" />
    ///  class using the specified default XML namespace. </summary>
    ///  <param name="defaultNamespace">The default XML namespace to use for imported type mappings.</param>
    {class} function init(defaultNamespace: string): DNXmlReflectionImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlReflectionImporter" />
    ///  class using the specified XML serialization overrides. </summary>
    ///  <param name="attributeOverrides">An object that overrides how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class serializes mapped types.</param>
    {class} function init(attributeOverrides: DNXmlAttributeOverrides): DNXmlReflectionImporter; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlReflectionImporter" />
    ///  class using the specified XML serialization overrides and default XML namespace. </summary>
    ///  <param name="attributeOverrides">An object that overrides how the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class serializes mapped types.</param>
    ///  <param name="defaultNamespace">The default XML namespace to use for imported type mappings.</param>
    {class} function init(attributeOverrides: DNXmlAttributeOverrides; defaultNamespace: string): DNXmlReflectionImporter; overload;

  end;

  ///<summary>Generates mappings to XML schema element declarations, including literal XML Schema Definition (XSD) message parts in a Web Services Description Language (WSDL) document, for .NET Framework types or Web service method information. </summary>
  [DNTypeName('System.Xml.Serialization.XmlReflectionImporter')]
  DNXmlReflectionImporter = interface(DDN.mscorlib.DNObject)
  ['{D94A52A1-034A-325B-B5FF-B0B6778B6231}']
  { methods } 

    ///<summary>Includes mappings for derived types for later use when import methods are invoked. </summary>
    ///  <param name="provider">An instance of the <see cref="T:System.Reflection.ICustomAttributeProvider" />
    ///  class that contains custom attributes derived from the <see cref="T:System.Xml.Serialization.XmlIncludeAttribute" />
    ///  attribute.</param>
    procedure IncludeTypes(provider: DDN.mscorlib.DNICustomAttributeProvider);
    ///<summary>Includes mappings for a type for later use when import methods are invoked. </summary>
    ///  <param name="type">The .NET Framework type for which to save type mapping information.</param>
    procedure IncludeType(&type: DDN.mscorlib.DNType);
    ///<summary>Generates a mapping to an XML Schema element for a specified .NET Framework type. </summary>
    ///  <param name="type">The .NET Framework type for which to generate a type mapping.</param>
    ///<returns>Internal .NET Framework mapping of a type to an XML Schema element.</returns>
    function ImportTypeMapping(&type: DDN.mscorlib.DNType): DNXmlTypeMapping; overload;
    ///<summary>Generates a mapping to an XML Schema element for a .NET Framework type, using the specified type and namespace. </summary>
    ///  <param name="type">The .NET Framework type for which to generate a type mapping.</param>
    ///  <param name="defaultNamespace">The default XML namespace to use.</param>
    ///<returns>Internal .NET Framework mapping of a type to an XML Schema element.</returns>
    function ImportTypeMapping(&type: DDN.mscorlib.DNType; defaultNamespace: string): DNXmlTypeMapping; overload;
    ///<summary>Generates a mapping to an XML Schema element for a .NET Framework type, using the specified type and attribute. </summary>
    ///  <param name="type">The .NET Framework type for which to generate a type mapping.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  attribute that is applied to the type.</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  that represents a mapping of a .NET Framework type to an XML Schema element.</returns>
    function ImportTypeMapping(&type: DDN.mscorlib.DNType; root: DNXmlRootAttribute): DNXmlTypeMapping; overload;
    ///<summary>Generates a mapping to an XML Schema element for a .NET Framework type, using the specified type, attribute, and namespace. </summary>
    ///  <param name="type">The .NET Framework type for which to generate a type mapping.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  attribute that is applied to the type.</param>
    ///  <param name="defaultNamespace">The default XML namespace to use.</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  that contains the internal .NET Framework mapping of a type to an XML Schema element.</returns>
    function ImportTypeMapping(&type: DDN.mscorlib.DNType; root: DNXmlRootAttribute; defaultNamespace: string): DNXmlTypeMapping; overload;
    ///<summary>Generates internal type mappings for information from a Web service method. </summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of <see cref="T:System.Xml.Serialization.XmlReflectionMember" />
    ///  objects that contain .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  if elements that correspond to Web Services Description Language (WSDL) message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  with mappings to the element parts of a WSDL message definition.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean): DNXmlMembersMapping; overload;
    ///<summary>Returns internal type mappings using information from a Web service method, and allows you to specify an XML element name, XML namespace, and other options.</summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of <see cref="T:System.Xml.Serialization.XmlReflectionMember" />
    ///  objects that contain .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  if elements that correspond to Web Services Description Language (WSDL) message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="rpc"><see langword="true" />
    ///  if the method is a remote procedure call; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  that contains the mappings.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean; rpc: Boolean): DNXmlMembersMapping; overload;
    ///<summary>Returns internal type mappings using information from a Web service method, and allows you to specify an XML element name, XML namespace, and other options.</summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of <see cref="T:System.Xml.Serialization.XmlReflectionMember" />
    ///  objects that contain .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  if elements that correspond to Web Services Description Language (WSDL) message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="rpc"><see langword="true" />
    ///  if the method is a remote procedure call; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="openModel"><see langword="true" />
    ///  to specify that the generated schema type will be marked with the<see langword=" &lt;xs:anyAttribute&gt;" />
    ///  element; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  that contains the mappings.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean; rpc: Boolean; openModel: Boolean): DNXmlMembersMapping; overload;
    ///<summary>Generates internal type mappings for information from a Web service method.</summary>
    ///  <param name="elementName">An XML element name produced from the Web service method.</param>
    ///  <param name="ns">An XML element namespace produced from the Web service method.</param>
    ///  <param name="members">An array of <see cref="T:System.Xml.Serialization.XmlReflectionMember" />
    ///  objects that contain .NET Framework code entities that belong to a Web service method.</param>
    ///  <param name="hasWrapperElement"><see langword="true" />
    ///  if elements that correspond to Web Services Description Language (WSDL) message parts should be enclosed in an extra wrapper element in a SOAP message; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="rpc"><see langword="true" />
    ///  if the method is a remote procedure call; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="openModel"><see langword="true" />
    ///  to specify that the generated schema type will be marked with the<see langword=" &lt;xs:anyAttribute&gt;" />
    ///  element; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="access">One of the <see cref="T:System.Xml.Serialization.XmlMappingAccess" />
    ///  values. The default is <see langword="None" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  that contains the mappings.</returns>
    function ImportMembersMapping(elementName: string; ns: string; members: TArray<DNXmlReflectionMember>; hasWrapperElement: Boolean; rpc: Boolean; openModel: Boolean; access: DNXmlMappingAccess): DNXmlMembersMapping; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlReflectionImporter = class(TDNGenericImport<DNXmlReflectionImporterClass, DNXmlReflectionImporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlReflectionMemberClass = interface(DDN.mscorlib.DNObjectClass)
  ['{8728B6C5-0901-586D-8E72-B14A45774490}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlReflectionMember" />
    ///  class. </summary>
    {class} function init: DNXmlReflectionMember;

  end;

  ///<summary>Provides mappings between code entities in .NET Framework Web service methods and the content of Web Services Description Language (WSDL) messages that are defined for SOAP Web services. </summary>
  [DNTypeName('System.Xml.Serialization.XmlReflectionMember')]
  DNXmlReflectionMember = interface(DDN.mscorlib.DNObject)
  ['{601D7460-4E98-3B98-81FC-36655E98A587}']
  { getters & setters } 

    function get_MemberType: DDN.mscorlib.DNType;
    procedure set_MemberType(value: DDN.mscorlib.DNType);
    function get_XmlAttributes: DNXmlAttributes;
    procedure set_XmlAttributes(value: DNXmlAttributes);
    function get_SoapAttributes: DNSoapAttributes;
    procedure set_SoapAttributes(value: DNSoapAttributes);
    function get_MemberName: string;
    procedure set_MemberName(value: string);
    function get_IsReturnValue: Boolean;
    procedure set_IsReturnValue(value: Boolean);
    function get_OverrideIsNullable: Boolean;
    procedure set_OverrideIsNullable(value: Boolean);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the type of the Web service method member code entity that is represented by this mapping. </summary>
    ///<returns>The <see cref="T:System.Type" />
    ///  of the Web service method member code entity that is represented by this mapping.</returns>
    property MemberType: DDN.mscorlib.DNType read get_MemberType write set_MemberType;
    ///<summary>Gets or sets an <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  with the collection of <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  -related attributes that have been applied to the member code entity. </summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlAttributes" />
    ///  that represents XML attributes that have been applied to the member code.</returns>
    property XmlAttributes: DNXmlAttributes read get_XmlAttributes write set_XmlAttributes;
    ///<summary>Gets or sets a <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  with the collection of SOAP-related attributes that have been applied to the member code entity. </summary>
    ///<returns>A <see cref="T:System.Xml.Serialization.SoapAttributes" />
    ///  that contains the objects that represent SOAP attributes applied to the member.</returns>
    property SoapAttributes: DNSoapAttributes read get_SoapAttributes write set_SoapAttributes;
    ///<summary>Gets or sets the name of the Web service method member for this mapping. </summary>
    ///<returns>The name of the Web service method.</returns>
    property MemberName: string read get_MemberName write set_MemberName;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.Serialization.XmlReflectionMember" />
    ///  represents a Web service method return value, as opposed to an output parameter. </summary>
    ///<returns><see langword="true" />
    ///  , if the member represents a Web service return value; otherwise, <see langword="false" />
    ///  .</returns>
    property IsReturnValue: Boolean read get_IsReturnValue write set_IsReturnValue;
    ///<summary>Gets or sets a value that indicates that the value of the corresponding XML element definition's isNullable attribute is <see langword="false" />
    ///  .</summary>
    ///<returns><see langword="True" />
    ///  to override the <see cref="P:System.Xml.Serialization.XmlElementAttribute.IsNullable" />
    ///  property; otherwise, <see langword="false" />
    ///  .</returns>
    property OverrideIsNullable: Boolean read get_OverrideIsNullable write set_OverrideIsNullable;
  end;

  TDNXmlReflectionMember = class(TDNGenericImport<DNXmlReflectionMemberClass, DNXmlReflectionMember>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSchemaEnumeratorClass = interface(DDN.mscorlib.DNObjectClass)
  ['{D418A3CC-F8AF-5180-B026-2EEB20120977}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaEnumerator" />
    ///  class. </summary>
    ///  <param name="list">The <see cref="T:System.Xml.Serialization.XmlSchemas" />
    ///  object you want to iterate over.</param>
    {class} function init(list: DNXmlSchemas): DNXmlSchemaEnumerator;

  end;

  ///<summary>Enables iteration over a collection of <see cref="T:System.Xml.Schema.XmlSchema" />
  ///  objects. </summary>
  [DNTypeName('System.Xml.Serialization.XmlSchemaEnumerator')]
  DNXmlSchemaEnumerator = interface(DDN.mscorlib.DNObject)
  ['{FA59412D-209D-3972-B5AC-C213B9814A82}']
  { getters & setters } 

    function get_Current: DNXmlSchema;

  { methods } 

    ///<summary>Releases all resources used by the <see cref="T:System.Xml.Serialization.XmlSchemaEnumerator" />
    ///  .</summary>
    procedure Dispose;
    ///<summary>Advances the enumerator to the next item in the collection.</summary>
    ///<returns><see langword="true" />
    ///  if the move is successful; otherwise, <see langword="false" />
    ///  .</returns>
    function MoveNext: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the current element in the collection.</summary>
    ///<returns>The current <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object in the collection.</returns>
    property Current: DNXmlSchema read get_Current;
  end;

  TDNXmlSchemaEnumerator = class(TDNGenericImport<DNXmlSchemaEnumeratorClass, DNXmlSchemaEnumerator>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSchemaExporterClass = interface(DDN.mscorlib.DNObjectClass)
  ['{38494AC2-69F7-51D5-B570-804573527920}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSchemaExporter" />
    ///  class. </summary>
    ///  <param name="schemas">A collection of <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  objects to which element declarations obtained from type mappings are added.</param>
    {class} function init(schemas: DNXmlSchemas): DNXmlSchemaExporter;

  end;

  ///<summary>Populates <see cref="T:System.Xml.Schema.XmlSchema" />
  ///  objects with XML schema element declarations that are found in type mapping objects. </summary>
  [DNTypeName('System.Xml.Serialization.XmlSchemaExporter')]
  DNXmlSchemaExporter = interface(DDN.mscorlib.DNObject)
  ['{C1FFC767-8FA6-3E14-BBC0-705E6C078AC2}']
  { methods } 

    ///<summary>Adds an element declaration for a .NET Framework type to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object. </summary>
    ///  <param name="xmlTypeMapping">The internal mapping between a .NET Framework type and an XML schema element.</param>
    procedure ExportTypeMapping(xmlTypeMapping: DNXmlTypeMapping); overload;
    ///<summary>Adds an element declaration to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object for a single element part of a literal SOAP message definition.</summary>
    ///  <param name="xmlMembersMapping">Internal .NET Framework type mappings for the element parts of a Web Services Description Language (WSDL) message definition.</param>
    ///<returns>An <see cref="T:System.Xml.XmlQualifiedName" />
    ///  that represents the qualified XML name of the exported element declaration.</returns>
    function ExportTypeMapping(xmlMembersMapping: DNXmlMembersMapping): DNXmlQualifiedName; overload;
    ///<summary>Adds an element declaration to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  for each of the element parts of a literal SOAP message definition. </summary>
    ///  <param name="xmlMembersMapping">The internal .NET Framework type mappings for the element parts of a Web Services Description Language (WSDL) message definition.</param>
    procedure ExportMembersMapping(xmlMembersMapping: DNXmlMembersMapping); overload;
    ///<summary>Adds an element declaration to the applicable <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  for each of the element parts of a literal SOAP message definition, and specifies whether enclosing elements are included.</summary>
    ///  <param name="xmlMembersMapping">The internal mapping between a .NET Framework type and an XML schema element.</param>
    ///  <param name="exportEnclosingType"><see langword="true" />
    ///  if the schema elements that enclose the schema are to be included; otherwise, <see langword="false" />
    ///  .</param>
    procedure ExportMembersMapping(xmlMembersMapping: DNXmlMembersMapping; exportEnclosingType: Boolean); overload;
    ///<summary>Exports an &lt;any&gt; element to the <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object that is identified by the specified namespace.</summary>
    ///  <param name="ns">The namespace of the XML schema document to which to add an &lt;any&gt; element.</param>
    ///<returns>An arbitrary name assigned to the &lt;any&gt; element declaration.</returns>
    function ExportAnyType(ns: string): string; overload;
    ///<summary>Adds an element declaration for an object or type to a SOAP message or to an <see cref="T:System.Xml.Schema.XmlSchema" />
    ///  object.</summary>
    ///  <param name="members">An <see cref="T:System.Xml.Serialization.XmlMembersMapping" />
    ///  that contains mappings to export.</param>
    ///<returns>The string "any" with an appended integer. </returns>
    function ExportAnyType(members: DNXmlMembersMapping): string; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlSchemaExporter = class(TDNGenericImport<DNXmlSchemaExporterClass, DNXmlSchemaExporter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializationGeneratedCodeClass = interface(DDN.mscorlib.DNObjectClass)
  ['{DC76D1D9-DB22-5575-BFBB-C28D81A28A5D}']
  end;

  ///<summary>An abstract class that is the base class for <see cref="T:System.Xml.Serialization.XmlSerializationReader" />
  ///  and <see cref="T:System.Xml.Serialization.XmlSerializationWriter" />
  ///  and that contains methods common to both of these types.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializationGeneratedCode')]
  DNXmlSerializationGeneratedCode = interface(DDN.mscorlib.DNObject)
  ['{B8663396-B740-365E-8443-9B06F3FCB665}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlSerializationGeneratedCode = class(TDNGenericImport<DNXmlSerializationGeneratedCodeClass, DNXmlSerializationGeneratedCode>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializationReaderClass = interface(DNXmlSerializationGeneratedCodeClass)
  ['{1A9F3E1B-7E94-549D-893A-DDF9D6E7112A}']
  end;

  ///<summary>Controls deserialization by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  class. </summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializationReader')]
  DNXmlSerializationReader = interface(DNXmlSerializationGeneratedCode)
  ['{2793BAB3-2B3F-3703-AE19-2E0377C2123A}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlSerializationReader = class(TDNGenericImport<DNXmlSerializationReaderClass, DNXmlSerializationReader>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializationWriterClass = interface(DNXmlSerializationGeneratedCodeClass)
  ['{439D2195-1061-514B-9ABC-AEFAB77FB890}']
  end;

  ///<summary>Represents an abstract class used for controlling serialization by the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  class.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializationWriter')]
  DNXmlSerializationWriter = interface(DNXmlSerializationGeneratedCode)
  ['{582828C1-EC93-3AE4-9465-3D06C109DD33}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlSerializationWriter = class(TDNGenericImport<DNXmlSerializationWriterClass, DNXmlSerializationWriter>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializerClass = interface(DDN.mscorlib.DNObjectClass)
  ['{9F4A9DB4-304F-51CA-A18A-BE77F9D1321F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of type <see cref="T:System.Object" />
    ///  into XML document instances, and deserialize XML document instances into objects of type <see cref="T:System.Object" />
    ///  . Each object to be serialized can itself contain instances of classes, which this overload overrides with other classes. This overload also specifies the default namespace for all the XML elements and the class to use as the XML root element.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize. </param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that extends or overrides the behavior of the class specified in the <paramref name="type" />
    ///  parameter. </param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize. </param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that defines the XML root element properties. </param>
    ///  <param name="defaultNamespace">The default namespace of all XML elements in the XML document. </param>
    {class} function init(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides; extraTypes: TArray<DDN.mscorlib.DNType>; root: DNXmlRootAttribute; defaultNamespace: string): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and deserialize an XML document into object of the specified type. It also specifies the class to use as the XML root element.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize. </param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that represents the XML root element. </param>
    {class} function init(&type: DDN.mscorlib.DNType; root: DNXmlRootAttribute): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and deserialize XML documents into object of a specified type. If a property or field returns an array, the <paramref name="extraTypes" />
    ///  parameter specifies objects that can be inserted into the array.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize. </param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize. </param>
    {class} function init(&type: DDN.mscorlib.DNType; extraTypes: TArray<DDN.mscorlib.DNType>): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and deserialize XML documents into objects of the specified type. Each object to be serialized can itself contain instances of classes, which this overload can override with other classes.</summary>
    ///  <param name="type">The type of the object to serialize. </param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  . </param>
    {class} function init(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides): DNXmlSerializer; overload;
    ///<summary>Initializes an instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class using an object that maps one type to another.</summary>
    ///  <param name="xmlTypeMapping">An <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  that maps one type to another. </param>
    {class} function init(xmlTypeMapping: DNXmlTypeMapping): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and deserialize XML documents into objects of the specified type.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize. </param>
    {class} function init(&type: DDN.mscorlib.DNType): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and deserialize XML documents into objects of the specified type. Specifies the default namespace for all the XML elements.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize. </param>
    ///  <param name="defaultNamespace">The default namespace to use for all the XML elements. </param>
    {class} function init(&type: DDN.mscorlib.DNType; defaultNamespace: string): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of type <see cref="T:System.Object" />
    ///  into XML document instances, and deserialize XML document instances into objects of type <see cref="T:System.Object" />
    ///  . Each object to be serialized can itself contain instances of classes, which this overload overrides with other classes. This overload also specifies the default namespace for all the XML elements and the class to use as the XML root element.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize.</param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that extends or overrides the behavior of the class specified in the <paramref name="type" />
    ///  parameter.</param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that defines the XML root element properties.</param>
    ///  <param name="defaultNamespace">The default namespace of all XML elements in the XML document.</param>
    ///  <param name="location">The location of the types.</param>
    {class} function init(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides; extraTypes: TArray<DDN.mscorlib.DNType>; root: DNXmlRootAttribute; defaultNamespace: string; location: string): DNXmlSerializer; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML document instances, and deserialize XML document instances into objects of the specified type. This overload allows you to supply other types that can be encountered during a serialization or deserialization operation, as well as a default namespace for all XML elements, the class to use as the XML root element, its location, and credentials required for access.</summary>
    ///  <param name="type">The type of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize.</param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that extends or overrides the behavior of the class specified in the <paramref name="type" />
    ///  parameter.</param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that defines the XML root element properties.</param>
    ///  <param name="defaultNamespace">The default namespace of all XML elements in the XML document.</param>
    ///  <param name="location">The location of the types.</param>
    ///  <param name="evidence">An instance of the <see cref="T:System.Security.Policy.Evidence" />
    ///  class that contains credentials required to access types.</param>
    {class} function init(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides; extraTypes: TArray<DDN.mscorlib.DNType>; root: DNXmlRootAttribute; defaultNamespace: string; location: string; evidence: DDN.mscorlib.DNEvidence): DNXmlSerializer; overload;

  { static methods } 

    ///<summary>Returns an array of <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  objects created from an array of <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  objects.</summary>
    ///  <param name="mappings">An array of <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  that maps one type to another. </param>
    ///<returns>An array of <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  objects.</returns>
    {class} function FromMappings(mappings: TArray<DNXmlMapping>): TArray<DNXmlSerializer>; overload;
    ///<summary>Returns an assembly that contains custom-made serializers used to serialize or deserialize the specified type or types, using the specified mappings.</summary>
    ///  <param name="types">A collection of types.</param>
    ///  <param name="mappings">A collection of <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects used to convert one type to another.</param>
    ///<returns>An <see cref="T:System.Reflection.Assembly" />
    ///  object that contains serializers for the supplied types and mappings.</returns>
    {class} function GenerateSerializer(types: TArray<DDN.mscorlib.DNType>; mappings: TArray<DNXmlMapping>): DDN.mscorlib.DNAssembly; overload;
    ///<summary>Returns the name of the assembly that contains one or more versions of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  especially created to serialize or deserialize the specified type.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  you are deserializing.</param>
    ///<returns>The name of the assembly that contains an <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  for the type.</returns>
    {class} function GetXmlSerializerAssemblyName(&type: DDN.mscorlib.DNType): string; overload;
    ///<summary>Returns the name of the assembly that contains the serializer for the specified type in the specified namespace.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  you are interested in.</param>
    ///  <param name="defaultNamespace">The namespace of the type.</param>
    ///<returns>The name of the assembly that contains specially built serializers.</returns>
    {class} function GetXmlSerializerAssemblyName(&type: DDN.mscorlib.DNType; defaultNamespace: string): string; overload;
    ///<summary>Returns an instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class from the specified mappings.</summary>
    ///  <param name="mappings">An array of <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects.</param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the deserialized object.</param>
    ///<returns>An instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class.</returns>
    {class} function FromMappings(mappings: TArray<DNXmlMapping>; &type: DDN.mscorlib.DNType): TArray<DNXmlSerializer>; overload;
    ///<summary>Returns an instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class created from mappings of one XML type to another.</summary>
    ///  <param name="mappings">An array of <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  objects used to map one type to another.</param>
    ///  <param name="evidence">An instance of the <see cref="T:System.Security.Policy.Evidence" />
    ///  class that contains host and assembly data presented to the common language runtime policy system.</param>
    ///<returns>An instance of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class.</returns>
    {class} function FromMappings(mappings: TArray<DNXmlMapping>; evidence: DDN.mscorlib.DNEvidence): TArray<DNXmlSerializer>; overload;
    ///<summary>Returns an assembly that contains custom-made serializers used to serialize or deserialize the specified type or types, using the specified mappings and compiler settings and options. </summary>
    ///  <param name="types">An array of type <see cref="T:System.Type" />
    ///  that contains objects used to serialize and deserialize data.</param>
    ///  <param name="mappings">An array of type <see cref="T:System.Xml.Serialization.XmlMapping" />
    ///  that maps the XML data to the type data.</param>
    ///  <param name="parameters">An instance of the <see cref="T:System.CodeDom.Compiler.CompilerParameters" />
    ///  class that represents the parameters used to invoke a compiler.</param>
    ///<returns>An <see cref="T:System.Reflection.Assembly" />
    ///  that contains special versions of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    {class} function GenerateSerializer(types: TArray<DDN.mscorlib.DNType>; mappings: TArray<DNXmlMapping>; parameters: DDN.System.DNCompilerParameters): DDN.mscorlib.DNAssembly; overload;
    ///<summary>Returns an array of <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  objects created from an array of types.</summary>
    ///  <param name="types">An array of <see cref="T:System.Type" />
    ///  objects. </param>
    ///<returns>An array of <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  objects.</returns>
    {class} function FromTypes(types: TArray<DDN.mscorlib.DNType>): TArray<DNXmlSerializer>;

  end;

  ///<summary>Serializes and deserializes objects into and from XML documents. The <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  enables you to control how objects are encoded into XML.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializer')]
  DNXmlSerializer = interface(DDN.mscorlib.DNObject)
  ['{EBD11B66-2F03-34DA-85F9-E3E1E9B67175}']
  { events } 

    procedure add_UnknownNode(value: DNXmlNodeEventHandler);
    procedure remove_UnknownNode(value: DNXmlNodeEventHandler);
    procedure add_UnknownAttribute(value: DNXmlAttributeEventHandler);
    procedure remove_UnknownAttribute(value: DNXmlAttributeEventHandler);
    procedure add_UnknownElement(value: DNXmlElementEventHandler);
    procedure remove_UnknownElement(value: DNXmlElementEventHandler);
    procedure add_UnreferencedObject(value: DNUnreferencedObjectEventHandler);
    procedure remove_UnreferencedObject(value: DNUnreferencedObjectEventHandler);

  { methods } 

    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="textWriter">The <see cref="T:System.IO.TextWriter" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The <see cref="T:System.Object" />
    ///  to serialize. </param>
    procedure Serialize(textWriter: DDN.mscorlib.DNTextWriter; o: DDN.mscorlib.DNObject); overload;
    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.IO.TextWriter" />
    ///  and references the specified namespaces.</summary>
    ///  <param name="textWriter">The <see cref="T:System.IO.TextWriter" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The <see cref="T:System.Object" />
    ///  to serialize. </param>
    ///  <param name="namespaces">The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  that contains namespaces for the generated XML document. </param>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during serialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    procedure Serialize(textWriter: DDN.mscorlib.DNTextWriter; o: DDN.mscorlib.DNObject; namespaces: DNXmlSerializerNamespaces); overload;
    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="stream">The <see cref="T:System.IO.Stream" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The <see cref="T:System.Object" />
    ///  to serialize. </param>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during serialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    procedure Serialize(stream: DDN.mscorlib.DNStream; o: DDN.mscorlib.DNObject); overload;
    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.IO.Stream" />
    ///  that references the specified namespaces.</summary>
    ///  <param name="stream">The <see cref="T:System.IO.Stream" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The <see cref="T:System.Object" />
    ///  to serialize. </param>
    ///  <param name="namespaces">The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  referenced by the object. </param>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during serialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    procedure Serialize(stream: DDN.mscorlib.DNStream; o: DDN.mscorlib.DNObject; namespaces: DNXmlSerializerNamespaces); overload;
    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="xmlWriter">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The <see cref="T:System.Object" />
    ///  to serialize. </param>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during serialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    procedure Serialize(xmlWriter: DNXmlWriter; o: DDN.mscorlib.DNObject); overload;
    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  and references the specified namespaces.</summary>
    ///  <param name="xmlWriter">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The <see cref="T:System.Object" />
    ///  to serialize. </param>
    ///  <param name="namespaces">The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  referenced by the object. </param>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during serialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    procedure Serialize(xmlWriter: DNXmlWriter; o: DDN.mscorlib.DNObject; namespaces: DNXmlSerializerNamespaces); overload;
    ///<summary>Serializes the specified object and writes the XML document to a file using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  and references the specified namespaces and encoding style.</summary>
    ///  <param name="xmlWriter">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the XML document. </param>
    ///  <param name="o">The object to serialize. </param>
    ///  <param name="namespaces">The <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  referenced by the object. </param>
    ///  <param name="encodingStyle">The encoding style of the serialized XML. </param>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during serialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    procedure Serialize(xmlWriter: DNXmlWriter; o: DDN.mscorlib.DNObject; namespaces: DNXmlSerializerNamespaces; encodingStyle: string); overload;
    ///<summary>Deserializes the XML document contained by the specified <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="stream">The <see cref="T:System.IO.Stream" />
    ///  that contains the XML document to deserialize. </param>
    ///<returns>The <see cref="T:System.Object" />
    ///  being deserialized.</returns>
    function Deserialize(stream: DDN.mscorlib.DNStream): DDN.mscorlib.DNObject; overload;
    ///<summary>Deserializes the XML document contained by the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="textReader">The <see cref="T:System.IO.TextReader" />
    ///  that contains the XML document to deserialize. </param>
    ///<returns>The <see cref="T:System.Object" />
    ///  being deserialized.</returns>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during deserialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    function Deserialize(textReader: DDN.mscorlib.DNTextReader): DDN.mscorlib.DNObject; overload;
    ///<summary>Deserializes the XML document contained by the specified <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="xmlReader">The <see cref="T:System.Xml.XmlReader" />
    ///  that contains the XML document to deserialize. </param>
    ///<returns>The <see cref="T:System.Object" />
    ///  being deserialized.</returns>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during deserialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    function Deserialize(xmlReader: DNXmlReader): DDN.mscorlib.DNObject; overload;
    ///<summary>Deserializes an XML document contained by the specified <see cref="T:System.Xml.XmlReader" />
    ///  and allows the overriding of events that occur during deserialization.</summary>
    ///  <param name="xmlReader">The <see cref="T:System.Xml.XmlReader" />
    ///  that contains the document to deserialize.</param>
    ///  <param name="events">An instance of the <see cref="T:System.Xml.Serialization.XmlDeserializationEvents" />
    ///  class. </param>
    ///<returns>The <see cref="T:System.Object" />
    ///  being deserialized.</returns>
    function Deserialize(xmlReader: DNXmlReader; events: DNXmlDeserializationEvents): DDN.mscorlib.DNObject; overload;
    ///<summary>Deserializes the XML document contained by the specified <see cref="T:System.Xml.XmlReader" />
    ///  and encoding style.</summary>
    ///  <param name="xmlReader">The <see cref="T:System.Xml.XmlReader" />
    ///  that contains the XML document to deserialize. </param>
    ///  <param name="encodingStyle">The encoding style of the serialized XML. </param>
    ///<returns>The deserialized object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An error occurred during deserialization. The original exception is available using the <see cref="P:System.Exception.InnerException" />
    ///  property. </exception>
    function Deserialize(xmlReader: DNXmlReader; encodingStyle: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Gets a value that indicates whether this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can deserialize a specified XML document.</summary>
    ///  <param name="xmlReader">An <see cref="T:System.Xml.XmlReader" />
    ///  that points to the document to deserialize. </param>
    ///<returns><see langword="true" />
    ///  if this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can deserialize the object that the <see cref="T:System.Xml.XmlReader" />
    ///  points to; otherwise, <see langword="false" />
    ///  .</returns>
    function CanDeserialize(xmlReader: DNXmlReader): Boolean;
    ///<summary>Serializes the specified <see cref="T:System.Object" />
    ///  and writes the XML document to a file using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  , XML namespaces, and encoding. </summary>
    ///  <param name="xmlWriter">The <see cref="T:System.Xml.XmlWriter" />
    ///  used to write the XML document.</param>
    ///  <param name="o">The object to serialize.</param>
    ///  <param name="namespaces">An instance of the <see langword="XmlSerializaerNamespaces" />
    ///  that contains namespaces and prefixes to use.</param>
    ///  <param name="encodingStyle">The encoding used in the document.</param>
    ///  <param name="id">For SOAP encoded messages, the base used to generate id attributes. </param>
    procedure Serialize(xmlWriter: DNXmlWriter; o: DDN.mscorlib.DNObject; namespaces: DNXmlSerializerNamespaces; encodingStyle: string; id: string); overload;
    ///<summary>Deserializes the object using the data contained by the specified <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="xmlReader">An instance of the <see cref="T:System.Xml.XmlReader" />
    ///  class used to read the document.</param>
    ///  <param name="encodingStyle">The encoding used.</param>
    ///  <param name="events">An instance of the <see cref="T:System.Xml.Serialization.XmlDeserializationEvents" />
    ///  class. </param>
    ///<returns>The object being deserialized.</returns>
    function Deserialize(xmlReader: DNXmlReader; encodingStyle: string; events: DNXmlDeserializationEvents): DDN.mscorlib.DNObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlSerializer = class(TDNGenericImport<DNXmlSerializerClass, DNXmlSerializer>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializerFactoryClass = interface(DDN.mscorlib.DNObjectClass)
  ['{3AD3F7C9-18B9-569F-B723-8717A92228A3}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerFactory" />
    ///  class. </summary>
    {class} function init: DNXmlSerializerFactory;

  end;

  ///<summary>Creates typed versions of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  for more efficient serialization.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializerFactory')]
  DNXmlSerializerFactory = interface(DDN.mscorlib.DNObject)
  ['{D07FA41E-7200-3A84-BBAF-DEB64D2BD7BF}']
  { methods } 

    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML document instances, and vice versa. Each object to be serialized can itself contain instances of classes, which this overload can override with other classes. This overload also specifies the default namespace for all the XML elements, and the class to use as the XML root element.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to serialize.</param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that contains fields that override the default serialization behavior.</param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that represents the XML root element.</param>
    ///  <param name="defaultNamespace">The default namespace of all XML elements in the XML document. </param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides; extraTypes: TArray<DDN.mscorlib.DNType>; root: DNXmlRootAttribute; defaultNamespace: string): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializerFactory" />
    ///  class that is used to serialize the specified type. If a property or field returns an array, the <paramref name="extraTypes" />
    ///  parameter specifies objects that can be inserted into the array.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to serialize.</param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; extraTypes: TArray<DDN.mscorlib.DNType>): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializerFactory" />
    ///  class using an object that maps one type to another.</summary>
    ///  <param name="xmlTypeMapping">An <see cref="T:System.Xml.Serialization.XmlTypeMapping" />
    ///  that maps one type to another.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that is specifically created to serialize the mapped type.</returns>
    function CreateSerializer(xmlTypeMapping: DNXmlTypeMapping): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializerFactory" />
    ///  class that is used to serialize the specified type.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to serialize.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that is specifically created to serialize the specified type.</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializerFactory" />
    ///  class that is used to serialize the specified type and namespace.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to serialize.</param>
    ///  <param name="defaultNamespace">The default namespace to use for all the XML elements. </param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that is specifically created to serialize the specified type.</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; defaultNamespace: string): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML document instances, and vice versa. Each object to be serialized can itself contain instances of classes, which this overload can override with other classes. This overload also specifies the default namespace for all the XML elements, and the class to use as the XML root element.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize.</param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that extends or overrides the behavior of the class specified in the type parameter.</param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that defines the XML root element properties.</param>
    ///  <param name="defaultNamespace">The default namespace of all XML elements in the XML document.</param>
    ///  <param name="location">The path that specifies the location of the types.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .
    ///</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides; extraTypes: TArray<DDN.mscorlib.DNType>; root: DNXmlRootAttribute; defaultNamespace: string; location: string): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML document instances, and vice versa. Each object to be serialized can itself contain instances of classes, which this overload can override with other classes. This overload also specifies the default namespace for all the XML elements, and the class to use as the XML root element.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  of the object that this <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  can serialize.</param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that extends or overrides the behavior of the class specified in the type parameter.</param>
    ///  <param name="extraTypes">A <see cref="T:System.Type" />
    ///  array of additional object types to serialize.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that defines the XML root element properties.</param>
    ///  <param name="defaultNamespace">The default namespace of all XML elements in the XML document.</param>
    ///  <param name="location">The path that specifies the location of the types.</param>
    ///  <param name="evidence">An instance of the <see cref="T:System.Security.Policy.Evidence" />
    ///  class that contains credentials needed to access types.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides; extraTypes: TArray<DDN.mscorlib.DNType>; root: DNXmlRootAttribute; defaultNamespace: string; location: string; evidence: DDN.mscorlib.DNEvidence): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and vice versa. Specifies the object that represents the XML root element.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to serialize.</param>
    ///  <param name="root">An <see cref="T:System.Xml.Serialization.XmlRootAttribute" />
    ///  that represents the XML root element.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; root: DNXmlRootAttribute): DNXmlSerializer; overload;
    ///<summary>Returns a derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class that can serialize objects of the specified type into XML documents, and vice versa. Each object to be serialized can itself contain instances of classes, which this overload can override with other classes.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to serialize.</param>
    ///  <param name="overrides">An <see cref="T:System.Xml.Serialization.XmlAttributeOverrides" />
    ///  that contains fields that override the default serialization behavior.</param>
    ///<returns>A derivation of the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  .</returns>
    function CreateSerializer(&type: DDN.mscorlib.DNType; overrides: DNXmlAttributeOverrides): DNXmlSerializer; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlSerializerFactory = class(TDNGenericImport<DNXmlSerializerFactoryClass, DNXmlSerializerFactory>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializerImplementationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{AB600CF3-BA29-5EF2-B169-14E47174AFB6}']
  end;

  ///<summary>Defines the reader, writer, and methods for pre-generated, typed serializers.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializerImplementation')]
  DNXmlSerializerImplementation = interface(DDN.mscorlib.DNObject)
  ['{AFB9069E-5170-39EA-9FD6-7DA3B4F519AA}']
  { getters & setters } 

    function get_Reader: DNXmlSerializationReader;
    function get_Writer: DNXmlSerializationWriter;
    function get_ReadMethods: DDN.mscorlib.DNHashtable;
    function get_WriteMethods: DDN.mscorlib.DNHashtable;
    function get_TypedSerializers: DDN.mscorlib.DNHashtable;

  { methods } 

    ///<summary>Gets a value that determines whether a type can be serialized.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to be serialized.</param>
    ///<returns><see langword="true" />
    ///  if the type can be serialized; otherwise, <see langword="false" />
    ///  .</returns>
    function CanSerialize(&type: DDN.mscorlib.DNType): Boolean;
    ///<summary>Returns a serializer for the specified type.</summary>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to be serialized.</param>
    ///<returns>An instance of a type derived from the <see cref="T:System.Xml.Serialization.XmlSerializer" />
    ///  class. </returns>
    function GetSerializer(&type: DDN.mscorlib.DNType): DNXmlSerializer;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the XML reader object that is used by the serializer.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlSerializationReader" />
    ///  that is used to read an XML document or data stream.</returns>
    property Reader: DNXmlSerializationReader read get_Reader;
    ///<summary>Gets the XML writer object for the serializer.</summary>
    ///<returns>An <see cref="T:System.Xml.Serialization.XmlSerializationWriter" />
    ///  that is used to write to an XML data stream or document.</returns>
    property Writer: DNXmlSerializationWriter read get_Writer;
    ///<summary>Gets the collection of methods that is used to read a data stream.</summary>
    ///<returns>A <see cref="T:System.Collections.Hashtable" />
    ///  that contains the methods.</returns>
    property ReadMethods: DDN.mscorlib.DNHashtable read get_ReadMethods;
    ///<summary>Get the collection of methods that is used to write to a data stream.</summary>
    ///<returns>A <see cref="T:System.Collections.Hashtable" />
    ///  that contains the methods.</returns>
    property WriteMethods: DDN.mscorlib.DNHashtable read get_WriteMethods;
    ///<summary>Gets the collection of typed serializers that is found in the assembly.</summary>
    ///<returns>A <see cref="T:System.Collections.Hashtable" />
    ///  that contains the typed serializers.</returns>
    property TypedSerializers: DDN.mscorlib.DNHashtable read get_TypedSerializers;
  end;

  TDNXmlSerializerImplementation = class(TDNGenericImport<DNXmlSerializerImplementationClass, DNXmlSerializerImplementation>) end;

  //-------------namespace: System.Xml.Serialization----------------
  DNXmlSerializerNamespacesClass = interface(DDN.mscorlib.DNObjectClass)
  ['{02202380-E072-5AFC-8069-9984588C88B4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  class.</summary>
    {class} function init: DNXmlSerializerNamespaces; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  class, using the specified instance of <see langword="XmlSerializerNamespaces" />
    ///  containing the collection of prefix and namespace pairs.</summary>
    ///  <param name="namespaces">An instance of the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  containing the namespace and prefix pairs. </param>
    {class} function init(namespaces: DNXmlSerializerNamespaces): DNXmlSerializerNamespaces; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  class.</summary>
    ///  <param name="namespaces">An array of <see cref="T:System.Xml.XmlQualifiedName" />
    ///  objects. </param>
    {class} function init(namespaces: TArray<DNXmlQualifiedName>): DNXmlSerializerNamespaces; overload;

  end;

  ///<summary>Contains the XML namespaces and prefixes that the <see cref="T:System.Xml.Serialization.XmlSerializer" />
  ///  uses to generate qualified names in an XML-document instance.</summary>
  [DNTypeName('System.Xml.Serialization.XmlSerializerNamespaces')]
  DNXmlSerializerNamespaces = interface(DDN.mscorlib.DNObject)
  ['{9BD7B184-9480-3EF7-B0D2-DC3B5BB21447}']
  { getters & setters } 

    function get_Count: Int32;

  { methods } 

    ///<summary>Adds a prefix and namespace pair to an <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  object.</summary>
    ///  <param name="prefix">The prefix associated with an XML namespace. </param>
    ///  <param name="ns">An XML namespace. </param>
    procedure Add(prefix: string; ns: string);
    ///<summary>Gets the array of prefix and namespace pairs in an <see cref="T:System.Xml.Serialization.XmlSerializerNamespaces" />
    ///  object.</summary>
    ///<returns>An array of <see cref="T:System.Xml.XmlQualifiedName" />
    ///  objects that are used as qualified names in an XML document.</returns>
    function ToArray: TArray<DNXmlQualifiedName>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of prefix and namespace pairs in the collection.</summary>
    ///<returns>The number of prefix and namespace pairs in the collection.</returns>
    property Count: Int32 read get_Count;
  end;

  TDNXmlSerializerNamespaces = class(TDNGenericImport<DNXmlSerializerNamespacesClass, DNXmlSerializerNamespaces>) end;

  //-------------namespace: System.Xml----------------
  DNXmlConvertClass = interface(DDN.mscorlib.DNObjectClass)
  ['{1D7987C8-2E38-54B3-B6C4-5F0A9579B7A4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlConvert" />
    ///  class. </summary>
    {class} function init: DNXmlConvert;

  { static methods } 

    ///<summary>Converts the name to a valid XML name.</summary>
    ///  <param name="name">A name to be translated. </param>
    ///<returns>Returns the name with any invalid characters replaced by an escape string.</returns>
    {class} function EncodeName(name: string): string;
    ///<summary>Verifies the name is valid according to the XML specification.</summary>
    ///  <param name="name">The name to be encoded. </param>
    ///<returns>The encoded name.</returns>
    {class} function EncodeNmToken(name: string): string;
    ///<summary>Converts the name to a valid XML local name.</summary>
    ///  <param name="name">The name to be encoded. </param>
    ///<returns>The encoded name.</returns>
    {class} function EncodeLocalName(name: string): string;
    ///<summary>Verifies that the name is a valid name according to the W3C Extended Markup Language recommendation.</summary>
    ///  <param name="name">The name to verify. </param>
    ///<returns>The name, if it is a valid XML name.</returns>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="name" />
    ///  is not a valid XML name. </exception><exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  or String.Empty. </exception>
    {class} function VerifyName(name: string): string;
    ///<summary>Verifies that the name is a valid <see langword="NCName" />
    ///  according to the W3C Extended Markup Language recommendation. An <see langword="NCName" />
    ///  is a name that cannot contain a colon.</summary>
    ///  <param name="name">The name to verify. </param>
    ///<returns>The name, if it is a valid NCName.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  or String.Empty. </exception><exception cref="T:System.Xml.XmlException"><paramref name="name" />
    ///  is not a valid non-colon name. </exception>
    {class} function VerifyNCName(name: string): string;
    ///<summary>Verifies that the string is a valid NMTOKEN according to the W3C XML Schema Part2: Datatypes recommendation</summary>
    ///  <param name="name">The string you wish to verify.</param>
    ///<returns>The name token, if it is a valid NMTOKEN.</returns>
    ///<exception cref="T:System.Xml.XmlException">The string is not a valid name token.</exception><exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception>
    {class} function VerifyNMTOKEN(name: string): string;
    ///<summary>Returns the passed-in string if all the characters and surrogate pair characters in the string argument are valid XML characters, otherwise an <see langword="XmlException" />
    ///  is thrown with information on the first invalid character encountered. </summary>
    ///  <param name="content"><see cref="T:System.String" />
    ///  that contains characters to verify.</param>
    ///<returns>Returns the passed-in string if all the characters and surrogate-pair characters in the string argument are valid XML characters, otherwise an <see langword="XmlException" />
    ///  is thrown with information on the first invalid character encountered.</returns>
    {class} function VerifyXmlChars(content: string): string;
    ///<summary>Returns the passed in string instance if all the characters in the string argument are valid public id characters.</summary>
    ///  <param name="publicId"><see cref="T:System.String" />
    ///  that contains the id to validate.</param>
    ///<returns>Returns the passed-in string if all the characters in the argument are valid public id characters.</returns>
    {class} function VerifyPublicId(publicId: string): string;
    ///<summary>Returns the passed-in string instance if all the characters in the string argument are valid whitespace characters. </summary>
    ///  <param name="content"><see cref="T:System.String" />
    ///  to verify.</param>
    ///<returns>Returns the passed-in string instance if all the characters in the string argument are valid whitespace characters, otherwise <see langword="null" />
    ///  .</returns>
    {class} function VerifyWhitespace(content: string): string;
    ///<summary>Checks if the passed-in character is a valid Start Name Character type.</summary>
    ///  <param name="ch">The character to validate.</param>
    ///<returns><see langword="true" />
    ///  if the character is a valid Start Name Character type; otherwise, <see langword="false" />
    ///  . </returns>
    {class} function IsStartNCNameChar(ch: Char): Boolean;
    ///<summary>Checks whether the passed-in character is a valid non-colon character type.</summary>
    ///  <param name="ch">The character to verify as a non-colon character.</param>
    ///<returns>Returns <see langword="true" />
    ///  if the character is a valid non-colon character type; otherwise, <see langword="false" />
    ///  .</returns>
    {class} function IsNCNameChar(ch: Char): Boolean;
    ///<summary>Checks if the passed-in character is a valid XML character.</summary>
    ///  <param name="ch">The character to validate.</param>
    ///<returns><see langword="true" />
    ///  if the passed in character is a valid XML character; otherwise <see langword="false" />
    ///  .</returns>
    {class} function IsXmlChar(ch: Char): Boolean;
    ///<summary>Checks if the passed-in surrogate pair of characters is a valid XML character.</summary>
    ///  <param name="lowChar">The surrogate character to validate.</param>
    ///  <param name="highChar">The surrogate character to validate.</param>
    ///<returns><see langword="true" />
    ///  if the passed in surrogate pair of characters is a valid XML character; otherwise <see langword="false" />
    ///  .</returns>
    {class} function IsXmlSurrogatePair(lowChar: Char; highChar: Char): Boolean;
    ///<summary>Checks if the passed-in character is a valid XML whitespace character.</summary>
    ///  <param name="ch">The character to validate.</param>
    ///<returns><see langword="true" />
    ///  if the passed in character is a valid XML whitespace character; otherwise <see langword="false" />
    ///  .</returns>
    {class} function IsWhitespaceChar(ch: Char): Boolean;
    ///<summary>Converts the <see cref="T:System.Char" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Char" />
    ///  .</returns>
    {class} function ToString(value: Char): string; overload;
    ///<summary>Converts the <see cref="T:System.Decimal" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Decimal" />
    ///  .</returns>
    {class} function ToString(value: DDN.mscorlib.DNDecimal): string; overload;
    ///<summary>Converts the <see cref="T:System.SByte" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="SByte" />
    ///  .</returns>
    {class} function ToString(value: SByte): string; overload;
    ///<summary>Converts the <see cref="T:System.Int16" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Int16" />
    ///  .</returns>
    {class} function ToString(value: Int16): string; overload;
    ///<summary>Converts the <see cref="T:System.Int32" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Int32" />
    ///  .</returns>
    {class} function ToString(value: Int32): string; overload;
    ///<summary>Converts the <see cref="T:System.Int64" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Int64" />
    ///  .</returns>
    {class} function ToString(value: Int64): string; overload;
    ///<summary>Converts the <see cref="T:System.Byte" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Byte" />
    ///  .</returns>
    {class} function ToString(value: Byte): string; overload;
    ///<summary>Converts the <see cref="T:System.UInt16" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="UInt16" />
    ///  .</returns>
    {class} function ToString(value: UInt16): string; overload;
    ///<summary>Converts the <see cref="T:System.UInt32" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="UInt32" />
    ///  .</returns>
    {class} function ToString(value: UInt32): string; overload;
    ///<summary>Converts the <see cref="T:System.UInt64" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="UInt64" />
    ///  .</returns>
    {class} function ToString(value: UInt64): string; overload;
    ///<summary>Converts the <see cref="T:System.TimeSpan" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="TimeSpan" />
    ///  .</returns>
    {class} function ToString(value: DDN.mscorlib.DNTimeSpan): string; overload;
    ///<summary>Converts the <see cref="T:System.DateTime" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///  <param name="format">The format structure that defines how to display the converted string. Valid formats include "yyyy-MM-ddTHH:mm:sszzzzzz" and its subsets. </param>
    ///<returns>A string representation of the <see langword="DateTime" />
    ///  in the specified format.</returns>
    {class} function ToString(value: DDN.mscorlib.DNDateTime; format: string): string; overload;
    ///<summary>Converts the supplied <see cref="T:System.DateTimeOffset" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The <see cref="T:System.DateTimeOffset" />
    ///  to be converted.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  representation of the supplied <see cref="T:System.DateTimeOffset" />
    ///  .</returns>
    {class} function ToString(value: DDN.mscorlib.DNDateTimeOffset): string; overload;
    ///<summary>Converts the supplied <see cref="T:System.DateTimeOffset" />
    ///  to a <see cref="T:System.String" />
    ///  in the specified format.</summary>
    ///  <param name="value">The <see cref="T:System.DateTimeOffset" />
    ///  to be converted.</param>
    ///  <param name="format">The format to which <paramref name="s" />
    ///  is converted. The format parameter can be any subset of the W3C Recommendation for the XML dateTime type. (For more information see http://www.w3.org/TR/xmlschema-2/#dateTime.)</param>
    ///<returns>A <see cref="T:System.String" />
    ///  representation in the specified format of the supplied <see cref="T:System.DateTimeOffset" />
    ///  .</returns>
    {class} function ToString(value: DDN.mscorlib.DNDateTimeOffset; format: string): string; overload;
    ///<summary>Converts the <see cref="T:System.Guid" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Guid" />
    ///  .</returns>
    {class} function ToString(value: DDN.mscorlib.DNGuid): string; overload;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Char" />
    ///  equivalent.</summary>
    ///  <param name="s">The string containing a single character to convert. </param>
    ///<returns>A <see langword="Char" />
    ///  representing the single character.</returns>
    ///<exception cref="T:System.ArgumentNullException">The value of the <paramref name="s" />
    ///  parameter is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException">The <paramref name="s" />
    ///  parameter contains more than one character. </exception>
    {class} function ToChar(s: string): Char;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Decimal" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="Decimal" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Decimal.MinValue" />
    ///  or greater than <see cref="F:System.Decimal.MaxValue" />
    ///  . </exception>
    {class} function ToDecimal(s: string): DDN.mscorlib.DNDecimal;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.SByte" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>An <see langword="SByte" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.SByte.MinValue" />
    ///  or greater than <see cref="F:System.SByte.MaxValue" />
    ///  . </exception>
    {class} function ToSByte(s: string): SByte;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Int16" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>An <see langword="Int16" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Int16.MinValue" />
    ///  or greater than <see cref="F:System.Int16.MaxValue" />
    ///  . </exception>
    {class} function ToInt16(s: string): Int16;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Int32" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>An <see langword="Int32" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Int32.MinValue" />
    ///  or greater than <see cref="F:System.Int32.MaxValue" />
    ///  . </exception>
    {class} function ToInt32(s: string): Int32;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Int64" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>An <see langword="Int64" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Int64.MinValue" />
    ///  or greater than <see cref="F:System.Int64.MaxValue" />
    ///  . </exception>
    {class} function ToInt64(s: string): Int64;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Byte" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="Byte" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Byte.MinValue" />
    ///  or greater than <see cref="F:System.Byte.MaxValue" />
    ///  . </exception>
    {class} function ToByte(s: string): Byte;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.UInt16" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="UInt16" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.UInt16.MinValue" />
    ///  or greater than <see cref="F:System.UInt16.MaxValue" />
    ///  . </exception>
    {class} function ToUInt16(s: string): UInt16;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.UInt32" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="UInt32" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.UInt32.MinValue" />
    ///  or greater than <see cref="F:System.UInt32.MaxValue" />
    ///  . </exception>
    {class} function ToUInt32(s: string): UInt32;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.UInt64" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="UInt64" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.UInt64.MinValue" />
    ///  or greater than <see cref="F:System.UInt64.MaxValue" />
    ///  . </exception>
    {class} function ToUInt64(s: string): UInt64;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTime" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="DateTime" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is an empty string or is not in the correct format. </exception>
    {class} function ToDateTime(s: string): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTime" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///  <param name="format">The format structure to apply to the converted <see langword="DateTime" />
    ///  . Valid formats include "yyyy-MM-ddTHH:mm:sszzzzzz" and its subsets. The string is validated against this format. </param>
    ///<returns>A <see langword="DateTime" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  or <paramref name="format" />
    ///  is String.Empty -or-
    ///  <paramref name="s" />
    ///  does not contain a date and time that corresponds to <paramref name="format" />
    ///  . </exception>
    {class} function ToDateTime(s: string; format: string): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTime" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///  <param name="formats">An array containing the format structures to apply to the converted <see langword="DateTime" />
    ///  . Valid formats include "yyyy-MM-ddTHH:mm:sszzzzzz" and its subsets. </param>
    ///<returns>A <see langword="DateTime" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  or an element of <paramref name="formats" />
    ///  is String.Empty -or-
    ///  <paramref name="s" />
    ///  does not contain a date and time that corresponds to any of the elements of <paramref name="formats" />
    ///  . </exception>
    {class} function ToDateTime(s: string; formats: TArray<string>): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Converts the supplied <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTimeOffset" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert.
    ///  Note   The string must conform to a subset of the W3C Recommendation for the XML dateTime type. For more information see http://www.w3.org/TR/xmlschema-2/#dateTime.</param>
    ///<returns>The <see cref="T:System.DateTimeOffset" />
    ///  equivalent of the supplied string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException">The argument passed to this method is outside the range of allowable values. For information about allowable values, see <see cref="T:System.DateTimeOffset" />
    ///  .</exception><exception cref="T:System.FormatException">The argument passed to this method does not conform to a subset of the W3C Recommendations for the XML dateTime type. For more information see http://www.w3.org/TR/xmlschema-2/#dateTime.</exception>
    {class} function ToDateTimeOffset(s: string): DDN.mscorlib.DNDateTimeOffset; overload;
    ///<summary>Converts the supplied <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTimeOffset" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert.</param>
    ///  <param name="format">The format from which <paramref name="s" />
    ///  is converted. The format parameter can be any subset of the W3C Recommendation for the XML dateTime type. (For more information see http://www.w3.org/TR/xmlschema-2/#dateTime.) The string <paramref name="s" />
    ///  is validated against this format.</param>
    ///<returns>The <see cref="T:System.DateTimeOffset" />
    ///  equivalent of the supplied string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  or <paramref name="format" />
    ///  is an empty string or is not in the specified format.</exception>
    {class} function ToDateTimeOffset(s: string; format: string): DDN.mscorlib.DNDateTimeOffset; overload;
    ///<summary>Converts the supplied <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTimeOffset" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert.</param>
    ///  <param name="formats">An array of formats from which <paramref name="s" />
    ///  can be converted. Each format in <paramref name="formats" />
    ///  can be any subset of the W3C Recommendation for the XML dateTime type. (For more information see http://www.w3.org/TR/xmlschema-2/#dateTime.) The string <paramref name="s" />
    ///  is validated against one of these formats.</param>
    ///<returns>The <see cref="T:System.DateTimeOffset" />
    ///  equivalent of the supplied string.</returns>
    {class} function ToDateTimeOffset(s: string; formats: TArray<string>): DDN.mscorlib.DNDateTimeOffset; overload;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Guid" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="Guid" />
    ///  equivalent of the string.</returns>
    {class} function ToGuid(s: string): DDN.mscorlib.DNGuid;
    ///<summary>Verifies that the string is a valid token according to the W3C XML Schema Part2: Datatypes recommendation.</summary>
    ///  <param name="token">The string value you wish to verify.</param>
    ///<returns>The token, if it is a valid token.</returns>
    ///<exception cref="T:System.Xml.XmlException">The string value is not a valid token.</exception>
    {class} function VerifyTOKEN(token: string): string;
    ///<summary>Returns the passed-in character instance if the character in the argument is a valid public id character, otherwise <see langword="null" />
    ///  .</summary>
    ///  <param name="ch"><see cref="T:System.Char" />
    ///  object to validate.</param>
    ///<returns>Returns the passed-in character if the character is a valid public id character, otherwise <see langword="null" />
    ///  .</returns>
    {class} function IsPublicIdChar(ch: Char): Boolean;
    ///<summary>Converts the <see cref="T:System.Single" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Single" />
    ///  .</returns>
    {class} function ToString(value: Single): string; overload;
    ///<summary>Converts the <see cref="T:System.Double" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Double" />
    ///  .</returns>
    {class} function ToString(value: Double): string; overload;
    ///<summary>Converts the <see cref="T:System.DateTime" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="DateTime" />
    ///  in the format yyyy-MM-ddTHH:mm:ss where 'T' is a constant literal.</returns>
    {class} function ToString(value: DDN.mscorlib.DNDateTime): string; overload;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Single" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="Single" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Single.MinValue" />
    ///  or greater than <see cref="F:System.Single.MaxValue" />
    ///  . </exception>
    {class} function ToSingle(s: string): Single;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.TimeSpan" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. The string format must conform to the W3C XML Schema Part 2: Datatypes recommendation for duration.</param>
    ///<returns>A <see langword="TimeSpan" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in correct format to represent a <see langword="TimeSpan" />
    ///  value. </exception>
    {class} function ToTimeSpan(s: string): DDN.mscorlib.DNTimeSpan;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.DateTime" />
    ///  using the <see cref="T:System.Xml.XmlDateTimeSerializationMode" />
    ///  specified</summary>
    ///  <param name="s">The <see cref="T:System.String" />
    ///  value to convert.</param>
    ///  <param name="dateTimeOption">One of the <see cref="T:System.Xml.XmlDateTimeSerializationMode" />
    ///  values that specify whether the date should be converted to local time or preserved as Coordinated Universal Time (UTC), if it is a UTC date.</param>
    ///<returns>A <see cref="T:System.DateTime" />
    ///  equivalent of the <see cref="T:System.String" />
    ///  .</returns>
    ///<exception cref="T:System.NullReferenceException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The <paramref name="dateTimeOption" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is an empty string or is not in a valid format.</exception>
    {class} function ToDateTime(s: string; dateTimeOption: DNXmlDateTimeSerializationMode): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Decodes a name. This method does the reverse of the <see cref="M:System.Xml.XmlConvert.EncodeName(System.String)" />
    ///  and <see cref="M:System.Xml.XmlConvert.EncodeLocalName(System.String)" />
    ///  methods.</summary>
    ///  <param name="name">The name to be transformed. </param>
    ///<returns>The decoded name.</returns>
    {class} function DecodeName(name: string): string;
    ///<summary>Converts the <see cref="T:System.Boolean" />
    ///  to a <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="value">The value to convert. </param>
    ///<returns>A string representation of the <see langword="Boolean" />
    ///  , that is, "true" or "false".</returns>
    {class} function ToString(value: Boolean): string; overload;
    ///<summary>Converts the <see cref="T:System.DateTime" />
    ///  to a <see cref="T:System.String" />
    ///  using the <see cref="T:System.Xml.XmlDateTimeSerializationMode" />
    ///  specified.</summary>
    ///  <param name="value">The <see cref="T:System.DateTime" />
    ///  value to convert.</param>
    ///  <param name="dateTimeOption">One of the <see cref="T:System.Xml.XmlDateTimeSerializationMode" />
    ///  values that specify how to treat the <see cref="T:System.DateTime" />
    ///  value.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  equivalent of the <see cref="T:System.DateTime" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="dateTimeOption" />
    ///  value is not valid.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  or <paramref name="dateTimeOption" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function ToString(value: DDN.mscorlib.DNDateTime; dateTimeOption: DNXmlDateTimeSerializationMode): string; overload;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Boolean" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="Boolean" />
    ///  value, that is, <see langword="true" />
    ///  or <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  does not represent a <see langword="Boolean" />
    ///  value. </exception>
    {class} function ToBoolean(s: string): Boolean;
    ///<summary>Converts the <see cref="T:System.String" />
    ///  to a <see cref="T:System.Double" />
    ///  equivalent.</summary>
    ///  <param name="s">The string to convert. </param>
    ///<returns>A <see langword="Double" />
    ///  equivalent of the string.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="s" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.FormatException"><paramref name="s" />
    ///  is not in the correct format. </exception><exception cref="T:System.OverflowException"><paramref name="s" />
    ///  represents a number less than <see cref="F:System.Double.MinValue" />
    ///  or greater than <see cref="F:System.Double.MaxValue" />
    ///  . </exception>
    {class} function ToDouble(s: string): Double;

  end;

  ///<summary>Encodes and decodes XML names, and provides methods for converting between common language runtime types and XML Schema definition language (XSD) types. When converting data types, the values returned are locale-independent.</summary>
  [DNTypeName('System.Xml.XmlConvert')]
  DNXmlConvert = interface(DDN.mscorlib.DNObject)
  ['{B3F984D5-ADCA-3752-990B-4347693F5B74}']
  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string; overload;

  end;

  TDNXmlConvert = class(TDNGenericImport<DNXmlConvertClass, DNXmlConvert>) end;

  //-------------namespace: System.Xml----------------
  DNXmlImplementationClass = interface(DDN.mscorlib.DNObjectClass)
  ['{616B9815-E140-5278-AE6F-7D21CF454BB0}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlImplementation" />
    ///  class.</summary>
    {class} function init: DNXmlImplementation; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlImplementation" />
    ///  class with the <see cref="T:System.Xml.XmlNameTable" />
    ///  specified.</summary>
    ///  <param name="nt">An <see cref="T:System.Xml.XmlNameTable" />
    ///  object.</param>
    {class} function init(nt: DNXmlNameTable): DNXmlImplementation; overload;

  end;

  ///<summary>Defines the context for a set of <see cref="T:System.Xml.XmlDocument" />
  ///  objects.</summary>
  [DNTypeName('System.Xml.XmlImplementation')]
  DNXmlImplementation = interface(DDN.mscorlib.DNObject)
  ['{B742D53C-E509-34DC-BAD5-2B37A1AFC661}']
  { methods } 

    ///<summary>Creates a new <see cref="T:System.Xml.XmlDocument" />
    ///  .</summary>
    ///<returns>The new <see langword="XmlDocument" />
    ///  object.</returns>
    function CreateDocument: DNXmlDocument;
    ///<summary>Tests if the Document Object Model (DOM) implementation implements a specific feature.</summary>
    ///  <param name="strFeature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="strVersion">This is the version number of the package name to test. If the version is not specified (<see langword="null" />
    ///  ), supporting any version of the feature causes the method to return <see langword="true" />
    ///  . </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  .The following table shows the combinations that cause <see langword="HasFeature" />
    ///  to return <see langword="true" />
    ///  .strFeature strVersion XML 1.0 XML 2.0 </returns>
    function HasFeature(strFeature: string; strVersion: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlImplementation = class(TDNGenericImport<DNXmlImplementationClass, DNXmlImplementation>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNamedNodeMapClass = interface(DNObjectClass)
  ['{B74D75C0-1E64-5FD7-9BB2-52B25E3AB6A3}']
  end;

  ///<summary>Represents a collection of nodes that can be accessed by name or index.</summary>
  [DNTypeName('System.Xml.XmlNamedNodeMap')]
  DNXmlNamedNodeMap = interface(DDN.mscorlib.DNIEnumerable)
  ['{291396F7-2B76-36E2-8E89-0C2BAB420F83}']
  { getters & setters } 

    function get_Count: Int32;

  { methods } 

    ///<summary>Retrieves an <see cref="T:System.Xml.XmlNode" />
    ///  specified by name.</summary>
    ///  <param name="name">The qualified name of the node to retrieve. It is matched against the <see cref="P:System.Xml.XmlNode.Name" />
    ///  property of the matching node.</param>
    ///<returns>An <see langword="XmlNode" />
    ///  with the specified name or <see langword="null" />
    ///  if a matching node is not found.</returns>
    function GetNamedItem(name: string): DNXmlNode; overload;
    ///<summary>Adds an <see cref="T:System.Xml.XmlNode" />
    ///  using its <see cref="P:System.Xml.XmlNode.Name" />
    ///  property.</summary>
    ///  <param name="node">An <see langword="XmlNode" />
    ///  to store in the <see langword="XmlNamedNodeMap" />
    ///  . If a node with that name is already present in the map, it is replaced by the new one.</param>
    ///<returns>If the <paramref name="node" />
    ///  replaces an existing node with the same name, the old node is returned; otherwise, <see langword="null" />
    ///  is returned.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="node" />
    ///  was created from a different <see cref="T:System.Xml.XmlDocument" />
    ///  than the one that created the <see langword="XmlNamedNodeMap" />
    ///  ; or the <see langword="XmlNamedNodeMap" />
    ///  is read-only.</exception>
    function SetNamedItem(node: DNXmlNode): DNXmlNode;
    ///<summary>Removes the node from the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///  <param name="name">The qualified name of the node to remove. The name is matched against the <see cref="P:System.Xml.XmlNode.Name" />
    ///  property of the matching node.</param>
    ///<returns>The <see langword="XmlNode" />
    ///  removed from this <see langword="XmlNamedNodeMap" />
    ///  or <see langword="null" />
    ///  if a matching node was not found.</returns>
    function RemoveNamedItem(name: string): DNXmlNode; overload;
    ///<summary>Retrieves the node at the specified index in the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///  <param name="index">The index position of the node to retrieve from the <see langword="XmlNamedNodeMap" />
    ///  . The index is zero-based; therefore, the index of the first node is 0 and the index of the last node is <see cref="P:System.Xml.XmlNamedNodeMap.Count" />
    ///  -1.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  at the specified index. If <paramref name="index" />
    ///  is less than 0 or greater than or equal to the <see cref="P:System.Xml.XmlNamedNodeMap.Count" />
    ///  property, <see langword="null" />
    ///  is returned.</returns>
    function Item(index: Int32): DNXmlNode;
    ///<summary>Retrieves a node with the matching <see cref="P:System.Xml.XmlNode.LocalName" />
    ///  and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="localName">The local name of the node to retrieve.</param>
    ///  <param name="namespaceURI">The namespace Uniform Resource Identifier (URI) of the node to retrieve.</param>
    ///<returns>An <see cref="T:System.Xml.XmlNode" />
    ///  with the matching local name and namespace URI or <see langword="null" />
    ///  if a matching node was not found.</returns>
    function GetNamedItem(localName: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Removes a node with the matching <see cref="P:System.Xml.XmlNode.LocalName" />
    ///  and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="localName">The local name of the node to remove.</param>
    ///  <param name="namespaceURI">The namespace URI of the node to remove.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  removed or <see langword="null" />
    ///  if a matching node was not found.</returns>
    function RemoveNamedItem(localName: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Provides support for the "foreach" style iteration over the collection of nodes in the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///<returns>An enumerator object.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of nodes in the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///<returns>The number of nodes.</returns>
    property Count: Int32 read get_Count;
  end;

  TDNXmlNamedNodeMap = class(TDNGenericImport<DNXmlNamedNodeMapClass, DNXmlNamedNodeMap>) end;

  //-------------namespace: System.Xml----------------
  DNXmlAttributeCollectionClass = interface(DNXmlNamedNodeMapClass)
  ['{7D8D432B-42C5-5DD1-81AC-C7E940F30448}']
  end;

  ///<summary>Represents a collection of attributes that can be accessed by name or index.</summary>
  [DNTypeName('System.Xml.XmlAttributeCollection')]
  DNXmlAttributeCollection = interface(DNXmlNamedNodeMap)
  ['{AFF15495-0AAB-3C7F-A744-CB752611089E}']
  { getters & setters } 

    function get_ItemOf(i: Int32): DNXmlAttribute; overload;
    function get_ItemOf(name: string): DNXmlAttribute; overload;
    function get_ItemOf(localName: string; namespaceURI: string): DNXmlAttribute; overload;
    function get_Count: Int32;

  { methods } 

    ///<summary>Adds a <see cref="T:System.Xml.XmlNode" />
    ///  using its <see cref="P:System.Xml.XmlNode.Name" />
    ///  property </summary>
    ///  <param name="node">An attribute node to store in this collection. The node will later be accessible using the name of the node. If a node with that name is already present in the collection, it is replaced by the new one; otherwise, the node is appended to the end of the collection. </param>
    ///<returns>If the <paramref name="node" />
    ///  replaces an existing node with the same name, the old node is returned; otherwise, the added node is returned.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="node" />
    ///  was created from a different <see cref="T:System.Xml.XmlDocument" />
    ///  than the one that created this collection.This <see langword="XmlAttributeCollection" />
    ///  is read-only. </exception><exception cref="T:System.InvalidOperationException"><paramref name="node" />
    ///  is an <see cref="T:System.Xml.XmlAttribute" />
    ///  that is already an attribute of another <see cref="T:System.Xml.XmlElement" />
    ///  object. To re-use attributes in other elements, you must clone the <see langword="XmlAttribute" />
    ///  objects you want to re-use. </exception>
    function SetNamedItem(node: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified attribute as the first node in the collection.</summary>
    ///  <param name="node">The <see cref="T:System.Xml.XmlAttribute" />
    ///  to insert. </param>
    ///<returns>The <see langword="XmlAttribute" />
    ///  added to the collection.</returns>
    function Prepend(node: DNXmlAttribute): DNXmlAttribute;
    ///<summary>Inserts the specified attribute as the last node in the collection.</summary>
    ///  <param name="node">The <see cref="T:System.Xml.XmlAttribute" />
    ///  to insert. </param>
    ///<returns>The <see langword="XmlAttribute" />
    ///  to append to the collection.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="node" />
    ///  was created from a document different from the one that created this collection. </exception>
    function Append(node: DNXmlAttribute): DNXmlAttribute;
    ///<summary>Inserts the specified attribute immediately before the specified reference attribute.</summary>
    ///  <param name="newNode">The <see cref="T:System.Xml.XmlAttribute" />
    ///  to insert. </param>
    ///  <param name="refNode">The <see cref="T:System.Xml.XmlAttribute" />
    ///  that is the reference attribute. <paramref name="newNode" />
    ///  is placed before the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The <see langword="XmlAttribute" />
    ///  to insert into the collection.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="newNode" />
    ///  was created from a document different from the one that created this collection. Or the <paramref name="refNode" />
    ///  is not a member of this collection. </exception>
    function InsertBefore(newNode: DNXmlAttribute; refNode: DNXmlAttribute): DNXmlAttribute;
    ///<summary>Inserts the specified attribute immediately after the specified reference attribute.</summary>
    ///  <param name="newNode">The <see cref="T:System.Xml.XmlAttribute" />
    ///  to insert. </param>
    ///  <param name="refNode">The <see cref="T:System.Xml.XmlAttribute" />
    ///  that is the reference attribute. <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The <see langword="XmlAttribute" />
    ///  to insert into the collection.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="newNode" />
    ///  was created from a document different from the one that created this collection. Or the <paramref name="refNode" />
    ///  is not a member of this collection. </exception>
    function InsertAfter(newNode: DNXmlAttribute; refNode: DNXmlAttribute): DNXmlAttribute;
    ///<summary>Removes the specified attribute from the collection.</summary>
    ///  <param name="node">The <see cref="T:System.Xml.XmlAttribute" />
    ///  to remove. </param>
    ///<returns>The node removed or <see langword="null" />
    ///  if it is not found in the collection.</returns>
    function Remove(node: DNXmlAttribute): DNXmlAttribute;
    ///<summary>Removes the attribute corresponding to the specified index from the collection.</summary>
    ///  <param name="i">The index of the node to remove. The first node has index 0. </param>
    ///<returns>Returns <see langword="null" />
    ///  if there is no attribute at the specified index.</returns>
    function RemoveAt(i: Int32): DNXmlAttribute;
    ///<summary>Removes all attributes from the collection.</summary>
    procedure RemoveAll;
    ///<summary>Copies all the <see cref="T:System.Xml.XmlAttribute" />
    ///  objects from this collection into the given array.</summary>
    ///  <param name="array">The array that is the destination of the objects copied from this collection. </param>
    ///  <param name="index">The index in the array where copying begins. </param>
    procedure CopyTo(&array: TArray<DNXmlAttribute>; index: Int32);
    ///<summary>Retrieves an <see cref="T:System.Xml.XmlNode" />
    ///  specified by name.</summary>
    ///  <param name="name">The qualified name of the node to retrieve. It is matched against the <see cref="P:System.Xml.XmlNode.Name" />
    ///  property of the matching node.</param>
    ///<returns>An <see langword="XmlNode" />
    ///  with the specified name or <see langword="null" />
    ///  if a matching node is not found.</returns>
    function GetNamedItem(name: string): DNXmlNode; overload;
    ///<summary>Removes the node from the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///  <param name="name">The qualified name of the node to remove. The name is matched against the <see cref="P:System.Xml.XmlNode.Name" />
    ///  property of the matching node.</param>
    ///<returns>The <see langword="XmlNode" />
    ///  removed from this <see langword="XmlNamedNodeMap" />
    ///  or <see langword="null" />
    ///  if a matching node was not found.</returns>
    function RemoveNamedItem(name: string): DNXmlNode; overload;
    ///<summary>Retrieves the node at the specified index in the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///  <param name="index">The index position of the node to retrieve from the <see langword="XmlNamedNodeMap" />
    ///  . The index is zero-based; therefore, the index of the first node is 0 and the index of the last node is <see cref="P:System.Xml.XmlNamedNodeMap.Count" />
    ///  -1.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  at the specified index. If <paramref name="index" />
    ///  is less than 0 or greater than or equal to the <see cref="P:System.Xml.XmlNamedNodeMap.Count" />
    ///  property, <see langword="null" />
    ///  is returned.</returns>
    function Item(index: Int32): DNXmlNode;
    ///<summary>Retrieves a node with the matching <see cref="P:System.Xml.XmlNode.LocalName" />
    ///  and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="localName">The local name of the node to retrieve.</param>
    ///  <param name="namespaceURI">The namespace Uniform Resource Identifier (URI) of the node to retrieve.</param>
    ///<returns>An <see cref="T:System.Xml.XmlNode" />
    ///  with the matching local name and namespace URI or <see langword="null" />
    ///  if a matching node was not found.</returns>
    function GetNamedItem(localName: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Removes a node with the matching <see cref="P:System.Xml.XmlNode.LocalName" />
    ///  and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="localName">The local name of the node to remove.</param>
    ///  <param name="namespaceURI">The namespace URI of the node to remove.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  removed or <see langword="null" />
    ///  if a matching node was not found.</returns>
    function RemoveNamedItem(localName: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Provides support for the "foreach" style iteration over the collection of nodes in the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///<returns>An enumerator object.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    property ItemOf[i: Int32]: DNXmlAttribute read get_ItemOf; default;
    property ItemOf[name: string]: DNXmlAttribute read get_ItemOf; default;
    property ItemOf[localName: string; namespaceURI: string]: DNXmlAttribute read get_ItemOf; default;
    ///<summary>Gets the number of nodes in the <see langword="XmlNamedNodeMap" />
    ///  .</summary>
    ///<returns>The number of nodes.</returns>
    property Count: Int32 read get_Count;
  end;

  TDNXmlAttributeCollection = class(TDNGenericImport<DNXmlAttributeCollectionClass, DNXmlAttributeCollection>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNamespaceManagerClass = interface(DNObjectClass)
  ['{B8483CCF-B8DD-5A89-B0AB-9F9015775557}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="nameTable">The <see cref="T:System.Xml.XmlNameTable" />
    ///  to use. </param>
    ///<exception cref="T:System.NullReferenceException"><see langword="null" />
    ///  is passed to the constructor </exception>
    {class} function init(nameTable: DNXmlNameTable): DNXmlNamespaceManager;

  end;

  ///<summary>Resolves, adds, and removes namespaces to a collection and provides scope management for these namespaces. </summary>
  [DNTypeName('System.Xml.XmlNamespaceManager')]
  DNXmlNamespaceManager = interface(DNIXmlNamespaceResolver)
  ['{C5338A3B-B457-3C22-9CD2-4786DF44090F}']
  { getters & setters } 

    function get_NameTable: DNXmlNameTable;
    function get_DefaultNamespace: string;

  { methods } 

    ///<summary>Pushes a namespace scope onto the stack.</summary>
    procedure PushScope;
    ///<summary>Pops a namespace scope off the stack.</summary>
    ///<returns><see langword="true" />
    ///  if there are namespace scopes left on the stack; <see langword="false" />
    ///  if there are no more namespaces to pop.</returns>
    function PopScope: Boolean;
    ///<summary>Removes the given namespace for the given prefix.</summary>
    ///  <param name="prefix">The prefix for the namespace </param>
    ///  <param name="uri">The namespace to remove for the given prefix. The namespace removed is from the current namespace scope. Namespaces outside the current scope are ignored. </param>
    ///<exception cref="T:System.ArgumentNullException">The value of <paramref name="prefix" />
    ///  or <paramref name="uri" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure RemoveNamespace(prefix: string; uri: string);
    ///<summary>Gets the namespace URI for the specified prefix.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass String.Empty. </param>
    ///<returns>Returns the namespace URI for <paramref name="prefix" />
    ///  or <see langword="null" />
    ///  if there is no mapped namespace. The returned string is atomized.For more information on atomized strings, see the <see cref="T:System.Xml.XmlNameTable" />
    ///  class.</returns>
    function LookupNamespace(prefix: string): string;
    ///<summary>Finds the prefix declared for the given namespace URI.</summary>
    ///  <param name="uri">The namespace to resolve for the prefix. </param>
    ///<returns>The matching prefix. If there is no mapped prefix, the method returns String.Empty. If a null value is supplied, then <see langword="null" />
    ///  is returned.</returns>
    function LookupPrefix(uri: string): string;
    ///<summary>Gets a value indicating whether the supplied prefix has a namespace defined for the current pushed scope.</summary>
    ///  <param name="prefix">The prefix of the namespace you want to find. </param>
    ///<returns><see langword="true" />
    ///  if there is a namespace defined; otherwise, <see langword="false" />
    ///  .</returns>
    function HasNamespace(prefix: string): Boolean;
    ///<summary>Adds the given namespace to the collection.</summary>
    ///  <param name="prefix">The prefix to associate with the namespace being added. Use String.Empty to add a default namespace.
    ///  NoteIf the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  will be used for resolving namespaces in an XML Path Language (XPath) expression, a prefix must be specified. If an XPath expression does not include a prefix, it is assumed that the namespace Uniform Resource Identifier (URI) is the empty namespace. For more information about XPath expressions and the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  , refer to the <see cref="M:System.Xml.XmlNode.SelectNodes(System.String)" />
    ///  and <see cref="M:System.Xml.XPath.XPathExpression.SetContext(System.Xml.XmlNamespaceManager)" />
    ///  methods.</param>
    ///  <param name="uri">The namespace to add. </param>
    ///<exception cref="T:System.ArgumentException">The value for <paramref name="prefix" />
    ///  is "xml" or "xmlns". </exception><exception cref="T:System.ArgumentNullException">The value for <paramref name="prefix" />
    ///  or <paramref name="uri" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure AddNamespace(prefix: string; uri: string);
    ///<summary>Returns an enumerator to use to iterate through the namespaces in the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  containing the prefixes stored by the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets a collection of namespace names keyed by prefix which can be used to enumerate the namespaces currently in scope.</summary>
    ///  <param name="scope">An enumeration value that specifies the type of namespace nodes to return.</param>
    ///<returns>A collection of namespace and prefix pairs currently in scope.</returns>
    function GetNamespacesInScope(scope: DNXmlNamespaceScope): DDN.mscorlib.DNIDictionary<string, string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this object.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNameTable" />
    ///  used by this object.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets the namespace URI for the default namespace.</summary>
    ///<returns>Returns the namespace URI for the default namespace, or String.Empty if there is no default namespace.</returns>
    property DefaultNamespace: string read get_DefaultNamespace;
  end;

  TDNXmlNamespaceManager = class(TDNGenericImport<DNXmlNamespaceManagerClass, DNXmlNamespaceManager>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXsltContextClass = interface(DNXmlNamespaceManagerClass)
  ['{E4CAE55E-6F3A-5F42-8DAA-CBED5B921C26}']
  end;

  ///<summary>Encapsulates the current execution context of the Extensible Stylesheet Language for Transformations (XSLT) processor allowing XML Path Language (XPath) to resolve functions, parameters, and namespaces within XPath expressions.</summary>
  [DNTypeName('System.Xml.Xsl.XsltContext')]
  DNXsltContext = interface(DNXmlNamespaceManager)
  ['{59A37C60-EAB8-31A2-BF26-C2C67285426B}']
  { getters & setters } 

    function get_Whitespace: Boolean;
    function get_NameTable: DNXmlNameTable;
    function get_DefaultNamespace: string;

  { methods } 

    ///<summary>When overridden in a derived class, resolves a variable reference and returns an <see cref="T:System.Xml.Xsl.IXsltContextVariable" />
    ///  representing the variable.</summary>
    ///  <param name="prefix">The prefix of the variable as it appears in the XPath expression. </param>
    ///  <param name="name">The name of the variable. </param>
    ///<returns>An <see cref="T:System.Xml.Xsl.IXsltContextVariable" />
    ///  representing the variable at runtime.</returns>
    function ResolveVariable(prefix: string; name: string): DNIXsltContextVariable;
    ///<summary>When overridden in a derived class, resolves a function reference and returns an <see cref="T:System.Xml.Xsl.IXsltContextFunction" />
    ///  representing the function. The <see cref="T:System.Xml.Xsl.IXsltContextFunction" />
    ///  is used at execution time to get the return value of the function.</summary>
    ///  <param name="prefix">The prefix of the function as it appears in the XPath expression. </param>
    ///  <param name="name">The name of the function. </param>
    ///  <param name="ArgTypes">An array of argument types for the function being resolved. This allows you to select between methods with the same name (for example, overloaded methods). </param>
    ///<returns>An <see cref="T:System.Xml.Xsl.IXsltContextFunction" />
    ///  representing the function.</returns>
    function ResolveFunction(prefix: string; name: string; ArgTypes: TArray<DNXPathResultType>): DNIXsltContextFunction;
    ///<summary>When overridden in a derived class, evaluates whether to preserve white space nodes or strip them for the given context.</summary>
    ///  <param name="node">The white space node that is to be preserved or stripped in the current context. </param>
    ///<returns>Returns <see langword="true" />
    ///  if the white space is to be preserved or <see langword="false" />
    ///  if the white space is to be stripped.</returns>
    function PreserveWhitespace(node: DNXPathNavigator): Boolean;
    ///<summary>When overridden in a derived class, compares the base Uniform Resource Identifiers (URIs) of two documents based upon the order the documents were loaded by the XSLT processor (that is, the <see cref="T:System.Xml.Xsl.XslTransform" />
    ///  class).</summary>
    ///  <param name="baseUri">The base URI of the first document to compare. </param>
    ///  <param name="nextbaseUri">The base URI of the second document to compare. </param>
    ///<returns>An integer value describing the relative order of the two base URIs: <see langword="-" />
    ///  1 if <paramref name="baseUri" />
    ///  occurs before <paramref name="nextbaseUri" />
    ///  ; 0 if the two base URIs are identical; and 1 if <paramref name="baseUri" />
    ///  occurs after <paramref name="nextbaseUri" />
    ///  .</returns>
    function CompareDocument(baseUri: string; nextbaseUri: string): Int32;
    ///<summary>Pushes a namespace scope onto the stack.</summary>
    procedure PushScope;
    ///<summary>Pops a namespace scope off the stack.</summary>
    ///<returns><see langword="true" />
    ///  if there are namespace scopes left on the stack; <see langword="false" />
    ///  if there are no more namespaces to pop.</returns>
    function PopScope: Boolean;
    ///<summary>Removes the given namespace for the given prefix.</summary>
    ///  <param name="prefix">The prefix for the namespace </param>
    ///  <param name="uri">The namespace to remove for the given prefix. The namespace removed is from the current namespace scope. Namespaces outside the current scope are ignored. </param>
    ///<exception cref="T:System.ArgumentNullException">The value of <paramref name="prefix" />
    ///  or <paramref name="uri" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure RemoveNamespace(prefix: string; uri: string);
    ///<summary>Gets the namespace URI for the specified prefix.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass String.Empty. </param>
    ///<returns>Returns the namespace URI for <paramref name="prefix" />
    ///  or <see langword="null" />
    ///  if there is no mapped namespace. The returned string is atomized.For more information on atomized strings, see the <see cref="T:System.Xml.XmlNameTable" />
    ///  class.</returns>
    function LookupNamespace(prefix: string): string;
    ///<summary>Finds the prefix declared for the given namespace URI.</summary>
    ///  <param name="uri">The namespace to resolve for the prefix. </param>
    ///<returns>The matching prefix. If there is no mapped prefix, the method returns String.Empty. If a null value is supplied, then <see langword="null" />
    ///  is returned.</returns>
    function LookupPrefix(uri: string): string;
    ///<summary>Gets a value indicating whether the supplied prefix has a namespace defined for the current pushed scope.</summary>
    ///  <param name="prefix">The prefix of the namespace you want to find. </param>
    ///<returns><see langword="true" />
    ///  if there is a namespace defined; otherwise, <see langword="false" />
    ///  .</returns>
    function HasNamespace(prefix: string): Boolean;
    ///<summary>Adds the given namespace to the collection.</summary>
    ///  <param name="prefix">The prefix to associate with the namespace being added. Use String.Empty to add a default namespace.
    ///  NoteIf the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  will be used for resolving namespaces in an XML Path Language (XPath) expression, a prefix must be specified. If an XPath expression does not include a prefix, it is assumed that the namespace Uniform Resource Identifier (URI) is the empty namespace. For more information about XPath expressions and the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  , refer to the <see cref="M:System.Xml.XmlNode.SelectNodes(System.String)" />
    ///  and <see cref="M:System.Xml.XPath.XPathExpression.SetContext(System.Xml.XmlNamespaceManager)" />
    ///  methods.</param>
    ///  <param name="uri">The namespace to add. </param>
    ///<exception cref="T:System.ArgumentException">The value for <paramref name="prefix" />
    ///  is "xml" or "xmlns". </exception><exception cref="T:System.ArgumentNullException">The value for <paramref name="prefix" />
    ///  or <paramref name="uri" />
    ///  is <see langword="null" />
    ///  . </exception>
    procedure AddNamespace(prefix: string; uri: string);
    ///<summary>Returns an enumerator to use to iterate through the namespaces in the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  containing the prefixes stored by the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Gets a collection of namespace names keyed by prefix which can be used to enumerate the namespaces currently in scope.</summary>
    ///  <param name="scope">An enumeration value that specifies the type of namespace nodes to return.</param>
    ///<returns>A collection of namespace and prefix pairs currently in scope.</returns>
    function GetNamespacesInScope(scope: DNXmlNamespaceScope): DDN.mscorlib.DNIDictionary<string, string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, gets a value indicating whether to include white space nodes in the output.</summary>
    ///<returns><see langword="true" />
    ///  to check white space nodes in the source document for inclusion in the output; <see langword="false" />
    ///  to not evaluate white space nodes. The default is <see langword="true" />
    ///  .</returns>
    property Whitespace: Boolean read get_Whitespace;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this object.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNameTable" />
    ///  used by this object.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets the namespace URI for the default namespace.</summary>
    ///<returns>Returns the namespace URI for the default namespace, or String.Empty if there is no default namespace.</returns>
    property DefaultNamespace: string read get_DefaultNamespace;
  end;

  TDNXsltContext = class(TDNGenericImport<DNXsltContextClass, DNXsltContext>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNameTableClass = interface(DDN.mscorlib.DNObjectClass)
  ['{77150595-D80A-50B6-8E01-202CC752528A}']
  end;

  ///<summary>Table of atomized string objects.</summary>
  [DNTypeName('System.Xml.XmlNameTable')]
  DNXmlNameTable = interface(DDN.mscorlib.DNObject)
  ['{14B8B8DB-2F35-39C8-A2F8-9BC1E9834472}']
  { methods } 

    ///<summary>When overridden in a derived class, gets the atomized string containing the same characters as the specified range of characters in the given array.</summary>
    ///  <param name="array">The character array containing the name to look up. </param>
    ///  <param name="offset">The zero-based index into the array specifying the first character of the name. </param>
    ///  <param name="length">The number of characters in the name. </param>
    ///<returns>The atomized string or <see langword="null" />
    ///  if the string has not already been atomized. If <paramref name="length" />
    ///  is zero, String.Empty is returned.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">0 &gt; <paramref name="offset" />
    ///  -or-
    ///  <paramref name="offset" />
    ///  &gt;= <paramref name="array" />
    ///  .Length -or-
    ///  <paramref name="length" />
    ///  &gt; <paramref name="array" />
    ///  .Length The above conditions do not cause an exception to be thrown if <paramref name="length" />
    ///  =0. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" />
    ///  &lt; 0. </exception>
    function Get(&array: TArray<Char>; offset: Int32; length: Int32): string; overload;
    ///<summary>When overridden in a derived class, gets the atomized string containing the same value as the specified string.</summary>
    ///  <param name="array">The name to look up. </param>
    ///<returns>The atomized string or <see langword="null" />
    ///  if the string has not already been atomized.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception>
    function Get(&array: string): string; overload;
    ///<summary>When overridden in a derived class, atomizes the specified string and adds it to the <see langword="XmlNameTable" />
    ///  .</summary>
    ///  <param name="array">The character array containing the name to add. </param>
    ///  <param name="offset">Zero-based index into the array specifying the first character of the name. </param>
    ///  <param name="length">The number of characters in the name. </param>
    ///<returns>The new atomized string or the existing one if it already exists. If length is zero, String.Empty is returned.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">0 &gt; <paramref name="offset" />
    ///  -or-
    ///  <paramref name="offset" />
    ///  &gt;= <paramref name="array" />
    ///  .Length -or-
    ///  <paramref name="length" />
    ///  &gt; <paramref name="array" />
    ///  .Length The above conditions do not cause an exception to be thrown if <paramref name="length" />
    ///  =0. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" />
    ///  &lt; 0. </exception>
    function Add(&array: TArray<Char>; offset: Int32; length: Int32): string; overload;
    ///<summary>When overridden in a derived class, atomizes the specified string and adds it to the <see langword="XmlNameTable" />
    ///  .</summary>
    ///  <param name="array">The name to add. </param>
    ///<returns>The new atomized string or the existing one if it already exists.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception>
    function Add(&array: string): string; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXmlNameTable = class(TDNGenericImport<DNXmlNameTableClass, DNXmlNameTable>) end;

  //-------------namespace: System.Xml----------------
  DNNameTableClass = interface(DNXmlNameTableClass)
  ['{E8743B09-46E8-5553-8DFA-1124B6A93420}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see langword="NameTable" />
    ///  class.</summary>
    {class} function init: DNNameTable;

  end;

  ///<summary>Implements a single-threaded <see cref="T:System.Xml.XmlNameTable" />
  ///  .</summary>
  [DNTypeName('System.Xml.NameTable')]
  DNNameTable = interface(DNXmlNameTable)
  ['{A1C619FD-4BBD-32AC-B386-1EA2575A039B}']
  { methods } 

    ///<summary>Atomizes the specified string and adds it to the <see langword="NameTable" />
    ///  .</summary>
    ///  <param name="key">The string to add. </param>
    ///<returns>The atomized string or the existing string if it already exists in the <see langword="NameTable" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="key" />
    ///  is <see langword="null" />
    ///  . </exception>
    function Add(key: string): string; overload;
    ///<summary>Atomizes the specified string and adds it to the <see langword="NameTable" />
    ///  .</summary>
    ///  <param name="key">The character array containing the string to add. </param>
    ///  <param name="start">The zero-based index into the array specifying the first character of the string. </param>
    ///  <param name="len">The number of characters in the string. </param>
    ///<returns>The atomized string or the existing string if one already exists in the <see langword="NameTable" />
    ///  . If <paramref name="len" />
    ///  is zero, String.Empty is returned.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">0 &gt; <paramref name="start" />
    ///  -or-
    ///  <paramref name="start" />
    ///  &gt;= <paramref name="key" />
    ///  .Length -or-
    ///  <paramref name="len" />
    ///  &gt;= <paramref name="key" />
    ///  .Length The above conditions do not cause an exception to be thrown if <paramref name="len" />
    ///  =0. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="len" />
    ///  &lt; 0. </exception>
    function Add(key: TArray<Char>; start: Int32; len: Int32): string; overload;
    ///<summary>Gets the atomized string with the specified value.</summary>
    ///  <param name="value">The name to find. </param>
    ///<returns>The atomized string object or <see langword="null" />
    ///  if the string has not already been atomized.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="value" />
    ///  is <see langword="null" />
    ///  . </exception>
    function Get(value: string): string; overload;
    ///<summary>Gets the atomized string containing the same characters as the specified range of characters in the given array.</summary>
    ///  <param name="key">The character array containing the name to find. </param>
    ///  <param name="start">The zero-based index into the array specifying the first character of the name. </param>
    ///  <param name="len">The number of characters in the name. </param>
    ///<returns>The atomized string or <see langword="null" />
    ///  if the string has not already been atomized. If <paramref name="len" />
    ///  is zero, String.Empty is returned.</returns>
    ///<exception cref="T:System.IndexOutOfRangeException">0 &gt; <paramref name="start" />
    ///  -or-
    ///  <paramref name="start" />
    ///  &gt;= <paramref name="key" />
    ///  .Length -or-
    ///  <paramref name="len" />
    ///  &gt;= <paramref name="key" />
    ///  .Length The above conditions do not cause an exception to be thrown if <paramref name="len" />
    ///  =0. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="len" />
    ///  &lt; 0. </exception>
    function Get(key: TArray<Char>; start: Int32; len: Int32): string; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNNameTable = class(TDNGenericImport<DNNameTableClass, DNNameTable>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNodeClass = interface(DNObjectClass)
  ['{67ED459D-701F-5264-948A-65FB8009A866}']
  end;

  ///<summary>Represents a single node in the XML document. </summary>
  [DNTypeName('System.Xml.XmlNode')]
  DNXmlNode = interface(DDN.mscorlib.DNICloneable)
  ['{1E11AFE9-F059-35CC-A0C3-B9AA38701C21}']
  { getters & setters } 

    function get_Name: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_LocalName: string;
    function get_IsReadOnly: Boolean;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates an <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  for navigating this object.</summary>
    ///<returns>An <see langword="XPathNavigator" />
    ///  object used to navigate the node. The <see langword="XPathNavigator" />
    ///  is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node. </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node <paramref name="oldChild" />
    ///  with <paramref name="newChild" />
    ///  node.</summary>
    ///  <param name="newChild">The new node to put in the child list. </param>
    ///  <param name="oldChild">The node being replaced in the list. </param>
    ///<returns>The node replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node. </exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes specified child node.</summary>
    ///  <param name="oldChild">The node being removed. </param>
    ///<returns>The node removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only. </exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location.</param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location. </param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Creates a duplicate of the node, when overridden in a derived class.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The cloned node.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling this method on a node type that cannot be cloned. </exception>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    ///<summary>Saves the current node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  , when overridden in a derived class.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the child nodes of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  , when overridden in a derived class.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node, when overridden in a derived class.</summary>
    ///<returns>The qualified name of the node. The name returned is dependent on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Name Attribute The qualified name of the attribute. CDATA #cdata-section Comment #comment Document #document DocumentFragment #document-fragment DocumentType The document type name. Element The qualified name of the element. Entity The name of the entity. EntityReference The name of the entity referenced. Notation The notation name. ProcessingInstruction The target of the processing instruction. Text #text Whitespace #whitespace SignificantWhitespace #significant-whitespace XmlDeclaration #xml-declaration </returns>
    property Name: string read get_Name;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Value Attribute The value of the attribute. CDATASection The content of the CDATA Section. Comment The content of the comment. Document
    ///<see langword="null" />
    ///  . DocumentFragment
    ///<see langword="null" />
    ///  . DocumentType
    ///<see langword="null" />
    ///  . Element
    ///<see langword="null" />
    ///  . You can use the <see cref="P:System.Xml.XmlElement.InnerText" />
    ///  or <see cref="P:System.Xml.XmlElement.InnerXml" />
    ///  properties to access the value of the element node. Entity
    ///<see langword="null" />
    ///  . EntityReference
    ///<see langword="null" />
    ///  . Notation
    ///<see langword="null" />
    ///  . ProcessingInstruction The entire content excluding the target. Text The content of the text node. SignificantWhitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. Whitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. XmlDeclaration The content of the declaration (that is, everything between &lt;?xml and ?&gt;). </returns>
    ///<exception cref="T:System.ArgumentException">Setting the value of a node that is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the value of a node that is not supposed to have a value (for example, an Element node). </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the type of the current node, when overridden in a derived class.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlNodeType" />
    ///  values.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.NodeType Return Value of ParentNode Attribute, Document, DocumentFragment, Entity, Notation Returns <see langword="null" />
    ///  ; these nodes do not have parents. CDATA Returns the element or entity reference containing the CDATA section. Comment Returns the element, entity reference, document type, or document containing the comment. DocumentType Returns the document node. Element Returns the parent node of the element. If the element is the root node in the tree, the parent is the document node. EntityReference Returns the element, attribute, or entity reference containing the entity reference. ProcessingInstruction Returns the document, element, document type, or entity reference containing the processing instruction. Text Returns the parent element, attribute, or entity reference containing the text node. </returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see langword="XmlNode" />
    ///  . If there is no preceding node, <see langword="null" />
    ///  is returned.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The next <see langword="XmlNode" />
    ///  . If there is no next node, <see langword="null" />
    ///  is returned.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.If the node is an <see cref="T:System.Xml.XmlDocument" />
    ///  (NodeType equals XmlNodeType.Document), this property returns <see langword="null" />
    ///  .</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. For example, <see langword="Prefix" />
    ///  is bk for the element &lt;bk:book&gt;. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The specified prefix is "xml" and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute and the specified prefix is "xmlns" and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/ ".This node is an attribute and the qualifiedName of this node is "xmlns". </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the local name of the node, when overridden in a derived class.</summary>
    ///<returns>The name of the node with the prefix removed. For example, <see langword="LocalName" />
    ///  is book for the element &lt;bk:book&gt;.The name returned is dependent on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Name Attribute The local name of the attribute. CDATA #cdata-section Comment #comment Document #document DocumentFragment #document-fragment DocumentType The document type name. Element The local name of the element. Entity The name of the entity. EntityReference The name of the entity referenced. Notation The notation name. ProcessingInstruction The target of the processing instruction. Text #text Whitespace #whitespace SignificantWhitespace #significant-whitespace XmlDeclaration #xml-declaration </returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets or sets the concatenated values of the node and all its child nodes.</summary>
    ///<returns>The concatenated values of the node and all its child nodes.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the markup containing this node and all its child nodes.</summary>
    ///<returns>The markup containing this node and all its child nodes.
    ///<see langword="OuterXml" />
    ///  does not return default attributes.</returns>
    property OuterXml: string read get_OuterXml;
    ///<summary>Gets or sets the markup representing only the child nodes of this node.</summary>
    ///<returns>The markup of the child nodes of this node.
    ///<see langword="InnerXml" />
    ///  does not return default attributes.</returns>
    ///<exception cref="T:System.InvalidOperationException">Setting this property on a node that cannot have child nodes. </exception><exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Gets the post schema validation infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the post schema validation infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The location from which the node was loaded or String.Empty if the node has no base URI.</returns>
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlNode = class(TDNGenericImport<DNXmlNodeClass, DNXmlNode>) end;

  //-------------namespace: System.Xml----------------
  DNXmlAttributeClass = interface(DNXmlNodeClass)
  ['{568F5F75-91DF-5716-991A-DE584FED5846}']
  { static getter & setter } 

    procedure set_InnerText(value: string);
    procedure set_InnerXml(value: string);

  { static propertys } 

    ///<summary>Sets the concatenated values of the node and all its children.</summary>
    ///<returns>The concatenated values of the node and all its children. For attribute nodes, this property has the same functionality as the <see cref="P:System.Xml.XmlAttribute.Value" />
    ///  property.</returns>
    {class} property InnerText: string write set_InnerText;
    ///<summary>Sets the value of the attribute.</summary>
    ///<returns>The attribute value.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed.</exception>
    {class} property InnerXml: string write set_InnerXml;
  end;

  ///<summary>Represents an attribute. Valid and default values for the attribute are defined in a document type definition (DTD) or schema.</summary>
  [DNTypeName('System.Xml.XmlAttribute')]
  DNXmlAttribute = interface(DNXmlNode)
  ['{D53A0503-137B-30F4-8409-E7299C90A5C8}']
  { getters & setters } 

    function get_ParentNode: DNXmlNode;
    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_OwnerDocument: DNXmlDocument;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    procedure set_InnerText(value: string);
    function get_Specified: Boolean;
    function get_OwnerElement: DNXmlElement;
    procedure set_InnerXml(value: string);
    function get_BaseURI: string;
    function get_ChildNodes: DNXmlNodeList;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Attributes: DNXmlAttributeCollection;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself </param>
    ///<returns>The duplicate node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see cref="T:System.Xml.XmlNode" />
    ///  to insert.</param>
    ///  <param name="refChild">The <see cref="T:System.Xml.XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node.</exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only.</exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see cref="T:System.Xml.XmlNode" />
    ///  to insert.</param>
    ///  <param name="refChild">The <see cref="T:System.Xml.XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed after the <paramref name="refChild" />
    ///  .</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node.</exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only.</exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node specified with the new child node specified.</summary>
    ///  <param name="newChild">The new child <see cref="T:System.Xml.XmlNode" />
    ///  .</param>
    ///  <param name="oldChild">The <see cref="T:System.Xml.XmlNode" />
    ///  to replace.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node.</exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node.</exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes the specified child node.</summary>
    ///  <param name="oldChild">The <see cref="T:System.Xml.XmlNode" />
    ///  to remove.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only.</exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The <see cref="T:System.Xml.XmlNode" />
    ///  to add. If it is an <see cref="T:System.Xml.XmlDocumentFragment" />
    ///  , the entire contents of the document fragment are moved into the child list of this node.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node.</exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.</exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The <see cref="T:System.Xml.XmlNode" />
    ///  to add.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node.</exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.</exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save.</param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save.</param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Creates an <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  for navigating this object.</summary>
    ///<returns>An <see langword="XPathNavigator" />
    ///  object used to navigate the node. The <see langword="XPathNavigator" />
    ///  is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the parent of this node. For <see langword="XmlAttribute" />
    ///  nodes, this property always returns <see langword="null" />
    ///  .</summary>
    ///<returns>For <see langword="XmlAttribute" />
    ///  nodes, this property always returns <see langword="null" />
    ///  .</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>The qualified name of the attribute node.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>The name of the attribute node with the prefix removed. In the following example &lt;book bk:genre= 'novel'&gt;, the <see langword="LocalName" />
    ///  of the attribute is <see langword="genre" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If the attribute is not explicitly given a namespace, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only.</exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The namespaceURI of this node is <see langword="null" />
    ///  .The specified prefix is "xml", and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute, the specified prefix is "xmlns", and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/".This node is an attribute, and the qualifiedName of this node is "xmlns" [Namespaces].</exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>The node type for <see langword="XmlAttribute" />
    ///  nodes is XmlNodeType.Attribute.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>An XML document to which this node belongs.</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. For <see langword="XmlAttribute" />
    ///  nodes, this property is the value of attribute.</returns>
    ///<exception cref="T:System.ArgumentException">The node is read-only and a set operation is called.</exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the post-schema-validation-infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  containing the post-schema-validation-infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Sets the concatenated values of the node and all its children.</summary>
    ///<returns>The concatenated values of the node and all its children. For attribute nodes, this property has the same functionality as the <see cref="P:System.Xml.XmlAttribute.Value" />
    ///  property.</returns>
    property InnerText: string write set_InnerText;
    ///<summary>Gets a value indicating whether the attribute value was explicitly set.</summary>
    ///<returns><see langword="true" />
    ///  if this attribute was explicitly given a value in the original instance document; otherwise, <see langword="false" />
    ///  . A value of <see langword="false" />
    ///  indicates that the value of the attribute came from the DTD.</returns>
    property Specified: Boolean read get_Specified;
    ///<summary>Gets the <see cref="T:System.Xml.XmlElement" />
    ///  to which the attribute belongs.</summary>
    ///<returns>The <see langword="XmlElement" />
    ///  that the attribute belongs to or <see langword="null" />
    ///  if this attribute is not part of an <see langword="XmlElement" />
    ///  .</returns>
    property OwnerElement: DNXmlElement read get_OwnerElement;
    ///<summary>Sets the value of the attribute.</summary>
    ///<returns>The attribute value.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed.</exception>
    property InnerXml: string write set_InnerXml;
    ///<summary>Gets the base Uniform Resource Identifier (URI) of the node.</summary>
    ///<returns>The location from which the node was loaded or String.Empty if the node has no base URI. Attribute nodes have the same base URI as their owner element. If an attribute node does not have an owner element, <see langword="BaseURI" />
    ///  returns String.Empty.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see langword="XmlNode" />
    ///  . If there is no preceding node, <see langword="null" />
    ///  is returned.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The next <see langword="XmlNode" />
    ///  . If there is no next node, <see langword="null" />
    ///  is returned.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets the markup containing this node and all its child nodes.</summary>
    ///<returns>The markup containing this node and all its child nodes.
    ///<see langword="OuterXml" />
    ///  does not return default attributes.</returns>
    property OuterXml: string read get_OuterXml;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlAttribute = class(TDNGenericImport<DNXmlAttributeClass, DNXmlAttribute>) end;

  //-------------namespace: System.Xml----------------
  DNXmlDocumentClass = interface(DNXmlNodeClass)
  ['{72ECC820-5D8B-5542-9F37-BD21B3B1CDF4}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);
    procedure set_InnerText(value: string);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlDocument" />
    ///  class.</summary>
    {class} function init: DNXmlDocument; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlDocument" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="nt">The <see langword="XmlNameTable" />
    ///  to use. </param>
    {class} function init(nt: DNXmlNameTable): DNXmlDocument; overload;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  to use for resolving external resources.</summary>
    ///<returns>The <see langword="XmlResolver" />
    ///  to use.In version 1.1 of the.NET Framework, the caller must be fully trusted in order to specify an <see langword="XmlResolver" />
    ///  .</returns>
    ///<exception cref="T:System.Xml.XmlException">This property is set to <see langword="null" />
    ///  and an external DTD or entity is encountered. </exception>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>
    ///  Throws an <see cref="T:System.InvalidOperationException" />
    ///  in all cases.</summary>
    ///<returns>The values of the node and all its child nodes.</returns>
    ///<exception cref="T:System.InvalidOperationException">In all cases.</exception>
    {class} property InnerText: string write set_InnerText;
  end;

  ///<summary>Represents an XML document. You can use this class to load, validate, edit, add, and position XML in a document.</summary>
  [DNTypeName('System.Xml.XmlDocument')]
  DNXmlDocument = interface(DNXmlNode)
  ['{25C48904-3F45-36CE-9DAC-C679105D5308}']
  { getters & setters } 

    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_DocumentType: DNXmlDocumentType;
    function get_Implementation: DNXmlImplementation;
    function get_Name: string;
    function get_LocalName: string;
    function get_DocumentElement: DNXmlElement;
    function get_OwnerDocument: DNXmlDocument;
    function get_Schemas: DNXmlSchemaSet;
    procedure set_Schemas(value: DNXmlSchemaSet);
    procedure set_XmlResolver(value: DNXmlResolver);
    function get_NameTable: DNXmlNameTable;
    function get_PreserveWhitespace: Boolean;
    procedure set_PreserveWhitespace(value: Boolean);
    function get_IsReadOnly: Boolean;
    procedure set_InnerText(value: string);
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ChildNodes: DNXmlNodeList;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Attributes: DNXmlAttributeCollection;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_OuterXml: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { events } 

    procedure add_NodeInserting(value: DNXmlNodeChangedEventHandler);
    procedure remove_NodeInserting(value: DNXmlNodeChangedEventHandler);
    procedure add_NodeInserted(value: DNXmlNodeChangedEventHandler);
    procedure remove_NodeInserted(value: DNXmlNodeChangedEventHandler);
    procedure add_NodeRemoving(value: DNXmlNodeChangedEventHandler);
    procedure remove_NodeRemoving(value: DNXmlNodeChangedEventHandler);
    procedure add_NodeRemoved(value: DNXmlNodeChangedEventHandler);
    procedure remove_NodeRemoved(value: DNXmlNodeChangedEventHandler);
    procedure add_NodeChanging(value: DNXmlNodeChangedEventHandler);
    procedure remove_NodeChanging(value: DNXmlNodeChangedEventHandler);
    procedure add_NodeChanged(value: DNXmlNodeChangedEventHandler);
    procedure remove_NodeChanged(value: DNXmlNodeChangedEventHandler);

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The cloned <see langword="XmlDocument" />
    ///  node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Creates an <see cref="T:System.Xml.XmlAttribute" />
    ///  with the specified <see cref="P:System.Xml.XmlDocument.Name" />
    ///  .</summary>
    ///  <param name="name">The qualified name of the attribute. If the name contains a colon, the <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  property reflects the part of the name preceding the first colon and the <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  property reflects the part of the name following the first colon. The <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  remains empty unless the prefix is a recognized built-in prefix such as xmlns. In this case <see langword="NamespaceURI" />
    ///  has a value of http://www.w3.org/2000/xmlns/. </param>
    ///<returns>The new <see langword="XmlAttribute" />
    ///  .</returns>
    function CreateAttribute(name: string): DNXmlAttribute; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlCDataSection" />
    ///  containing the specified data.</summary>
    ///  <param name="data">The content of the new <see langword="XmlCDataSection" />
    ///  . </param>
    ///<returns>The new <see langword="XmlCDataSection" />
    ///  .</returns>
    function CreateCDataSection(data: string): DNXmlCDataSection;
    ///<summary>Creates an <see cref="T:System.Xml.XmlComment" />
    ///  containing the specified data.</summary>
    ///  <param name="data">The content of the new <see langword="XmlComment" />
    ///  . </param>
    ///<returns>The new <see langword="XmlComment" />
    ///  .</returns>
    function CreateComment(data: string): DNXmlComment;
    ///<summary>Returns a new <see cref="T:System.Xml.XmlDocumentType" />
    ///  object.</summary>
    ///  <param name="name">Name of the document type. </param>
    ///  <param name="publicId">The public identifier of the document type or <see langword="null" />
    ///  . You can specify a public URI and also a system identifier to identify the location of the external DTD subset.</param>
    ///  <param name="systemId">The system identifier of the document type or <see langword="null" />
    ///  . Specifies the URL of the file location for the external DTD subset.</param>
    ///  <param name="internalSubset">The DTD internal subset of the document type or <see langword="null" />
    ///  . </param>
    ///<returns>The new <see langword="XmlDocumentType" />
    ///  .</returns>
    function CreateDocumentType(name: string; publicId: string; systemId: string; internalSubset: string): DNXmlDocumentType;
    ///<summary>Creates an <see cref="T:System.Xml.XmlDocumentFragment" />
    ///  .</summary>
    ///<returns>The new <see langword="XmlDocumentFragment" />
    ///  .</returns>
    function CreateDocumentFragment: DNXmlDocumentFragment;
    ///<summary>Creates an element with the specified name.</summary>
    ///  <param name="name">The qualified name of the element. If the name contains a colon then the <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  property reflects the part of the name preceding the colon and the <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  property reflects the part of the name after the colon. The qualified name cannot include a prefix of'xmlns'. </param>
    ///<returns>The new <see langword="XmlElement" />
    ///  .</returns>
    function CreateElement(name: string): DNXmlElement; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlEntityReference" />
    ///  with the specified name.</summary>
    ///  <param name="name">The name of the entity reference. </param>
    ///<returns>The new <see langword="XmlEntityReference" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The name is invalid (for example, names starting with'#' are invalid.) </exception>
    function CreateEntityReference(name: string): DNXmlEntityReference;
    ///<summary>Creates an <see cref="T:System.Xml.XmlProcessingInstruction" />
    ///  with the specified name and data.</summary>
    ///  <param name="target">The name of the processing instruction. </param>
    ///  <param name="data">The data for the processing instruction. </param>
    ///<returns>The new <see langword="XmlProcessingInstruction" />
    ///  .</returns>
    function CreateProcessingInstruction(target: string; data: string): DNXmlProcessingInstruction;
    ///<summary>Creates an <see cref="T:System.Xml.XmlDeclaration" />
    ///  node with the specified values.</summary>
    ///  <param name="version">The version must be "1.0". </param>
    ///  <param name="encoding">The value of the encoding attribute. This is the encoding that is used when you save the <see cref="T:System.Xml.XmlDocument" />
    ///  to a file or a stream; therefore, it must be set to a string supported by the <see cref="T:System.Text.Encoding" />
    ///  class, otherwise <see cref="M:System.Xml.XmlDocument.Save(System.String)" />
    ///  fails. If this is <see langword="null" />
    ///  or String.Empty, the <see langword="Save" />
    ///  method does not write an encoding attribute on the XML declaration and therefore the default encoding, UTF-8, is used.Note: If the <see langword="XmlDocument" />
    ///  is saved to either a <see cref="T:System.IO.TextWriter" />
    ///  or an <see cref="T:System.Xml.XmlTextWriter" />
    ///  , this encoding value is discarded. Instead, the encoding of the <see langword="TextWriter" />
    ///  or the <see langword="XmlTextWriter" />
    ///  is used. This ensures that the XML written out can be read back using the correct encoding. </param>
    ///  <param name="standalone">The value must be either "yes" or "no". If this is <see langword="null" />
    ///  or String.Empty, the <see langword="Save" />
    ///  method does not write a standalone attribute on the XML declaration. </param>
    ///<returns>The new <see langword="XmlDeclaration" />
    ///  node.</returns>
    ///<exception cref="T:System.ArgumentException">The values of <paramref name="version" />
    ///  or <paramref name="standalone" />
    ///  are something other than the ones specified above. </exception>
    function CreateXmlDeclaration(version: string; encoding: string; standalone: string): DNXmlDeclaration;
    ///<summary>Creates an <see cref="T:System.Xml.XmlText" />
    ///  with the specified text.</summary>
    ///  <param name="text">The text for the Text node. </param>
    ///<returns>The new <see langword="XmlText" />
    ///  node.</returns>
    function CreateTextNode(text: string): DNXmlText;
    ///<summary>Creates an <see cref="T:System.Xml.XmlSignificantWhitespace" />
    ///  node.</summary>
    ///  <param name="text">The string must contain only the following characters &amp;#20; &amp;#10; &amp;#13; and &amp;#9; </param>
    ///<returns>A new <see langword="XmlSignificantWhitespace" />
    ///  node.</returns>
    function CreateSignificantWhitespace(text: string): DNXmlSignificantWhitespace;
    ///<summary>Creates a new <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object for navigating this document.</summary>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Creates an <see cref="T:System.Xml.XmlWhitespace" />
    ///  node.</summary>
    ///  <param name="text">The string must contain only the following characters &amp;#20; &amp;#10; &amp;#13; and &amp;#9; </param>
    ///<returns>A new <see langword="XmlWhitespace" />
    ///  node.</returns>
    function CreateWhitespace(text: string): DNXmlWhitespace;
    ///<summary>Returns an <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all descendant elements that match the specified <see cref="P:System.Xml.XmlDocument.Name" />
    ///  .</summary>
    ///  <param name="name">The qualified name to match. It is matched against the <see langword="Name" />
    ///  property of the matching node. The special value "*" matches all tags. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all matching nodes. If no nodes match <paramref name="name" />
    ///  , the returned collection will be empty.</returns>
    function GetElementsByTagName(name: string): DNXmlNodeList; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlAttribute" />
    ///  with the specified qualified name and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="qualifiedName">The qualified name of the attribute. If the name contains a colon then the <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  property will reflect the part of the name preceding the colon and the <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  property will reflect the part of the name after the colon. </param>
    ///  <param name="namespaceURI">The namespaceURI of the attribute. If the qualified name includes a prefix of xmlns, then this parameter must be http://www.w3.org/2000/xmlns/. </param>
    ///<returns>The new <see langword="XmlAttribute" />
    ///  .</returns>
    function CreateAttribute(qualifiedName: string; namespaceURI: string): DNXmlAttribute; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlElement" />
    ///  with the qualified name and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="qualifiedName">The qualified name of the element. If the name contains a colon then the <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  property will reflect the part of the name preceding the colon and the <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  property will reflect the part of the name after the colon. The qualified name cannot include a prefix of'xmlns'. </param>
    ///  <param name="namespaceURI">The namespace URI of the element. </param>
    ///<returns>The new <see langword="XmlElement" />
    ///  .</returns>
    function CreateElement(qualifiedName: string; namespaceURI: string): DNXmlElement; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all descendant elements that match the specified <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="localName">The LocalName to match. The special value "*" matches all tags. </param>
    ///  <param name="namespaceURI">NamespaceURI to match. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all matching nodes. If no nodes match the specified <paramref name="localName" />
    ///  and <paramref name="namespaceURI" />
    ///  , the returned collection will be empty.</returns>
    function GetElementsByTagName(localName: string; namespaceURI: string): DNXmlNodeList; overload;
    ///<summary>Gets the <see cref="T:System.Xml.XmlElement" />
    ///  with the specified ID.</summary>
    ///  <param name="elementId">The attribute ID to match. </param>
    ///<returns>The <see langword="XmlElement" />
    ///  with the matching ID or <see langword="null" />
    ///  if no matching element is found.</returns>
    function GetElementById(elementId: string): DNXmlElement;
    ///<summary>Imports a node from another document to the current document.</summary>
    ///  <param name="node">The node being imported. </param>
    ///  <param name="deep"><see langword="true" />
    ///  to perform a deep clone; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>The imported <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling this method on a node type which cannot be imported. </exception>
    function ImportNode(node: DNXmlNode; deep: Boolean): DNXmlNode;
    ///<summary>Creates an <see cref="T:System.Xml.XmlAttribute" />
    ///  with the specified <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  , <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  , and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="prefix">The prefix of the attribute (if any). String.Empty and <see langword="null" />
    ///  are equivalent. </param>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute (if any). String.Empty and <see langword="null" />
    ///  are equivalent. If <paramref name="prefix" />
    ///  is xmlns, then this parameter must be http://www.w3.org/2000/xmlns/; otherwise an exception is thrown. </param>
    ///<returns>The new <see langword="XmlAttribute" />
    ///  .</returns>
    function CreateAttribute(prefix: string; localName: string; namespaceURI: string): DNXmlAttribute; overload;
    ///<summary>Creates an element with the specified <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  , <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  , and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="prefix">The prefix of the new element (if any). String.Empty and <see langword="null" />
    ///  are equivalent. </param>
    ///  <param name="localName">The local name of the new element. </param>
    ///  <param name="namespaceURI">The namespace URI of the new element (if any). String.Empty and <see langword="null" />
    ///  are equivalent. </param>
    ///<returns>The new <see cref="T:System.Xml.XmlElement" />
    ///  .</returns>
    function CreateElement(prefix: string; localName: string; namespaceURI: string): DNXmlElement; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlNode" />
    ///  with the specified node type, <see cref="P:System.Xml.XmlDocument.Name" />
    ///  , and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="nodeTypeString">String version of the <see cref="T:System.Xml.XmlNodeType" />
    ///  of the new node. This parameter must be one of the values listed in the table below. </param>
    ///  <param name="name">The qualified name of the new node. If the name contains a colon, it is parsed into <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  and <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  components. </param>
    ///  <param name="namespaceURI">The namespace URI of the new node. </param>
    ///<returns>The new <see langword="XmlNode" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The name was not provided and the <see langword="XmlNodeType" />
    ///  requires a name; or <paramref name="nodeTypeString" />
    ///  is not one of the strings listed below. </exception>
    function CreateNode(nodeTypeString: string; name: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlNode" />
    ///  with the specified <see cref="T:System.Xml.XmlNodeType" />
    ///  , <see cref="P:System.Xml.XmlDocument.Name" />
    ///  , and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="type">The <see langword="XmlNodeType" />
    ///  of the new node. </param>
    ///  <param name="name">The qualified name of the new node. If the name contains a colon then it is parsed into <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  and <see cref="P:System.Xml.XmlDocument.LocalName" />
    ///  components. </param>
    ///  <param name="namespaceURI">The namespace URI of the new node. </param>
    ///<returns>The new <see langword="XmlNode" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The name was not provided and the <see langword="XmlNodeType" />
    ///  requires a name. </exception>
    function CreateNode(&type: DNXmlNodeType; name: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Creates an <see cref="T:System.Xml.XmlNode" />
    ///  object based on the information in the <see cref="T:System.Xml.XmlReader" />
    ///  . The reader must be positioned on a node or attribute.</summary>
    ///  <param name="reader">The XML source </param>
    ///<returns>The new <see langword="XmlNode" />
    ///  or <see langword="null" />
    ///  if no more nodes exist.</returns>
    ///<exception cref="T:System.NullReferenceException">The reader is positioned on a node type that does not translate to a valid DOM node (for example, EndElement or EndEntity). </exception>
    function ReadNode(reader: DNXmlReader): DNXmlNode;
    ///<summary>Loads the XML document from the specified URL.</summary>
    ///  <param name="filename">URL for the file containing the XML document to load. The URL can be either a local file or an HTTP URL (a Web address).</param>
    ///<exception cref="T:System.Xml.XmlException">There is a load or parse error in the XML. In this case, a <see cref="T:System.IO.FileNotFoundException" />
    ///  is raised. </exception><exception cref="T:System.ArgumentException"><paramref name="filename" />
    ///  is a zero-length string, contains only white space, or contains one or more invalid characters as defined by <see cref="F:System.IO.Path.InvalidPathChars" />
    ///  . </exception><exception cref="T:System.ArgumentNullException"><paramref name="filename" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length. For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters. </exception><exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid (for example, it is on an unmapped drive). </exception><exception cref="T:System.IO.IOException">An I/O error occurred while opening the file. </exception><exception cref="T:System.UnauthorizedAccessException"><paramref name="filename" />
    ///  specified a file that is read-only.-or- This operation is not supported on the current platform.-or-
    ///  <paramref name="filename" />
    ///  specified a directory.-or- The caller does not have the required permission. </exception><exception cref="T:System.IO.FileNotFoundException">The file specified in <paramref name="filename" />
    ///  was not found. </exception><exception cref="T:System.NotSupportedException"><paramref name="filename" />
    ///  is in an invalid format. </exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    procedure Load(filename: string); overload;
    ///<summary>Loads the XML document from the specified stream.</summary>
    ///  <param name="inStream">The stream containing the XML document to load. </param>
    ///<exception cref="T:System.Xml.XmlException">There is a load or parse error in the XML. In this case, a <see cref="T:System.IO.FileNotFoundException" />
    ///  is raised. </exception>
    procedure Load(inStream: DDN.mscorlib.DNStream); overload;
    ///<summary>Loads the XML document from the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="txtReader">The <see langword="TextReader" />
    ///  used to feed the XML data into the document. </param>
    ///<exception cref="T:System.Xml.XmlException">There is a load or parse error in the XML. In this case, the document remains empty. </exception>
    procedure Load(txtReader: DDN.mscorlib.DNTextReader); overload;
    ///<summary>Loads the XML document from the specified <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  used to feed the XML data into the document. </param>
    ///<exception cref="T:System.Xml.XmlException">There is a load or parse error in the XML. In this case, the document remains empty. </exception>
    procedure Load(reader: DNXmlReader); overload;
    ///<summary>Loads the XML document from the specified string.</summary>
    ///  <param name="xml">String containing the XML document to load. </param>
    ///<exception cref="T:System.Xml.XmlException">There is a load or parse error in the XML. In this case, the document remains empty. </exception>
    procedure LoadXml(xml: string);
    ///<summary>Saves the XML document to the specified file. If the specified file exists, this method overwrites it.</summary>
    ///  <param name="filename">The location of the file where you want to save the document. </param>
    ///<exception cref="T:System.Xml.XmlException">The operation would not result in a well formed XML document (for example, no document element or duplicate XML declarations). </exception>
    procedure Save(filename: string); overload;
    ///<summary>Saves the XML document to the specified stream.</summary>
    ///  <param name="outStream">The stream to which you want to save. </param>
    ///<exception cref="T:System.Xml.XmlException">The operation would not result in a well formed XML document (for example, no document element or duplicate XML declarations). </exception>
    procedure Save(outStream: DDN.mscorlib.DNStream); overload;
    ///<summary>Saves the XML document to the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="writer">The <see langword="TextWriter" />
    ///  to which you want to save. </param>
    ///<exception cref="T:System.Xml.XmlException">The operation would not result in a well formed XML document (for example, no document element or duplicate XML declarations). </exception>
    procedure Save(writer: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Saves the <see langword="XmlDocument" />
    ///  node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the <see langword="XmlDocument" />
    ///  node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="xw">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(xw: DNXmlWriter);
    ///<summary>Validates the <see cref="T:System.Xml.XmlDocument" />
    ///  against the XML Schema Definition Language (XSD) schemas contained in the <see cref="P:System.Xml.XmlDocument.Schemas" />
    ///  property.</summary>
    ///  <param name="validationEventHandler">The <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  object that receives information about schema validation warnings and errors.</param>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">A schema validation event occurred and no <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  object was specified.</exception>
    procedure Validate(validationEventHandler: DNValidationEventHandler); overload;
    ///<summary>Creates a <see cref="T:System.Xml.XmlNode" />
    ///  with the specified <see cref="T:System.Xml.XmlNodeType" />
    ///  , <see cref="P:System.Xml.XmlNode.Prefix" />
    ///  , <see cref="P:System.Xml.XmlDocument.Name" />
    ///  , and <see cref="P:System.Xml.XmlNode.NamespaceURI" />
    ///  .</summary>
    ///  <param name="type">The <see langword="XmlNodeType" />
    ///  of the new node. </param>
    ///  <param name="prefix">The prefix of the new node. </param>
    ///  <param name="name">The local name of the new node. </param>
    ///  <param name="namespaceURI">The namespace URI of the new node. </param>
    ///<returns>The new <see langword="XmlNode" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The name was not provided and the <see langword="XmlNodeType" />
    ///  requires a name. </exception>
    function CreateNode(&type: DNXmlNodeType; prefix: string; name: string; namespaceURI: string): DNXmlNode; overload;
    ///<summary>Saves the XML document to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    ///<exception cref="T:System.Xml.XmlException">The operation would not result in a well formed XML document (for example, no document element or duplicate XML declarations). </exception>
    procedure Save(w: DNXmlWriter); overload;
    ///<summary>Validates the <see cref="T:System.Xml.XmlNode" />
    ///  object specified against the XML Schema Definition Language (XSD) schemas in the <see cref="P:System.Xml.XmlDocument.Schemas" />
    ///  property.</summary>
    ///  <param name="validationEventHandler">The <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  object that receives information about schema validation warnings and errors.</param>
    ///  <param name="nodeToValidate">The <see cref="T:System.Xml.XmlNode" />
    ///  object created from an <see cref="T:System.Xml.XmlDocument" />
    ///  to validate.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XmlNode" />
    ///  object parameter was not created from an <see cref="T:System.Xml.XmlDocument" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlNode" />
    ///  object parameter is not an element, attribute, document fragment, or the root node.</exception><exception cref="T:System.Xml.Schema.XmlSchemaValidationException">A schema validation event occurred and no <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  object was specified.</exception>
    procedure Validate(validationEventHandler: DNValidationEventHandler; nodeToValidate: DNXmlNode); overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node. </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node <paramref name="oldChild" />
    ///  with <paramref name="newChild" />
    ///  node.</summary>
    ///  <param name="newChild">The new node to put in the child list. </param>
    ///  <param name="oldChild">The node being replaced in the list. </param>
    ///<returns>The node replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node. </exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes specified child node.</summary>
    ///  <param name="oldChild">The node being removed. </param>
    ///<returns>The node removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only. </exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location.</param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location. </param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the type of the current node.</summary>
    ///<returns>The node type. For <see langword="XmlDocument" />
    ///  nodes, this value is XmlNodeType.Document.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent node of this node (for nodes that can have parents).</summary>
    ///<returns>Always returns <see langword="null" />
    ///  .</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets the node containing the DOCTYPE declaration.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  containing the DocumentType (DOCTYPE declaration).</returns>
    property DocumentType: DNXmlDocumentType read get_DocumentType;
    ///<summary>Gets the <see cref="T:System.Xml.XmlImplementation" />
    ///  object for the current document.</summary>
    ///<returns>The <see langword="XmlImplementation" />
    ///  object for the current document.</returns>
    property &Implementation: DNXmlImplementation read get_Implementation;
    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For <see langword="XmlDocument" />
    ///  nodes, the name is #document.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For <see langword="XmlDocument" />
    ///  nodes, the local name is #document.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the root <see cref="T:System.Xml.XmlElement" />
    ///  for the document.</summary>
    ///<returns>The <see langword="XmlElement" />
    ///  that represents the root of the XML document tree. If no root exists, <see langword="null" />
    ///  is returned.</returns>
    property DocumentElement: DNXmlElement read get_DocumentElement;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which the current node belongs.</summary>
    ///<returns>For <see langword="XmlDocument" />
    ///  nodes (<see cref="P:System.Xml.XmlDocument.NodeType" />
    ///  equals XmlNodeType.Document), this property always returns <see langword="null" />
    ///  .</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object associated with this <see cref="T:System.Xml.XmlDocument" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object containing the XML Schema Definition Language (XSD) schemas associated with this <see cref="T:System.Xml.XmlDocument" />
    ///  ; otherwise, an empty <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object.</returns>
    property Schemas: DNXmlSchemaSet read get_Schemas write set_Schemas;
    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  to use for resolving external resources.</summary>
    ///<returns>The <see langword="XmlResolver" />
    ///  to use.In version 1.1 of the.NET Framework, the caller must be fully trusted in order to specify an <see langword="XmlResolver" />
    ///  .</returns>
    ///<exception cref="T:System.Xml.XmlException">This property is set to <see langword="null" />
    ///  and an external DTD or entity is encountered. </exception>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this implementation.</summary>
    ///<returns>An <see langword="XmlNameTable" />
    ///  enabling you to get the atomized version of a string within the document.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets or sets a value indicating whether to preserve white space in element content.</summary>
    ///<returns><see langword="true" />
    ///  to preserve white space; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property PreserveWhitespace: Boolean read get_PreserveWhitespace write set_PreserveWhitespace;
    ///<summary>Gets a value indicating whether the current node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the current node is read-only; otherwise <see langword="false" />
    ///  . <see langword="XmlDocument" />
    ///  nodes always return <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>
    ///  Throws an <see cref="T:System.InvalidOperationException" />
    ///  in all cases.</summary>
    ///<returns>The values of the node and all its child nodes.</returns>
    ///<exception cref="T:System.InvalidOperationException">In all cases.</exception>
    property InnerText: string write set_InnerText;
    ///<summary>Gets or sets the markup representing the children of the current node.</summary>
    ///<returns>The markup of the children of the current node.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Returns the Post-Schema-Validation-Infoset (PSVI) of the node.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object representing the PSVI of the node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The location from which the node was loaded.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Value Attribute The value of the attribute. CDATASection The content of the CDATA Section. Comment The content of the comment. Document
    ///<see langword="null" />
    ///  . DocumentFragment
    ///<see langword="null" />
    ///  . DocumentType
    ///<see langword="null" />
    ///  . Element
    ///<see langword="null" />
    ///  . You can use the <see cref="P:System.Xml.XmlElement.InnerText" />
    ///  or <see cref="P:System.Xml.XmlElement.InnerXml" />
    ///  properties to access the value of the element node. Entity
    ///<see langword="null" />
    ///  . EntityReference
    ///<see langword="null" />
    ///  . Notation
    ///<see langword="null" />
    ///  . ProcessingInstruction The entire content excluding the target. Text The content of the text node. SignificantWhitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. Whitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. XmlDeclaration The content of the declaration (that is, everything between &lt;?xml and ?&gt;). </returns>
    ///<exception cref="T:System.ArgumentException">Setting the value of a node that is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the value of a node that is not supposed to have a value (for example, an Element node). </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see langword="XmlNode" />
    ///  . If there is no preceding node, <see langword="null" />
    ///  is returned.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The next <see langword="XmlNode" />
    ///  . If there is no next node, <see langword="null" />
    ///  is returned.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. For example, <see langword="Prefix" />
    ///  is bk for the element &lt;bk:book&gt;. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The specified prefix is "xml" and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute and the specified prefix is "xmlns" and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/ ".This node is an attribute and the qualifiedName of this node is "xmlns". </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the markup containing this node and all its child nodes.</summary>
    ///<returns>The markup containing this node and all its child nodes.
    ///<see langword="OuterXml" />
    ///  does not return default attributes.</returns>
    property OuterXml: string read get_OuterXml;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlDocument = class(TDNGenericImport<DNXmlDocumentClass, DNXmlDocument>) end;

  //-------------namespace: System.Xml----------------
  DNXmlDocumentFragmentClass = interface(DNXmlNodeClass)
  ['{6E0EA61D-9BC6-5CA3-BBB9-2C261777C15D}']
  end;

  ///<summary>Represents a lightweight object that is useful for tree insert operations.</summary>
  [DNTypeName('System.Xml.XmlDocumentFragment')]
  DNXmlDocumentFragment = interface(DNXmlNode)
  ['{495A1294-FF3E-3F56-A99F-A1AA85127036}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_OwnerDocument: DNXmlDocument;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ChildNodes: DNXmlNodeList;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Attributes: DNXmlAttributeCollection;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_OuterXml: string;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Creates an <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  for navigating this object.</summary>
    ///<returns>An <see langword="XPathNavigator" />
    ///  object used to navigate the node. The <see langword="XPathNavigator" />
    ///  is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node. </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node <paramref name="oldChild" />
    ///  with <paramref name="newChild" />
    ///  node.</summary>
    ///  <param name="newChild">The new node to put in the child list. </param>
    ///  <param name="oldChild">The node being replaced in the list. </param>
    ///<returns>The node replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node. </exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes specified child node.</summary>
    ///  <param name="oldChild">The node being removed. </param>
    ///<returns>The node removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only. </exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location.</param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location. </param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For <see langword="XmlDocumentFragment" />
    ///  , the name is <see langword="#document-fragment" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For <see langword="XmlDocumentFragment" />
    ///  nodes, the local name is <see langword="#document-fragment" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For <see langword="XmlDocumentFragment" />
    ///  nodes, this value is XmlNodeType.DocumentFragment.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The parent of this node.For <see langword="XmlDocumentFragment" />
    ///  nodes, this property is always <see langword="null" />
    ///  .</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>The <see langword="XmlDocument" />
    ///  to which this node belongs.</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets or sets the markup representing the children of this node.</summary>
    ///<returns>The markup of the children of this node.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Value Attribute The value of the attribute. CDATASection The content of the CDATA Section. Comment The content of the comment. Document
    ///<see langword="null" />
    ///  . DocumentFragment
    ///<see langword="null" />
    ///  . DocumentType
    ///<see langword="null" />
    ///  . Element
    ///<see langword="null" />
    ///  . You can use the <see cref="P:System.Xml.XmlElement.InnerText" />
    ///  or <see cref="P:System.Xml.XmlElement.InnerXml" />
    ///  properties to access the value of the element node. Entity
    ///<see langword="null" />
    ///  . EntityReference
    ///<see langword="null" />
    ///  . Notation
    ///<see langword="null" />
    ///  . ProcessingInstruction The entire content excluding the target. Text The content of the text node. SignificantWhitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. Whitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. XmlDeclaration The content of the declaration (that is, everything between &lt;?xml and ?&gt;). </returns>
    ///<exception cref="T:System.ArgumentException">Setting the value of a node that is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the value of a node that is not supposed to have a value (for example, an Element node). </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see langword="XmlNode" />
    ///  . If there is no preceding node, <see langword="null" />
    ///  is returned.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The next <see langword="XmlNode" />
    ///  . If there is no next node, <see langword="null" />
    ///  is returned.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. For example, <see langword="Prefix" />
    ///  is bk for the element &lt;bk:book&gt;. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The specified prefix is "xml" and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute and the specified prefix is "xmlns" and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/ ".This node is an attribute and the qualifiedName of this node is "xmlns". </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets or sets the concatenated values of the node and all its child nodes.</summary>
    ///<returns>The concatenated values of the node and all its child nodes.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the markup containing this node and all its child nodes.</summary>
    ///<returns>The markup containing this node and all its child nodes.
    ///<see langword="OuterXml" />
    ///  does not return default attributes.</returns>
    property OuterXml: string read get_OuterXml;
    ///<summary>Gets the post schema validation infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the post schema validation infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The location from which the node was loaded or String.Empty if the node has no base URI.</returns>
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlDocumentFragment = class(TDNGenericImport<DNXmlDocumentFragmentClass, DNXmlDocumentFragment>) end;

  //-------------namespace: System.Xml----------------
  DNXmlEntityClass = interface(DNXmlNodeClass)
  ['{58105CFA-A4B1-5776-8C52-FC78B1A05533}']
  end;

  ///<summary>Represents an entity declaration, such as &lt;!ENTITY... &gt;.</summary>
  [DNTypeName('System.Xml.XmlEntity')]
  DNXmlEntity = interface(DNXmlNode)
  ['{BBF8E184-152C-3140-917E-A6A3030C164E}']
  { getters & setters } 

    function get_IsReadOnly: Boolean;
    function get_Name: string;
    function get_LocalName: string;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_PublicId: string;
    function get_SystemId: string;
    function get_NotationName: string;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_BaseURI: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node. Entity nodes cannot be cloned. Calling this method on an <see cref="T:System.Xml.XmlEntity" />
    ///  object throws an exception.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself.</param>
    ///<returns>Returns a copy of the <see cref="T:System.Xml.XmlNode" />
    ///  from which the method is called.</returns>
    ///<exception cref="T:System.InvalidOperationException">Entity nodes cannot be cloned. Calling this method on an <see cref="T:System.Xml.XmlEntity" />
    ///  object throws an exception.</exception>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . For <see langword="XmlEntity" />
    ///  nodes, this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . For <see langword="XmlEntity" />
    ///  nodes, this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Creates an <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  for navigating this object.</summary>
    ///<returns>An <see langword="XPathNavigator" />
    ///  object used to navigate the node. The <see langword="XPathNavigator" />
    ///  is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node. </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node <paramref name="oldChild" />
    ///  with <paramref name="newChild" />
    ///  node.</summary>
    ///  <param name="newChild">The new node to put in the child list. </param>
    ///  <param name="oldChild">The node being replaced in the list. </param>
    ///<returns>The node replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node. </exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes specified child node.</summary>
    ///  <param name="oldChild">The node being removed. </param>
    ///<returns>The node removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only. </exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location.</param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location. </param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .Because <see langword="XmlEntity" />
    ///  nodes are read-only, this property always returns <see langword="true" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets the name of the node.</summary>
    ///<returns>The name of the entity.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the name of the node without the namespace prefix.</summary>
    ///<returns>For <see langword="XmlEntity" />
    ///  nodes, this property returns the name of the entity.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the concatenated values of the entity node and all its children.</summary>
    ///<returns>The concatenated values of the node and all its children.</returns>
    ///<exception cref="T:System.InvalidOperationException">Attempting to set the property. </exception>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the type of the node.</summary>
    ///<returns>The node type. For <see langword="XmlEntity" />
    ///  nodes, the value is XmlNodeType.Entity.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the value of the public identifier on the entity declaration.</summary>
    ///<returns>The public identifier on the entity. If there is no public identifier, <see langword="null" />
    ///  is returned.</returns>
    property PublicId: string read get_PublicId;
    ///<summary>Gets the value of the system identifier on the entity declaration.</summary>
    ///<returns>The system identifier on the entity. If there is no system identifier, <see langword="null" />
    ///  is returned.</returns>
    property SystemId: string read get_SystemId;
    ///<summary>Gets the name of the optional NDATA attribute on the entity declaration.</summary>
    ///<returns>The name of the NDATA attribute. If there is no NDATA, <see langword="null" />
    ///  is returned.</returns>
    property NotationName: string read get_NotationName;
    ///<summary>Gets the markup representing this node and all its children.</summary>
    ///<returns>For <see langword="XmlEntity" />
    ///  nodes, String.Empty is returned.</returns>
    property OuterXml: string read get_OuterXml;
    ///<summary>Gets the markup representing the children of this node.</summary>
    ///<returns>For <see langword="XmlEntity" />
    ///  nodes, String.Empty is returned.</returns>
    ///<exception cref="T:System.InvalidOperationException">Attempting to set the property. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Gets the base Uniform Resource Identifier (URI) of the current node.</summary>
    ///<returns>The location from which the node was loaded.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Value Attribute The value of the attribute. CDATASection The content of the CDATA Section. Comment The content of the comment. Document
    ///<see langword="null" />
    ///  . DocumentFragment
    ///<see langword="null" />
    ///  . DocumentType
    ///<see langword="null" />
    ///  . Element
    ///<see langword="null" />
    ///  . You can use the <see cref="P:System.Xml.XmlElement.InnerText" />
    ///  or <see cref="P:System.Xml.XmlElement.InnerXml" />
    ///  properties to access the value of the element node. Entity
    ///<see langword="null" />
    ///  . EntityReference
    ///<see langword="null" />
    ///  . Notation
    ///<see langword="null" />
    ///  . ProcessingInstruction The entire content excluding the target. Text The content of the text node. SignificantWhitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. Whitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. XmlDeclaration The content of the declaration (that is, everything between &lt;?xml and ?&gt;). </returns>
    ///<exception cref="T:System.ArgumentException">Setting the value of a node that is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the value of a node that is not supposed to have a value (for example, an Element node). </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.NodeType Return Value of ParentNode Attribute, Document, DocumentFragment, Entity, Notation Returns <see langword="null" />
    ///  ; these nodes do not have parents. CDATA Returns the element or entity reference containing the CDATA section. Comment Returns the element, entity reference, document type, or document containing the comment. DocumentType Returns the document node. Element Returns the parent node of the element. If the element is the root node in the tree, the parent is the document node. EntityReference Returns the element, attribute, or entity reference containing the entity reference. ProcessingInstruction Returns the document, element, document type, or entity reference containing the processing instruction. Text Returns the parent element, attribute, or entity reference containing the text node. </returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see langword="XmlNode" />
    ///  . If there is no preceding node, <see langword="null" />
    ///  is returned.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The next <see langword="XmlNode" />
    ///  . If there is no next node, <see langword="null" />
    ///  is returned.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.If the node is an <see cref="T:System.Xml.XmlDocument" />
    ///  (NodeType equals XmlNodeType.Document), this property returns <see langword="null" />
    ///  .</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. For example, <see langword="Prefix" />
    ///  is bk for the element &lt;bk:book&gt;. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The specified prefix is "xml" and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute and the specified prefix is "xmlns" and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/ ".This node is an attribute and the qualifiedName of this node is "xmlns". </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the post schema validation infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the post schema validation infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlEntity = class(TDNGenericImport<DNXmlEntityClass, DNXmlEntity>) end;

  //-------------namespace: System.Xml----------------
  DNXmlLinkedNodeClass = interface(DNXmlNodeClass)
  ['{91F2964A-C0B9-50C3-A29B-A15A2597FEC1}']
  end;

  ///<summary>Gets the node immediately preceding or following this node.</summary>
  [DNTypeName('System.Xml.XmlLinkedNode')]
  DNXmlLinkedNode = interface(DNXmlNode)
  ['{E1A8457C-7DBB-37D9-95EF-B132116B2C67}']
  { getters & setters } 

    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Name: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_LocalName: string;
    function get_IsReadOnly: Boolean;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates an <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  for navigating this object.</summary>
    ///<returns>An <see langword="XPathNavigator" />
    ///  object used to navigate the node. The <see langword="XPathNavigator" />
    ///  is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node. </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node <paramref name="oldChild" />
    ///  with <paramref name="newChild" />
    ///  node.</summary>
    ///  <param name="newChild">The new node to put in the child list. </param>
    ///  <param name="oldChild">The node being replaced in the list. </param>
    ///<returns>The node replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node. </exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes specified child node.</summary>
    ///  <param name="oldChild">The node being removed. </param>
    ///<returns>The node removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only. </exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location.</param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location. </param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Creates a duplicate of the node, when overridden in a derived class.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The cloned node.</returns>
    ///<exception cref="T:System.InvalidOperationException">Calling this method on a node type that cannot be cloned. </exception>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    ///<summary>Saves the current node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  , when overridden in a derived class.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the child nodes of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  , when overridden in a derived class.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this node or <see langword="null" />
    ///  if one does not exist.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets the qualified name of the node, when overridden in a derived class.</summary>
    ///<returns>The qualified name of the node. The name returned is dependent on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Name Attribute The qualified name of the attribute. CDATA #cdata-section Comment #comment Document #document DocumentFragment #document-fragment DocumentType The document type name. Element The qualified name of the element. Entity The name of the entity. EntityReference The name of the entity referenced. Notation The notation name. ProcessingInstruction The target of the processing instruction. Text #text Whitespace #whitespace SignificantWhitespace #significant-whitespace XmlDeclaration #xml-declaration </returns>
    property Name: string read get_Name;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Value Attribute The value of the attribute. CDATASection The content of the CDATA Section. Comment The content of the comment. Document
    ///<see langword="null" />
    ///  . DocumentFragment
    ///<see langword="null" />
    ///  . DocumentType
    ///<see langword="null" />
    ///  . Element
    ///<see langword="null" />
    ///  . You can use the <see cref="P:System.Xml.XmlElement.InnerText" />
    ///  or <see cref="P:System.Xml.XmlElement.InnerXml" />
    ///  properties to access the value of the element node. Entity
    ///<see langword="null" />
    ///  . EntityReference
    ///<see langword="null" />
    ///  . Notation
    ///<see langword="null" />
    ///  . ProcessingInstruction The entire content excluding the target. Text The content of the text node. SignificantWhitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. Whitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. XmlDeclaration The content of the declaration (that is, everything between &lt;?xml and ?&gt;). </returns>
    ///<exception cref="T:System.ArgumentException">Setting the value of a node that is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the value of a node that is not supposed to have a value (for example, an Element node). </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the type of the current node, when overridden in a derived class.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlNodeType" />
    ///  values.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.NodeType Return Value of ParentNode Attribute, Document, DocumentFragment, Entity, Notation Returns <see langword="null" />
    ///  ; these nodes do not have parents. CDATA Returns the element or entity reference containing the CDATA section. Comment Returns the element, entity reference, document type, or document containing the comment. DocumentType Returns the document node. Element Returns the parent node of the element. If the element is the root node in the tree, the parent is the document node. EntityReference Returns the element, attribute, or entity reference containing the entity reference. ProcessingInstruction Returns the document, element, document type, or entity reference containing the processing instruction. Text Returns the parent element, attribute, or entity reference containing the text node. </returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.If the node is an <see cref="T:System.Xml.XmlDocument" />
    ///  (NodeType equals XmlNodeType.Document), this property returns <see langword="null" />
    ///  .</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. For example, <see langword="Prefix" />
    ///  is bk for the element &lt;bk:book&gt;. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The specified prefix is "xml" and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute and the specified prefix is "xmlns" and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/ ".This node is an attribute and the qualifiedName of this node is "xmlns". </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the local name of the node, when overridden in a derived class.</summary>
    ///<returns>The name of the node with the prefix removed. For example, <see langword="LocalName" />
    ///  is book for the element &lt;bk:book&gt;.The name returned is dependent on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Name Attribute The local name of the attribute. CDATA #cdata-section Comment #comment Document #document DocumentFragment #document-fragment DocumentType The document type name. Element The local name of the element. Entity The name of the entity. EntityReference The name of the entity referenced. Notation The notation name. ProcessingInstruction The target of the processing instruction. Text #text Whitespace #whitespace SignificantWhitespace #significant-whitespace XmlDeclaration #xml-declaration </returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets or sets the concatenated values of the node and all its child nodes.</summary>
    ///<returns>The concatenated values of the node and all its child nodes.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the markup containing this node and all its child nodes.</summary>
    ///<returns>The markup containing this node and all its child nodes.
    ///<see langword="OuterXml" />
    ///  does not return default attributes.</returns>
    property OuterXml: string read get_OuterXml;
    ///<summary>Gets or sets the markup representing only the child nodes of this node.</summary>
    ///<returns>The markup of the child nodes of this node.
    ///<see langword="InnerXml" />
    ///  does not return default attributes.</returns>
    ///<exception cref="T:System.InvalidOperationException">Setting this property on a node that cannot have child nodes. </exception><exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Gets the post schema validation infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the post schema validation infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The location from which the node was loaded or String.Empty if the node has no base URI.</returns>
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlLinkedNode = class(TDNGenericImport<DNXmlLinkedNodeClass, DNXmlLinkedNode>) end;

  //-------------namespace: System.Xml----------------
  DNXmlCharacterDataClass = interface(DNXmlLinkedNodeClass)
  ['{42D10EF7-A1BE-5E21-BD42-86ECD3B911FD}']
  end;

  ///<summary>Provides text manipulation methods that are used by several classes.</summary>
  [DNTypeName('System.Xml.XmlCharacterData')]
  DNXmlCharacterData = interface(DNXmlLinkedNode)
  ['{6DDDB0FA-19BB-3660-ABC7-A8E351F02593}']
  { getters & setters } 

    function get_Value: string;
    procedure set_Value(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Data: string;
    procedure set_Data(value: string);
    function get_Length: Int32;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Name: string;
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_LocalName: string;
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Retrieves a substring of the full string from the specified range.</summary>
    ///  <param name="offset">The position within the string to start retrieving. An offset of zero indicates the starting point is at the start of the data. </param>
    ///  <param name="count">The number of characters to retrieve. </param>
    ///<returns>The substring corresponding to the specified range.</returns>
    function Substring(offset: Int32; count: Int32): string;
    ///<summary>Appends the specified string to the end of the character data of the node.</summary>
    ///  <param name="strData">The string to insert into the existing string. </param>
    procedure AppendData(strData: string);
    ///<summary>Inserts the specified string at the specified character offset.</summary>
    ///  <param name="offset">The position within the string to insert the supplied string data. </param>
    ///  <param name="strData">The string data that is to be inserted into the existing string. </param>
    procedure InsertData(offset: Int32; strData: string);
    ///<summary>Removes a range of characters from the node.</summary>
    ///  <param name="offset">The position within the string to start deleting. </param>
    ///  <param name="count">The number of characters to delete. </param>
    procedure DeleteData(offset: Int32; count: Int32);
    ///<summary>Replaces the specified number of characters starting at the specified offset with the specified string.</summary>
    ///  <param name="offset">The position within the string to start replacing. </param>
    ///  <param name="count">The number of characters to replace. </param>
    ///  <param name="strData">The new data that replaces the old string data. </param>
    procedure ReplaceData(offset: Int32; count: Int32; strData: string);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function CloneNode(deep: Boolean): DNXmlNode;
    function Supports(feature: string; version: string): Boolean;
    procedure WriteTo(w: DNXmlWriter);
    procedure WriteContentTo(w: DNXmlWriter);
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value of the node.</returns>
    ///<exception cref="T:System.ArgumentException">Node is read-only. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets the concatenated values of the node and all the children of the node.</summary>
    ///<returns>The concatenated values of the node and all the children of the node.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Contains the data of the node.</summary>
    ///<returns>The data of the node.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets the length of the data, in characters.</summary>
    ///<returns>The length, in characters, of the string in the <see cref="P:System.Xml.XmlCharacterData.Data" />
    ///  property. The length may be zero; that is, CharacterData nodes can be empty.</returns>
    property Length: Int32 read get_Length;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this node or <see langword="null" />
    ///  if one does not exist.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    property Name: string read get_Name;
    property NodeType: DNXmlNodeType read get_NodeType;
    property ParentNode: DNXmlNode read get_ParentNode;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property LocalName: string read get_LocalName;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlCharacterData = class(TDNGenericImport<DNXmlCharacterDataClass, DNXmlCharacterData>) end;

  //-------------namespace: System.Xml----------------
  DNXmlCDataSectionClass = interface(DNXmlCharacterDataClass)
  ['{97FBAC7B-CA59-5B48-A7E2-B077AF8D1A99}']
  end;

  ///<summary>Represents a CDATA section.</summary>
  [DNTypeName('System.Xml.XmlCDataSection')]
  DNXmlCDataSection = interface(DNXmlCharacterData)
  ['{1810EA9B-175D-3CDC-8921-290FD122D830}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_PreviousText: DNXmlNode;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Data: string;
    procedure set_Data(value: string);
    function get_Length: Int32;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. Because CDATA nodes do not have children, regardless of the parameter setting, the cloned node will always include the data content. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Retrieves a substring of the full string from the specified range.</summary>
    ///  <param name="offset">The position within the string to start retrieving. An offset of zero indicates the starting point is at the start of the data. </param>
    ///  <param name="count">The number of characters to retrieve. </param>
    ///<returns>The substring corresponding to the specified range.</returns>
    function Substring(offset: Int32; count: Int32): string;
    ///<summary>Appends the specified string to the end of the character data of the node.</summary>
    ///  <param name="strData">The string to insert into the existing string. </param>
    procedure AppendData(strData: string);
    ///<summary>Inserts the specified string at the specified character offset.</summary>
    ///  <param name="offset">The position within the string to insert the supplied string data. </param>
    ///  <param name="strData">The string data that is to be inserted into the existing string. </param>
    procedure InsertData(offset: Int32; strData: string);
    ///<summary>Removes a range of characters from the node.</summary>
    ///  <param name="offset">The position within the string to start deleting. </param>
    ///  <param name="count">The number of characters to delete. </param>
    procedure DeleteData(offset: Int32; count: Int32);
    ///<summary>Replaces the specified number of characters starting at the specified offset with the specified string.</summary>
    ///  <param name="offset">The position within the string to start replacing. </param>
    ///  <param name="count">The number of characters to replace. </param>
    ///  <param name="strData">The new data that replaces the old string data. </param>
    procedure ReplaceData(offset: Int32; count: Int32; strData: string);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For CDATA nodes, the name is <see langword="#cdata-section" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For CDATA nodes, the local name is <see langword="#cdata-section" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>The node type. For CDATA nodes, the value is XmlNodeType.CDATA.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value of the node.</returns>
    ///<exception cref="T:System.ArgumentException">Node is read-only. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets the concatenated values of the node and all the children of the node.</summary>
    ///<returns>The concatenated values of the node and all the children of the node.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Contains the data of the node.</summary>
    ///<returns>The data of the node.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets the length of the data, in characters.</summary>
    ///<returns>The length, in characters, of the string in the <see cref="P:System.Xml.XmlCharacterData.Data" />
    ///  property. The length may be zero; that is, CharacterData nodes can be empty.</returns>
    property Length: Int32 read get_Length;
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    property NextSibling: DNXmlNode read get_NextSibling;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
  end;

  TDNXmlCDataSection = class(TDNGenericImport<DNXmlCDataSectionClass, DNXmlCDataSection>) end;

  //-------------namespace: System.Xml----------------
  DNXmlCommentClass = interface(DNXmlCharacterDataClass)
  ['{BB4F609E-8620-50D3-BD93-A5228DAAD94E}']
  end;

  ///<summary>Represents the content of an XML comment.</summary>
  [DNTypeName('System.Xml.XmlComment')]
  DNXmlComment = interface(DNXmlCharacterData)
  ['{CC1B4DB8-000C-375C-85B6-C4F457CA604C}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Data: string;
    procedure set_Data(value: string);
    function get_Length: Int32;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. Because comment nodes do not have children, the cloned node always includes the text content, regardless of the parameter setting. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . Because comment nodes do not have children, this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Retrieves a substring of the full string from the specified range.</summary>
    ///  <param name="offset">The position within the string to start retrieving. An offset of zero indicates the starting point is at the start of the data. </param>
    ///  <param name="count">The number of characters to retrieve. </param>
    ///<returns>The substring corresponding to the specified range.</returns>
    function Substring(offset: Int32; count: Int32): string;
    ///<summary>Appends the specified string to the end of the character data of the node.</summary>
    ///  <param name="strData">The string to insert into the existing string. </param>
    procedure AppendData(strData: string);
    ///<summary>Inserts the specified string at the specified character offset.</summary>
    ///  <param name="offset">The position within the string to insert the supplied string data. </param>
    ///  <param name="strData">The string data that is to be inserted into the existing string. </param>
    procedure InsertData(offset: Int32; strData: string);
    ///<summary>Removes a range of characters from the node.</summary>
    ///  <param name="offset">The position within the string to start deleting. </param>
    ///  <param name="count">The number of characters to delete. </param>
    procedure DeleteData(offset: Int32; count: Int32);
    ///<summary>Replaces the specified number of characters starting at the specified offset with the specified string.</summary>
    ///  <param name="offset">The position within the string to start replacing. </param>
    ///  <param name="count">The number of characters to replace. </param>
    ///  <param name="strData">The new data that replaces the old string data. </param>
    procedure ReplaceData(offset: Int32; count: Int32; strData: string);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For comment nodes, the value is <see langword="#comment" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For comment nodes, the value is <see langword="#comment" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For comment nodes, the value is XmlNodeType.Comment.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value of the node.</returns>
    ///<exception cref="T:System.ArgumentException">Node is read-only. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets the concatenated values of the node and all the children of the node.</summary>
    ///<returns>The concatenated values of the node and all the children of the node.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Contains the data of the node.</summary>
    ///<returns>The data of the node.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets the length of the data, in characters.</summary>
    ///<returns>The length, in characters, of the string in the <see cref="P:System.Xml.XmlCharacterData.Data" />
    ///  property. The length may be zero; that is, CharacterData nodes can be empty.</returns>
    property Length: Int32 read get_Length;
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    property NextSibling: DNXmlNode read get_NextSibling;
    property ParentNode: DNXmlNode read get_ParentNode;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlComment = class(TDNGenericImport<DNXmlCommentClass, DNXmlComment>) end;

  //-------------namespace: System.Xml----------------
  DNXmlSignificantWhitespaceClass = interface(DNXmlCharacterDataClass)
  ['{D3D69425-089C-5BEC-8B98-2869CBCD58BA}']
  end;

  ///<summary>Represents white space between markup in a mixed content node or white space within an xml:space= 'preserve' scope. This is also referred to as significant white space.</summary>
  [DNTypeName('System.Xml.XmlSignificantWhitespace')]
  DNXmlSignificantWhitespace = interface(DNXmlCharacterData)
  ['{0B172DBB-0D28-360D-B6DA-C98B3EC1449A}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_PreviousText: DNXmlNode;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Data: string;
    procedure set_Data(value: string);
    function get_Length: Int32;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. For significant white space nodes, the cloned node always includes the data value, regardless of the parameter setting. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Retrieves a substring of the full string from the specified range.</summary>
    ///  <param name="offset">The position within the string to start retrieving. An offset of zero indicates the starting point is at the start of the data. </param>
    ///  <param name="count">The number of characters to retrieve. </param>
    ///<returns>The substring corresponding to the specified range.</returns>
    function Substring(offset: Int32; count: Int32): string;
    ///<summary>Appends the specified string to the end of the character data of the node.</summary>
    ///  <param name="strData">The string to insert into the existing string. </param>
    procedure AppendData(strData: string);
    ///<summary>Inserts the specified string at the specified character offset.</summary>
    ///  <param name="offset">The position within the string to insert the supplied string data. </param>
    ///  <param name="strData">The string data that is to be inserted into the existing string. </param>
    procedure InsertData(offset: Int32; strData: string);
    ///<summary>Removes a range of characters from the node.</summary>
    ///  <param name="offset">The position within the string to start deleting. </param>
    ///  <param name="count">The number of characters to delete. </param>
    procedure DeleteData(offset: Int32; count: Int32);
    ///<summary>Replaces the specified number of characters starting at the specified offset with the specified string.</summary>
    ///  <param name="offset">The position within the string to start replacing. </param>
    ///  <param name="count">The number of characters to replace. </param>
    ///  <param name="strData">The new data that replaces the old string data. </param>
    procedure ReplaceData(offset: Int32; count: Int32; strData: string);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For <see langword="XmlSignificantWhitespace" />
    ///  nodes, this property returns <see langword="#significant-whitespace" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For <see langword="XmlSignificantWhitespace" />
    ///  nodes, this property returns <see langword="#significant-whitespace" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For <see langword="XmlSignificantWhitespace" />
    ///  nodes, this value is XmlNodeType.SignificantWhitespace.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of the current node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  parent node of the current node.</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The white space characters found in the node.</returns>
    ///<exception cref="T:System.ArgumentException">Setting <see langword="Value" />
    ///  to invalid white space characters. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
    ///<summary>Gets or sets the concatenated values of the node and all the children of the node.</summary>
    ///<returns>The concatenated values of the node and all the children of the node.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Contains the data of the node.</summary>
    ///<returns>The data of the node.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets the length of the data, in characters.</summary>
    ///<returns>The length, in characters, of the string in the <see cref="P:System.Xml.XmlCharacterData.Data" />
    ///  property. The length may be zero; that is, CharacterData nodes can be empty.</returns>
    property Length: Int32 read get_Length;
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    property NextSibling: DNXmlNode read get_NextSibling;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
  end;

  TDNXmlSignificantWhitespace = class(TDNGenericImport<DNXmlSignificantWhitespaceClass, DNXmlSignificantWhitespace>) end;

  //-------------namespace: System.Xml----------------
  DNXmlTextClass = interface(DNXmlCharacterDataClass)
  ['{0651B7EA-6BE9-59ED-A83D-2E5F61F97A05}']
  end;

  ///<summary>Represents the text content of an element or attribute.</summary>
  [DNTypeName('System.Xml.XmlText')]
  DNXmlText = interface(DNXmlCharacterData)
  ['{C23B6FD2-1BB3-3560-8729-8F78B16B5B5C}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_PreviousText: DNXmlNode;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Data: string;
    procedure set_Data(value: string);
    function get_Length: Int32;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Splits the node into two nodes at the specified offset, keeping both in the tree as siblings.</summary>
    ///  <param name="offset">The offset at which to split the node. </param>
    ///<returns>The new node.</returns>
    function SplitText(offset: Int32): DNXmlText;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . <see langword="XmlText" />
    ///  nodes do not have children, so this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Retrieves a substring of the full string from the specified range.</summary>
    ///  <param name="offset">The position within the string to start retrieving. An offset of zero indicates the starting point is at the start of the data. </param>
    ///  <param name="count">The number of characters to retrieve. </param>
    ///<returns>The substring corresponding to the specified range.</returns>
    function Substring(offset: Int32; count: Int32): string;
    ///<summary>Appends the specified string to the end of the character data of the node.</summary>
    ///  <param name="strData">The string to insert into the existing string. </param>
    procedure AppendData(strData: string);
    ///<summary>Inserts the specified string at the specified character offset.</summary>
    ///  <param name="offset">The position within the string to insert the supplied string data. </param>
    ///  <param name="strData">The string data that is to be inserted into the existing string. </param>
    procedure InsertData(offset: Int32; strData: string);
    ///<summary>Removes a range of characters from the node.</summary>
    ///  <param name="offset">The position within the string to start deleting. </param>
    ///  <param name="count">The number of characters to delete. </param>
    procedure DeleteData(offset: Int32; count: Int32);
    ///<summary>Replaces the specified number of characters starting at the specified offset with the specified string.</summary>
    ///  <param name="offset">The position within the string to start replacing. </param>
    ///  <param name="count">The number of characters to replace. </param>
    ///  <param name="strData">The new data that replaces the old string data. </param>
    procedure ReplaceData(offset: Int32; count: Int32; strData: string);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For text nodes, this property returns <see langword="#text" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For text nodes, this property returns <see langword="#text" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For text nodes, this value is XmlNodeType.Text.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The content of the text node.</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
    ///<summary>Gets or sets the concatenated values of the node and all the children of the node.</summary>
    ///<returns>The concatenated values of the node and all the children of the node.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Contains the data of the node.</summary>
    ///<returns>The data of the node.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets the length of the data, in characters.</summary>
    ///<returns>The length, in characters, of the string in the <see cref="P:System.Xml.XmlCharacterData.Data" />
    ///  property. The length may be zero; that is, CharacterData nodes can be empty.</returns>
    property Length: Int32 read get_Length;
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    property NextSibling: DNXmlNode read get_NextSibling;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
  end;

  TDNXmlText = class(TDNGenericImport<DNXmlTextClass, DNXmlText>) end;

  //-------------namespace: System.Xml----------------
  DNXmlWhitespaceClass = interface(DNXmlCharacterDataClass)
  ['{2A70CCA8-A245-5913-A121-09B607B6A137}']
  end;

  ///<summary>Represents white space in element content.</summary>
  [DNTypeName('System.Xml.XmlWhitespace')]
  DNXmlWhitespace = interface(DNXmlCharacterData)
  ['{7665AD2A-852F-30AD-8E7A-09633B25E173}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_PreviousText: DNXmlNode;
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Data: string;
    procedure set_Data(value: string);
    function get_Length: Int32;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. For white space nodes, the cloned node always includes the data value, regardless of the parameter setting. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to save.</param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Retrieves a substring of the full string from the specified range.</summary>
    ///  <param name="offset">The position within the string to start retrieving. An offset of zero indicates the starting point is at the start of the data. </param>
    ///  <param name="count">The number of characters to retrieve. </param>
    ///<returns>The substring corresponding to the specified range.</returns>
    function Substring(offset: Int32; count: Int32): string;
    ///<summary>Appends the specified string to the end of the character data of the node.</summary>
    ///  <param name="strData">The string to insert into the existing string. </param>
    procedure AppendData(strData: string);
    ///<summary>Inserts the specified string at the specified character offset.</summary>
    ///  <param name="offset">The position within the string to insert the supplied string data. </param>
    ///  <param name="strData">The string data that is to be inserted into the existing string. </param>
    procedure InsertData(offset: Int32; strData: string);
    ///<summary>Removes a range of characters from the node.</summary>
    ///  <param name="offset">The position within the string to start deleting. </param>
    ///  <param name="count">The number of characters to delete. </param>
    procedure DeleteData(offset: Int32; count: Int32);
    ///<summary>Replaces the specified number of characters starting at the specified offset with the specified string.</summary>
    ///  <param name="offset">The position within the string to start replacing. </param>
    ///  <param name="count">The number of characters to replace. </param>
    ///  <param name="strData">The new data that replaces the old string data. </param>
    procedure ReplaceData(offset: Int32; count: Int32; strData: string);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For <see langword="XmlWhitespace" />
    ///  nodes, this property returns <see langword="#whitespace" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For <see langword="XmlWhitespace" />
    ///  nodes, this property returns <see langword="#whitespace" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the node.</summary>
    ///<returns>For <see langword="XmlWhitespace" />
    ///  nodes, the value is <see cref="F:System.Xml.XmlNodeType.Whitespace" />
    ///  .</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of the current node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  parent node of the current node.</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The white space characters found in the node.</returns>
    ///<exception cref="T:System.ArgumentException">Setting <see cref="P:System.Xml.XmlWhitespace.Value" />
    ///  to invalid white space characters. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
    ///<summary>Gets or sets the concatenated values of the node and all the children of the node.</summary>
    ///<returns>The concatenated values of the node and all the children of the node.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Contains the data of the node.</summary>
    ///<returns>The data of the node.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets the length of the data, in characters.</summary>
    ///<returns>The length, in characters, of the string in the <see cref="P:System.Xml.XmlCharacterData.Data" />
    ///  property. The length may be zero; that is, CharacterData nodes can be empty.</returns>
    property Length: Int32 read get_Length;
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    property NextSibling: DNXmlNode read get_NextSibling;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
  end;

  TDNXmlWhitespace = class(TDNGenericImport<DNXmlWhitespaceClass, DNXmlWhitespace>) end;

  //-------------namespace: System.Xml----------------
  DNXmlDeclarationClass = interface(DNXmlLinkedNodeClass)
  ['{A6529FEA-8312-512A-987C-49BDDB60B87F}']
  end;

  ///<summary>Represents the XML declaration node &lt;?xml version='1.0'...?&gt;.</summary>
  [DNTypeName('System.Xml.XmlDeclaration')]
  DNXmlDeclaration = interface(DNXmlLinkedNode)
  ['{E98CE747-E1FC-355C-8454-95C884B8FB04}']
  { getters & setters } 

    function get_Version: string;
    function get_Encoding: string;
    procedure set_Encoding(value: string);
    function get_Standalone: string;
    procedure set_Standalone(value: string);
    function get_Value: string;
    procedure set_Value(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. Because <see langword="XmlDeclaration" />
    ///  nodes do not have children, the cloned node always includes the data value, regardless of the parameter setting. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . Because <see langword="XmlDeclaration" />
    ///  nodes do not have children, this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the XML version of the document.</summary>
    ///<returns>The value is always <see langword="1.0" />
    ///  .</returns>
    property Version: string read get_Version;
    ///<summary>Gets or sets the encoding level of the XML document.</summary>
    ///<returns>The valid character encoding name. The most commonly supported character encoding names for XML are the following: Category Encoding Names Unicode UTF-8, UTF-16 ISO 10646 ISO-10646-UCS-2, ISO-10646-UCS-4 ISO 8859 ISO-8859-n (where "n" is a digit from 1 to 9) JIS X-0208-1997 ISO-2022-JP, Shift_JIS, EUC-JP This value is optional. If a value is not set, this property returns String.Empty.If an encoding attribute is not included, UTF-8 encoding is assumed when the document is written or saved out.</returns>
    property Encoding: string read get_Encoding write set_Encoding;
    ///<summary>Gets or sets the value of the standalone attribute.</summary>
    ///<returns>Valid values are <see langword="yes" />
    ///  if all entity declarations required by the XML document are contained within the document or <see langword="no" />
    ///  if an external document type definition (DTD) is required. If a standalone attribute is not present in the XML declaration, this property returns String.Empty.</returns>
    property Standalone: string read get_Standalone write set_Standalone;
    ///<summary>Gets or sets the value of the <see langword="XmlDeclaration" />
    ///  .</summary>
    ///<returns>The contents of the <see langword="XmlDeclaration" />
    ///  (that is, everything between &lt;?xml and ?&gt;).</returns>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets or sets the concatenated values of the <see langword="XmlDeclaration" />
    ///  .</summary>
    ///<returns>The concatenated values of the <see langword="XmlDeclaration" />
    ///  (that is, everything between &lt;?xml and ?&gt;).</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For <see langword="XmlDeclaration" />
    ///  nodes, the name is <see langword="xml" />
    ///  .</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For <see langword="XmlDeclaration" />
    ///  nodes, the local name is <see langword="xml" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For <see langword="XmlDeclaration" />
    ///  nodes, this value is XmlNodeType.XmlDeclaration.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this node or <see langword="null" />
    ///  if one does not exist.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    property ParentNode: DNXmlNode read get_ParentNode;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlDeclaration = class(TDNGenericImport<DNXmlDeclarationClass, DNXmlDeclaration>) end;

  //-------------namespace: System.Xml----------------
  DNXmlDocumentTypeClass = interface(DNXmlLinkedNodeClass)
  ['{BEC420DE-802C-5F38-95F7-CA44F66DB28E}']
  end;

  ///<summary>Represents the document type declaration.</summary>
  [DNTypeName('System.Xml.XmlDocumentType')]
  DNXmlDocumentType = interface(DNXmlLinkedNode)
  ['{7AF5641A-36C3-3113-83DA-937C8D756FC0}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_IsReadOnly: Boolean;
    function get_Entities: DNXmlNamedNodeMap;
    function get_Notations: DNXmlNamedNodeMap;
    function get_PublicId: string;
    function get_SystemId: string;
    function get_InternalSubset: string;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. For document type nodes, the cloned node always includes the subtree, regardless of the parameter setting. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . For <see langword="XmlDocumentType" />
    ///  nodes, this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For DocumentType nodes, this property returns the name of the document type.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For DocumentType nodes, this property returns the name of the document type.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For DocumentType nodes, this value is XmlNodeType.DocumentType.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .Because DocumentType nodes are read-only, this property always returns <see langword="true" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets the collection of <see cref="T:System.Xml.XmlEntity" />
    ///  nodes declared in the document type declaration.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlNamedNodeMap" />
    ///  containing the <see langword="XmlEntity" />
    ///  nodes. The returned <see langword="XmlNamedNodeMap" />
    ///  is read-only.</returns>
    property Entities: DNXmlNamedNodeMap read get_Entities;
    ///<summary>Gets the collection of <see cref="T:System.Xml.XmlNotation" />
    ///  nodes present in the document type declaration.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlNamedNodeMap" />
    ///  containing the <see langword="XmlNotation" />
    ///  nodes. The returned <see langword="XmlNamedNodeMap" />
    ///  is read-only.</returns>
    property Notations: DNXmlNamedNodeMap read get_Notations;
    ///<summary>Gets the value of the public identifier on the DOCTYPE declaration.</summary>
    ///<returns>The public identifier on the DOCTYPE. If there is no public identifier, <see langword="null" />
    ///  is returned.</returns>
    property PublicId: string read get_PublicId;
    ///<summary>Gets the value of the system identifier on the DOCTYPE declaration.</summary>
    ///<returns>The system identifier on the DOCTYPE. If there is no system identifier, <see langword="null" />
    ///  is returned.</returns>
    property SystemId: string read get_SystemId;
    ///<summary>Gets the value of the document type definition (DTD) internal subset on the DOCTYPE declaration.</summary>
    ///<returns>The DTD internal subset on the DOCTYPE. If there is no DTD internal subset, String.Empty is returned.</returns>
    property InternalSubset: string read get_InternalSubset;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this node or <see langword="null" />
    ///  if one does not exist.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    property Value: string read get_Value write set_Value;
    property ParentNode: DNXmlNode read get_ParentNode;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property InnerText: string read get_InnerText write set_InnerText;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlDocumentType = class(TDNGenericImport<DNXmlDocumentTypeClass, DNXmlDocumentType>) end;

  //-------------namespace: System.Xml----------------
  DNXmlElementClass = interface(DNXmlLinkedNodeClass)
  ['{95FBF49A-C7B8-52DE-9824-77FC0B51F4A3}']
  end;

  ///<summary>Represents an element.</summary>
  [DNTypeName('System.Xml.XmlElement')]
  DNXmlElement = interface(DNXmlLinkedNode)
  ['{4F4034C5-F0F2-3631-965C-95B3A6E74446}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_ParentNode: DNXmlNode;
    function get_OwnerDocument: DNXmlDocument;
    function get_IsEmpty: Boolean;
    procedure set_IsEmpty(value: Boolean);
    function get_Attributes: DNXmlAttributeCollection;
    function get_HasAttributes: Boolean;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_NextSibling: DNXmlNode;
    function get_PreviousSibling: DNXmlNode;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ChildNodes: DNXmlNodeList;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself (and its attributes if the node is an <see langword="XmlElement" />
    ///  ). </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Returns the value for the attribute with the specified name.</summary>
    ///  <param name="name">The name of the attribute to retrieve. This is a qualified name. It is matched against the <see langword="Name" />
    ///  property of the matching node. </param>
    ///<returns>The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value.</returns>
    function GetAttribute(name: string): string; overload;
    ///<summary>Sets the value of the attribute with the specified name.</summary>
    ///  <param name="name">The name of the attribute to create or alter. This is a qualified name. If the name contains a colon it is parsed into prefix and local name components. </param>
    ///  <param name="value">The value to set for the attribute. </param>
    ///<exception cref="T:System.Xml.XmlException">The specified name contains an invalid character. </exception><exception cref="T:System.ArgumentException">The node is read-only. </exception>
    procedure SetAttribute(name: string; value: string); overload;
    ///<summary>Removes an attribute by name.</summary>
    ///  <param name="name">The name of the attribute to remove.This is a qualified name. It is matched against the <see langword="Name" />
    ///  property of the matching node. </param>
    ///<exception cref="T:System.ArgumentException">The node is read-only. </exception>
    procedure RemoveAttribute(name: string); overload;
    ///<summary>Returns the <see langword="XmlAttribute" />
    ///  with the specified name.</summary>
    ///  <param name="name">The name of the attribute to retrieve. This is a qualified name. It is matched against the <see langword="Name" />
    ///  property of the matching node. </param>
    ///<returns>The specified <see langword="XmlAttribute" />
    ///  or <see langword="null" />
    ///  if a matching attribute was not found.</returns>
    function GetAttributeNode(name: string): DNXmlAttribute; overload;
    ///<summary>Adds the specified <see cref="T:System.Xml.XmlAttribute" />
    ///  .</summary>
    ///  <param name="newAttr">The <see langword="XmlAttribute" />
    ///  node to add to the attribute collection for this element. </param>
    ///<returns>If the attribute replaces an existing attribute with the same name, the old <see langword="XmlAttribute" />
    ///  is returned; otherwise, <see langword="null" />
    ///  is returned.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="newAttr" />
    ///  was created from a different document than the one that created this node. Or this node is read-only. </exception><exception cref="T:System.InvalidOperationException">The <paramref name="newAttr" />
    ///  is already an attribute of another <see langword="XmlElement" />
    ///  object. You must explicitly clone <see langword="XmlAttribute" />
    ///  nodes to re-use them in other <see langword="XmlElement" />
    ///  objects. </exception>
    function SetAttributeNode(newAttr: DNXmlAttribute): DNXmlAttribute; overload;
    ///<summary>Removes the specified <see cref="T:System.Xml.XmlAttribute" />
    ///  .</summary>
    ///  <param name="oldAttr">The <see langword="XmlAttribute" />
    ///  node to remove. If the removed attribute has a default value, it is immediately replaced. </param>
    ///<returns>The removed <see langword="XmlAttribute" />
    ///  or <see langword="null" />
    ///  if <paramref name="oldAttr" />
    ///  is not an attribute node of the <see langword="XmlElement" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception>
    function RemoveAttributeNode(oldAttr: DNXmlAttribute): DNXmlAttribute; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all descendant elements that match the specified <see cref="P:System.Xml.XmlElement.Name" />
    ///  .</summary>
    ///  <param name="name">The name tag to match. This is a qualified name. It is matched against the <see langword="Name" />
    ///  property of the matching node. The asterisk (*) is a special value that matches all tags. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all matching nodes. The list is empty if there are no matching nodes.</returns>
    function GetElementsByTagName(name: string): DNXmlNodeList; overload;
    ///<summary>Returns the value for the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute to retrieve. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute to retrieve. </param>
    ///<returns>The value of the specified attribute. An empty string is returned if a matching attribute is not found or if the attribute does not have a specified or default value.</returns>
    function GetAttribute(localName: string; namespaceURI: string): string; overload;
    ///<summary>Sets the value of the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///  <param name="value">The value to set for the attribute. </param>
    ///<returns>The attribute value.</returns>
    function SetAttribute(localName: string; namespaceURI: string; value: string): string; overload;
    ///<summary>Removes an attribute with the specified local name and namespace URI. (If the removed attribute has a default value, it is immediately replaced).</summary>
    ///  <param name="localName">The local name of the attribute to remove. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute to remove. </param>
    ///<exception cref="T:System.ArgumentException">The node is read-only. </exception>
    procedure RemoveAttribute(localName: string; namespaceURI: string); overload;
    ///<summary>Returns the <see cref="T:System.Xml.XmlAttribute" />
    ///  with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns>The specified <see langword="XmlAttribute" />
    ///  or <see langword="null" />
    ///  if a matching attribute was not found.</returns>
    function GetAttributeNode(localName: string; namespaceURI: string): DNXmlAttribute; overload;
    ///<summary>Adds the specified <see cref="T:System.Xml.XmlAttribute" />
    ///  .</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns>The <see langword="XmlAttribute" />
    ///  to add.</returns>
    function SetAttributeNode(localName: string; namespaceURI: string): DNXmlAttribute; overload;
    ///<summary>Removes the <see cref="T:System.Xml.XmlAttribute" />
    ///  specified by the local name and namespace URI. (If the removed attribute has a default value, it is immediately replaced).</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns>The removed <see langword="XmlAttribute" />
    ///  or <see langword="null" />
    ///  if the <see langword="XmlElement" />
    ///  does not have a matching attribute node.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception>
    function RemoveAttributeNode(localName: string; namespaceURI: string): DNXmlAttribute; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all descendant elements that match the specified <see cref="P:System.Xml.XmlElement.LocalName" />
    ///  and <see cref="P:System.Xml.XmlElement.NamespaceURI" />
    ///  .</summary>
    ///  <param name="localName">The local name to match. The asterisk (*) is a special value that matches all tags. </param>
    ///  <param name="namespaceURI">The namespace URI to match. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a list of all matching nodes. The list is empty if there are no matching nodes.</returns>
    function GetElementsByTagName(localName: string; namespaceURI: string): DNXmlNodeList; overload;
    ///<summary>Determines whether the current node has an attribute with the specified name.</summary>
    ///  <param name="name">The name of the attribute to find. This is a qualified name. It is matched against the <see langword="Name" />
    ///  property of the matching node. </param>
    ///<returns><see langword="true" />
    ///  if the current node has the specified attribute; otherwise, <see langword="false" />
    ///  .</returns>
    function HasAttribute(name: string): Boolean; overload;
    ///<summary>Determines whether the current node has an attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute to find. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute to find. </param>
    ///<returns><see langword="true" />
    ///  if the current node has the specified attribute; otherwise, <see langword="false" />
    ///  .</returns>
    function HasAttribute(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Saves the current node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Removes the attribute node with the specified index from the element. (If the removed attribute has a default value, it is immediately replaced).</summary>
    ///  <param name="i">The index of the node to remove. The first node has index 0. </param>
    ///<returns>The attribute node removed or <see langword="null" />
    ///  if there is no node at the given index.</returns>
    function RemoveAttributeAt(i: Int32): DNXmlNode;
    ///<summary>Removes all specified attributes from the element. Default attributes are not removed.</summary>
    procedure RemoveAllAttributes;
    ///<summary>Removes all specified attributes and children of the current node. Default attributes are not removed.</summary>
    procedure RemoveAll;
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>The qualified name of the node. For <see langword="XmlElement" />
    ///  nodes, this is the tag name of the element.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the current node.</summary>
    ///<returns>The name of the current node with the prefix removed. For example, <see langword="LocalName" />
    ///  is book for the element &lt;bk:book&gt;.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The namespaceURI of this node is <see langword="null" />
    ///  .The specified prefix is "xml" and the namespaceURI of this node is different from http://www.w3.org/XML/1998/namespace. </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>The node type. For <see langword="XmlElement" />
    ///  nodes, this value is XmlNodeType.Element.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.</returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>The <see langword="XmlDocument" />
    ///  to which this element belongs.</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets or sets the tag format of the element.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the element is to be serialized in the short tag format "&lt;item/&gt;"; <see langword="false" />
    ///  for the long format "&lt;item&gt;&lt;/item&gt;".When setting this property, if set to <see langword="true" />
    ///  , the children of the element are removed and the element is serialized in the short tag format. If set to <see langword="false" />
    ///  , the value of the property is changed (regardless of whether or not the element has content); if the element is empty, it is serialized in the long format.This property is a Microsoft extension to the Document Object Model (DOM).</returns>
    property IsEmpty: Boolean read get_IsEmpty write set_IsEmpty;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the list of attributes for this node.</summary>
    ///<returns><see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the list of attributes for this node.</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets a <see langword="boolean" />
    ///  value indicating whether the current node has any attributes.</summary>
    ///<returns><see langword="true" />
    ///  if the current node has attributes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasAttributes: Boolean read get_HasAttributes;
    ///<summary>Gets the post schema validation infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the post schema validation infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets or sets the markup representing just the children of this node.</summary>
    ///<returns>The markup of the children of this node.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML specified when setting this property is not well-formed. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Gets or sets the concatenated values of the node and all its children.</summary>
    ///<returns>The concatenated values of the node and all its children.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this element.</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  immediately following this element.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    property Value: string read get_Value write set_Value;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlElement = class(TDNGenericImport<DNXmlElementClass, DNXmlElement>) end;

  //-------------namespace: System.Xml----------------
  DNXmlEntityReferenceClass = interface(DNXmlLinkedNodeClass)
  ['{90401A09-6381-574B-823A-E3F8F43DAFCD}']
  end;

  ///<summary>Represents an entity reference node.</summary>
  [DNTypeName('System.Xml.XmlEntityReference')]
  DNXmlEntityReference = interface(DNXmlLinkedNode)
  ['{A49C5C6E-C1A3-30E6-AED4-6AB2D32BA301}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_IsReadOnly: Boolean;
    function get_BaseURI: string;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. For <see langword="XmlEntityReference" />
    ///  nodes, this method always returns an entity reference node with no children. The replacement text is set when the node is inserted into a parent. </param>
    ///<returns>The cloned node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the node.</summary>
    ///<returns>The name of the entity referenced.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For <see langword="XmlEntityReference" />
    ///  nodes, this property returns the name of the entity referenced.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value of the node. For <see langword="XmlEntityReference" />
    ///  nodes, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">Node is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the property. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the type of the node.</summary>
    ///<returns>The node type. For <see langword="XmlEntityReference" />
    ///  nodes, the value is XmlNodeType.EntityReference.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .Because <see langword="XmlEntityReference" />
    ///  nodes are read-only, this property always returns <see langword="true" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets the base Uniform Resource Identifier (URI) of the current node.</summary>
    ///<returns>The location from which the node was loaded.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this node or <see langword="null" />
    ///  if one does not exist.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    property ParentNode: DNXmlNode read get_ParentNode;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property InnerText: string read get_InnerText write set_InnerText;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlEntityReference = class(TDNGenericImport<DNXmlEntityReferenceClass, DNXmlEntityReference>) end;

  //-------------namespace: System.Xml----------------
  DNXmlProcessingInstructionClass = interface(DNXmlLinkedNodeClass)
  ['{A00F64E7-9C95-55E8-BE6E-9B41100EE844}']
  end;

  ///<summary>Represents a processing instruction, which XML defines to keep processor-specific information in the text of the document.</summary>
  [DNTypeName('System.Xml.XmlProcessingInstruction')]
  DNXmlProcessingInstruction = interface(DNXmlLinkedNode)
  ['{2550041F-0896-38C3-9876-092B4D27211E}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_Value: string;
    procedure set_Value(value: string);
    function get_Target: string;
    function get_Data: string;
    procedure set_Data(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_NodeType: DNXmlNodeType;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_IsReadOnly: Boolean;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself. </param>
    ///<returns>The duplicate node.</returns>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves all the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . Because ProcessingInstruction nodes do not have children, this method has no effect.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    function CreateNavigator: DNXPathNavigator;
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    procedure Normalize;
    function Clone: DNXmlNode;
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    procedure RemoveAll;
    function GetNamespaceOfPrefix(prefix: string): string;
    function GetPrefixOfNamespace(namespaceURI: string): string;
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the qualified name of the node.</summary>
    ///<returns>For processing instruction nodes, this property returns the target of the processing instruction.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the node.</summary>
    ///<returns>For processing instruction nodes, this property returns the target of the processing instruction.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The entire content of the processing instruction, excluding the target.</returns>
    ///<exception cref="T:System.ArgumentException">Node is read-only. </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the target of the processing instruction.</summary>
    ///<returns>The target of the processing instruction.</returns>
    property Target: string read get_Target;
    ///<summary>Gets or sets the content of the processing instruction, excluding the target.</summary>
    ///<returns>The content of the processing instruction, excluding the target.</returns>
    property Data: string read get_Data write set_Data;
    ///<summary>Gets or sets the concatenated values of the node and all its children.</summary>
    ///<returns>The concatenated values of the node and all its children.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>For <see langword="XmlProcessingInstruction" />
    ///  nodes, this value is XmlNodeType.ProcessingInstruction.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see cref="T:System.Xml.XmlNode" />
    ///  or <see langword="null" />
    ///  if one does not exist.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  immediately following this node or <see langword="null" />
    ///  if one does not exist.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    property ParentNode: DNXmlNode read get_ParentNode;
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    property FirstChild: DNXmlNode read get_FirstChild;
    property LastChild: DNXmlNode read get_LastChild;
    property HasChildNodes: Boolean read get_HasChildNodes;
    property NamespaceURI: string read get_NamespaceURI;
    property Prefix: string read get_Prefix write set_Prefix;
    property IsReadOnly: Boolean read get_IsReadOnly;
    property OuterXml: string read get_OuterXml;
    property InnerXml: string read get_InnerXml write set_InnerXml;
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlProcessingInstruction = class(TDNGenericImport<DNXmlProcessingInstructionClass, DNXmlProcessingInstruction>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNotationClass = interface(DNXmlNodeClass)
  ['{B4568DBC-491D-59E9-AC4E-B505B14EA8BF}']
  end;

  ///<summary>Represents a notation declaration, such as &lt;!NOTATION... &gt;.</summary>
  [DNTypeName('System.Xml.XmlNotation')]
  DNXmlNotation = interface(DNXmlNode)
  ['{E0331AF9-CC77-3962-9CAF-E24976945240}']
  { getters & setters } 

    function get_Name: string;
    function get_LocalName: string;
    function get_NodeType: DNXmlNodeType;
    function get_IsReadOnly: Boolean;
    function get_PublicId: string;
    function get_SystemId: string;
    function get_OuterXml: string;
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_Value: string;
    procedure set_Value(value: string);
    function get_ParentNode: DNXmlNode;
    function get_ChildNodes: DNXmlNodeList;
    function get_PreviousSibling: DNXmlNode;
    function get_NextSibling: DNXmlNode;
    function get_Attributes: DNXmlAttributeCollection;
    function get_OwnerDocument: DNXmlDocument;
    function get_FirstChild: DNXmlNode;
    function get_LastChild: DNXmlNode;
    function get_HasChildNodes: Boolean;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    procedure set_Prefix(value: string);
    function get_InnerText: string;
    procedure set_InnerText(value: string);
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_BaseURI: string;
    function get_Item(name: string): DNXmlElement; overload;
    function get_Item(localname: string; ns: string): DNXmlElement; overload;
    function get_PreviousText: DNXmlNode;

  { methods } 

    ///<summary>Creates a duplicate of this node. Notation nodes cannot be cloned. Calling this method on an <see cref="T:System.Xml.XmlNotation" />
    ///  object throws an exception.</summary>
    ///  <param name="deep"><see langword="true" />
    ///  to recursively clone the subtree under the specified node; <see langword="false" />
    ///  to clone only the node itself.</param>
    ///<returns>Returns a <see cref="T:System.Xml.XmlNode" />
    ///  copy of the node from which the method is called.</returns>
    ///<exception cref="T:System.InvalidOperationException">Notation nodes cannot be cloned. Calling this method on an <see cref="T:System.Xml.XmlNotation" />
    ///  object throws an exception.</exception>
    function CloneNode(deep: Boolean): DNXmlNode;
    ///<summary>Saves the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . This method has no effect on <see langword="XmlNotation" />
    ///  nodes.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteTo(w: DNXmlWriter);
    ///<summary>Saves the children of the node to the specified <see cref="T:System.Xml.XmlWriter" />
    ///  . This method has no effect on <see langword="XmlNotation" />
    ///  nodes.</summary>
    ///  <param name="w">The <see langword="XmlWriter" />
    ///  to which you want to save. </param>
    procedure WriteContentTo(w: DNXmlWriter);
    ///<summary>Creates an <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  for navigating this object.</summary>
    ///<returns>An <see langword="XPathNavigator" />
    ///  object used to navigate the node. The <see langword="XPathNavigator" />
    ///  is positioned on the node from which the method was called. It is not positioned on the root of the document.</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. </exception>
    function SelectSingleNode(xpath: string): DNXmlNode; overload;
    ///<summary>Selects the first <see langword="XmlNode" />
    ///  that matches the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>The first <see langword="XmlNode" />
    ///  that matches the XPath query or <see langword="null" />
    ///  if no matching node is found. </returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectSingleNode(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNode; overload;
    ///<summary>Selects a list of nodes matching the XPath expression.</summary>
    ///  <param name="xpath">The XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix. See XPath Examples.</exception>
    function SelectNodes(xpath: string): DNXmlNodeList; overload;
    ///<summary>Selects a list of nodes matching the XPath expression. Any prefixes found in the XPath expression are resolved using the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///  <param name="xpath">The XPath expression. See XPath Examples.</param>
    ///  <param name="nsmgr">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for resolving namespaces for prefixes in the XPath expression. </param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeList" />
    ///  containing a collection of nodes matching the XPath query.</returns>
    ///<exception cref="T:System.Xml.XPath.XPathException">The XPath expression contains a prefix which is not defined in the <see langword="XmlNamespaceManager" />
    ///  . </exception>
    function SelectNodes(xpath: string; nsmgr: DNXmlNamespaceManager): DNXmlNodeList; overload;
    ///<summary>Inserts the specified node immediately before the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newChild" />
    ///  is placed before this node. </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertBefore(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Inserts the specified node immediately after the specified reference node.</summary>
    ///  <param name="newChild">The <see langword="XmlNode" />
    ///  to insert. </param>
    ///  <param name="refChild">The <see langword="XmlNode" />
    ///  that is the reference node. The <paramref name="newNode" />
    ///  is placed after the <paramref name="refNode" />
    ///  . </param>
    ///<returns>The node being inserted.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.The <paramref name="refChild" />
    ///  is not a child of this node.This node is read-only. </exception>
    function InsertAfter(newChild: DNXmlNode; refChild: DNXmlNode): DNXmlNode;
    ///<summary>Replaces the child node <paramref name="oldChild" />
    ///  with <paramref name="newChild" />
    ///  node.</summary>
    ///  <param name="newChild">The new node to put in the child list. </param>
    ///  <param name="oldChild">The node being replaced in the list. </param>
    ///<returns>The node replaced.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only.The <paramref name="oldChild" />
    ///  is not a child of this node. </exception>
    function ReplaceChild(newChild: DNXmlNode; oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Removes specified child node.</summary>
    ///  <param name="oldChild">The node being removed. </param>
    ///<returns>The node removed.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="oldChild" />
    ///  is not a child of this node. Or this node is read-only. </exception>
    function RemoveChild(oldChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the beginning of the list of child nodes for this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location.</param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function PrependChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Adds the specified node to the end of the list of child nodes, of this node.</summary>
    ///  <param name="newChild">The node to add. All the contents of the node to be added are moved into the specified location. </param>
    ///<returns>The node added.</returns>
    ///<exception cref="T:System.InvalidOperationException">This node is of a type that does not allow child nodes of the type of the <paramref name="newChild" />
    ///  node.The <paramref name="newChild" />
    ///  is an ancestor of this node. </exception><exception cref="T:System.ArgumentException">The <paramref name="newChild" />
    ///  was created from a different document than the one that created this node.This node is read-only. </exception>
    function AppendChild(newChild: DNXmlNode): DNXmlNode;
    ///<summary>Puts all XmlText nodes in the full depth of the sub-tree underneath this XmlNode into a "normal" form where only markup (that is, tags, comments, processing instructions, CDATA sections, and entity references) separates XmlText nodes, that is, there are no adjacent XmlText nodes.</summary>
    procedure Normalize;
    ///<summary>Creates a duplicate of this node.</summary>
    ///<returns>The cloned node.</returns>
    function Clone: DNXmlNode;
    ///<summary>Get an enumerator that iterates through the child nodes in the current node.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object that can be used to iterate through the child nodes in the current node.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>Removes all the child nodes and/or attributes of the current node.</summary>
    procedure RemoveAll;
    ///<summary>Looks up the closest xmlns declaration for the given prefix that is in scope for the current node and returns the namespace URI in the declaration.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to find. </param>
    ///<returns>The namespace URI of the specified prefix.</returns>
    function GetNamespaceOfPrefix(prefix: string): string;
    ///<summary>Looks up the closest xmlns declaration for the given namespace URI that is in scope for the current node and returns the prefix defined in that declaration.</summary>
    ///  <param name="namespaceURI">The namespace URI whose prefix you want to find. </param>
    ///<returns>The prefix for the specified namespace URI.</returns>
    function GetPrefixOfNamespace(namespaceURI: string): string;
    ///<summary>Tests if the DOM implementation implements a specific feature.</summary>
    ///  <param name="feature">The package name of the feature to test. This name is not case-sensitive. </param>
    ///  <param name="version">The version number of the package name to test. If the version is not specified (null), supporting any version of the feature causes the method to return true. </param>
    ///<returns><see langword="true" />
    ///  if the feature is implemented in the specified version; otherwise, <see langword="false" />
    ///  . The following table describes the combinations that return <see langword="true" />
    ///  .Feature Version XML 1.0 XML 2.0 </returns>
    function Supports(feature: string; version: string): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the name of the current node.</summary>
    ///<returns>The name of the notation.</returns>
    property Name: string read get_Name;
    ///<summary>Gets the name of the current node without the namespace prefix.</summary>
    ///<returns>For <see langword="XmlNotation" />
    ///  nodes, this property returns the name of the notation.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the type of the current node.</summary>
    ///<returns>The node type. For <see langword="XmlNotation" />
    ///  nodes, the value is XmlNodeType.Notation.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets a value indicating whether the node is read-only.</summary>
    ///<returns><see langword="true" />
    ///  if the node is read-only; otherwise <see langword="false" />
    ///  .Because <see langword="XmlNotation" />
    ///  nodes are read-only, this property always returns <see langword="true" />
    ///  .</returns>
    property IsReadOnly: Boolean read get_IsReadOnly;
    ///<summary>Gets the value of the public identifier on the notation declaration.</summary>
    ///<returns>The public identifier on the notation. If there is no public identifier, <see langword="null" />
    ///  is returned.</returns>
    property PublicId: string read get_PublicId;
    ///<summary>Gets the value of the system identifier on the notation declaration.</summary>
    ///<returns>The system identifier on the notation. If there is no system identifier, <see langword="null" />
    ///  is returned.</returns>
    property SystemId: string read get_SystemId;
    ///<summary>Gets the markup representing this node and all its children.</summary>
    ///<returns>For <see langword="XmlNotation" />
    ///  nodes, String.Empty is returned.</returns>
    property OuterXml: string read get_OuterXml;
    ///<summary>Gets the markup representing the children of this node.</summary>
    ///<returns>For <see langword="XmlNotation" />
    ///  nodes, String.Empty is returned.</returns>
    ///<exception cref="T:System.InvalidOperationException">Attempting to set the property. </exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>Gets or sets the value of the node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node: Type Value Attribute The value of the attribute. CDATASection The content of the CDATA Section. Comment The content of the comment. Document
    ///<see langword="null" />
    ///  . DocumentFragment
    ///<see langword="null" />
    ///  . DocumentType
    ///<see langword="null" />
    ///  . Element
    ///<see langword="null" />
    ///  . You can use the <see cref="P:System.Xml.XmlElement.InnerText" />
    ///  or <see cref="P:System.Xml.XmlElement.InnerXml" />
    ///  properties to access the value of the element node. Entity
    ///<see langword="null" />
    ///  . EntityReference
    ///<see langword="null" />
    ///  . Notation
    ///<see langword="null" />
    ///  . ProcessingInstruction The entire content excluding the target. Text The content of the text node. SignificantWhitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. Whitespace The white space characters. White space can consist of one or more space characters, carriage returns, line feeds, or tabs. XmlDeclaration The content of the declaration (that is, everything between &lt;?xml and ?&gt;). </returns>
    ///<exception cref="T:System.ArgumentException">Setting the value of a node that is read-only. </exception><exception cref="T:System.InvalidOperationException">Setting the value of a node that is not supposed to have a value (for example, an Element node). </exception>
    property Value: string read get_Value write set_Value;
    ///<summary>Gets the parent of this node (for nodes that can have parents).</summary>
    ///<returns>The <see langword="XmlNode" />
    ///  that is the parent of the current node. If a node has just been created and not yet added to the tree, or if it has been removed from the tree, the parent is <see langword="null" />
    ///  . For all other nodes, the value returned depends on the <see cref="P:System.Xml.XmlNode.NodeType" />
    ///  of the node. The following table describes the possible return values for the <see langword="ParentNode" />
    ///  property.NodeType Return Value of ParentNode Attribute, Document, DocumentFragment, Entity, Notation Returns <see langword="null" />
    ///  ; these nodes do not have parents. CDATA Returns the element or entity reference containing the CDATA section. Comment Returns the element, entity reference, document type, or document containing the comment. DocumentType Returns the document node. Element Returns the parent node of the element. If the element is the root node in the tree, the parent is the document node. EntityReference Returns the element, attribute, or entity reference containing the entity reference. ProcessingInstruction Returns the document, element, document type, or entity reference containing the processing instruction. Text Returns the parent element, attribute, or entity reference containing the text node. </returns>
    property ParentNode: DNXmlNode read get_ParentNode;
    ///<summary>Gets all the child nodes of the node.</summary>
    ///<returns>An object that contains all the child nodes of the node.If there are no child nodes, this property returns an empty <see cref="T:System.Xml.XmlNodeList" />
    ///  .</returns>
    property ChildNodes: DNXmlNodeList read get_ChildNodes;
    ///<summary>Gets the node immediately preceding this node.</summary>
    ///<returns>The preceding <see langword="XmlNode" />
    ///  . If there is no preceding node, <see langword="null" />
    ///  is returned.</returns>
    property PreviousSibling: DNXmlNode read get_PreviousSibling;
    ///<summary>Gets the node immediately following this node.</summary>
    ///<returns>The next <see langword="XmlNode" />
    ///  . If there is no next node, <see langword="null" />
    ///  is returned.</returns>
    property NextSibling: DNXmlNode read get_NextSibling;
    ///<summary>Gets an <see cref="T:System.Xml.XmlAttributeCollection" />
    ///  containing the attributes of this node.</summary>
    ///<returns>An <see langword="XmlAttributeCollection" />
    ///  containing the attributes of the node.If the node is of type XmlNodeType.Element, the attributes of the node are returned. Otherwise, this property returns <see langword="null" />
    ///  .</returns>
    property Attributes: DNXmlAttributeCollection read get_Attributes;
    ///<summary>Gets the <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlDocument" />
    ///  to which this node belongs.If the node is an <see cref="T:System.Xml.XmlDocument" />
    ///  (NodeType equals XmlNodeType.Document), this property returns <see langword="null" />
    ///  .</returns>
    property OwnerDocument: DNXmlDocument read get_OwnerDocument;
    ///<summary>Gets the first child of the node.</summary>
    ///<returns>The first child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property FirstChild: DNXmlNode read get_FirstChild;
    ///<summary>Gets the last child of the node.</summary>
    ///<returns>The last child of the node. If there is no such node, <see langword="null" />
    ///  is returned.</returns>
    property LastChild: DNXmlNode read get_LastChild;
    ///<summary>Gets a value indicating whether this node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the node has child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildNodes: Boolean read get_HasChildNodes;
    ///<summary>Gets the namespace URI of this node.</summary>
    ///<returns>The namespace URI of this node. If there is no namespace URI, this property returns String.Empty.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets or sets the namespace prefix of this node.</summary>
    ///<returns>The namespace prefix of this node. For example, <see langword="Prefix" />
    ///  is bk for the element &lt;bk:book&gt;. If there is no prefix, this property returns String.Empty.</returns>
    ///<exception cref="T:System.ArgumentException">This node is read-only. </exception><exception cref="T:System.Xml.XmlException">The specified prefix contains an invalid character.The specified prefix is malformed.The specified prefix is "xml" and the namespaceURI of this node is different from "http://www.w3.org/XML/1998/namespace".This node is an attribute and the specified prefix is "xmlns" and the namespaceURI of this node is different from "http://www.w3.org/2000/xmlns/ ".This node is an attribute and the qualifiedName of this node is "xmlns". </exception>
    property Prefix: string read get_Prefix write set_Prefix;
    ///<summary>Gets or sets the concatenated values of the node and all its child nodes.</summary>
    ///<returns>The concatenated values of the node and all its child nodes.</returns>
    property InnerText: string read get_InnerText write set_InnerText;
    ///<summary>Gets the post schema validation infoset that has been assigned to this node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the post schema validation infoset of this node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The location from which the node was loaded or String.Empty if the node has no base URI.</returns>
    property BaseURI: string read get_BaseURI;
    property Item[name: string]: DNXmlElement read get_Item; default;
    property Item[localname: string; ns: string]: DNXmlElement read get_Item; default;
    ///<summary>Gets the text node that immediately precedes this node.</summary>
    ///<returns>Returns <see cref="T:System.Xml.XmlNode" />
    ///  .</returns>
    property PreviousText: DNXmlNode read get_PreviousText;
  end;

  TDNXmlNotation = class(TDNGenericImport<DNXmlNotationClass, DNXmlNotation>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNodeListClass = interface(DNObjectClass)
  ['{CD04361B-0A59-52B5-8AD4-CB82A6CB6425}']
  end;

  ///<summary>Represents an ordered collection of nodes.</summary>
  [DNTypeName('System.Xml.XmlNodeList')]
  DNXmlNodeList = interface(DDN.mscorlib.DNIEnumerable)
  ['{A82A4A5B-6914-3CC4-B7C3-EBB1D009992C}']
  { getters & setters } 

    function get_Count: Int32;
    function get_ItemOf(i: Int32): DNXmlNode;

  { methods } 

    ///<summary>Retrieves a node at the given index.</summary>
    ///  <param name="index">The zero-based index into the list of nodes.</param>
    ///<returns>The <see cref="T:System.Xml.XmlNode" />
    ///  with the specified index in the collection. If <paramref name="index" />
    ///  is greater than or equal to the number of nodes in the list, this returns <see langword="null" />
    ///  .</returns>
    function Item(index: Int32): DNXmlNode;
    ///<summary>Gets an enumerator that iterates through the collection of nodes.</summary>
    ///<returns>An enumerator used to iterate through the collection of nodes.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the number of nodes in the <see langword="XmlNodeList" />
    ///  .</summary>
    ///<returns>The number of nodes in the <see langword="XmlNodeList" />
    ///  .</returns>
    property Count: Int32 read get_Count;
    property ItemOf[i: Int32]: DNXmlNode read get_ItemOf; default;
  end;

  TDNXmlNodeList = class(TDNGenericImport<DNXmlNodeListClass, DNXmlNodeList>) end;

  //-------------namespace: System.Xml----------------
  DNXmlParserContextClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0E6B1786-198D-5A8F-8792-DB639A99D507}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see langword="XmlParserContext" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  , <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  , <see langword="xml:lang" />
    ///  , and <see langword="xml:space" />
    ///  values.</summary>
    ///  <param name="nt">The <see cref="T:System.Xml.XmlNameTable" />
    ///  to use to atomize strings. If this is <see langword="null" />
    ///  , the name table used to construct the <paramref name="nsMgr" />
    ///  is used instead. For more information about atomized strings, see <see cref="T:System.Xml.XmlNameTable" />
    ///  . </param>
    ///  <param name="nsMgr">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for looking up namespace information, or <see langword="null" />
    ///  . </param>
    ///  <param name="xmlLang">The <see langword="xml:lang" />
    ///  scope. </param>
    ///  <param name="xmlSpace">An <see cref="T:System.Xml.XmlSpace" />
    ///  value indicating the <see langword="xml:space" />
    ///  scope. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="nt" />
    ///  is not the same <see langword="XmlNameTable" />
    ///  used to construct <paramref name="nsMgr" />
    ///  . </exception>
    {class} function init(nt: DNXmlNameTable; nsMgr: DNXmlNamespaceManager; xmlLang: string; xmlSpace: DNXmlSpace): DNXmlParserContext; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlParserContext" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  , <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  , <see langword="xml:lang" />
    ///  , <see langword="xml:space" />
    ///  , and encoding.</summary>
    ///  <param name="nt">The <see cref="T:System.Xml.XmlNameTable" />
    ///  to use to atomize strings. If this is <see langword="null" />
    ///  , the name table used to construct the <paramref name="nsMgr" />
    ///  is used instead. For more information on atomized strings, see <see cref="T:System.Xml.XmlNameTable" />
    ///  . </param>
    ///  <param name="nsMgr">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for looking up namespace information, or <see langword="null" />
    ///  . </param>
    ///  <param name="xmlLang">The <see langword="xml:lang" />
    ///  scope. </param>
    ///  <param name="xmlSpace">An <see cref="T:System.Xml.XmlSpace" />
    ///  value indicating the <see langword="xml:space" />
    ///  scope. </param>
    ///  <param name="enc">An <see cref="T:System.Text.Encoding" />
    ///  object indicating the encoding setting. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="nt" />
    ///  is not the same <see langword="XmlNameTable" />
    ///  used to construct <paramref name="nsMgr" />
    ///  . </exception>
    {class} function init(nt: DNXmlNameTable; nsMgr: DNXmlNamespaceManager; xmlLang: string; xmlSpace: DNXmlSpace; enc: DDN.mscorlib.DNEncoding): DNXmlParserContext; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlParserContext" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  , <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  , base URI, <see langword="xml:lang" />
    ///  , <see langword="xml:space" />
    ///  , and document type values.</summary>
    ///  <param name="nt">The <see cref="T:System.Xml.XmlNameTable" />
    ///  to use to atomize strings. If this is <see langword="null" />
    ///  , the name table used to construct the <paramref name="nsMgr" />
    ///  is used instead. For more information about atomized strings, see <see cref="T:System.Xml.XmlNameTable" />
    ///  . </param>
    ///  <param name="nsMgr">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for looking up namespace information, or <see langword="null" />
    ///  . </param>
    ///  <param name="docTypeName">The name of the document type declaration. </param>
    ///  <param name="pubId">The public identifier. </param>
    ///  <param name="sysId">The system identifier. </param>
    ///  <param name="internalSubset">The internal DTD subset. The DTD subset is used for entity resolution, not for document validation.</param>
    ///  <param name="baseURI">The base URI for the XML fragment (the location from which the fragment was loaded). </param>
    ///  <param name="xmlLang">The <see langword="xml:lang" />
    ///  scope. </param>
    ///  <param name="xmlSpace">An <see cref="T:System.Xml.XmlSpace" />
    ///  value indicating the <see langword="xml:space" />
    ///  scope. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="nt" />
    ///  is not the same <see langword="XmlNameTable" />
    ///  used to construct <paramref name="nsMgr" />
    ///  . </exception>
    {class} function init(nt: DNXmlNameTable; nsMgr: DNXmlNamespaceManager; docTypeName: string; pubId: string; sysId: string; internalSubset: string; baseURI: string; xmlLang: string; xmlSpace: DNXmlSpace): DNXmlParserContext; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlParserContext" />
    ///  class with the specified <see cref="T:System.Xml.XmlNameTable" />
    ///  , <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  , base URI, <see langword="xml:lang" />
    ///  , <see langword="xml:space" />
    ///  , encoding, and document type values.</summary>
    ///  <param name="nt">The <see cref="T:System.Xml.XmlNameTable" />
    ///  to use to atomize strings. If this is <see langword="null" />
    ///  , the name table used to construct the <paramref name="nsMgr" />
    ///  is used instead. For more information about atomized strings, see <see cref="T:System.Xml.XmlNameTable" />
    ///  . </param>
    ///  <param name="nsMgr">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  to use for looking up namespace information, or <see langword="null" />
    ///  . </param>
    ///  <param name="docTypeName">The name of the document type declaration. </param>
    ///  <param name="pubId">The public identifier. </param>
    ///  <param name="sysId">The system identifier. </param>
    ///  <param name="internalSubset">The internal DTD subset. The DTD is used for entity resolution, not for document validation.</param>
    ///  <param name="baseURI">The base URI for the XML fragment (the location from which the fragment was loaded). </param>
    ///  <param name="xmlLang">The <see langword="xml:lang" />
    ///  scope. </param>
    ///  <param name="xmlSpace">An <see cref="T:System.Xml.XmlSpace" />
    ///  value indicating the <see langword="xml:space" />
    ///  scope. </param>
    ///  <param name="enc">An <see cref="T:System.Text.Encoding" />
    ///  object indicating the encoding setting. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="nt" />
    ///  is not the same <see langword="XmlNameTable" />
    ///  used to construct <paramref name="nsMgr" />
    ///  . </exception>
    {class} function init(nt: DNXmlNameTable; nsMgr: DNXmlNamespaceManager; docTypeName: string; pubId: string; sysId: string; internalSubset: string; baseURI: string; xmlLang: string; xmlSpace: DNXmlSpace; enc: DDN.mscorlib.DNEncoding): DNXmlParserContext; overload;

  end;

  ///<summary>Provides all the context information required by the <see cref="T:System.Xml.XmlReader" />
  ///  to parse an XML fragment.</summary>
  [DNTypeName('System.Xml.XmlParserContext')]
  DNXmlParserContext = interface(DDN.mscorlib.DNObject)
  ['{406E8126-3D39-3708-BBD1-E5414D1C792F}']
  { getters & setters } 

    function get_NameTable: DNXmlNameTable;
    procedure set_NameTable(value: DNXmlNameTable);
    function get_NamespaceManager: DNXmlNamespaceManager;
    procedure set_NamespaceManager(value: DNXmlNamespaceManager);
    function get_DocTypeName: string;
    procedure set_DocTypeName(value: string);
    function get_PublicId: string;
    procedure set_PublicId(value: string);
    function get_SystemId: string;
    procedure set_SystemId(value: string);
    function get_BaseURI: string;
    procedure set_BaseURI(value: string);
    function get_InternalSubset: string;
    procedure set_InternalSubset(value: string);
    function get_XmlLang: string;
    procedure set_XmlLang(value: string);
    function get_XmlSpace: DNXmlSpace;
    procedure set_XmlSpace(value: DNXmlSpace);
    function get_Encoding: DDN.mscorlib.DNEncoding;
    procedure set_Encoding(value: DDN.mscorlib.DNEncoding);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  used to atomize strings. For more information on atomized strings, see <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///<returns>The <see langword="XmlNameTable" />
    ///  .</returns>
    property NameTable: DNXmlNameTable read get_NameTable write set_NameTable;
    ///<summary>Gets or sets the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</summary>
    ///<returns>The <see langword="XmlNamespaceManager" />
    ///  .</returns>
    property NamespaceManager: DNXmlNamespaceManager read get_NamespaceManager write set_NamespaceManager;
    ///<summary>Gets or sets the name of the document type declaration.</summary>
    ///<returns>The name of the document type declaration.</returns>
    property DocTypeName: string read get_DocTypeName write set_DocTypeName;
    ///<summary>Gets or sets the public identifier.</summary>
    ///<returns>The public identifier.</returns>
    property PublicId: string read get_PublicId write set_PublicId;
    ///<summary>Gets or sets the system identifier.</summary>
    ///<returns>The system identifier.</returns>
    property SystemId: string read get_SystemId write set_SystemId;
    ///<summary>Gets or sets the base URI.</summary>
    ///<returns>The base URI to use to resolve the DTD file.</returns>
    property BaseURI: string read get_BaseURI write set_BaseURI;
    ///<summary>Gets or sets the internal DTD subset.</summary>
    ///<returns>The internal DTD subset. For example, this property returns everything between the square brackets &lt;!DOCTYPE doc [...]&gt;.</returns>
    property InternalSubset: string read get_InternalSubset write set_InternalSubset;
    ///<summary>Gets or sets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  scope. If there is no <see langword="xml:lang" />
    ///  in scope, <see langword="String.Empty" />
    ///  is returned.</returns>
    property XmlLang: string read get_XmlLang write set_XmlLang;
    ///<summary>Gets or sets the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlSpace" />
    ///  value indicating the <see langword="xml:space" />
    ///  scope.</returns>
    property XmlSpace: DNXmlSpace read get_XmlSpace write set_XmlSpace;
    ///<summary>Gets or sets the encoding type.</summary>
    ///<returns>An <see cref="T:System.Text.Encoding" />
    ///  object indicating the encoding type.</returns>
    property Encoding: DDN.mscorlib.DNEncoding read get_Encoding write set_Encoding;
  end;

  TDNXmlParserContext = class(TDNGenericImport<DNXmlParserContextClass, DNXmlParserContext>) end;

  //-------------namespace: System.Xml----------------
  DNXmlQualifiedNameClass = interface(DDN.mscorlib.DNObjectClass)
  ['{990D471B-E959-556A-AFED-5552CA20D4A4}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  class.</summary>
    {class} function init: DNXmlQualifiedName; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  class with the specified name.</summary>
    ///  <param name="name">The local name to use as the name of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object. </param>
    {class} function init(name: string): DNXmlQualifiedName; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  class with the specified name and namespace.</summary>
    ///  <param name="name">The local name to use as the name of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object. </param>
    ///  <param name="ns">The namespace for the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object. </param>
    {class} function init(name: string; ns: string): DNXmlQualifiedName; overload;

  { static fields getter & setter } 

   function __fakeFieldGet_Empty: DNXmlQualifiedName;

  { static fields } 

    ///<summary>Provides an empty <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</summary>
    {class} property Empty: DNXmlQualifiedName read __fakeFieldGet_Empty;

  { static methods } 

    ///<summary>Returns the string value of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</summary>
    ///  <param name="name">The name of the object. </param>
    ///  <param name="ns">The namespace of the object. </param>
    ///<returns>The string value of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  in the format of <see langword="namespace:localname" />
    ///  . If the object does not have a namespace defined, this method returns just the local name.</returns>
    {class} function ToString(name: string; ns: string): string; overload;

  end;

  ///<summary>Represents an XML qualified name.</summary>
  [DNTypeName('System.Xml.XmlQualifiedName')]
  DNXmlQualifiedName = interface(DDN.mscorlib.DNObject)
  ['{74BB3238-7944-3CD8-8790-E945BBE5866E}']
  { getters & setters } 

    function get_Namespace: string;
    function get_Name: string;
    function get_IsEmpty: Boolean;

  { methods } 

    ///<summary>Returns the hash code for the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</summary>
    ///<returns>A hash code for this object.</returns>
    function GetHashCode: Int32;
    ///<summary>Determines whether the specified <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object is equal to the current <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object. </summary>
    ///  <param name="other">The <see cref="T:System.Xml.XmlQualifiedName" />
    ///  to compare. </param>
    ///<returns><see langword="true" />
    ///  if the two are the same instance object; otherwise, <see langword="false" />
    ///  .</returns>
    function Equals(other: DDN.mscorlib.DNObject): Boolean;
    ///<summary>Returns the string value of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</summary>
    ///<returns>The string value of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  in the format of <see langword="namespace:localname" />
    ///  . If the object does not have a namespace defined, this method returns just the local name.</returns>
    function ToString: string; overload;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a string representation of the namespace of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</summary>
    ///<returns>A string representation of the namespace or String.Empty if a namespace is not defined for the object.</returns>
    property Namespace: string read get_Namespace;
    ///<summary>Gets a string representation of the qualified name of the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  .</summary>
    ///<returns>A string representation of the qualified name or String.Empty if a name is not defined for the object.</returns>
    property Name: string read get_Name;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlQualifiedName" />
    ///  is empty.</summary>
    ///<returns><see langword="true" />
    ///  if name and namespace are empty strings; otherwise, <see langword="false" />
    ///  .</returns>
    property IsEmpty: Boolean read get_IsEmpty;
  end;

  TDNXmlQualifiedName = class(TDNGenericImport<DNXmlQualifiedNameClass, DNXmlQualifiedName>) end;

  //-------------namespace: System.Xml----------------
  DNXmlReaderClass = interface(DNObjectClass)
  ['{BED71FF4-9350-5FA7-AEB4-E4B0CBD7BE7A}']
  { static methods } 

    ///<summary>Returns a value indicating whether the string argument is a valid XML name.</summary>
    ///  <param name="str">The name to validate.</param>
    ///<returns><see langword="true" />
    ///  if the name is valid; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="str" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function IsName(str: string): Boolean;
    ///<summary>Returns a value indicating whether or not the string argument is a valid XML name token.</summary>
    ///  <param name="str">The name token to validate.</param>
    ///<returns><see langword="true" />
    ///  if it is a valid name token; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="str" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function IsNameToken(str: string): Boolean;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance with specified URI.</summary>
    ///  <param name="inputUri">The URI for the file that contains the XML data. The <see cref="T:System.Xml.XmlUrlResolver" />
    ///  class is used to convert the path to a canonical data representation.</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.SecurityException">The <see cref="T:System.Xml.XmlReader" />
    ///  does not have sufficient permissions to access the location of the XML data.</exception><exception cref="T:System.IO.FileNotFoundException">The file identified by the URI does not exist.</exception><exception cref="T:System.UriFormatException">
    ///  In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception, <see cref="T:System.FormatException" />
    ///  , instead.The URI format is not correct.</exception>
    {class} function Create(inputUri: string): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified URI and settings.</summary>
    ///  <param name="inputUri">The URI for the file containing the XML data. The <see cref="T:System.Xml.XmlResolver" />
    ///  object on the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object is used to convert the path to a canonical data representation. If <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" />
    ///  is <see langword="null" />
    ///  , a new <see cref="T:System.Xml.XmlUrlResolver" />
    ///  object is used.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.IO.FileNotFoundException">The file specified by the URI cannot be found.</exception><exception cref="T:System.UriFormatException">
    ///  In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception, <see cref="T:System.FormatException" />
    ///  , instead.The URI format is not correct.</exception>
    {class} function Create(inputUri: string; settings: DNXmlReaderSettings): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified URI, settings, and context information for parsing.</summary>
    ///  <param name="inputUri">The URI for the file containing the XML data. The <see cref="T:System.Xml.XmlResolver" />
    ///  object on the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object is used to convert the path to a canonical data representation. If <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" />
    ///  is <see langword="null" />
    ///  , a new <see cref="T:System.Xml.XmlUrlResolver" />
    ///  object is used.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="inputContext">The context information required to parse the XML fragment. The context information can include the <see cref="T:System.Xml.XmlNameTable" />
    ///  to use, encoding, namespace scope, the current xml:lang and xml:space scope, base URI, and document type definition. This value can be <see langword="null" />
    ///  .</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see langword="inputUri" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.SecurityException">The <see cref="T:System.Xml.XmlReader" />
    ///  does not have sufficient permissions to access the location of the XML data.</exception><exception cref="T:System.ArgumentException">The <see cref="P:System.Xml.XmlReaderSettings.NameTable" />
    ///  and <see cref="P:System.Xml.XmlParserContext.NameTable" />
    ///  properties both contain values. (Only one of these <see langword="NameTable" />
    ///  properties can be set and used).</exception><exception cref="T:System.IO.FileNotFoundException">The file specified by the URI cannot be found.</exception><exception cref="T:System.UriFormatException">The URI format is not correct.</exception>
    {class} function Create(inputUri: string; settings: DNXmlReaderSettings; inputContext: DNXmlParserContext): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance using the specified stream with default settings.</summary>
    ///  <param name="input">The stream that contains the XML data.The <see cref="T:System.Xml.XmlReader" />
    ///  scans the first bytes of the stream looking for a byte order mark or other sign of encoding. When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Security.SecurityException">The <see cref="T:System.Xml.XmlReader" />
    ///  does not have sufficient permissions to access the location of the XML data.</exception>
    {class} function Create(input: DDN.mscorlib.DNStream): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance with the specified stream and settings.</summary>
    ///  <param name="input">The stream that contains the XML data.The <see cref="T:System.Xml.XmlReader" />
    ///  scans the first bytes of the stream looking for a byte order mark or other sign of encoding. When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(input: DDN.mscorlib.DNStream; settings: DNXmlReaderSettings): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance using the specified stream, base URI, and settings.</summary>
    ///  <param name="input">The stream that contains the XML data. The <see cref="T:System.Xml.XmlReader" />
    ///  scans the first bytes of the stream looking for a byte order mark or other sign of encoding. When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="baseUri">The base URI for the entity or document being read. This value can be <see langword="null" />
    ///  .
    ///  Security Note   The base URI is used to resolve the relative URI of the XML document. Do not use a base URI from an untrusted source.</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(input: DDN.mscorlib.DNStream; settings: DNXmlReaderSettings; baseUri: string): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance using the specified stream, settings, and context information for parsing.</summary>
    ///  <param name="input">The stream that contains the XML data. The <see cref="T:System.Xml.XmlReader" />
    ///  scans the first bytes of the stream looking for a byte order mark or other sign of encoding. When encoding is determined, the encoding is used to continue reading the stream, and processing continues parsing the input as a stream of (Unicode) characters.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="inputContext">The context information required to parse the XML fragment. The context information can include the <see cref="T:System.Xml.XmlNameTable" />
    ///  to use, encoding, namespace scope, the current xml:lang and xml:space scope, base URI, and document type definition. This value can be <see langword="null" />
    ///  .</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(input: DDN.mscorlib.DNStream; settings: DNXmlReaderSettings; inputContext: DNXmlParserContext): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified text reader.</summary>
    ///  <param name="input">The text reader from which to read the XML data. A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration is not used by the XML reader to decode the data stream.</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(input: DDN.mscorlib.DNTextReader): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified text reader and settings.</summary>
    ///  <param name="input">The text reader from which to read the XML data. A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration isn't used by the XML reader to decode the data stream.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  . This value can be <see langword="null" />
    ///  .</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(input: DDN.mscorlib.DNTextReader; settings: DNXmlReaderSettings): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified text reader, settings, and base URI.</summary>
    ///  <param name="input">The text reader from which to read the XML data. A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration isn't used by the <see cref="T:System.Xml.XmlReader" />
    ///  to decode the data stream.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="baseUri">The base URI for the entity or document being read. This value can be <see langword="null" />
    ///  .
    ///  Security Note   The base URI is used to resolve the relative URI of the XML document. Do not use a base URI from an untrusted source.</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(input: DDN.mscorlib.DNTextReader; settings: DNXmlReaderSettings; baseUri: string): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified text reader, settings, and context information for parsing.</summary>
    ///  <param name="input">The text reader from which to read the XML data. A text reader returns a stream of Unicode characters, so the encoding specified in the XML declaration isn't used by the XML reader to decode the data stream.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="inputContext">The context information required to parse the XML fragment. The context information can include the <see cref="T:System.Xml.XmlNameTable" />
    ///  to use, encoding, namespace scope, the current xml:lang and xml:space scope, base URI, and document type definition.This value can be <see langword="null" />
    ///  .</param>
    ///<returns>An object that is used to read the XML data in the stream.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException">The <see cref="P:System.Xml.XmlReaderSettings.NameTable" />
    ///  and <see cref="P:System.Xml.XmlParserContext.NameTable" />
    ///  properties both contain values. (Only one of these <see langword="NameTable" />
    ///  properties can be set and used).</exception>
    {class} function Create(input: DDN.mscorlib.DNTextReader; settings: DNXmlReaderSettings; inputContext: DNXmlParserContext): DNXmlReader; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlReader" />
    ///  instance by using the specified XML reader and settings.</summary>
    ///  <param name="reader">The object that you want to use as the underlying XML reader.</param>
    ///  <param name="settings">The settings for the new <see cref="T:System.Xml.XmlReader" />
    ///  instance.The conformance level of the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object must either match the conformance level of the underlying reader, or it must be set to <see cref="F:System.Xml.ConformanceLevel.Auto" />
    ///  .</param>
    ///<returns>An object that is wrapped around the specified <see cref="T:System.Xml.XmlReader" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="reader" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">If the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object specifies a conformance level that is not consistent with conformance level of the underlying reader.-or-The underlying <see cref="T:System.Xml.XmlReader" />
    ///  is in an <see cref="F:System.Xml.ReadState.Error" />
    ///  or <see cref="F:System.Xml.ReadState.Closed" />
    ///  state.</exception>
    {class} function Create(reader: DNXmlReader; settings: DNXmlReaderSettings): DNXmlReader; overload;

  end;

  ///<summary>Represents a reader that provides fast, noncached, forward-only access to XML data.To browse the .NET Framework source code for this type, see the Reference Source.</summary>
  [DNTypeName('System.Xml.XmlReader')]
  DNXmlReader = interface(DDN.mscorlib.DNIDisposable)
  ['{E265CBE9-7445-3F96-8618-DA44B4ECEF45}']
  { getters & setters } 

    function get_Settings: DNXmlReaderSettings;
    function get_NodeType: DNXmlNodeType;
    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    function get_HasValue: Boolean;
    function get_Value: string;
    function get_Depth: Int32;
    function get_BaseURI: string;
    function get_IsEmptyElement: Boolean;
    function get_IsDefault: Boolean;
    function get_QuoteChar: Char;
    function get_XmlSpace: DNXmlSpace;
    function get_XmlLang: string;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_AttributeCount: Int32;
    function get_Item(i: Int32): string; overload;
    function get_Item(name: string): string; overload;
    function get_Item(name: string; namespaceURI: string): string; overload;
    function get_EOF: Boolean;
    function get_ReadState: DNReadState;
    function get_NameTable: DNXmlNameTable;
    function get_CanResolveEntity: Boolean;
    function get_CanReadBinaryContent: Boolean;
    function get_CanReadValueChunk: Boolean;
    function get_HasAttributes: Boolean;

  { methods } 

    ///<summary>Reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsObject: DDN.mscorlib.DNObject;
    ///<summary>Reads the text content at the current position as a <see langword="Boolean" />
    ///  .</summary>
    ///<returns>The text content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsBoolean: Boolean;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTime: DDN.mscorlib.DNDateTime;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTimeOffset" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTimeOffset" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTimeOffset: DDN.mscorlib.DNDateTimeOffset;
    ///<summary>Reads the text content at the current position as a double-precision floating-point number.</summary>
    ///<returns>The text content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDouble: Double;
    ///<summary>Reads the text content at the current position as a single-precision floating point number.</summary>
    ///<returns>The text content at the current position as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsFloat: Single;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDecimal: DDN.mscorlib.DNDecimal;
    ///<summary>Reads the text content at the current position as a 32-bit signed integer.</summary>
    ///<returns>The text content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsInt: Int32;
    ///<summary>Reads the text content at the current position as a 64-bit signed integer.</summary>
    ///<returns>The text content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsLong: Int64;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsString: string;
    ///<summary>Reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion. For example, this can be used when converting an <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object to an xs:string.This value can be <see langword="null" />
    ///  .</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.FormatException">The content is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="returnType" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not a supported node type. See the table below for details.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject(localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element contents as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime(localName: string; namespaceURI: string): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble(localName: string; namespaceURI: string): Double; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a single-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat(localName: string; namespaceURI: string): Single; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal(localName: string; namespaceURI: string): DDN.mscorlib.DNDecimal; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt(localName: string; namespaceURI: string): Int32; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong(localName: string; namespaceURI: string): Int64; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString(localName: string; namespaceURI: string): string; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver; localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>When overridden in a derived class, moves to the attribute with the specified index.</summary>
    ///  <param name="i">The index of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentOutOfRangeException">The parameter has a negative value.</exception>
    procedure MoveToAttribute(i: Int32); overload;
    ///<summary>When overridden in a derived class, changes the <see cref="P:System.Xml.XmlReader.ReadState" />
    ///  to <see cref="F:System.Xml.ReadState.Closed" />
    ///  .</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Close;
    ///<summary>Skips the children of the current node.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Skip;
    ///<summary>Reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node does not have a value (<see cref="P:System.Xml.XmlReader.HasValue" />
    ///  is <see langword="false" />
    ///  ).</exception><exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer, or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The XML data is not well-formed.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadValueChunk(buffer: TArray<Char>; index: Int32; count: Int32): Int32;
    ///<summary>When overridden in a derived class, reads the contents of an element or text node as a string. However, we recommend that you use the <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///<returns>The contents of the element or an empty string.</returns>
    ///<exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadString: string;
    ///<summary>Checks whether the current node is a content (non-white space text, <see langword="CDATA" />
    ///  , <see langword="Element" />
    ///  , <see langword="EndElement" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  ) node. If the node is not a content node, the reader skips ahead to the next content node or end of file. It skips over nodes of the following type: <see langword="ProcessingInstruction" />
    ///  , <see langword="DocumentType" />
    ///  , <see langword="Comment" />
    ///  , <see langword="Whitespace" />
    ///  , or <see langword="SignificantWhitespace" />
    ///  .</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToContent: DNXmlNodeType;
    ///<summary>Checks that the current node is an element and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.Name" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream. -or- The <see cref="P:System.Xml.XmlReader.Name" />
    ///  of the element does not match the given <paramref name="name" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(name: string); overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given string before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="name">The name to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="Name" />
    ///  does not match the given argument; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(name: string): string; overload;
    ///<summary>Checks that the current content node is an end tag and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">The current node is not an end tag or if incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadEndElement;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  finds a start tag or empty element tag; <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement: Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given argument.</summary>
    ///  <param name="name">The string matched against the <see langword="Name" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element and the <see langword="Name" />
    ///  property matches the specified string. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the element <see langword="Name" />
    ///  property does not match the specified string.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(name: string): Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found match the given strings.</summary>
    ///  <param name="localname">The string to match against the <see langword="LocalName" />
    ///  property of the element found.</param>
    ///  <param name="ns">The string to match against the <see langword="NamespaceURI" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the <see langword="LocalName" />
    ///  and <see langword="NamespaceURI" />
    ///  properties of the element do not match the specified strings.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(localname: string; ns: string): Boolean; overload;
    ///<summary>Reads until an element with the specified qualified name is found.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToFollowing(name: string): Boolean; overload;
    ///<summary>Reads until an element with the specified local name and namespace URI is found.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToFollowing(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToDescendant(name: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToDescendant(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToNextSibling(name: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the sibling element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise, <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToNextSibling(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>When overridden in a derived class, reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.If the current node is neither an element nor attribute, an empty string is returned.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadInnerXml: string;
    ///<summary>When overridden in a derived class, reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadOuterXml: string;
    ///<summary>Returns a new <see langword="XmlReader" />
    ///  instance that can be used to read the current node, and all its descendants.</summary>
    ///<returns>A new XML reader instance set to <see cref="F:System.Xml.ReadState.Initial" />
    ///  . Calling the <see cref="M:System.Xml.XmlReader.Read" />
    ///  method positions the new reader on the node that was current before the call to the <see cref="M:System.Xml.XmlReader.ReadSubtree" />
    ///  method.</returns>
    ///<exception cref="T:System.InvalidOperationException">The XML reader isn't positioned on an element when this method is called.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadSubtree: DNXmlReader;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlReader" />
    ///  class.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Dispose;
    ///<summary>Asynchronously gets the value of the current node.</summary>
    ///<returns>The value of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function GetValueAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>;
    ///<summary>Asynchronously skips the children of the current node.</summary>
    ///<returns>The current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function SkipAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadValueChunkAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously checks whether the current node is a content node. If the node is not a content node, the reader skips ahead to the next content node or end of file.</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function MoveToContentAsync: DDN.mscorlib.DNTask<DNXmlNodeType>;
    ///<summary>Reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject: DDN.mscorlib.DNObject; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Boolean" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean: Boolean; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.DateTime" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime: DDN.mscorlib.DNDateTime; overload;
    ///<summary>Reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a double-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble: Double; overload;
    ///<summary>Reads the current element and returns the contents as single-precision floating-point number.</summary>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat: Single; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal: DDN.mscorlib.DNDecimal; overload;
    ///<summary>Reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt: Int32; overload;
    ///<summary>Reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong: Int64; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString: string; overload;
    ///<summary>Reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>When overridden in a derived class, gets the value of the attribute with the specified <see cref="P:System.Xml.XmlReader.Name" />
    ///  .</summary>
    ///  <param name="name">The qualified name of the attribute.</param>
    ///<returns>The value of the specified attribute. If the attribute is not found or the value is <see langword="String.Empty" />
    ///  , <see langword="null" />
    ///  is returned.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function GetAttribute(name: string): string; overload;
    ///<summary>When overridden in a derived class, gets the value of the attribute with the specified <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  .</summary>
    ///  <param name="name">The local name of the attribute.</param>
    ///  <param name="namespaceURI">The namespace URI of the attribute.</param>
    ///<returns>The value of the specified attribute. If the attribute is not found or the value is <see langword="String.Empty" />
    ///  , <see langword="null" />
    ///  is returned. This method does not move the reader.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function GetAttribute(name: string; namespaceURI: string): string; overload;
    ///<summary>When overridden in a derived class, gets the value of the attribute with the specified index.</summary>
    ///  <param name="i">The index of the attribute. The index is zero-based. (The first attribute has index 0.)</param>
    ///<returns>The value of the specified attribute. This method does not move the reader.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i" />
    ///  is out of range. It must be non-negative and less than the size of the attribute collection.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function GetAttribute(i: Int32): string; overload;
    ///<summary>When overridden in a derived class, moves to the attribute with the specified <see cref="P:System.Xml.XmlReader.Name" />
    ///  .</summary>
    ///  <param name="name">The qualified name of the attribute.</param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the reader's position does not change.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function MoveToAttribute(name: string): Boolean; overload;
    ///<summary>When overridden in a derived class, moves to the attribute with the specified <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  .</summary>
    ///  <param name="name">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the reader's position does not change.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function MoveToAttribute(name: string; ns: string): Boolean; overload;
    ///<summary>When overridden in a derived class, moves to the first attribute.</summary>
    ///<returns><see langword="true" />
    ///  if an attribute exists (the reader moves to the first attribute); otherwise, <see langword="false" />
    ///  (the position of the reader does not change).</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToFirstAttribute: Boolean;
    ///<summary>When overridden in a derived class, moves to the next attribute.</summary>
    ///<returns><see langword="true" />
    ///  if there is a next attribute; <see langword="false" />
    ///  if there are no more attributes.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToNextAttribute: Boolean;
    ///<summary>When overridden in a derived class, moves to the element that contains the current attribute node.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <see langword="false" />
    ///  if the reader is not positioned on an attribute (the position of the reader does not change).</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToElement: Boolean;
    ///<summary>When overridden in a derived class, parses the attribute value into one or more <see langword="Text" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  nodes.</summary>
    ///<returns><see langword="true" />
    ///  if there are nodes to return.
    ///<see langword="false" />
    ///  if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.An empty attribute, such as, misc="", returns <see langword="true" />
    ///  with a single node with a value of <see langword="String.Empty" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadAttributeValue: Boolean;
    ///<summary>When overridden in a derived class, reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function Read: Boolean;
    ///<summary>When overridden in a derived class, resolves a namespace prefix in the current element's scope.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass an empty string. </param>
    ///<returns>The namespace URI to which the prefix maps or <see langword="null" />
    ///  if no matching prefix is found.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function LookupNamespace(prefix: string): string;
    ///<summary>When overridden in a derived class, resolves the entity reference for <see langword="EntityReference" />
    ///  nodes.</summary>
    ///<exception cref="T:System.InvalidOperationException">The reader is not positioned on an <see langword="EntityReference" />
    ///  node; this implementation of the reader cannot resolve entities (<see cref="P:System.Xml.XmlReader.CanResolveEntity" />
    ///  returns <see langword="false" />
    ///  ).</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ResolveEntity;
    ///<summary>Reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the <see langword="Base64" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the content and returns the <see langword="BinHex" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the <see langword="BinHex" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="localname">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.-or-The <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found do not match the given arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(localname: string; ns: string); overload;
    ///<summary>Reads a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">The next content node is not a start tag; or the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString: string; overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found matches the given strings before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="localname">The local name to check.</param>
    ///  <param name="ns">The namespace URI to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="LocalName" />
    ///  or <see langword="NamespaceURI" />
    ///  do not match the given arguments; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(localname: string; ns: string): string; overload;
    ///<summary>Asynchronously reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="Base64" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the content and returns the <see langword="BinHex" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="BinHex" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadInnerXmlAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadOuterXmlAsync: DDN.mscorlib.DNTask<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this <see cref="T:System.Xml.XmlReader" />
    ///  instance.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this reader instance. If this reader was not created using the <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  method, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Settings: DNXmlReaderSettings read get_Settings;
    ///<summary>When overridden in a derived class, gets the type of the current node.</summary>
    ///<returns>One of the enumeration values that specify the type of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>When overridden in a derived class, gets the qualified name of the current node.</summary>
    ///<returns>The qualified name of the current node. For example, <see langword="Name" />
    ///  is <see langword="bk:book" />
    ///  for the element &lt;bk:book&gt;.The name returned is dependent on the <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the node. The following node types return the listed values. All other node types return an empty string.Node type Name
    ///<see langword="Attribute" />
    ///  The name of the attribute.
    ///<see langword="DocumentType" />
    ///  The document type name.
    ///<see langword="Element" />
    ///  The tag name.
    ///<see langword="EntityReference" />
    ///  The name of the entity referenced.
    ///<see langword="ProcessingInstruction" />
    ///  The target of the processing instruction.
    ///<see langword="XmlDeclaration" />
    ///  The literal string <see langword="xml" />
    ///  . </returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Name: string read get_Name;
    ///<summary>When overridden in a derived class, gets the local name of the current node.</summary>
    ///<returns>The name of the current node with the prefix removed. For example, <see langword="LocalName" />
    ///  is <see langword="book" />
    ///  for the element &lt;bk:book&gt;.For node types that do not have a name (like <see langword="Text" />
    ///  , <see langword="Comment" />
    ///  , and so on), this property returns <see langword="String.Empty" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property LocalName: string read get_LocalName;
    ///<summary>When overridden in a derived class, gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</summary>
    ///<returns>The namespace URI of the current node; otherwise an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>When overridden in a derived class, gets the namespace prefix associated with the current node.</summary>
    ///<returns>The namespace prefix associated with the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Prefix: string read get_Prefix;
    ///<summary>When overridden in a derived class, gets a value indicating whether the current node can have a <see cref="P:System.Xml.XmlReader.Value" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the node on which the reader is currently positioned can have a <see langword="Value" />
    ///  ; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the node has a value of <see langword="String.Empty" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property HasValue: Boolean read get_HasValue;
    ///<summary>When overridden in a derived class, gets the text value of the current node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the node. The following table lists node types that have a value to return. All other node types return <see langword="String.Empty" />
    ///  .Node type Value
    ///<see langword="Attribute" />
    ///  The value of the attribute.
    ///<see langword="CDATA" />
    ///  The content of the CDATA section.
    ///<see langword="Comment" />
    ///  The content of the comment.
    ///<see langword="DocumentType" />
    ///  The internal subset.
    ///<see langword="ProcessingInstruction" />
    ///  The entire content, excluding the target.
    ///<see langword="SignificantWhitespace" />
    ///  The white space between markup in a mixed content model.
    ///<see langword="Text" />
    ///  The content of the text node.
    ///<see langword="Whitespace" />
    ///  The white space between markup.
    ///<see langword="XmlDeclaration" />
    ///  The content of the declaration. </returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Value: string read get_Value;
    ///<summary>When overridden in a derived class, gets the depth of the current node in the XML document.</summary>
    ///<returns>The depth of the current node in the XML document.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Depth: Int32 read get_Depth;
    ///<summary>When overridden in a derived class, gets the base URI of the current node.</summary>
    ///<returns>The base URI of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property BaseURI: string read get_BaseURI;
    ///<summary>When overridden in a derived class, gets a value indicating whether the current node is an empty element (for example, &lt;MyElement/&gt;).</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an element (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  equals <see langword="XmlNodeType.Element" />
    ///  ) that ends with /&gt;; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property IsEmptyElement: Boolean read get_IsEmptyElement;
    ///<summary>When overridden in a derived class, gets a value indicating whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an attribute whose value was generated from the default value defined in the DTD or schema; <see langword="false" />
    ///  if the attribute value was explicitly set.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property IsDefault: Boolean read get_IsDefault;
    ///<summary>When overridden in a derived class, gets the quotation mark character used to enclose the value of an attribute node.</summary>
    ///<returns>The quotation mark character (" or ') used to enclose the value of an attribute node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property QuoteChar: Char read get_QuoteChar;
    ///<summary>When overridden in a derived class, gets the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlSpace" />
    ///  values. If no <see langword="xml:space" />
    ///  scope exists, this property defaults to <see langword="XmlSpace.None" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property XmlSpace: DNXmlSpace read get_XmlSpace;
    ///<summary>When overridden in a derived class, gets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  scope.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property XmlLang: string read get_XmlLang;
    ///<summary>Gets the schema information that has been assigned to the current node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the schema information for the current node. Schema information can be set on elements, attributes, or on text nodes with a non-null <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  (typed values).If the current node is not one of the above node types, or if the <see langword="XmlReader" />
    ///  instance does not report schema information, this property returns <see langword="null" />
    ///  .If this property is called from an <see cref="T:System.Xml.XmlTextReader" />
    ///  or an <see cref="T:System.Xml.XmlValidatingReader" />
    ///  object, this property always returns <see langword="null" />
    ///  . These <see langword="XmlReader" />
    ///  implementations do not expose schema information through the <see langword="SchemaInfo" />
    ///  property.If you have to get the post-schema-validation information set (PSVI) for an element, position the reader on the end tag of the element, rather than on the start tag. You get the PSVI through the <see langword="SchemaInfo" />
    ///  property of a reader. The validating reader that is created through <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  with the <see cref="P:System.Xml.XmlReaderSettings.ValidationType" />
    ///  property set to <see cref="F:System.Xml.ValidationType.Schema" />
    ///  has complete PSVI for an element only when the reader is positioned on the end tag of an element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets The Common Language Runtime (CLR) type for the current node.</summary>
    ///<returns>The CLR type that corresponds to the typed value of the node. The default is <see langword="System.String" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    ///<summary>When overridden in a derived class, gets the number of attributes on the current node.</summary>
    ///<returns>The number of attributes on the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property AttributeCount: Int32 read get_AttributeCount;
    property Item[i: Int32]: string read get_Item; default;
    property Item[name: string]: string read get_Item; default;
    property Item[name: string; namespaceURI: string]: string read get_Item; default;
    ///<summary>When overridden in a derived class, gets a value indicating whether the reader is positioned at the end of the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned at the end of the stream; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property EOF: Boolean read get_EOF;
    ///<summary>When overridden in a derived class, gets the state of the reader.</summary>
    ///<returns>One of the enumeration values that specifies the state of the reader.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property ReadState: DNReadState read get_ReadState;
    ///<summary>When overridden in a derived class, gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this implementation.</summary>
    ///<returns>The <see langword="XmlNameTable" />
    ///  enabling you to get the atomized version of a string within the node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets a value indicating whether this reader can parse and resolve entities.</summary>
    ///<returns><see langword="true" />
    ///  if the reader can parse and resolve entities; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property CanResolveEntity: Boolean read get_CanResolveEntity;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlReader" />
    ///  implements the binary content read methods.</summary>
    ///<returns><see langword="true" />
    ///  if the binary content read methods are implemented; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property CanReadBinaryContent: Boolean read get_CanReadBinaryContent;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XmlReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property CanReadValueChunk: Boolean read get_CanReadValueChunk;
    ///<summary>Gets a value indicating whether the current node has any attributes.</summary>
    ///<returns><see langword="true" />
    ///  if the current node has attributes; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property HasAttributes: Boolean read get_HasAttributes;
  end;

  TDNXmlReader = class(TDNGenericImport<DNXmlReaderClass, DNXmlReader>) end;

  //-------------namespace: System.Xml----------------
  DNXmlNodeReaderClass = interface(DNXmlReaderClass)
  ['{FB9EB325-C8B4-5A7C-839D-2BD7311CA461}']
  { constructors } 

    ///<summary>Creates an instance of the <see langword="XmlNodeReader" />
    ///  class using the specified <see cref="T:System.Xml.XmlNode" />
    ///  .</summary>
    ///  <param name="node">The <see langword="XmlNode" />
    ///  you want to read. </param>
    {class} function init(node: DNXmlNode): DNXmlNodeReader;

  end;

  ///<summary>Represents a reader that provides fast, non-cached forward only access to XML data in an <see cref="T:System.Xml.XmlNode" />
  ///  .</summary>
  [DNTypeName('System.Xml.XmlNodeReader')]
  DNXmlNodeReader = interface(DNXmlReader)
  ['{A91FE415-7469-3E8F-9EBD-318B69E0DDEE}']
  { getters & setters } 

    function get_NodeType: DNXmlNodeType;
    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    function get_HasValue: Boolean;
    function get_Value: string;
    function get_Depth: Int32;
    function get_BaseURI: string;
    function get_CanResolveEntity: Boolean;
    function get_IsEmptyElement: Boolean;
    function get_IsDefault: Boolean;
    function get_XmlSpace: DNXmlSpace;
    function get_XmlLang: string;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_AttributeCount: Int32;
    function get_EOF: Boolean;
    function get_ReadState: DNReadState;
    function get_HasAttributes: Boolean;
    function get_NameTable: DNXmlNameTable;
    function get_CanReadBinaryContent: Boolean;
    function get_Settings: DNXmlReaderSettings;
    function get_QuoteChar: Char;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_Item(i: Int32): string; overload;
    function get_Item(name: string): string; overload;
    function get_Item(name: string; namespaceURI: string): string; overload;
    function get_CanReadValueChunk: Boolean;

  { methods } 

    ///<summary>Gets the value of the attribute with the specified name.</summary>
    ///  <param name="name">The qualified name of the attribute. </param>
    ///<returns>The value of the specified attribute. If the attribute is not found, <see langword="null" />
    ///  is returned.</returns>
    function GetAttribute(name: string): string; overload;
    ///<summary>Gets the value of the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="name">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns>The value of the specified attribute. If the attribute is not found, <see langword="null" />
    ///  is returned.</returns>
    function GetAttribute(name: string; namespaceURI: string): string; overload;
    ///<summary>Gets the value of the attribute with the specified index.</summary>
    ///  <param name="attributeIndex">The index of the attribute. The index is zero-based. (The first attribute has index 0.) </param>
    ///<returns>The value of the specified attribute.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" />
    ///  parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlNodeReader.AttributeCount" />
    ///  . </exception>
    function GetAttribute(attributeIndex: Int32): string; overload;
    ///<summary>Moves to the attribute with the specified name.</summary>
    ///  <param name="name">The qualified name of the attribute. </param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the reader's position does not change.</returns>
    function MoveToAttribute(name: string): Boolean; overload;
    ///<summary>Moves to the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="name">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the reader's position does not change.</returns>
    function MoveToAttribute(name: string; namespaceURI: string): Boolean; overload;
    ///<summary>Moves to the attribute with the specified index.</summary>
    ///  <param name="attributeIndex">The index of the attribute. </param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" />
    ///  parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlReader.AttributeCount" />
    ///  . </exception>
    procedure MoveToAttribute(attributeIndex: Int32); overload;
    ///<summary>Moves to the first attribute.</summary>
    ///<returns><see langword="true" />
    ///  if an attribute exists (the reader moves to the first attribute); otherwise, <see langword="false" />
    ///  (the position of the reader does not change).</returns>
    function MoveToFirstAttribute: Boolean;
    ///<summary>Moves to the next attribute.</summary>
    ///<returns><see langword="true" />
    ///  if there is a next attribute; <see langword="false" />
    ///  if there are no more attributes.</returns>
    function MoveToNextAttribute: Boolean;
    ///<summary>Moves to the element that contains the current attribute node.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <see langword="false" />
    ///  if the reader is not positioned on an attribute (the position of the reader does not change).</returns>
    function MoveToElement: Boolean;
    ///<summary>Reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    function Read: Boolean;
    ///<summary>Changes the <see cref="P:System.Xml.XmlNodeReader.ReadState" />
    ///  to <see langword="Closed" />
    ///  .</summary>
    procedure Close;
    ///<summary>Skips the children of the current node.</summary>
    procedure Skip;
    ///<summary>Reads the contents of an element or text node as a string.</summary>
    ///<returns>The contents of the element or text-like node (This can include CDATA, Text nodes, and so on). This can be an empty string if the reader is positioned on something other than an element or text node, or if there is no more text content to return in the current context.
    ///<see langword="Note:" />
    ///  The text node can be either an element or an attribute text node.</returns>
    function ReadString: string;
    ///<summary>Resolves a namespace prefix in the current element's scope.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass an empty string. This string does not have to be atomized. </param>
    ///<returns>The namespace URI to which the prefix maps or <see langword="null" />
    ///  if no matching prefix is found.</returns>
    function LookupNamespace(prefix: string): string;
    ///<summary>Resolves the entity reference for <see langword="EntityReference" />
    ///  nodes.</summary>
    ///<exception cref="T:System.InvalidOperationException">The reader is not positioned on an <see langword="EntityReference" />
    ///  node. </exception>
    procedure ResolveEntity;
    ///<summary>Parses the attribute value into one or more <see langword="Text" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  nodes.</summary>
    ///<returns><see langword="true" />
    ///  if there are nodes to return.
    ///<see langword="false" />
    ///  if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.An empty attribute, such as, misc="", returns <see langword="true" />
    ///  with a single node with a value of String.Empty.</returns>
    function ReadAttributeValue: Boolean;
    ///<summary>Reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlNodeReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
    function ReadContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the content and returns the BinHex decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlNodeReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
    function ReadContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the Base64 content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
    function ReadElementContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the BinHex content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
    function ReadElementContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsObject: DDN.mscorlib.DNObject;
    ///<summary>Reads the text content at the current position as a <see langword="Boolean" />
    ///  .</summary>
    ///<returns>The text content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsBoolean: Boolean;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTime: DDN.mscorlib.DNDateTime;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTimeOffset" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTimeOffset" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTimeOffset: DDN.mscorlib.DNDateTimeOffset;
    ///<summary>Reads the text content at the current position as a double-precision floating-point number.</summary>
    ///<returns>The text content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDouble: Double;
    ///<summary>Reads the text content at the current position as a single-precision floating point number.</summary>
    ///<returns>The text content at the current position as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsFloat: Single;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDecimal: DDN.mscorlib.DNDecimal;
    ///<summary>Reads the text content at the current position as a 32-bit signed integer.</summary>
    ///<returns>The text content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsInt: Int32;
    ///<summary>Reads the text content at the current position as a 64-bit signed integer.</summary>
    ///<returns>The text content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsLong: Int64;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsString: string;
    ///<summary>Reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion. For example, this can be used when converting an <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object to an xs:string.This value can be <see langword="null" />
    ///  .</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.FormatException">The content is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="returnType" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not a supported node type. See the table below for details.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject(localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element contents as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime(localName: string; namespaceURI: string): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble(localName: string; namespaceURI: string): Double; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a single-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat(localName: string; namespaceURI: string): Single; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal(localName: string; namespaceURI: string): DDN.mscorlib.DNDecimal; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt(localName: string; namespaceURI: string): Int32; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong(localName: string; namespaceURI: string): Int64; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString(localName: string; namespaceURI: string): string; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver; localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node does not have a value (<see cref="P:System.Xml.XmlReader.HasValue" />
    ///  is <see langword="false" />
    ///  ).</exception><exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer, or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The XML data is not well-formed.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadValueChunk(buffer: TArray<Char>; index: Int32; count: Int32): Int32;
    ///<summary>Checks whether the current node is a content (non-white space text, <see langword="CDATA" />
    ///  , <see langword="Element" />
    ///  , <see langword="EndElement" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  ) node. If the node is not a content node, the reader skips ahead to the next content node or end of file. It skips over nodes of the following type: <see langword="ProcessingInstruction" />
    ///  , <see langword="DocumentType" />
    ///  , <see langword="Comment" />
    ///  , <see langword="Whitespace" />
    ///  , or <see langword="SignificantWhitespace" />
    ///  .</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToContent: DNXmlNodeType;
    ///<summary>Checks that the current node is an element and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.Name" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream. -or- The <see cref="P:System.Xml.XmlReader.Name" />
    ///  of the element does not match the given <paramref name="name" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(name: string); overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given string before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="name">The name to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="Name" />
    ///  does not match the given argument; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(name: string): string; overload;
    ///<summary>Checks that the current content node is an end tag and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">The current node is not an end tag or if incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadEndElement;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  finds a start tag or empty element tag; <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement: Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given argument.</summary>
    ///  <param name="name">The string matched against the <see langword="Name" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element and the <see langword="Name" />
    ///  property matches the specified string. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the element <see langword="Name" />
    ///  property does not match the specified string.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(name: string): Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found match the given strings.</summary>
    ///  <param name="localname">The string to match against the <see langword="LocalName" />
    ///  property of the element found.</param>
    ///  <param name="ns">The string to match against the <see langword="NamespaceURI" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the <see langword="LocalName" />
    ///  and <see langword="NamespaceURI" />
    ///  properties of the element do not match the specified strings.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(localname: string; ns: string): Boolean; overload;
    ///<summary>Reads until an element with the specified qualified name is found.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToFollowing(name: string): Boolean; overload;
    ///<summary>Reads until an element with the specified local name and namespace URI is found.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToFollowing(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToDescendant(name: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToDescendant(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToNextSibling(name: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the sibling element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise, <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToNextSibling(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>When overridden in a derived class, reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.If the current node is neither an element nor attribute, an empty string is returned.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadInnerXml: string;
    ///<summary>When overridden in a derived class, reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadOuterXml: string;
    ///<summary>Returns a new <see langword="XmlReader" />
    ///  instance that can be used to read the current node, and all its descendants.</summary>
    ///<returns>A new XML reader instance set to <see cref="F:System.Xml.ReadState.Initial" />
    ///  . Calling the <see cref="M:System.Xml.XmlReader.Read" />
    ///  method positions the new reader on the node that was current before the call to the <see cref="M:System.Xml.XmlReader.ReadSubtree" />
    ///  method.</returns>
    ///<exception cref="T:System.InvalidOperationException">The XML reader isn't positioned on an element when this method is called.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadSubtree: DNXmlReader;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlReader" />
    ///  class.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Dispose;
    ///<summary>Asynchronously gets the value of the current node.</summary>
    ///<returns>The value of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function GetValueAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>;
    ///<summary>Asynchronously skips the children of the current node.</summary>
    ///<returns>The current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function SkipAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadValueChunkAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously checks whether the current node is a content node. If the node is not a content node, the reader skips ahead to the next content node or end of file.</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function MoveToContentAsync: DDN.mscorlib.DNTask<DNXmlNodeType>;
    ///<summary>Reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject: DDN.mscorlib.DNObject; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Boolean" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean: Boolean; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.DateTime" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime: DDN.mscorlib.DNDateTime; overload;
    ///<summary>Reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a double-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble: Double; overload;
    ///<summary>Reads the current element and returns the contents as single-precision floating-point number.</summary>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat: Single; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal: DDN.mscorlib.DNDecimal; overload;
    ///<summary>Reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt: Int32; overload;
    ///<summary>Reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong: Int64; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString: string; overload;
    ///<summary>Reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="localname">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.-or-The <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found do not match the given arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(localname: string; ns: string); overload;
    ///<summary>Reads a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">The next content node is not a start tag; or the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString: string; overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found matches the given strings before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="localname">The local name to check.</param>
    ///  <param name="ns">The namespace URI to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="LocalName" />
    ///  or <see langword="NamespaceURI" />
    ///  do not match the given arguments; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(localname: string; ns: string): string; overload;
    ///<summary>Asynchronously reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="Base64" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the content and returns the <see langword="BinHex" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="BinHex" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadInnerXmlAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadOuterXmlAsync: DDN.mscorlib.DNTask<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the type of the current node.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlNodeType" />
    ///  values representing the type of the current node.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the qualified name of the current node.</summary>
    ///<returns>The qualified name of the current node. For example, <see langword="Name" />
    ///  is <see langword="bk:book" />
    ///  for the element &lt;bk:book&gt;.The name returned is dependent on the <see cref="P:System.Xml.XmlNodeReader.NodeType" />
    ///  of the node. The following node types return the listed values. All other node types return an empty string.Node Type Name
    ///<see langword="Attribute" />
    ///  The name of the attribute.
    ///<see langword="DocumentType" />
    ///  The document type name.
    ///<see langword="Element" />
    ///  The tag name.
    ///<see langword="EntityReference" />
    ///  The name of the entity referenced.
    ///<see langword="ProcessingInstruction" />
    ///  The target of the processing instruction.
    ///<see langword="XmlDeclaration" />
    ///  The literal string <see langword="xml" />
    ///  . </returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the current node.</summary>
    ///<returns>The name of the current node with the prefix removed. For example, <see langword="LocalName" />
    ///  is <see langword="book" />
    ///  for the element &lt;bk:book&gt;.For node types that do not have a name (like <see langword="Text" />
    ///  , <see langword="Comment" />
    ///  , and so on), this property returns String.Empty.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</summary>
    ///<returns>The namespace URI of the current node; otherwise an empty string.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets the namespace prefix associated with the current node.</summary>
    ///<returns>The namespace prefix associated with the current node.</returns>
    property Prefix: string read get_Prefix;
    ///<summary>Gets a value indicating whether the current node can have a <see cref="P:System.Xml.XmlNodeReader.Value" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the node on which the reader is currently positioned can have a <see langword="Value" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property HasValue: Boolean read get_HasValue;
    ///<summary>Gets the text value of the current node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlNodeReader.NodeType" />
    ///  of the node. The following table lists node types that have a value to return. All other node types return String.Empty.Node Type Value
    ///<see langword="Attribute" />
    ///  The value of the attribute.
    ///<see langword="CDATA" />
    ///  The content of the CDATA section.
    ///<see langword="Comment" />
    ///  The content of the comment.
    ///<see langword="DocumentType" />
    ///  The internal subset.
    ///<see langword="ProcessingInstruction" />
    ///  The entire content, excluding the target.
    ///<see langword="SignificantWhitespace" />
    ///  The white space between markup in a mixed content model.
    ///<see langword="Text" />
    ///  The content of the text node.
    ///<see langword="Whitespace" />
    ///  The white space between markup.
    ///<see langword="XmlDeclaration" />
    ///  The content of the declaration. </returns>
    property Value: string read get_Value;
    ///<summary>Gets the depth of the current node in the XML document.</summary>
    ///<returns>The depth of the current node in the XML document.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The base URI of the current node.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets a value indicating whether this reader can parse and resolve entities.</summary>
    ///<returns><see langword="true" />
    ///  if the reader can parse and resolve entities; otherwise, <see langword="false" />
    ///  . <see langword="XmlNodeReader" />
    ///  always returns <see langword="true" />
    ///  .</returns>
    property CanResolveEntity: Boolean read get_CanResolveEntity;
    ///<summary>Gets a value indicating whether the current node is an empty element (for example, &lt;MyElement/&gt;).</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an element (<see cref="P:System.Xml.XmlNodeReader.NodeType" />
    ///  equals <see langword="XmlNodeType.Element" />
    ///  ) and it ends with /&gt;; otherwise, <see langword="false" />
    ///  .</returns>
    property IsEmptyElement: Boolean read get_IsEmptyElement;
    ///<summary>Gets a value indicating whether the current node is an attribute that was generated from the default value defined in the document type definition (DTD) or schema.</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an attribute whose value was generated from the default value defined in the DTD or schema; <see langword="false" />
    ///  if the attribute value was explicitly set.</returns>
    property IsDefault: Boolean read get_IsDefault;
    ///<summary>Gets the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlSpace" />
    ///  values. If no <see langword="xml:space" />
    ///  scope exists, this property defaults to <see langword="XmlSpace.None" />
    ///  .</returns>
    property XmlSpace: DNXmlSpace read get_XmlSpace;
    ///<summary>Gets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  scope.</returns>
    property XmlLang: string read get_XmlLang;
    ///<summary>Gets the schema information that has been assigned to the current node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the schema information for the current node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets the number of attributes on the current node.</summary>
    ///<returns>The number of attributes on the current node. This number includes default attributes.</returns>
    property AttributeCount: Int32 read get_AttributeCount;
    ///<summary>Gets a value indicating whether the reader is positioned at the end of the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned at the end of the stream; otherwise, <see langword="false" />
    ///  .</returns>
    property EOF: Boolean read get_EOF;
    ///<summary>Gets the state of the reader.</summary>
    ///<returns>One of the <see cref="T:System.Xml.ReadState" />
    ///  values.</returns>
    property ReadState: DNReadState read get_ReadState;
    ///<summary>Gets a value indicating whether the current node has any attributes.</summary>
    ///<returns><see langword="true" />
    ///  if the current node has attributes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasAttributes: Boolean read get_HasAttributes;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this implementation.</summary>
    ///<returns>The <see langword="XmlNameTable" />
    ///  enabling you to get the atomized version of a string within the node.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlNodeReader" />
    ///  implements the binary content read methods.</summary>
    ///<returns><see langword="true" />
    ///  if the binary content read methods are implemented; otherwise <see langword="false" />
    ///  . The <see cref="T:System.Xml.XmlNodeReader" />
    ///  class always returns <see langword="true" />
    ///  .</returns>
    property CanReadBinaryContent: Boolean read get_CanReadBinaryContent;
    ///<summary>Gets the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this <see cref="T:System.Xml.XmlReader" />
    ///  instance.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this reader instance. If this reader was not created using the <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  method, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Settings: DNXmlReaderSettings read get_Settings;
    ///<summary>When overridden in a derived class, gets the quotation mark character used to enclose the value of an attribute node.</summary>
    ///<returns>The quotation mark character (" or ') used to enclose the value of an attribute node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property QuoteChar: Char read get_QuoteChar;
    ///<summary>Gets The Common Language Runtime (CLR) type for the current node.</summary>
    ///<returns>The CLR type that corresponds to the typed value of the node. The default is <see langword="System.String" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    property Item[i: Int32]: string read get_Item; default;
    property Item[name: string]: string read get_Item; default;
    property Item[name: string; namespaceURI: string]: string read get_Item; default;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XmlReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property CanReadValueChunk: Boolean read get_CanReadValueChunk;
  end;

  TDNXmlNodeReader = class(TDNGenericImport<DNXmlNodeReaderClass, DNXmlNodeReader>) end;

  //-------------namespace: System.Xml----------------
  DNXmlTextReaderClass = interface(DNXmlReaderClass)
  ['{9248CA7D-8AA7-55A3-AB75-E3083B9C90D6}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified stream.</summary>
    ///  <param name="input">The stream containing the XML data to read. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="input" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(input: DDN.mscorlib.DNStream): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified URL and stream.</summary>
    ///  <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" />
    ///  is set to this value. </param>
    ///  <param name="input">The stream containing the XML data to read. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="input" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(url: string; input: DDN.mscorlib.DNStream): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified stream and <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="input">The stream containing the XML data to read. </param>
    ///  <param name="nt">The <see langword="XmlNameTable" />
    ///  to use. </param>
    ///<exception cref="T:System.NullReferenceException">The <paramref name="input" />
    ///  or <paramref name="nt" />
    ///  value is <see langword="null" />
    ///  . </exception>
    {class} function init(input: DDN.mscorlib.DNStream; nt: DNXmlNameTable): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified URL, stream and <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" />
    ///  is set to this value. If <paramref name="url" />
    ///  is <see langword="null" />
    ///  , <see langword="BaseURI" />
    ///  is set to <see langword="String.Empty" />
    ///  . </param>
    ///  <param name="input">The stream containing the XML data to read. </param>
    ///  <param name="nt">The <see langword="XmlNameTable" />
    ///  to use. </param>
    ///<exception cref="T:System.NullReferenceException">The <paramref name="input" />
    ///  or <paramref name="nt" />
    ///  value is <see langword="null" />
    ///  . </exception>
    {class} function init(url: string; input: DDN.mscorlib.DNStream; nt: DNXmlNameTable): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="input">The <see langword="TextReader" />
    ///  containing the XML data to read. </param>
    {class} function init(input: DDN.mscorlib.DNTextReader): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified URL and <see cref="T:System.IO.TextReader" />
    ///  .</summary>
    ///  <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" />
    ///  is set to this value. </param>
    ///  <param name="input">The <see langword="TextReader" />
    ///  containing the XML data to read. </param>
    {class} function init(url: string; input: DDN.mscorlib.DNTextReader): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified <see cref="T:System.IO.TextReader" />
    ///  and <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="input">The <see langword="TextReader" />
    ///  containing the XML data to read. </param>
    ///  <param name="nt">The <see langword="XmlNameTable" />
    ///  to use. </param>
    ///<exception cref="T:System.NullReferenceException">The <paramref name="nt" />
    ///  value is <see langword="null" />
    ///  . </exception>
    {class} function init(input: DDN.mscorlib.DNTextReader; nt: DNXmlNameTable): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified URL, <see cref="T:System.IO.TextReader" />
    ///  and <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" />
    ///  is set to this value. If <paramref name="url" />
    ///  is <see langword="null" />
    ///  , <see langword="BaseURI" />
    ///  is set to <see langword="String.Empty" />
    ///  . </param>
    ///  <param name="input">The <see langword="TextReader" />
    ///  containing the XML data to read. </param>
    ///  <param name="nt">The <see langword="XmlNameTable" />
    ///  to use. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="nt" />
    ///  value is <see langword="null" />
    ///  . </exception>
    {class} function init(url: string; input: DDN.mscorlib.DNTextReader; nt: DNXmlNameTable): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified stream, <see cref="T:System.Xml.XmlNodeType" />
    ///  , and <see cref="T:System.Xml.XmlParserContext" />
    ///  .</summary>
    ///  <param name="xmlFragment">The stream containing the XML fragment to parse. </param>
    ///  <param name="fragType">The <see cref="T:System.Xml.XmlNodeType" />
    ///  of the XML fragment. This also determines what the fragment can contain. (See table below.) </param>
    ///  <param name="context">The <see cref="T:System.Xml.XmlParserContext" />
    ///  in which the <paramref name="xmlFragment" />
    ///  is to be parsed. This includes the <see cref="T:System.Xml.XmlNameTable" />
    ///  to use, encoding, namespace scope, the current xml:lang, and the xml:space scope. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="fragType" />
    ///  is not an Element, Attribute, or Document <see langword="XmlNodeType" />
    ///  . </exception><exception cref="T:System.ArgumentNullException"><paramref name="xmlFragment" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(xmlFragment: DDN.mscorlib.DNStream; fragType: DNXmlNodeType; context: DNXmlParserContext): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified string, <see cref="T:System.Xml.XmlNodeType" />
    ///  , and <see cref="T:System.Xml.XmlParserContext" />
    ///  .</summary>
    ///  <param name="xmlFragment">The string containing the XML fragment to parse. </param>
    ///  <param name="fragType">The <see cref="T:System.Xml.XmlNodeType" />
    ///  of the XML fragment. This also determines what the fragment string can contain. (See table below.) </param>
    ///  <param name="context">The <see cref="T:System.Xml.XmlParserContext" />
    ///  in which the <paramref name="xmlFragment" />
    ///  is to be parsed. This includes the <see cref="T:System.Xml.XmlNameTable" />
    ///  to use, encoding, namespace scope, the current xml:lang, and the xml:space scope. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="fragType" />
    ///  is not an <see langword="Element" />
    ///  , <see langword="Attribute" />
    ///  , or <see langword="Document" />
    ///<see langword="XmlNodeType" />
    ///  . </exception><exception cref="T:System.ArgumentNullException"><paramref name="xmlFragment" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(xmlFragment: string; fragType: DNXmlNodeType; context: DNXmlParserContext): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified file.</summary>
    ///  <param name="url">The URL for the file containing the XML data. The <see cref="P:System.Xml.XmlTextReader.BaseURI" />
    ///  is set to this value. </param>
    ///<exception cref="T:System.IO.FileNotFoundException">The specified file cannot be found.</exception><exception cref="T:System.IO.DirectoryNotFoundException">Part of the filename or directory cannot be found.</exception><exception cref="T:System.InvalidOperationException"><paramref name="url" />
    ///  is an empty string.</exception><exception cref="T:System.Net.WebException">The remote filename cannot be resolved.-or-An error occurred while processing the request.</exception><exception cref="T:System.UriFormatException"><paramref name="url" />
    ///  is not a valid URI.</exception>
    {class} function init(url: string): DNXmlTextReader; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />
    ///  class with the specified file and <see cref="T:System.Xml.XmlNameTable" />
    ///  .</summary>
    ///  <param name="url">The URL for the file containing the XML data to read. </param>
    ///  <param name="nt">The <see langword="XmlNameTable" />
    ///  to use. </param>
    ///<exception cref="T:System.NullReferenceException">The <paramref name="nt" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.IO.FileNotFoundException">The specified file cannot be found.</exception><exception cref="T:System.IO.DirectoryNotFoundException">Part of the filename or directory cannot be found.</exception><exception cref="T:System.InvalidOperationException"><paramref name="url" />
    ///  is an empty string.</exception><exception cref="T:System.Net.WebException">The remote filename cannot be resolved.-or-An error occurred while processing the request.</exception><exception cref="T:System.UriFormatException"><paramref name="url" />
    ///  is not a valid URI.</exception>
    {class} function init(url: string; nt: DNXmlNameTable): DNXmlTextReader; overload;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used for resolving DTD references.</summary>
    ///<returns>The <see langword="XmlResolver" />
    ///  to use. If set to <see langword="null" />
    ///  , external resources are not resolved.In version 1.1 of the .NET Framework, the caller must be fully trusted in order to specify an <see langword="XmlResolver" />
    ///  .</returns>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  ///<summary>Represents a reader that provides fast, non-cached, forward-only access to XML data.Starting with the .NET Framework 2.0, we recommend that you use the <see cref="T:System.Xml.XmlReader" />
  ///  class instead.</summary>
  [DNTypeName('System.Xml.XmlTextReader')]
  DNXmlTextReader = interface(DNXmlReader)
  ['{9C42EB13-F238-3F97-81B9-9C1B73D5A449}']
  { getters & setters } 

    function get_NodeType: DNXmlNodeType;
    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    function get_HasValue: Boolean;
    function get_Value: string;
    function get_Depth: Int32;
    function get_BaseURI: string;
    function get_IsEmptyElement: Boolean;
    function get_IsDefault: Boolean;
    function get_QuoteChar: Char;
    function get_XmlSpace: DNXmlSpace;
    function get_XmlLang: string;
    function get_AttributeCount: Int32;
    function get_EOF: Boolean;
    function get_ReadState: DNReadState;
    function get_NameTable: DNXmlNameTable;
    function get_CanResolveEntity: Boolean;
    function get_CanReadBinaryContent: Boolean;
    function get_CanReadValueChunk: Boolean;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_Namespaces: Boolean;
    procedure set_Namespaces(value: Boolean);
    function get_Normalization: Boolean;
    procedure set_Normalization(value: Boolean);
    function get_Encoding: DDN.mscorlib.DNEncoding;
    function get_WhitespaceHandling: DNWhitespaceHandling;
    procedure set_WhitespaceHandling(value: DNWhitespaceHandling);
    function get_ProhibitDtd: Boolean;
    procedure set_ProhibitDtd(value: Boolean);
    function get_DtdProcessing: DNDtdProcessing;
    procedure set_DtdProcessing(value: DNDtdProcessing);
    function get_EntityHandling: DNEntityHandling;
    procedure set_EntityHandling(value: DNEntityHandling);
    procedure set_XmlResolver(value: DNXmlResolver);
    function get_Settings: DNXmlReaderSettings;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_Item(i: Int32): string; overload;
    function get_Item(name: string): string; overload;
    function get_Item(name: string; namespaceURI: string): string; overload;
    function get_HasAttributes: Boolean;

  { methods } 

    ///<summary>Gets the value of the attribute with the specified name.</summary>
    ///  <param name="name">The qualified name of the attribute. </param>
    ///<returns>The value of the specified attribute. If the attribute is not found, <see langword="null" />
    ///  is returned.</returns>
    function GetAttribute(name: string): string; overload;
    ///<summary>Gets the value of the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns>The value of the specified attribute. If the attribute is not found, <see langword="null" />
    ///  is returned. This method does not move the reader.</returns>
    function GetAttribute(localName: string; namespaceURI: string): string; overload;
    ///<summary>Gets the value of the attribute with the specified index.</summary>
    ///  <param name="i">The index of the attribute. The index is zero-based. (The first attribute has index 0.) </param>
    ///<returns>The value of the specified attribute.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" />
    ///  parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlTextReader.AttributeCount" />
    ///  . </exception>
    function GetAttribute(i: Int32): string; overload;
    ///<summary>Moves to the attribute with the specified name.</summary>
    ///  <param name="name">The qualified name of the attribute. </param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the reader's position does not change.</returns>
    function MoveToAttribute(name: string): Boolean; overload;
    ///<summary>Moves to the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the reader's position does not change.</returns>
    function MoveToAttribute(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Moves to the attribute with the specified index.</summary>
    ///  <param name="i">The index of the attribute. </param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" />
    ///  parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlReader.AttributeCount" />
    ///  . </exception>
    procedure MoveToAttribute(i: Int32); overload;
    ///<summary>Moves to the first attribute.</summary>
    ///<returns><see langword="true" />
    ///  if an attribute exists (the reader moves to the first attribute); otherwise, <see langword="false" />
    ///  (the position of the reader does not change).</returns>
    function MoveToFirstAttribute: Boolean;
    ///<summary>Moves to the next attribute.</summary>
    ///<returns><see langword="true" />
    ///  if there is a next attribute; <see langword="false" />
    ///  if there are no more attributes.</returns>
    function MoveToNextAttribute: Boolean;
    ///<summary>Moves to the element that contains the current attribute node.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <see langword="false" />
    ///  if the reader is not positioned on an attribute (the position of the reader does not change).</returns>
    function MoveToElement: Boolean;
    ///<summary>Parses the attribute value into one or more <see langword="Text" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  nodes.</summary>
    ///<returns><see langword="true" />
    ///  if there are nodes to return.
    ///<see langword="false" />
    ///  if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.An empty attribute, such as, misc="", returns <see langword="true" />
    ///  with a single node with a value of <see langword="String.Empty" />
    ///  .</returns>
    function ReadAttributeValue: Boolean;
    ///<summary>Reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    ///<exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML. </exception>
    function Read: Boolean;
    ///<summary>Changes the <see cref="P:System.Xml.XmlReader.ReadState" />
    ///  to <see langword="Closed" />
    ///  .</summary>
    procedure Close;
    ///<summary>Skips the children of the current node.</summary>
    procedure Skip;
    ///<summary>Resolves a namespace prefix in the current element's scope.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass an empty string. This string does not have to be atomized. </param>
    ///<returns>The namespace URI to which the prefix maps or <see langword="null" />
    ///  if no matching prefix is found.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="P:System.Xml.XmlTextReader.Namespaces" />
    ///  property is set to <see langword="true" />
    ///  and the <paramref name="prefix" />
    ///  value is <see langword="null" />
    ///  . </exception>
    function LookupNamespace(prefix: string): string;
    ///<summary>Resolves the entity reference for <see langword="EntityReference" />
    ///  nodes.</summary>
    procedure ResolveEntity;
    ///<summary>Reads the content and returns the <see langword="Base64" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported in the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
    function ReadContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the Base64 content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlTextReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
    function ReadElementContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the content and returns the <see langword="BinHex" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlTextReader" />
    ///  implementation does not support this method.</exception>
    function ReadContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the <see langword="BinHex" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
    function ReadElementContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the contents of an element or a text node as a string.</summary>
    ///<returns>The contents of the element or text node. This can be an empty string if the reader is positioned on something other than an element or text node, or if there is no more text content to return in the current context.
    ///<see langword="Note:" />
    ///  The text node can be either an element or an attribute text node.</returns>
    ///<exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML. </exception><exception cref="T:System.InvalidOperationException">An invalid operation was attempted. </exception>
    function ReadString: string;
    ///<summary>Gets a value indicating whether the class can return line information.</summary>
    ///<returns><see langword="true" />
    ///  if the class can return line information; otherwise, <see langword="false" />
    ///  .</returns>
    function HasLineInfo: Boolean;
    ///<summary>Gets a collection that contains all namespaces currently in-scope.</summary>
    ///  <param name="scope">An <see cref="T:System.Xml.XmlNamespaceScope" />
    ///  value that specifies the type of namespace nodes to return.</param>
    ///<returns>An <see cref="T:System.Collections.IDictionary" />
    ///  object that contains all the current in-scope namespaces. If the reader is not positioned on an element, an empty dictionary (no namespaces) is returned.</returns>
    function GetNamespacesInScope(scope: DNXmlNamespaceScope): DDN.mscorlib.DNIDictionary<string, string>;
    ///<summary>Resets the state of the reader to ReadState.Initial.</summary>
    ///<exception cref="T:System.InvalidOperationException">Calling <see langword="ResetState" />
    ///  if the reader was constructed using an <see cref="T:System.Xml.XmlParserContext" />
    ///  . </exception><exception cref="T:System.Xml.XmlException">Documents in a single stream do not share the same encoding.</exception>
    procedure ResetState;
    ///<summary>Gets the remainder of the buffered XML.</summary>
    ///<returns>A <see cref="T:System.IO.TextReader" />
    ///  containing the remainder of the buffered XML.</returns>
    function GetRemainder: DDN.mscorlib.DNTextReader;
    ///<summary>Reads the text contents of an element into a character buffer. This method is designed to read large streams of embedded text by calling it successively.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. </param>
    ///  <param name="index">The position within <paramref name="buffer" />
    ///  where the method can begin writing text contents. </param>
    ///  <param name="count">The number of characters to write into <paramref name="buffer" />
    ///  . </param>
    ///<returns>The number of characters read. This can be <see langword="0" />
    ///  if the reader is not positioned on an element or if there is no more text content to return in the current context.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="count" />
    ///  is greater than the space specified in the <paramref name="buffer" />
    ///  (buffer size - <paramref name="index" />
    ///  ). </exception><exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///<see langword="&lt; 0" />
    ///  or <paramref name="count" />
    ///<see langword="&lt; 0" />
    ///  . </exception>
    function ReadChars(buffer: TArray<Char>; index: Int32; count: Int32): Int32;
    ///<summary>Decodes Base64 and returns the decoded binary bytes.</summary>
    ///  <param name="array">The array of characters that serves as the buffer to which the text contents are written. </param>
    ///  <param name="offset">The zero-based index into the array specifying where the method can begin to write to the buffer. </param>
    ///  <param name="len">The number of bytes to write into the buffer. </param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.Xml.XmlException">The Base64 sequence is not valid. </exception><exception cref="T:System.ArgumentNullException">The value of <paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  &lt; 0, or <paramref name="len" />
    ///  &lt; 0, or <paramref name="len" />
    ///  &gt; <paramref name="array" />
    ///  .Length- <paramref name="offset" />
    ///  . </exception>
    function ReadBase64(&array: TArray<Byte>; offset: Int32; len: Int32): Int32;
    ///<summary>Decodes <see langword="BinHex" />
    ///  and returns the decoded binary bytes.</summary>
    ///  <param name="array">The byte array that serves as the buffer to which the decoded binary bytes are written. </param>
    ///  <param name="offset">The zero-based index into the array specifying where the method can begin to write to the buffer. </param>
    ///  <param name="len">The number of bytes to write into the buffer. </param>
    ///<returns>The number of bytes written to your buffer.</returns>
    ///<exception cref="T:System.Xml.XmlException">The <see langword="BinHex" />
    ///  sequence is not valid. </exception><exception cref="T:System.ArgumentNullException">The value of <paramref name="array" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  &lt; 0, or <paramref name="len" />
    ///  &lt; 0, or <paramref name="len" />
    ///  &gt; <paramref name="array" />
    ///  .Length- <paramref name="offset" />
    ///  . </exception>
    function ReadBinHex(&array: TArray<Byte>; offset: Int32; len: Int32): Int32;
    ///<summary>Reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsObject: DDN.mscorlib.DNObject;
    ///<summary>Reads the text content at the current position as a <see langword="Boolean" />
    ///  .</summary>
    ///<returns>The text content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsBoolean: Boolean;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTime: DDN.mscorlib.DNDateTime;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTimeOffset" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTimeOffset" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTimeOffset: DDN.mscorlib.DNDateTimeOffset;
    ///<summary>Reads the text content at the current position as a double-precision floating-point number.</summary>
    ///<returns>The text content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDouble: Double;
    ///<summary>Reads the text content at the current position as a single-precision floating point number.</summary>
    ///<returns>The text content at the current position as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsFloat: Single;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDecimal: DDN.mscorlib.DNDecimal;
    ///<summary>Reads the text content at the current position as a 32-bit signed integer.</summary>
    ///<returns>The text content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsInt: Int32;
    ///<summary>Reads the text content at the current position as a 64-bit signed integer.</summary>
    ///<returns>The text content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsLong: Int64;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsString: string;
    ///<summary>Reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion. For example, this can be used when converting an <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object to an xs:string.This value can be <see langword="null" />
    ///  .</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.FormatException">The content is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="returnType" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not a supported node type. See the table below for details.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject(localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element contents as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime(localName: string; namespaceURI: string): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble(localName: string; namespaceURI: string): Double; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a single-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat(localName: string; namespaceURI: string): Single; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal(localName: string; namespaceURI: string): DDN.mscorlib.DNDecimal; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt(localName: string; namespaceURI: string): Int32; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong(localName: string; namespaceURI: string): Int64; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString(localName: string; namespaceURI: string): string; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver; localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node does not have a value (<see cref="P:System.Xml.XmlReader.HasValue" />
    ///  is <see langword="false" />
    ///  ).</exception><exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer, or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The XML data is not well-formed.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadValueChunk(buffer: TArray<Char>; index: Int32; count: Int32): Int32;
    ///<summary>Checks whether the current node is a content (non-white space text, <see langword="CDATA" />
    ///  , <see langword="Element" />
    ///  , <see langword="EndElement" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  ) node. If the node is not a content node, the reader skips ahead to the next content node or end of file. It skips over nodes of the following type: <see langword="ProcessingInstruction" />
    ///  , <see langword="DocumentType" />
    ///  , <see langword="Comment" />
    ///  , <see langword="Whitespace" />
    ///  , or <see langword="SignificantWhitespace" />
    ///  .</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToContent: DNXmlNodeType;
    ///<summary>Checks that the current node is an element and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.Name" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream. -or- The <see cref="P:System.Xml.XmlReader.Name" />
    ///  of the element does not match the given <paramref name="name" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(name: string); overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given string before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="name">The name to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="Name" />
    ///  does not match the given argument; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(name: string): string; overload;
    ///<summary>Checks that the current content node is an end tag and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">The current node is not an end tag or if incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadEndElement;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  finds a start tag or empty element tag; <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement: Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given argument.</summary>
    ///  <param name="name">The string matched against the <see langword="Name" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element and the <see langword="Name" />
    ///  property matches the specified string. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the element <see langword="Name" />
    ///  property does not match the specified string.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(name: string): Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found match the given strings.</summary>
    ///  <param name="localname">The string to match against the <see langword="LocalName" />
    ///  property of the element found.</param>
    ///  <param name="ns">The string to match against the <see langword="NamespaceURI" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the <see langword="LocalName" />
    ///  and <see langword="NamespaceURI" />
    ///  properties of the element do not match the specified strings.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(localname: string; ns: string): Boolean; overload;
    ///<summary>Reads until an element with the specified qualified name is found.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToFollowing(name: string): Boolean; overload;
    ///<summary>Reads until an element with the specified local name and namespace URI is found.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToFollowing(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToDescendant(name: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToDescendant(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToNextSibling(name: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the sibling element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise, <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToNextSibling(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>When overridden in a derived class, reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.If the current node is neither an element nor attribute, an empty string is returned.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadInnerXml: string;
    ///<summary>When overridden in a derived class, reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadOuterXml: string;
    ///<summary>Returns a new <see langword="XmlReader" />
    ///  instance that can be used to read the current node, and all its descendants.</summary>
    ///<returns>A new XML reader instance set to <see cref="F:System.Xml.ReadState.Initial" />
    ///  . Calling the <see cref="M:System.Xml.XmlReader.Read" />
    ///  method positions the new reader on the node that was current before the call to the <see cref="M:System.Xml.XmlReader.ReadSubtree" />
    ///  method.</returns>
    ///<exception cref="T:System.InvalidOperationException">The XML reader isn't positioned on an element when this method is called.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadSubtree: DNXmlReader;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlReader" />
    ///  class.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Dispose;
    ///<summary>Asynchronously gets the value of the current node.</summary>
    ///<returns>The value of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function GetValueAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>;
    ///<summary>Asynchronously skips the children of the current node.</summary>
    ///<returns>The current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function SkipAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadValueChunkAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously checks whether the current node is a content node. If the node is not a content node, the reader skips ahead to the next content node or end of file.</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function MoveToContentAsync: DDN.mscorlib.DNTask<DNXmlNodeType>;
    ///<summary>Reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject: DDN.mscorlib.DNObject; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Boolean" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean: Boolean; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.DateTime" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime: DDN.mscorlib.DNDateTime; overload;
    ///<summary>Reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a double-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble: Double; overload;
    ///<summary>Reads the current element and returns the contents as single-precision floating-point number.</summary>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat: Single; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal: DDN.mscorlib.DNDecimal; overload;
    ///<summary>Reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt: Int32; overload;
    ///<summary>Reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong: Int64; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString: string; overload;
    ///<summary>Reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="localname">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.-or-The <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found do not match the given arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(localname: string; ns: string); overload;
    ///<summary>Reads a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">The next content node is not a start tag; or the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString: string; overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found matches the given strings before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="localname">The local name to check.</param>
    ///  <param name="ns">The namespace URI to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="LocalName" />
    ///  or <see langword="NamespaceURI" />
    ///  do not match the given arguments; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(localname: string; ns: string): string; overload;
    ///<summary>Asynchronously reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="Base64" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the content and returns the <see langword="BinHex" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="BinHex" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadInnerXmlAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadOuterXmlAsync: DDN.mscorlib.DNTask<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the type of the current node.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlNodeType" />
    ///  values representing the type of the current node.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the qualified name of the current node.</summary>
    ///<returns>The qualified name of the current node. For example, <see langword="Name" />
    ///  is <see langword="bk:book" />
    ///  for the element &lt;bk:book&gt;.The name returned is dependent on the <see cref="P:System.Xml.XmlTextReader.NodeType" />
    ///  of the node. The following node types return the listed values. All other node types return an empty string.Node Type Name
    ///<see langword="Attribute" />
    ///  The name of the attribute.
    ///<see langword="DocumentType" />
    ///  The document type name.
    ///<see langword="Element" />
    ///  The tag name.
    ///<see langword="EntityReference" />
    ///  The name of the entity referenced.
    ///<see langword="ProcessingInstruction" />
    ///  The target of the processing instruction.
    ///<see langword="XmlDeclaration" />
    ///  The literal string <see langword="xml" />
    ///  . </returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the current node.</summary>
    ///<returns>The name of the current node with the prefix removed. For example, <see langword="LocalName" />
    ///  is <see langword="book" />
    ///  for the element &lt;bk:book&gt;.For node types that do not have a name (like <see langword="Text" />
    ///  , <see langword="Comment" />
    ///  , and so on), this property returns <see langword="String.Empty" />
    ///  .</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</summary>
    ///<returns>The namespace URI of the current node; otherwise an empty string.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets the namespace prefix associated with the current node.</summary>
    ///<returns>The namespace prefix associated with the current node.</returns>
    property Prefix: string read get_Prefix;
    ///<summary>Gets a value indicating whether the current node can have a <see cref="P:System.Xml.XmlTextReader.Value" />
    ///  other than <see langword="String.Empty" />
    ///  .</summary>
    ///<returns><see langword="true" />
    ///  if the node on which the reader is currently positioned can have a <see langword="Value" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property HasValue: Boolean read get_HasValue;
    ///<summary>Gets the text value of the current node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlTextReader.NodeType" />
    ///  of the node. The following table lists node types that have a value to return. All other node types return <see langword="String.Empty" />
    ///  .Node Type Value
    ///<see langword="Attribute" />
    ///  The value of the attribute.
    ///<see langword="CDATA" />
    ///  The content of the CDATA section.
    ///<see langword="Comment" />
    ///  The content of the comment.
    ///<see langword="DocumentType" />
    ///  The internal subset.
    ///<see langword="ProcessingInstruction" />
    ///  The entire content, excluding the target.
    ///<see langword="SignificantWhitespace" />
    ///  The white space within an <see langword="xml:space" />
    ///  = 'preserve' scope.
    ///<see langword="Text" />
    ///  The content of the text node.
    ///<see langword="Whitespace" />
    ///  The white space between markup.
    ///<see langword="XmlDeclaration" />
    ///  The content of the declaration. </returns>
    property Value: string read get_Value;
    ///<summary>Gets the depth of the current node in the XML document.</summary>
    ///<returns>The depth of the current node in the XML document.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The base URI of the current node.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets a value indicating whether the current node is an empty element (for example, &lt;MyElement/&gt;).</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an element (<see cref="P:System.Xml.XmlTextReader.NodeType" />
    ///  equals <see langword="XmlNodeType.Element" />
    ///  ) that ends with /&gt;; otherwise, <see langword="false" />
    ///  .</returns>
    property IsEmptyElement: Boolean read get_IsEmptyElement;
    ///<summary>Gets a value indicating whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</summary>
    ///<returns>This property always returns <see langword="false" />
    ///  . (<see cref="T:System.Xml.XmlTextReader" />
    ///  does not expand default attributes.) </returns>
    property IsDefault: Boolean read get_IsDefault;
    ///<summary>Gets the quotation mark character used to enclose the value of an attribute node.</summary>
    ///<returns>The quotation mark character (" or ') used to enclose the value of an attribute node.</returns>
    property QuoteChar: Char read get_QuoteChar;
    ///<summary>Gets the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlSpace" />
    ///  values. If no <see langword="xml:space" />
    ///  scope exists, this property defaults to <see langword="XmlSpace.None" />
    ///  .</returns>
    property XmlSpace: DNXmlSpace read get_XmlSpace;
    ///<summary>Gets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  scope.</returns>
    property XmlLang: string read get_XmlLang;
    ///<summary>Gets the number of attributes on the current node.</summary>
    ///<returns>The number of attributes on the current node.</returns>
    property AttributeCount: Int32 read get_AttributeCount;
    ///<summary>Gets a value indicating whether the reader is positioned at the end of the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned at the end of the stream; otherwise, <see langword="false" />
    ///  .</returns>
    property EOF: Boolean read get_EOF;
    ///<summary>Gets the state of the reader.</summary>
    ///<returns>One of the <see cref="T:System.Xml.ReadState" />
    ///  values.</returns>
    property ReadState: DNReadState read get_ReadState;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this implementation.</summary>
    ///<returns>The <see langword="XmlNameTable" />
    ///  enabling you to get the atomized version of a string within the node.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets a value indicating whether this reader can parse and resolve entities.</summary>
    ///<returns><see langword="true" />
    ///  if the reader can parse and resolve entities; otherwise, <see langword="false" />
    ///  . The <see langword="XmlTextReader" />
    ///  class always returns <see langword="true" />
    ///  .</returns>
    property CanResolveEntity: Boolean read get_CanResolveEntity;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlTextReader" />
    ///  implements the binary content read methods.</summary>
    ///<returns><see langword="true" />
    ///  if the binary content read methods are implemented; otherwise <see langword="false" />
    ///  . The <see cref="T:System.Xml.XmlTextReader" />
    ///  class always returns <see langword="true" />
    ///  .</returns>
    property CanReadBinaryContent: Boolean read get_CanReadBinaryContent;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlTextReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XmlTextReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method; otherwise <see langword="false" />
    ///  . The <see cref="T:System.Xml.XmlTextReader" />
    ///  class always returns <see langword="false" />
    ///  .</returns>
    property CanReadValueChunk: Boolean read get_CanReadValueChunk;
    ///<summary>Gets the current line number.</summary>
    ///<returns>The current line number.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the current line position.</summary>
    ///<returns>The current line position.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets or sets a value indicating whether to do namespace support.</summary>
    ///<returns><see langword="true" />
    ///  to do namespace support; otherwise, <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">Setting this property after a read operation has occurred (<see cref="P:System.Xml.XmlTextReader.ReadState" />
    ///  is not <see langword="ReadState.Initial" />
    ///  ). </exception>
    property Namespaces: Boolean read get_Namespaces write set_Namespaces;
    ///<summary>Gets or sets a value indicating whether to normalize white space and attribute values.</summary>
    ///<returns><see langword="true" />
    ///  to normalize; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">Setting this property when the reader is closed (<see cref="P:System.Xml.XmlTextReader.ReadState" />
    ///  is <see langword="ReadState.Closed" />
    ///  ). </exception>
    property Normalization: Boolean read get_Normalization write set_Normalization;
    ///<summary>Gets the encoding of the document.</summary>
    ///<returns>The encoding value. If no encoding attribute exists, and there is no byte-order mark, this defaults to UTF-8.</returns>
    property Encoding: DDN.mscorlib.DNEncoding read get_Encoding;
    ///<summary>Gets or sets a value that specifies how white space is handled.</summary>
    ///<returns>One of the <see cref="T:System.Xml.WhitespaceHandling" />
    ///  values. The default is <see langword="WhitespaceHandling.All" />
    ///  (returns <see langword="Whitespace" />
    ///  and <see langword="SignificantWhitespace" />
    ///  nodes).</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">Invalid value specified. </exception><exception cref="T:System.InvalidOperationException">Setting this property when the reader is closed (<see cref="P:System.Xml.XmlTextReader.ReadState" />
    ///  is <see langword="ReadState.Closed" />
    ///  ). </exception>
    property WhitespaceHandling: DNWhitespaceHandling read get_WhitespaceHandling write set_WhitespaceHandling;
    ///<summary>Gets or sets a value indicating whether to allow DTD processing. This property is obsolete. Use <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />
    ///  instead.</summary>
    ///<returns><see langword="true" />
    ///  to disallow DTD processing; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property ProhibitDtd: Boolean read get_ProhibitDtd write set_ProhibitDtd;
    ///<summary>Gets or sets the <see cref="T:System.Xml.DtdProcessing" />
    ///  enumeration.</summary>
    ///<returns>The <see cref="T:System.Xml.DtdProcessing" />
    ///  enumeration.</returns>
    property DtdProcessing: DNDtdProcessing read get_DtdProcessing write set_DtdProcessing;
    ///<summary>Gets or sets a value that specifies how the reader handles entities.</summary>
    ///<returns>One of the <see cref="T:System.Xml.EntityHandling" />
    ///  values. If no <see langword="EntityHandling" />
    ///  is specified, it defaults to <see langword="EntityHandling.ExpandCharEntities" />
    ///  .</returns>
    property EntityHandling: DNEntityHandling read get_EntityHandling write set_EntityHandling;
    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used for resolving DTD references.</summary>
    ///<returns>The <see langword="XmlResolver" />
    ///  to use. If set to <see langword="null" />
    ///  , external resources are not resolved.In version 1.1 of the .NET Framework, the caller must be fully trusted in order to specify an <see langword="XmlResolver" />
    ///  .</returns>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>Gets the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this <see cref="T:System.Xml.XmlReader" />
    ///  instance.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this reader instance. If this reader was not created using the <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  method, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Settings: DNXmlReaderSettings read get_Settings;
    ///<summary>Gets the schema information that has been assigned to the current node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the schema information for the current node. Schema information can be set on elements, attributes, or on text nodes with a non-null <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  (typed values).If the current node is not one of the above node types, or if the <see langword="XmlReader" />
    ///  instance does not report schema information, this property returns <see langword="null" />
    ///  .If this property is called from an <see cref="T:System.Xml.XmlTextReader" />
    ///  or an <see cref="T:System.Xml.XmlValidatingReader" />
    ///  object, this property always returns <see langword="null" />
    ///  . These <see langword="XmlReader" />
    ///  implementations do not expose schema information through the <see langword="SchemaInfo" />
    ///  property.If you have to get the post-schema-validation information set (PSVI) for an element, position the reader on the end tag of the element, rather than on the start tag. You get the PSVI through the <see langword="SchemaInfo" />
    ///  property of a reader. The validating reader that is created through <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  with the <see cref="P:System.Xml.XmlReaderSettings.ValidationType" />
    ///  property set to <see cref="F:System.Xml.ValidationType.Schema" />
    ///  has complete PSVI for an element only when the reader is positioned on the end tag of an element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets The Common Language Runtime (CLR) type for the current node.</summary>
    ///<returns>The CLR type that corresponds to the typed value of the node. The default is <see langword="System.String" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    property Item[i: Int32]: string read get_Item; default;
    property Item[name: string]: string read get_Item; default;
    property Item[name: string; namespaceURI: string]: string read get_Item; default;
    ///<summary>Gets a value indicating whether the current node has any attributes.</summary>
    ///<returns><see langword="true" />
    ///  if the current node has attributes; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property HasAttributes: Boolean read get_HasAttributes;
  end;

  TDNXmlTextReader = class(TDNGenericImport<DNXmlTextReaderClass, DNXmlTextReader>) end;

  //-------------namespace: System.Xml----------------
  DNXmlValidatingReaderClass = interface(DNXmlReaderClass)
  ['{1645BEFA-C34C-52E2-B176-909DD78E25CF}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { constructors } 

    ///<summary>Initializes a new instance of the <see langword="XmlValidatingReader" />
    ///  class that validates the content returned from the given <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  to read from while validating. The current implementation supports only <see cref="T:System.Xml.XmlTextReader" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The reader specified is not an <see langword="XmlTextReader" />
    ///  . </exception>
    {class} function init(reader: DNXmlReader): DNXmlValidatingReader; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlValidatingReader" />
    ///  class with the specified values.</summary>
    ///  <param name="xmlFragment">The string containing the XML fragment to parse. </param>
    ///  <param name="fragType">The <see cref="T:System.Xml.XmlNodeType" />
    ///  of the XML fragment. This also determines what the fragment string can contain (see table below). </param>
    ///  <param name="context">The <see cref="T:System.Xml.XmlParserContext" />
    ///  in which the XML fragment is to be parsed. This includes the <see cref="T:System.Xml.NameTable" />
    ///  to use, encoding, namespace scope, current xml:lang, and xml:space scope. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="fragType" />
    ///  is not one of the node types listed in the table below. </exception>
    {class} function init(xmlFragment: string; fragType: DNXmlNodeType; context: DNXmlParserContext): DNXmlValidatingReader; overload;
    ///<summary>Initializes a new instance of the <see langword="XmlValidatingReader" />
    ///  class with the specified values.</summary>
    ///  <param name="xmlFragment">The stream containing the XML fragment to parse. </param>
    ///  <param name="fragType">The <see cref="T:System.Xml.XmlNodeType" />
    ///  of the XML fragment. This determines what the fragment can contain (see table below). </param>
    ///  <param name="context">The <see cref="T:System.Xml.XmlParserContext" />
    ///  in which the XML fragment is to be parsed. This includes the <see cref="T:System.Xml.XmlNameTable" />
    ///  to use, encoding, namespace scope, current <see langword="xml:lang" />
    ///  , and <see langword="xml:space" />
    ///  scope. </param>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="fragType" />
    ///  is not one of the node types listed in the table below. </exception>
    {class} function init(xmlFragment: DDN.mscorlib.DNStream; fragType: DNXmlNodeType; context: DNXmlParserContext): DNXmlValidatingReader; overload;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used for resolving external document type definition (DTD) and schema location references. The <see langword="XmlResolver" />
    ///  is also used to handle any import or include elements found in XML Schema definition language (XSD) schemas.</summary>
    ///<returns>The <see langword="XmlResolver" />
    ///  to use. If set to <see langword="null" />
    ///  , external resources are not resolved.In version 1.1 of the .NET Framework, the caller must be fully trusted to specify an <see langword="XmlResolver" />
    ///  .</returns>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  ///<summary>Represents a reader that provides document type definition (DTD), XML-Data Reduced (XDR) schema, and XML Schema definition language (XSD) validation.This class is obsolete. Starting with the .NET Framework 2.0, we recommend that you use the <see cref="T:System.Xml.XmlReaderSettings" />
  ///  class and the <see cref="Overload:System.Xml.XmlReader.Create" />
  ///  method to create a validating XML reader.</summary>
  [DNTypeName('System.Xml.XmlValidatingReader')]
  DNXmlValidatingReader = interface(DNXmlReader)
  ['{08C23F4D-44D8-3B08-A427-06D6802DDAB0}']
  { getters & setters } 

    function get_NodeType: DNXmlNodeType;
    function get_Name: string;
    function get_LocalName: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    function get_HasValue: Boolean;
    function get_Value: string;
    function get_Depth: Int32;
    function get_BaseURI: string;
    function get_IsEmptyElement: Boolean;
    function get_IsDefault: Boolean;
    function get_QuoteChar: Char;
    function get_XmlSpace: DNXmlSpace;
    function get_XmlLang: string;
    function get_AttributeCount: Int32;
    function get_EOF: Boolean;
    function get_ReadState: DNReadState;
    function get_NameTable: DNXmlNameTable;
    function get_CanResolveEntity: Boolean;
    function get_CanReadBinaryContent: Boolean;
    function get_LineNumber: Int32;
    function get_LinePosition: Int32;
    function get_SchemaType: DDN.mscorlib.DNObject;
    function get_Reader: DNXmlReader;
    function get_ValidationType: DNValidationType;
    procedure set_ValidationType(value: DNValidationType);
    function get_Schemas: DNXmlSchemaCollection;
    function get_EntityHandling: DNEntityHandling;
    procedure set_EntityHandling(value: DNEntityHandling);
    procedure set_XmlResolver(value: DNXmlResolver);
    function get_Namespaces: Boolean;
    procedure set_Namespaces(value: Boolean);
    function get_Encoding: DDN.mscorlib.DNEncoding;
    function get_Settings: DNXmlReaderSettings;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_Item(i: Int32): string; overload;
    function get_Item(name: string): string; overload;
    function get_Item(name: string; namespaceURI: string): string; overload;
    function get_CanReadValueChunk: Boolean;
    function get_HasAttributes: Boolean;

  { events } 

    procedure add_ValidationEventHandler(value: DNValidationEventHandler);
    procedure remove_ValidationEventHandler(value: DNValidationEventHandler);

  { methods } 

    ///<summary>Gets the value of the attribute with the specified name.</summary>
    ///  <param name="name">The qualified name of the attribute. </param>
    ///<returns>The value of the specified attribute. If the attribute is not found, <see langword="null" />
    ///  is returned.</returns>
    function GetAttribute(name: string): string; overload;
    ///<summary>Gets the value of the attribute with the specified local name and namespace Uniform Resource Identifier (URI).</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns>The value of the specified attribute. If the attribute is not found, <see langword="null" />
    ///  is returned. This method does not move the reader.</returns>
    function GetAttribute(localName: string; namespaceURI: string): string; overload;
    ///<summary>Gets the value of the attribute with the specified index.</summary>
    ///  <param name="i">The index of the attribute. The index is zero-based. (The first attribute has index 0.) </param>
    ///<returns>The value of the specified attribute.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" />
    ///  parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlValidatingReader.AttributeCount" />
    ///  . </exception>
    function GetAttribute(i: Int32): string; overload;
    ///<summary>Moves to the attribute with the specified name.</summary>
    ///  <param name="name">The qualified name of the attribute. </param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the reader does not change.</returns>
    function MoveToAttribute(name: string): Boolean; overload;
    ///<summary>Moves to the attribute with the specified local name and namespace Uniform Resource Identifier (URI).</summary>
    ///  <param name="localName">The local name of the attribute. </param>
    ///  <param name="namespaceURI">The namespace URI of the attribute. </param>
    ///<returns><see langword="true" />
    ///  if the attribute is found; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the reader does not change.</returns>
    function MoveToAttribute(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Moves to the attribute with the specified index.</summary>
    ///  <param name="i">The index of the attribute. </param>
    ///<exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" />
    ///  parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlReader.AttributeCount" />
    ///  . </exception>
    procedure MoveToAttribute(i: Int32); overload;
    ///<summary>Moves to the first attribute.</summary>
    ///<returns><see langword="true" />
    ///  if an attribute exists (the reader moves to the first attribute); otherwise, <see langword="false" />
    ///  (the position of the reader does not change).</returns>
    function MoveToFirstAttribute: Boolean;
    ///<summary>Moves to the next attribute.</summary>
    ///<returns><see langword="true" />
    ///  if there is a next attribute; <see langword="false" />
    ///  if there are no more attributes.</returns>
    function MoveToNextAttribute: Boolean;
    ///<summary>Moves to the element that contains the current attribute node.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <see langword="false" />
    ///  if the reader is not positioned on an attribute (the position of the reader does not change).</returns>
    function MoveToElement: Boolean;
    ///<summary>Parses the attribute value into one or more <see langword="Text" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  nodes.</summary>
    ///<returns><see langword="true" />
    ///  if there are nodes to return.
    ///<see langword="false" />
    ///  if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.An empty attribute, such as, misc="", returns <see langword="true" />
    ///  with a single node with a value of String.Empty.</returns>
    function ReadAttributeValue: Boolean;
    ///<summary>Reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    function Read: Boolean;
    ///<summary>Changes the <see cref="P:System.Xml.XmlReader.ReadState" />
    ///  to Closed.</summary>
    procedure Close;
    ///<summary>Resolves a namespace prefix in the current element's scope.</summary>
    ///  <param name="prefix">The prefix whose namespace Uniform Resource Identifier (URI) you want to resolve. To match the default namespace, pass an empty string. </param>
    ///<returns>The namespace URI to which the prefix maps or <see langword="null" />
    ///  if no matching prefix is found.</returns>
    function LookupNamespace(prefix: string): string;
    ///<summary>Resolves the entity reference for <see langword="EntityReference" />
    ///  nodes.</summary>
    ///<exception cref="T:System.InvalidOperationException">The reader is not positioned on an <see langword="EntityReference" />
    ///  node. </exception>
    procedure ResolveEntity;
    ///<summary>Reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlValidatingReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
    function ReadContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the Base64 content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlValidatingReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
    function ReadElementContentAsBase64(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the content and returns the BinHex decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlValidatingReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
    ///  is not supported on the current node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlValidatingReader" />
    ///  implementation does not support this method.</exception>
    function ReadContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the element and decodes the BinHex content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlValidatingReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception><exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
    function ReadElementContentAsBinHex(buffer: TArray<Byte>; index: Int32; count: Int32): Int32;
    ///<summary>Reads the contents of an element or text node as a string.</summary>
    ///<returns>The contents of the element or text node. This can be an empty string if the reader is positioned on something other than an element or text node, or if there is no more text content to return in the current context.The text node can be either an element or an attribute text node.</returns>
    function ReadString: string;
    ///<summary>Gets a value indicating whether the class can return line information.</summary>
    ///<returns><see langword="true" />
    ///  if the class can return line information; otherwise, <see langword="false" />
    ///  .</returns>
    function HasLineInfo: Boolean;
    ///<summary>Gets the common language runtime type for the specified XML Schema definition language (XSD) type.</summary>
    ///<returns>The common language runtime type for the specified XML Schema type.</returns>
    function ReadTypedValue: DDN.mscorlib.DNObject;
    ///<summary>Reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsObject: DDN.mscorlib.DNObject;
    ///<summary>Reads the text content at the current position as a <see langword="Boolean" />
    ///  .</summary>
    ///<returns>The text content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsBoolean: Boolean;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTime: DDN.mscorlib.DNDateTime;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.DateTimeOffset" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.DateTimeOffset" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDateTimeOffset: DDN.mscorlib.DNDateTimeOffset;
    ///<summary>Reads the text content at the current position as a double-precision floating-point number.</summary>
    ///<returns>The text content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDouble: Double;
    ///<summary>Reads the text content at the current position as a single-precision floating point number.</summary>
    ///<returns>The text content at the current position as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsFloat: Single;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The text content at the current position as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsDecimal: DDN.mscorlib.DNDecimal;
    ///<summary>Reads the text content at the current position as a 32-bit signed integer.</summary>
    ///<returns>The text content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsInt: Int32;
    ///<summary>Reads the text content at the current position as a 64-bit signed integer.</summary>
    ///<returns>The text content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsLong: Int64;
    ///<summary>Reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.FormatException">The string format is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAsString: string;
    ///<summary>Reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion. For example, this can be used when converting an <see cref="T:System.Xml.XmlQualifiedName" />
    ///  object to an xs:string.This value can be <see langword="null" />
    ///  .</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.FormatException">The content is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="returnType" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node is not a supported node type. See the table below for details.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject(localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element contents as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime(localName: string; namespaceURI: string): DDN.mscorlib.DNDateTime; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble(localName: string; namespaceURI: string): Double; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a single-precision floating-point number.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat(localName: string; namespaceURI: string): Single; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal(localName: string; namespaceURI: string): DDN.mscorlib.DNDecimal; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt(localName: string; namespaceURI: string): Int32; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong(localName: string; namespaceURI: string): Int64; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString(localName: string; namespaceURI: string): string; overload;
    ///<summary>Checks that the specified local name and namespace URI matches that of the current element, then reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.ArgumentException">The specified local name and namespace URI do not match that of the current element being read.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver; localName: string; namespaceURI: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Skips the children of the current node.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Skip;
    ///<summary>Reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node does not have a value (<see cref="P:System.Xml.XmlReader.HasValue" />
    ///  is <see langword="false" />
    ///  ).</exception><exception cref="T:System.ArgumentNullException">The <paramref name="buffer" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer, or index + count is larger than the allocated buffer size.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" />
    ///  implementation does not support this method.</exception><exception cref="T:System.Xml.XmlException">The XML data is not well-formed.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadValueChunk(buffer: TArray<Char>; index: Int32; count: Int32): Int32;
    ///<summary>Checks whether the current node is a content (non-white space text, <see langword="CDATA" />
    ///  , <see langword="Element" />
    ///  , <see langword="EndElement" />
    ///  , <see langword="EntityReference" />
    ///  , or <see langword="EndEntity" />
    ///  ) node. If the node is not a content node, the reader skips ahead to the next content node or end of file. It skips over nodes of the following type: <see langword="ProcessingInstruction" />
    ///  , <see langword="DocumentType" />
    ///  , <see langword="Comment" />
    ///  , <see langword="Whitespace" />
    ///  , or <see langword="SignificantWhitespace" />
    ///  .</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function MoveToContent: DNXmlNodeType;
    ///<summary>Checks that the current node is an element and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.Name" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream. -or- The <see cref="P:System.Xml.XmlReader.Name" />
    ///  of the element does not match the given <paramref name="name" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(name: string); overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given string before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="name">The name to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="Name" />
    ///  does not match the given argument; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(name: string): string; overload;
    ///<summary>Checks that the current content node is an end tag and advances the reader to the next node.</summary>
    ///<exception cref="T:System.Xml.XmlException">The current node is not an end tag or if incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadEndElement;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag.</summary>
    ///<returns><see langword="true" />
    ///  if <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  finds a start tag or empty element tag; <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement: Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.Name" />
    ///  property of the element found matches the given argument.</summary>
    ///  <param name="name">The string matched against the <see langword="Name" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element and the <see langword="Name" />
    ///  property matches the specified string. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the element <see langword="Name" />
    ///  property does not match the specified string.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(name: string): Boolean; overload;
    ///<summary>Calls <see cref="M:System.Xml.XmlReader.MoveToContent" />
    ///  and tests if the current content node is a start tag or empty element tag and if the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found match the given strings.</summary>
    ///  <param name="localname">The string to match against the <see langword="LocalName" />
    ///  property of the element found.</param>
    ///  <param name="ns">The string to match against the <see langword="NamespaceURI" />
    ///  property of the element found.</param>
    ///<returns><see langword="true" />
    ///  if the resulting node is an element. <see langword="false" />
    ///  if a node type other than <see langword="XmlNodeType.Element" />
    ///  was found or if the <see langword="LocalName" />
    ///  and <see langword="NamespaceURI" />
    ///  properties of the element do not match the specified strings.</returns>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML is encountered in the input stream.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function IsStartElement(localname: string; ns: string): Boolean; overload;
    ///<summary>Reads until an element with the specified qualified name is found.</summary>
    ///  <param name="name">The qualified name of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToFollowing(name: string): Boolean; overload;
    ///<summary>Reads until an element with the specified local name and namespace URI is found.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns><see langword="true" />
    ///  if a matching element is found; otherwise <see langword="false" />
    ///  and the <see cref="T:System.Xml.XmlReader" />
    ///  is in an end of file state.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToFollowing(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToDescendant(name: string): Boolean; overload;
    ///<summary>Advances the <see cref="T:System.Xml.XmlReader" />
    ///  to the next descendant element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching descendant element is found; otherwise <see langword="false" />
    ///  . If a matching child element is not found, the <see cref="T:System.Xml.XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the element.If the <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element when <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
    ///  was called, this method returns <see langword="false" />
    ///  and the position of the <see cref="T:System.Xml.XmlReader" />
    ///  is not changed.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToDescendant(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified qualified name.</summary>
    ///  <param name="name">The qualified name of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentException">The parameter is an empty string.</exception>
    function ReadToNextSibling(name: string): Boolean; overload;
    ///<summary>Advances the <see langword="XmlReader" />
    ///  to the next sibling element with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the sibling element you wish to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the sibling element you wish to move to.</param>
    ///<returns><see langword="true" />
    ///  if a matching sibling element is found; otherwise, <see langword="false" />
    ///  . If a matching sibling element is not found, the <see langword="XmlReader" />
    ///  is positioned on the end tag (<see cref="P:System.Xml.XmlReader.NodeType" />
    ///  is <see langword="XmlNodeType.EndElement" />
    ///  ) of the parent element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.ArgumentNullException">Both parameter values are <see langword="null" />
    ///  .</exception>
    function ReadToNextSibling(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>When overridden in a derived class, reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.If the current node is neither an element nor attribute, an empty string is returned.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadInnerXml: string;
    ///<summary>When overridden in a derived class, reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.Xml.XmlException">The XML was not well-formed, or an error occurred while parsing the XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadOuterXml: string;
    ///<summary>Returns a new <see langword="XmlReader" />
    ///  instance that can be used to read the current node, and all its descendants.</summary>
    ///<returns>A new XML reader instance set to <see cref="F:System.Xml.ReadState.Initial" />
    ///  . Calling the <see cref="M:System.Xml.XmlReader.Read" />
    ///  method positions the new reader on the node that was current before the call to the <see cref="M:System.Xml.XmlReader.ReadSubtree" />
    ///  method.</returns>
    ///<exception cref="T:System.InvalidOperationException">The XML reader isn't positioned on an element when this method is called.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadSubtree: DNXmlReader;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlReader" />
    ///  class.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Dispose;
    ///<summary>Asynchronously gets the value of the current node.</summary>
    ///<returns>The value of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function GetValueAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the text content at the current position as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The text content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the next node from the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the next node was read successfully; <see langword="false" />
    ///  if there are no more nodes to read.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadAsync: DDN.mscorlib.DNTask<Boolean>;
    ///<summary>Asynchronously skips the children of the current node.</summary>
    ///<returns>The current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function SkipAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously reads large streams of text embedded in an XML document.</summary>
    ///  <param name="buffer">The array of characters that serves as the buffer to which the text contents are written. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset within the buffer where the <see cref="T:System.Xml.XmlReader" />
    ///  can start to copy the results.</param>
    ///  <param name="count">The maximum number of characters to copy into the buffer. The actual number of characters copied is returned from this method.</param>
    ///<returns>The number of characters read into the buffer. The value zero is returned when there is no more text content.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadValueChunkAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously checks whether the current node is a content node. If the node is not a content node, the reader skips ahead to the next content node or end of file.</summary>
    ///<returns>The <see cref="P:System.Xml.XmlReader.NodeType" />
    ///  of the current node found by the method or <see langword="XmlNodeType.None" />
    ///  if the reader has reached the end of the input stream.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function MoveToContentAsync: DDN.mscorlib.DNTask<DNXmlNodeType>;
    ///<summary>Reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsObject: DDN.mscorlib.DNObject; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Boolean" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Boolean" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Boolean" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsBoolean: Boolean; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.DateTime" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.DateTime" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.DateTime" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDateTime: DDN.mscorlib.DNDateTime; overload;
    ///<summary>Reads the current element and returns the contents as a double-precision floating-point number.</summary>
    ///<returns>The element content as a double-precision floating-point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a double-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDouble: Double; overload;
    ///<summary>Reads the current element and returns the contents as single-precision floating-point number.</summary>
    ///<returns>The element content as a single-precision floating point number.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a single-precision floating-point number.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsFloat: Single; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.Decimal" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.Decimal" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.Decimal" />
    ///  .</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsDecimal: DDN.mscorlib.DNDecimal; overload;
    ///<summary>Reads the current element and returns the contents as a 32-bit signed integer.</summary>
    ///<returns>The element content as a 32-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 32-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsInt: Int32; overload;
    ///<summary>Reads the current element and returns the contents as a 64-bit signed integer.</summary>
    ///<returns>The element content as a 64-bit signed integer.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a 64-bit signed integer.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsLong: Int64; overload;
    ///<summary>Reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to a <see cref="T:System.String" />
    ///  object.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAsString: string; overload;
    ///<summary>Reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.
    ///  Note   With the release of the .NET Framework 3.5, the value of the <paramref name="returnType" />
    ///  parameter can now be the <see cref="T:System.DateTimeOffset" />
    ///  type.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XmlReader" />
    ///  is not positioned on an element.</exception><exception cref="T:System.Xml.XmlException">The current element contains child elements.-or-The element content cannot be converted to the requested type.</exception><exception cref="T:System.ArgumentNullException">The method is called with <see langword="null" />
    ///  arguments.</exception><exception cref="T:System.OverflowException">Read <see langword="Decimal.MaxValue" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementContentAs(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>Checks that the current content node is an element with the given <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  and advances the reader to the next node.</summary>
    ///  <param name="localname">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///<exception cref="T:System.Xml.XmlException">Incorrect XML was encountered in the input stream.-or-The <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found do not match the given arguments.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure ReadStartElement(localname: string; ns: string); overload;
    ///<summary>Reads a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">The next content node is not a start tag; or the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString: string; overload;
    ///<summary>Checks that the <see cref="P:System.Xml.XmlReader.LocalName" />
    ///  and <see cref="P:System.Xml.XmlReader.NamespaceURI" />
    ///  properties of the element found matches the given strings before reading a text-only element. However, we recommend that you use the <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
    ///  method instead, because it provides a more straightforward way to handle this operation.</summary>
    ///  <param name="localname">The local name to check.</param>
    ///  <param name="ns">The namespace URI to check.</param>
    ///<returns>The text contained in the element that was read. An empty string if the element is empty.</returns>
    ///<exception cref="T:System.Xml.XmlException">If the next content node is not a start tag; if the element <see langword="LocalName" />
    ///  or <see langword="NamespaceURI" />
    ///  do not match the given arguments; or if the element found does not contain a simple text value.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function ReadElementString(localname: string; ns: string): string; overload;
    ///<summary>Asynchronously reads the text content at the current position as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>The text content as the most appropriate common language runtime (CLR) object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content as an object of the type specified.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The concatenated text content or attribute value converted to the requested type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as an <see cref="T:System.Object" />
    ///  .</summary>
    ///<returns>A boxed common language runtime (CLR) object of the most appropriate type. The <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  property determines the appropriate CLR type. If the content is typed as a list type, this method returns an array of boxed objects of the appropriate type.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsObjectAsync: DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the current element and returns the contents as a <see cref="T:System.String" />
    ///  object.</summary>
    ///<returns>The element content as a <see cref="T:System.String" />
    ///  object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsStringAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the element content as the requested type.</summary>
    ///  <param name="returnType">The type of the value to be returned.</param>
    ///  <param name="namespaceResolver">An <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object that is used to resolve any namespace prefixes related to type conversion.</param>
    ///<returns>The element content converted to the requested typed object.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsAsync(returnType: DDN.mscorlib.DNType; namespaceResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Asynchronously reads the content and returns the Base64 decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="Base64" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the content and returns the <see langword="BinHex" />
    ///  decoded binary bytes.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads the element and decodes the <see langword="BinHex" />
    ///  content.</summary>
    ///  <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />
    ///  .</param>
    ///  <param name="index">The offset into the buffer where to start copying the result.</param>
    ///  <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
    ///<returns>The number of bytes written to the buffer.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadElementContentAsBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask<Int32>;
    ///<summary>Asynchronously reads all the content, including markup, as a string.</summary>
    ///<returns>All the XML content, including markup, in the current node. If the current node has no children, an empty string is returned.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadInnerXmlAsync: DDN.mscorlib.DNTask<string>;
    ///<summary>Asynchronously reads the content, including markup, representing this node and all its children.</summary>
    ///<returns>If the reader is positioned on an element or an attribute node, this method returns all the XML content, including markup, of the current node and all its children; otherwise, it returns an empty string.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlReaderSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlReaderSettings.Async to true if you want to use Async Methods.”</exception>
    function ReadOuterXmlAsync: DDN.mscorlib.DNTask<string>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the type of the current node.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlNodeType" />
    ///  values representing the type of the current node.</returns>
    property NodeType: DNXmlNodeType read get_NodeType;
    ///<summary>Gets the qualified name of the current node.</summary>
    ///<returns>The qualified name of the current node. For example, <see langword="Name" />
    ///  is <see langword="bk:book" />
    ///  for the element &lt;bk:book&gt;.The name returned is dependent on the <see cref="P:System.Xml.XmlValidatingReader.NodeType" />
    ///  of the node. The following node types return the listed values. All other node types return an empty string.Node Type Name
    ///<see langword="Attribute" />
    ///  The name of the attribute.
    ///<see langword="DocumentType" />
    ///  The document type name.
    ///<see langword="Element" />
    ///  The tag name.
    ///<see langword="EntityReference" />
    ///  The name of the entity referenced.
    ///<see langword="ProcessingInstruction" />
    ///  The target of the processing instruction.
    ///<see langword="XmlDeclaration" />
    ///  The literal string <see langword="xml" />
    ///  . </returns>
    property Name: string read get_Name;
    ///<summary>Gets the local name of the current node.</summary>
    ///<returns>The name of the current node with the prefix removed. For example, <see langword="LocalName" />
    ///  is <see langword="book" />
    ///  for the element &lt;bk:book&gt;.For node types that do not have a name (like <see langword="Text" />
    ///  , <see langword="Comment" />
    ///  , and so on), this property returns String.Empty.</returns>
    property LocalName: string read get_LocalName;
    ///<summary>Gets the namespace Uniform Resource Identifier (URI) (as defined in the World Wide Web Consortium (W3C) Namespace specification) of the node on which the reader is positioned.</summary>
    ///<returns>The namespace URI of the current node; otherwise an empty string.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>Gets the namespace prefix associated with the current node.</summary>
    ///<returns>The namespace prefix associated with the current node.</returns>
    property Prefix: string read get_Prefix;
    ///<summary>Gets a value indicating whether the current node can have a <see cref="P:System.Xml.XmlValidatingReader.Value" />
    ///  other than String.Empty.</summary>
    ///<returns><see langword="true" />
    ///  if the node on which the reader is currently positioned can have a <see langword="Value" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    property HasValue: Boolean read get_HasValue;
    ///<summary>Gets the text value of the current node.</summary>
    ///<returns>The value returned depends on the <see cref="P:System.Xml.XmlValidatingReader.NodeType" />
    ///  of the node. The following table lists node types that have a value to return. All other node types return String.Empty.Node Type Value
    ///<see langword="Attribute" />
    ///  The value of the attribute.
    ///<see langword="CDATA" />
    ///  The content of the CDATA section.
    ///<see langword="Comment" />
    ///  The content of the comment.
    ///<see langword="DocumentType" />
    ///  The internal subset.
    ///<see langword="ProcessingInstruction" />
    ///  The entire content, excluding the target.
    ///<see langword="SignificantWhitespace" />
    ///  The white space between markup in a mixed content model.
    ///<see langword="Text" />
    ///  The content of the text node.
    ///<see langword="Whitespace" />
    ///  The white space between markup.
    ///<see langword="XmlDeclaration" />
    ///  The content of the declaration. </returns>
    property Value: string read get_Value;
    ///<summary>Gets the depth of the current node in the XML document.</summary>
    ///<returns>The depth of the current node in the XML document.</returns>
    property Depth: Int32 read get_Depth;
    ///<summary>Gets the base URI of the current node.</summary>
    ///<returns>The base URI of the current node.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>Gets a value indicating whether the current node is an empty element (for example, &lt;MyElement/&gt;).</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an element (<see cref="P:System.Xml.XmlValidatingReader.NodeType" />
    ///  equals <see langword="XmlNodeType.Element" />
    ///  ) that ends with /&gt;; otherwise, <see langword="false" />
    ///  .</returns>
    property IsEmptyElement: Boolean read get_IsEmptyElement;
    ///<summary>Gets a value indicating whether the current node is an attribute that was generated from the default value defined in the document type definition (DTD) or schema.</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an attribute whose value was generated from the default value defined in the DTD or schema; <see langword="false" />
    ///  if the attribute value was explicitly set.</returns>
    property IsDefault: Boolean read get_IsDefault;
    ///<summary>Gets the quotation mark character used to enclose the value of an attribute node.</summary>
    ///<returns>The quotation mark character (" or ') used to enclose the value of an attribute node.</returns>
    property QuoteChar: Char read get_QuoteChar;
    ///<summary>Gets the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlSpace" />
    ///  values. If no <see langword="xml:space" />
    ///  scope exists, this property defaults to <see langword="XmlSpace.None" />
    ///  .</returns>
    property XmlSpace: DNXmlSpace read get_XmlSpace;
    ///<summary>Gets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  scope.</returns>
    property XmlLang: string read get_XmlLang;
    ///<summary>Gets the number of attributes on the current node.</summary>
    ///<returns>The number of attributes on the current node. This number includes default attributes.</returns>
    property AttributeCount: Int32 read get_AttributeCount;
    ///<summary>Gets a value indicating whether the reader is positioned at the end of the stream.</summary>
    ///<returns><see langword="true" />
    ///  if the reader is positioned at the end of the stream; otherwise, <see langword="false" />
    ///  .</returns>
    property EOF: Boolean read get_EOF;
    ///<summary>Gets the state of the reader.</summary>
    ///<returns>One of the <see cref="T:System.Xml.ReadState" />
    ///  values.</returns>
    property ReadState: DNReadState read get_ReadState;
    ///<summary>Gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  associated with this implementation.</summary>
    ///<returns><see langword="XmlNameTable" />
    ///  that enables you to get the atomized version of a string within the node.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>Gets a value indicating whether this reader can parse and resolve entities.</summary>
    ///<returns><see langword="true" />
    ///  if the reader can parse and resolve entities; otherwise, <see langword="false" />
    ///  . <see langword="XmlValidatingReader" />
    ///  always returns <see langword="true" />
    ///  .</returns>
    property CanResolveEntity: Boolean read get_CanResolveEntity;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlValidatingReader" />
    ///  implements the binary content read methods.</summary>
    ///<returns><see langword="true" />
    ///  if the binary content read methods are implemented; otherwise <see langword="false" />
    ///  . The <see cref="T:System.Xml.XmlValidatingReader" />
    ///  class returns <see langword="true" />
    ///  .</returns>
    property CanReadBinaryContent: Boolean read get_CanReadBinaryContent;
    ///<summary>Gets the current line number.</summary>
    ///<returns>The current line number. The starting value for this property is 1.</returns>
    property LineNumber: Int32 read get_LineNumber;
    ///<summary>Gets the current line position.</summary>
    ///<returns>The current line position. The starting value for this property is 1.</returns>
    property LinePosition: Int32 read get_LinePosition;
    ///<summary>Gets a schema type object.</summary>
    ///<returns><see cref="T:System.Xml.Schema.XmlSchemaDatatype" />
    ///  , <see cref="T:System.Xml.Schema.XmlSchemaSimpleType" />
    ///  , or <see cref="T:System.Xml.Schema.XmlSchemaComplexType" />
    ///  depending whether the node value is a built in XML Schema definition language (XSD) type or a user defined simpleType or complexType; <see langword="null" />
    ///  if the current node has no schema type.</returns>
    property SchemaType: DDN.mscorlib.DNObject read get_SchemaType;
    ///<summary>Gets the <see cref="T:System.Xml.XmlReader" />
    ///  used to construct this <see langword="XmlValidatingReader" />
    ///  .</summary>
    ///<returns>The <see langword="XmlReader" />
    ///  specified in the constructor.</returns>
    property Reader: DNXmlReader read get_Reader;
    ///<summary>Gets or sets a value indicating the type of validation to perform.</summary>
    ///<returns>One of the <see cref="T:System.Xml.ValidationType" />
    ///  values. If this property is not set, it defaults to ValidationType.Auto.</returns>
    ///<exception cref="T:System.InvalidOperationException">Setting the property after a Read has been called. </exception>
    property ValidationType: DNValidationType read get_ValidationType write set_ValidationType;
    ///<summary>Gets a <see cref="T:System.Xml.Schema.XmlSchemaCollection" />
    ///  to use for validation.</summary>
    ///<returns>The <see langword="XmlSchemaCollection" />
    ///  to use for validation.</returns>
    property Schemas: DNXmlSchemaCollection read get_Schemas;
    ///<summary>Gets or sets a value that specifies how the reader handles entities.</summary>
    ///<returns>One of the <see cref="T:System.Xml.EntityHandling" />
    ///  values. If no <see langword="EntityHandling" />
    ///  is specified, it defaults to EntityHandling.ExpandEntities.</returns>
    ///<exception cref="T:System.ArgumentOutOfRangeException">Invalid value was specified. </exception>
    property EntityHandling: DNEntityHandling read get_EntityHandling write set_EntityHandling;
    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used for resolving external document type definition (DTD) and schema location references. The <see langword="XmlResolver" />
    ///  is also used to handle any import or include elements found in XML Schema definition language (XSD) schemas.</summary>
    ///<returns>The <see langword="XmlResolver" />
    ///  to use. If set to <see langword="null" />
    ///  , external resources are not resolved.In version 1.1 of the .NET Framework, the caller must be fully trusted to specify an <see langword="XmlResolver" />
    ///  .</returns>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>Gets or sets a value indicating whether to do namespace support.</summary>
    ///<returns><see langword="true" />
    ///  to do namespace support; otherwise, <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property Namespaces: Boolean read get_Namespaces write set_Namespaces;
    ///<summary>Gets the encoding attribute for the document.</summary>
    ///<returns>The encoding value. If no encoding attribute exists, and there is not byte-order mark, this defaults to UTF-8.</returns>
    property Encoding: DDN.mscorlib.DNEncoding read get_Encoding;
    ///<summary>Gets the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this <see cref="T:System.Xml.XmlReader" />
    ///  instance.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object used to create this reader instance. If this reader was not created using the <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  method, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Settings: DNXmlReaderSettings read get_Settings;
    ///<summary>Gets the schema information that has been assigned to the current node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object containing the schema information for the current node. Schema information can be set on elements, attributes, or on text nodes with a non-null <see cref="P:System.Xml.XmlReader.ValueType" />
    ///  (typed values).If the current node is not one of the above node types, or if the <see langword="XmlReader" />
    ///  instance does not report schema information, this property returns <see langword="null" />
    ///  .If this property is called from an <see cref="T:System.Xml.XmlTextReader" />
    ///  or an <see cref="T:System.Xml.XmlValidatingReader" />
    ///  object, this property always returns <see langword="null" />
    ///  . These <see langword="XmlReader" />
    ///  implementations do not expose schema information through the <see langword="SchemaInfo" />
    ///  property.If you have to get the post-schema-validation information set (PSVI) for an element, position the reader on the end tag of the element, rather than on the start tag. You get the PSVI through the <see langword="SchemaInfo" />
    ///  property of a reader. The validating reader that is created through <see cref="Overload:System.Xml.XmlReader.Create" />
    ///  with the <see cref="P:System.Xml.XmlReaderSettings.ValidationType" />
    ///  property set to <see cref="F:System.Xml.ValidationType.Schema" />
    ///  has complete PSVI for an element only when the reader is positioned on the end tag of an element.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets The Common Language Runtime (CLR) type for the current node.</summary>
    ///<returns>The CLR type that corresponds to the typed value of the node. The default is <see langword="System.String" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    property Item[i: Int32]: string read get_Item; default;
    property Item[name: string]: string read get_Item; default;
    property Item[name: string; namespaceURI: string]: string read get_Item; default;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XmlReader" />
    ///  implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
    ///  method; otherwise <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property CanReadValueChunk: Boolean read get_CanReadValueChunk;
    ///<summary>Gets a value indicating whether the current node has any attributes.</summary>
    ///<returns><see langword="true" />
    ///  if the current node has attributes; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlReader" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property HasAttributes: Boolean read get_HasAttributes;
  end;

  TDNXmlValidatingReader = class(TDNGenericImport<DNXmlValidatingReaderClass, DNXmlValidatingReader>) end;

  //-------------namespace: System.Xml----------------
  DNXmlReaderSettingsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{333069D0-1337-5A1D-988D-3D92D51A0162}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  class.</summary>
    {class} function init: DNXmlReaderSettings; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  class.</summary>
    ///  <param name="resolver">The XML resolver.</param>
    {class} function init(resolver: DNXmlResolver): DNXmlReaderSettings; overload;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used to access external documents.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlResolver" />
    ///  used to access external documents. If set to <see langword="null" />
    ///  , an <see cref="T:System.Xml.XmlException" />
    ///  is thrown when the <see cref="T:System.Xml.XmlReader" />
    ///  tries to access an external resource. The default is a new <see cref="T:System.Xml.XmlUrlResolver" />
    ///  with no credentials.  Starting with the .NET Framework 4.5.2, this setting has a default value of <see langword="null" />
    ///  .</returns>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  ///<summary>Specifies a set of features to support on the <see cref="T:System.Xml.XmlReader" />
  ///  object created by the <see cref="Overload:System.Xml.XmlReader.Create" />
  ///  method. </summary>
  [DNTypeName('System.Xml.XmlReaderSettings')]
  DNXmlReaderSettings = interface(DDN.mscorlib.DNObject)
  ['{A34E9932-0279-3945-87FC-037F0B86F4F9}']
  { getters & setters } 

    function get_Async: Boolean;
    procedure set_Async(value: Boolean);
    function get_NameTable: DNXmlNameTable;
    procedure set_NameTable(value: DNXmlNameTable);
    procedure set_XmlResolver(value: DNXmlResolver);
    function get_LineNumberOffset: Int32;
    procedure set_LineNumberOffset(value: Int32);
    function get_LinePositionOffset: Int32;
    procedure set_LinePositionOffset(value: Int32);
    function get_ConformanceLevel: DNConformanceLevel;
    procedure set_ConformanceLevel(value: DNConformanceLevel);
    function get_CheckCharacters: Boolean;
    procedure set_CheckCharacters(value: Boolean);
    function get_MaxCharactersInDocument: Int64;
    procedure set_MaxCharactersInDocument(value: Int64);
    function get_MaxCharactersFromEntities: Int64;
    procedure set_MaxCharactersFromEntities(value: Int64);
    function get_IgnoreWhitespace: Boolean;
    procedure set_IgnoreWhitespace(value: Boolean);
    function get_IgnoreProcessingInstructions: Boolean;
    procedure set_IgnoreProcessingInstructions(value: Boolean);
    function get_IgnoreComments: Boolean;
    procedure set_IgnoreComments(value: Boolean);
    function get_ProhibitDtd: Boolean;
    procedure set_ProhibitDtd(value: Boolean);
    function get_DtdProcessing: DNDtdProcessing;
    procedure set_DtdProcessing(value: DNDtdProcessing);
    function get_CloseInput: Boolean;
    procedure set_CloseInput(value: Boolean);
    function get_ValidationType: DNValidationType;
    procedure set_ValidationType(value: DNValidationType);
    function get_ValidationFlags: DNXmlSchemaValidationFlags;
    procedure set_ValidationFlags(value: DNXmlSchemaValidationFlags);
    function get_Schemas: DNXmlSchemaSet;
    procedure set_Schemas(value: DNXmlSchemaSet);

  { events } 

    procedure add_ValidationEventHandler(value: DNValidationEventHandler);
    procedure remove_ValidationEventHandler(value: DNValidationEventHandler);

  { methods } 

    ///<summary>Creates a copy of the <see cref="T:System.Xml.XmlReaderSettings" />
    ///  instance.</summary>
    ///<returns>The cloned <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object.</returns>
    function Clone: DNXmlReaderSettings;
    ///<summary>Resets the members of the settings class to their default values.</summary>
    procedure Reset;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets whether asynchronous <see cref="T:System.Xml.XmlReader" />
    ///  methods can be used on a particular <see cref="T:System.Xml.XmlReader" />
    ///  instance.</summary>
    ///<returns><see langword="true" />
    ///  if asynchronous methods can be used; otherwise, <see langword="false" />
    ///  .</returns>
    property Async: Boolean read get_Async write set_Async;
    ///<summary>Gets or sets the <see cref="T:System.Xml.XmlNameTable" />
    ///  used for atomized string comparisons.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlNameTable" />
    ///  that stores all the atomized strings used by all <see cref="T:System.Xml.XmlReader" />
    ///  instances created using this <see cref="T:System.Xml.XmlReaderSettings" />
    ///  object.The default is <see langword="null" />
    ///  . The created <see cref="T:System.Xml.XmlReader" />
    ///  instance will use a new empty <see cref="T:System.Xml.NameTable" />
    ///  if this value is <see langword="null" />
    ///  .</returns>
    property NameTable: DNXmlNameTable read get_NameTable write set_NameTable;
    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used to access external documents.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlResolver" />
    ///  used to access external documents. If set to <see langword="null" />
    ///  , an <see cref="T:System.Xml.XmlException" />
    ///  is thrown when the <see cref="T:System.Xml.XmlReader" />
    ///  tries to access an external resource. The default is a new <see cref="T:System.Xml.XmlUrlResolver" />
    ///  with no credentials.  Starting with the .NET Framework 4.5.2, this setting has a default value of <see langword="null" />
    ///  .</returns>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
    ///<summary>Gets or sets line number offset of the <see cref="T:System.Xml.XmlReader" />
    ///  object.</summary>
    ///<returns>The line number offset. The default is 0.</returns>
    property LineNumberOffset: Int32 read get_LineNumberOffset write set_LineNumberOffset;
    ///<summary>Gets or sets line position offset of the <see cref="T:System.Xml.XmlReader" />
    ///  object.</summary>
    ///<returns>The line position offset. The default is 0.</returns>
    property LinePositionOffset: Int32 read get_LinePositionOffset write set_LinePositionOffset;
    ///<summary>Gets or sets the level of conformance which the <see cref="T:System.Xml.XmlReader" />
    ///  will comply.</summary>
    ///<returns>One of the enumeration values that specifies the level of conformance that the XML reader will enforce. The default is <see cref="F:System.Xml.ConformanceLevel.Document" />
    ///  .</returns>
    property ConformanceLevel: DNConformanceLevel read get_ConformanceLevel write set_ConformanceLevel;
    ///<summary>Gets or sets a value indicating whether to do character checking.</summary>
    ///<returns><see langword="true" />
    ///  to do character checking; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .If the <see cref="T:System.Xml.XmlReader" />
    ///  is processing text data, it always checks that the XML names and text content are valid, regardless of the property setting. Setting <see cref="P:System.Xml.XmlReaderSettings.CheckCharacters" />
    ///  to <see langword="false" />
    ///  turns off character checking for character entity references.</returns>
    property CheckCharacters: Boolean read get_CheckCharacters write set_CheckCharacters;
    ///<summary>Gets or sets a value indicating the maximum allowable number of characters in an XML document. A zero (0) value means no limits on the size of the XML document. A non-zero value specifies the maximum size, in characters.</summary>
    ///<returns>The maximum allowable number of characters in an XML document. The default is 0.</returns>
    property MaxCharactersInDocument: Int64 read get_MaxCharactersInDocument write set_MaxCharactersInDocument;
    ///<summary>Gets or sets a value indicating the maximum allowable number of characters in a document that result from expanding entities.</summary>
    ///<returns>The maximum allowable number of characters from expanded entities. The default is 0.</returns>
    property MaxCharactersFromEntities: Int64 read get_MaxCharactersFromEntities write set_MaxCharactersFromEntities;
    ///<summary>Gets or sets a value indicating whether to ignore insignificant white space.</summary>
    ///<returns><see langword="true" />
    ///  to ignore white space; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IgnoreWhitespace: Boolean read get_IgnoreWhitespace write set_IgnoreWhitespace;
    ///<summary>Gets or sets a value indicating whether to ignore processing instructions.</summary>
    ///<returns><see langword="true" />
    ///  to ignore processing instructions; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IgnoreProcessingInstructions: Boolean read get_IgnoreProcessingInstructions write set_IgnoreProcessingInstructions;
    ///<summary>Gets or sets a value indicating whether to ignore comments.</summary>
    ///<returns><see langword="true" />
    ///  to ignore comments; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property IgnoreComments: Boolean read get_IgnoreComments write set_IgnoreComments;
    ///<summary>Gets or sets a value indicating whether to prohibit document type definition (DTD) processing. This property is obsolete. Use <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />
    ///  instead.</summary>
    ///<returns><see langword="true" />
    ///  to prohibit DTD processing; otherwise <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property ProhibitDtd: Boolean read get_ProhibitDtd write set_ProhibitDtd;
    ///<summary>Gets or sets a value that determines the processing of DTDs.</summary>
    ///<returns>One of the enumeration values that determines the processing of DTDs. The default is <see cref="F:System.Xml.DtdProcessing.Prohibit" />
    ///  .</returns>
    property DtdProcessing: DNDtdProcessing read get_DtdProcessing write set_DtdProcessing;
    ///<summary>Gets or sets a value indicating whether the underlying stream or <see cref="T:System.IO.TextReader" />
    ///  should be closed when the reader is closed.</summary>
    ///<returns><see langword="true" />
    ///  to close the underlying stream or <see cref="T:System.IO.TextReader" />
    ///  when the reader is closed; otherwise <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property CloseInput: Boolean read get_CloseInput write set_CloseInput;
    ///<summary>Gets or sets a value indicating whether the <see cref="T:System.Xml.XmlReader" />
    ///  will perform validation or type assignment when reading.</summary>
    ///<returns>One of the <see cref="T:System.Xml.ValidationType" />
    ///  values that indicates whether XmlReader will perform validation or type assignment when reading. The default is <see langword="ValidationType.None" />
    ///  .</returns>
    property ValidationType: DNValidationType read get_ValidationType write set_ValidationType;
    ///<summary>Gets or sets a value indicating the schema validation settings. This setting applies to <see cref="T:System.Xml.XmlReader" />
    ///  objects that validate schemas (<see cref="P:System.Xml.XmlReaderSettings.ValidationType" />
    ///  property set to <see langword="ValidationType.Schema" />
    ///  ).</summary>
    ///<returns>A bitwise combination of enumeration values that specify validation options. <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints" />
    ///  and <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.AllowXmlAttributes" />
    ///  are enabled by default. <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema" />
    ///  , <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation" />
    ///  , and <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings" />
    ///  are disabled by default.</returns>
    property ValidationFlags: DNXmlSchemaValidationFlags read get_ValidationFlags write set_ValidationFlags;
    ///<summary>Gets or sets the <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  to use when performing schema validation.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  to use when performing schema validation. The default is an empty <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  object.</returns>
    property Schemas: DNXmlSchemaSet read get_Schemas write set_Schemas;
  end;

  TDNXmlReaderSettings = class(TDNGenericImport<DNXmlReaderSettingsClass, DNXmlReaderSettings>) end;

  //-------------namespace: System.Xml----------------
  DNXmlResolverClass = interface(DDN.mscorlib.DNObjectClass)
  ['{EDE29340-6461-5FEC-9331-2E67780C1D99}']
  { static getter & setter } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { static propertys } 

    ///<summary>When overridden in a derived class, sets the credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see langword="XmlResolver" />
    ///  has no user credentials.</returns>
    {class} property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  ///<summary>Resolves external XML resources named by a Uniform Resource Identifier (URI).</summary>
  [DNTypeName('System.Xml.XmlResolver')]
  DNXmlResolver = interface(DDN.mscorlib.DNObject)
  ['{F2DEB691-8A4B-36EE-9262-ED43949B7CC1}']
  { getters & setters } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { methods } 

    ///<summary>When overridden in a derived class, resolves the absolute URI from the base and relative URIs.</summary>
    ///  <param name="baseUri">The base URI used to resolve the relative URI.</param>
    ///  <param name="relativeUri">The URI to resolve. The URI can be absolute or relative. If absolute, this value effectively replaces the <paramref name="baseUri" />
    ///  value. If relative, it combines with the <paramref name="baseUri" />
    ///  to make an absolute URI.</param>
    ///<returns>The absolute URI or <see langword="null" />
    ///  if the relative URI cannot be resolved.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="relativeUri" />
    ///  is <see langword="null" />
    ///  .</exception>
    function ResolveUri(baseUri: DDN.System.DNUri; relativeUri: string): DDN.System.DNUri;
    ///<summary>Enables the resolver to return types other than <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="absoluteUri">The URI.</param>
    ///  <param name="type">The type to return.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="type" />
    ///  is supported; otherwise, <see langword="false" />
    ///  .</returns>
    function SupportsType(absoluteUri: DDN.System.DNUri; &type: DDN.mscorlib.DNType): Boolean;
    ///<summary>Asynchronously maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current version only returns <see cref="T:System.IO.Stream" />
    ///  objects.</param>
    ///<returns>A stream object or <see langword="null" />
    ///  if a type other than stream is specified.</returns>
    function GetEntityAsync(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>When overridden in a derived class, maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current version only returns System.IO.Stream objects.</param>
    ///<returns>A stream object or <see langword="null" />
    ///  if a type other than stream is specified.</returns>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="ofObjectToReturn" />
    ///  is not a <see langword="Stream" />
    ///  type.</exception><exception cref="T:System.UriFormatException">The specified URI is not an absolute URI.</exception><exception cref="T:System.ArgumentNullException"><paramref name="absoluteUri" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Exception">There is a runtime error (for example, an interrupted server connection).</exception>
    function GetEntity(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, sets the credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see langword="XmlResolver" />
    ///  has no user credentials.</returns>
    property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  TDNXmlResolver = class(TDNGenericImport<DNXmlResolverClass, DNXmlResolver>) end;

  //-------------namespace: System.Xml.Resolvers----------------
  DNXmlPreloadedResolverClass = interface(DNXmlResolverClass)
  ['{D6792A31-45EC-5D74-9A1A-53860DAB4F1A}']
  { static getter & setter } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  class.</summary>
    {class} function init: DNXmlPreloadedResolver; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  class with the specified preloaded well-known DTDs.</summary>
    ///  <param name="preloadedDtds">The well-known DTDs that should be prepopulated into the cache.</param>
    {class} function init(preloadedDtds: DNXmlKnownDtds): DNXmlPreloadedResolver; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  class with the specified fallback resolver.</summary>
    ///  <param name="fallbackResolver">The <see langword="XmlResolver" />
    ///  , <see langword="XmlXapResolver" />
    ///  , or your own resolver.</param>
    {class} function init(fallbackResolver: DNXmlResolver): DNXmlPreloadedResolver; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  class with the specified fallback resolver and preloaded well-known DTDs.</summary>
    ///  <param name="fallbackResolver">The <see langword="XmlResolver" />
    ///  , <see langword="XmlXapResolver" />
    ///  , or your own resolver.</param>
    ///  <param name="preloadedDtds">The well-known DTDs that should be prepopulated into the cache.</param>
    {class} function init(fallbackResolver: DNXmlResolver; preloadedDtds: DNXmlKnownDtds): DNXmlPreloadedResolver; overload;
    {class} function init(fallbackResolver: DNXmlResolver; preloadedDtds: DNXmlKnownDtds; uriComparer: DDN.mscorlib.DNIEqualityComparer<DDN.System.DNUri>): DNXmlPreloadedResolver; overload;

  { static propertys } 

    ///<summary>Sets the credentials that are used to authenticate the underlying <see cref="T:System.Net.WebRequest" />
    ///  .</summary>
    ///<returns>The credentials that are used to authenticate the underlying web request.</returns>
    {class} property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  ///<summary>Represents a class that is used to prepopulate the cache with DTDs or XML streams.</summary>
  [DNTypeName('System.Xml.Resolvers.XmlPreloadedResolver')]
  DNXmlPreloadedResolver = interface(DNXmlResolver)
  ['{25F71FE6-DA1F-37E0-8D82-9E600E6214DA}']
  { getters & setters } 

    procedure set_Credentials(value: DDN.System.DNICredentials);
    function get_PreloadedUris: DDN.mscorlib.DNIEnumerable<DDN.System.DNUri>;

  { methods } 

    ///<summary>Determines whether the resolver supports other <see cref="T:System.Type" />
    ///  s than just <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="absoluteUri">The absolute URI to check.</param>
    ///  <param name="type">The <see cref="T:System.Type" />
    ///  to return.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Type" />
    ///  is supported; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  is <see langword="null" />
    ///  .</exception>
    function SupportsType(absoluteUri: DDN.System.DNUri; &type: DDN.mscorlib.DNType): Boolean;
    ///<summary>Adds a byte array to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store and maps it to a URI. If the store already contains a mapping for the same URI, the existing mapping is overridden.</summary>
    ///  <param name="uri">The URI of the data that is being added to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store.</param>
    ///  <param name="value">A byte array with the data that corresponds to the provided URI.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  or <paramref name="value" />
    ///  is <see langword="null" />
    ///  .</exception>
    procedure Add(uri: DDN.System.DNUri; value: TArray<Byte>); overload;
    ///<summary>Adds a byte array to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store and maps it to a URI. If the store already contains a mapping for the same URI, the existing mapping is overridden.</summary>
    ///  <param name="uri">The URI of the data that is being added to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store.</param>
    ///  <param name="value">A byte array with the data that corresponds to the provided URI.</param>
    ///  <param name="offset">The offset in the provided byte array where the data starts.</param>
    ///  <param name="count">The number of bytes to read from the byte array, starting at the provided offset.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  or <paramref name="value" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />
    ///  or <paramref name="count" />
    ///  is less than 0.-or-The length of the <paramref name="value" />
    ///  minus <paramref name="offset" />
    ///  is less than <paramref name="count." />
    ///</exception>
    procedure Add(uri: DDN.System.DNUri; value: TArray<Byte>; offset: Int32; count: Int32); overload;
    ///<summary>Adds a string with preloaded data to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store and maps it to a URI. If the store already contains a mapping for the same URI, the existing mapping is overridden.</summary>
    ///  <param name="uri">The URI of the data that is being added to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store.</param>
    ///  <param name="value">A <see langword="String" />
    ///  with the data that corresponds to the provided URI.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  or <paramref name="value" />
    ///  is <see langword="null" />
    ///  .</exception>
    procedure Add(uri: DDN.System.DNUri; value: string); overload;
    ///<summary>Removes the data that corresponds to the URI from the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  .</summary>
    ///  <param name="uri">The URI of the data that should be removed from the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  is <see langword="null" />
    ///  .</exception>
    procedure Remove(uri: DDN.System.DNUri);
    ///<summary>Resolves the absolute URI from the base and relative URIs.</summary>
    ///  <param name="baseUri">The base URI used to resolve the relative URI.</param>
    ///  <param name="relativeUri">The URI to resolve. The URI can be absolute or relative. If absolute, this value effectively replaces the <paramref name="baseUri" />
    ///  value. If relative, it combines with the <paramref name="baseUri" />
    ///  to make an absolute URI.</param>
    ///<returns>The <see cref="T:System.Uri" />
    ///  representing the absolute URI or <see langword="null" />
    ///  if the relative URI cannot be resolved.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  is <see langword="null" />
    ///  .</exception>
    function ResolveUri(baseUri: DDN.System.DNUri; relativeUri: string): DDN.System.DNUri;
    ///<summary>Maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">The current version of the .NET Framework for Silverlight does not use this parameter when resolving URIs. This parameter is provided for future extensibility purposes. For example, this parameter can be mapped to the xlink:role and used as an implementation-specific argument in other scenarios.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  supports <see cref="T:System.IO.Stream" />
    ///  objects and <see cref="T:System.IO.TextReader" />
    ///  objects for URIs that were added as <see langword="String" />
    ///  . If the requested type is not supported by the resolver, an exception will be thrown. Use the <see cref="M:System.Xml.Resolvers.XmlPreloadedResolver.SupportsType(System.Uri,System.Type)" />
    ///  method to determine whether a certain <see langword="Type" />
    ///  is supported by this resolver.</param>
    ///<returns>A <see cref="T:System.IO.Stream" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object that corresponds to the actual source.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="absoluteUri" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.XmlException">Cannot resolve URI passed in <paramref name="absoluteUri" />
    ///  .-or-
    ///  <paramref name="ofObjectToReturn" />
    ///  is not of a supported type.</exception>
    function GetEntity(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    ///<summary>Adds a <see cref="T:System.IO.Stream" />
    ///  to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store and maps it to a URI. If the store already contains a mapping for the same URI, the existing mapping is overridden.</summary>
    ///  <param name="uri">The URI of the data that is being added to the <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  store.</param>
    ///  <param name="value">A <see cref="T:System.IO.Stream" />
    ///  with the data that corresponds to the provided URI.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="uri" />
    ///  or <paramref name="value" />
    ///  is <see langword="null" />
    ///  .</exception>
    procedure Add(uri: DDN.System.DNUri; value: DDN.mscorlib.DNStream); overload;
    ///<summary>Asynchronously maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">The current version of the .NET Framework for Silverlight does not use this parameter when resolving URIs. This parameter is provided for future extensibility purposes. For example, this parameter can be mapped to the xlink:role and used as an implementation-specific argument in other scenarios.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The <see cref="T:System.Xml.Resolvers.XmlPreloadedResolver" />
    ///  supports <see cref="T:System.IO.Stream" />
    ///  objects and <see cref="T:System.IO.TextReader" />
    ///  objects for URIs that were added as <see langword="String" />
    ///  . If the requested type is not supported by the resolver, an exception will be thrown. Use the <see cref="M:System.Xml.Resolvers.XmlPreloadedResolver.SupportsType(System.Uri,System.Type)" />
    ///  method to determine whether a certain <see langword="Type" />
    ///  is supported by this resolver.</param>
    ///<returns>A <see cref="T:System.IO.Stream" />
    ///  or <see cref="T:System.IO.TextReader" />
    ///  object that corresponds to the actual source.</returns>
    function GetEntityAsync(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Sets the credentials that are used to authenticate the underlying <see cref="T:System.Net.WebRequest" />
    ///  .</summary>
    ///<returns>The credentials that are used to authenticate the underlying web request.</returns>
    property Credentials: DDN.System.DNICredentials write set_Credentials;
    ///<summary>Gets a collection of preloaded URIs.</summary>
    ///<returns>The collection of preloaded URIs.</returns>
    property PreloadedUris: DDN.mscorlib.DNIEnumerable<DDN.System.DNUri> read get_PreloadedUris;
  end;

  TDNXmlPreloadedResolver = class(TDNGenericImport<DNXmlPreloadedResolverClass, DNXmlPreloadedResolver>) end;

  //-------------namespace: System.Xml----------------
  DNXmlSecureResolverClass = interface(DNXmlResolverClass)
  ['{11A292E9-5293-562F-95D8-41BDF87FA727}']
  { static getter & setter } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  class with the <see cref="T:System.Xml.XmlResolver" />
    ///  and URL provided.</summary>
    ///  <param name="resolver">The XML resolver that is wrapped by the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  .</param>
    ///  <param name="securityUrl">The URL used to create the <see cref="T:System.Security.PermissionSet" />
    ///  that will be applied to the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . The <see cref="T:System.Xml.XmlSecureResolver" />
    ///  calls <see cref="M:System.Security.PermissionSet.PermitOnly" />
    ///  on the created <see cref="T:System.Security.PermissionSet" />
    ///  before calling <see cref="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  .</param>
    {class} function init(resolver: DNXmlResolver; securityUrl: string): DNXmlSecureResolver; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  class with the <see cref="T:System.Xml.XmlResolver" />
    ///  and <see cref="T:System.Security.Policy.Evidence" />
    ///  specified.</summary>
    ///  <param name="resolver">The XML resolver that is wrapped by the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  .</param>
    ///  <param name="evidence">The evidence used to create the <see cref="T:System.Security.PermissionSet" />
    ///  that will be applied to the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . The <see cref="T:System.Xml.XmlSecureResolver" />
    ///  calls the <see cref="M:System.Security.PermissionSet.PermitOnly" />
    ///  method on the created <see cref="T:System.Security.PermissionSet" />
    ///  before calling <see cref="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  .</param>
    {class} function init(resolver: DNXmlResolver; evidence: DDN.mscorlib.DNEvidence): DNXmlSecureResolver; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  class with the <see cref="T:System.Xml.XmlResolver" />
    ///  and <see cref="T:System.Security.PermissionSet" />
    ///  specified.</summary>
    ///  <param name="resolver">The XML resolver that is wrapped by the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  .</param>
    ///  <param name="permissionSet">The permission set to apply to the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . The <see cref="T:System.Xml.XmlSecureResolver" />
    ///  calls the <see cref="M:System.Security.PermissionSet.PermitOnly" />
    ///  method on the permission set before calling the <see cref="M:System.Xml.XmlSecureResolver.GetEntity(System.Uri,System.String,System.Type)" />
    ///  method on the underlying XML resolver.</param>
    {class} function init(resolver: DNXmlResolver; permissionSet: DDN.mscorlib.DNPermissionSet): DNXmlSecureResolver; overload;

  { static methods } 

    ///<summary>Creates evidence using the supplied URL.</summary>
    ///  <param name="securityUrl">The URL used to create the evidence.</param>
    ///<returns>The evidence generated from the supplied URL as defined by the default policy.</returns>
    {class} function CreateEvidenceForUrl(securityUrl: string): DDN.mscorlib.DNEvidence;

  { static propertys } 

    ///<summary>Sets credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. The <see cref="T:System.Xml.XmlSecureResolver" />
    ///  sets the given credentials on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  has no user credentials.</returns>
    {class} property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  ///<summary>Helps to secure another implementation of <see cref="T:System.Xml.XmlResolver" />
  ///  by wrapping the <see cref="T:System.Xml.XmlResolver" />
  ///  object and restricting the resources that the underlying <see cref="T:System.Xml.XmlResolver" />
  ///  has access to.</summary>
  [DNTypeName('System.Xml.XmlSecureResolver')]
  DNXmlSecureResolver = interface(DNXmlResolver)
  ['{2D1232D7-9DBC-35AD-A3B6-98F6CA04D053}']
  { getters & setters } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { methods } 

    ///<summary>Maps a URI to an object that contains the actual resource. This method temporarily sets the <see cref="T:System.Security.PermissionSet" />
    ///  created in the constructor by calling <see cref="M:System.Security.PermissionSet.PermitOnly" />
    ///  before calling <see langword="GetEntity" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  to open the resource.</summary>
    ///  <param name="absoluteUri">The URI that is returned from <see cref="M:System.Xml.XmlSecureResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current version only returns <see cref="T:System.IO.Stream" />
    ///  objects.</param>
    ///<returns>The stream returned by calling <see langword="GetEntity" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . If a type other than <see cref="T:System.IO.Stream" />
    ///  is specified, the method returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="ofObjectToReturn" />
    ///  is neither <see langword="null" />
    ///  nor a <see cref="T:System.IO.Stream" />
    ///  type.</exception><exception cref="T:System.UriFormatException">The specified URI is not an absolute URI.</exception><exception cref="T:System.NullReferenceException"><paramref name="absoluteUri" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Exception">There is a runtime error (for example, an interrupted server connection).</exception>
    function GetEntity(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    ///<summary>Resolves the absolute URI from the base and relative URIs by calling <see langword="ResolveUri" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  .</summary>
    ///  <param name="baseUri">The base URI used to resolve the relative URI.</param>
    ///  <param name="relativeUri">The URI to resolve. The URI can be absolute or relative. If absolute, this value effectively replaces the <paramref name="baseUri" />
    ///  value. If relative, it combines with the <paramref name="baseUri" />
    ///  to make an absolute URI.</param>
    ///<returns>The absolute URI or <see langword="null" />
    ///  if the relative URI cannot be resolved (returned by calling <see langword="ResolveUri" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  ).</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="relativeUri" />
    ///  is <see langword="null" />
    ///  .</exception>
    function ResolveUri(baseUri: DDN.System.DNUri; relativeUri: string): DDN.System.DNUri;
    ///<summary>Asynchronously maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlSecureResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current version only returns <see cref="T:System.IO.Stream" />
    ///  objects.</param>
    ///<returns>The stream returned by calling <see langword="GetEntity" />
    ///  on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . If a type other than <see cref="T:System.IO.Stream" />
    ///  is specified, the method returns <see langword="null" />
    ///  .</returns>
    function GetEntityAsync(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Enables the resolver to return types other than <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="absoluteUri">The URI.</param>
    ///  <param name="type">The type to return.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="type" />
    ///  is supported; otherwise, <see langword="false" />
    ///  .</returns>
    function SupportsType(absoluteUri: DDN.System.DNUri; &type: DDN.mscorlib.DNType): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Sets credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. The <see cref="T:System.Xml.XmlSecureResolver" />
    ///  sets the given credentials on the underlying <see cref="T:System.Xml.XmlResolver" />
    ///  . If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see cref="T:System.Xml.XmlSecureResolver" />
    ///  has no user credentials.</returns>
    property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  TDNXmlSecureResolver = class(TDNGenericImport<DNXmlSecureResolverClass, DNXmlSecureResolver>) end;

  //-------------namespace: System.Xml----------------
  DNXmlUrlResolverClass = interface(DNXmlResolverClass)
  ['{4ACC9404-F37B-52C5-9DFA-2B613A70A8A1}']
  { static getter & setter } 

    procedure set_Credentials(value: DDN.System.DNICredentials);
    procedure set_Proxy(value: DDN.System.DNIWebProxy);
    procedure set_CachePolicy(value: DDN.System.DNRequestCachePolicy);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlUrlResolver" />
    ///  class.</summary>
    {class} function init: DNXmlUrlResolver;

  { static propertys } 

    ///<summary>Sets credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see langword="XmlUrlResolver" />
    ///  has no user credentials.</returns>
    {class} property Credentials: DDN.System.DNICredentials write set_Credentials;
    ///<summary>Gets or sets the network proxy for the underlying <see cref="T:System.Net.WebRequest" />
    ///  object.</summary>
    ///<returns>The <see cref="T:System.Net.IWebProxy" />
    ///  to use to access the Internet resource.</returns>
    {class} property Proxy: DDN.System.DNIWebProxy write set_Proxy;
    ///<summary>Gets or sets the cache policy for the underlying <see cref="T:System.Net.WebRequest" />
    ///  object.</summary>
    ///<returns>The cache policy for the underlying web request.</returns>
    {class} property CachePolicy: DDN.System.DNRequestCachePolicy write set_CachePolicy;
  end;

  ///<summary>Resolves external XML resources named by a Uniform Resource Identifier (URI).</summary>
  [DNTypeName('System.Xml.XmlUrlResolver')]
  DNXmlUrlResolver = interface(DNXmlResolver)
  ['{7D359CC5-1CE8-3E77-9758-AF340B8CBE01}']
  { getters & setters } 

    procedure set_Credentials(value: DDN.System.DNICredentials);
    procedure set_Proxy(value: DDN.System.DNIWebProxy);
    procedure set_CachePolicy(value: DDN.System.DNRequestCachePolicy);

  { methods } 

    ///<summary>Maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current implementation only returns <see cref="T:System.IO.Stream" />
    ///  objects.</param>
    ///<returns>A stream object or <see langword="null" />
    ///  if a type other than stream is specified.</returns>
    ///<exception cref="T:System.Xml.XmlException"><paramref name="ofObjectToReturn" />
    ///  is neither <see langword="null" />
    ///  nor a <see langword="Stream" />
    ///  type.</exception><exception cref="T:System.UriFormatException">The specified URI is not an absolute URI.</exception><exception cref="T:System.ArgumentNullException"><paramref name="absoluteUri" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.Exception">There is a runtime error (for example, an interrupted server connection).</exception>
    function GetEntity(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    ///<summary>Resolves the absolute URI from the base and relative URIs.</summary>
    ///  <param name="baseUri">The base URI used to resolve the relative URI.</param>
    ///  <param name="relativeUri">The URI to resolve. The URI can be absolute or relative. If absolute, this value effectively replaces the <paramref name="baseUri" />
    ///  value. If relative, it combines with the <paramref name="baseUri" />
    ///  to make an absolute URI.</param>
    ///<returns>The absolute URI, or <see langword="null" />
    ///  if the relative URI cannot be resolved.</returns>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="baseUri" />
    ///  is <see langword="null" />
    ///  or <paramref name="relativeUri" />
    ///  is <see langword="null" />
    ///  .</exception>
    function ResolveUri(baseUri: DDN.System.DNUri; relativeUri: string): DDN.System.DNUri;
    ///<summary>Asynchronously maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current implementation only returns <see cref="T:System.IO.Stream" />
    ///  objects.</param>
    ///<returns>A stream object or <see langword="null" />
    ///  if a type other than stream is specified.</returns>
    function GetEntityAsync(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    ///<summary>Enables the resolver to return types other than <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="absoluteUri">The URI.</param>
    ///  <param name="type">The type to return.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="type" />
    ///  is supported; otherwise, <see langword="false" />
    ///  .</returns>
    function SupportsType(absoluteUri: DDN.System.DNUri; &type: DDN.mscorlib.DNType): Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Sets credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see langword="XmlUrlResolver" />
    ///  has no user credentials.</returns>
    property Credentials: DDN.System.DNICredentials write set_Credentials;
    ///<summary>Gets or sets the network proxy for the underlying <see cref="T:System.Net.WebRequest" />
    ///  object.</summary>
    ///<returns>The <see cref="T:System.Net.IWebProxy" />
    ///  to use to access the Internet resource.</returns>
    property Proxy: DDN.System.DNIWebProxy write set_Proxy;
    ///<summary>Gets or sets the cache policy for the underlying <see cref="T:System.Net.WebRequest" />
    ///  object.</summary>
    ///<returns>The cache policy for the underlying web request.</returns>
    property CachePolicy: DDN.System.DNRequestCachePolicy write set_CachePolicy;
  end;

  TDNXmlUrlResolver = class(TDNGenericImport<DNXmlUrlResolverClass, DNXmlUrlResolver>) end;

  //-------------namespace: System.Xml----------------
  DNXmlXapResolverClass = interface(DNXmlResolverClass)
  ['{94880A7B-7E64-56C6-8C7E-9DFFB432FCD4}']
  { static getter & setter } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlXapResolver" />
    ///  class.</summary>
    {class} function init: DNXmlXapResolver;

  { static methods } 

    ///<summary>Registers a resource stream resolver for the application.</summary>
    ///  <param name="appStreamResolver">An application resource resolver to register.</param>
    {class} procedure RegisterApplicationResourceStreamResolver(appStreamResolver: DNIApplicationResourceStreamResolver);

  { static propertys } 

    ///<summary>When overridden in a derived class, sets the credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see langword="XmlResolver" />
    ///  has no user credentials.</returns>
    {class} property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  ///<summary>The XmlXapResolver type is used to resolve resources in the Silverlight application’s XAP package. </summary>
  [DNTypeName('System.Xml.XmlXapResolver')]
  DNXmlXapResolver = interface(DNXmlResolver)
  ['{3CDE9F32-B3FA-3958-83FF-AE0C317F169B}']
  { getters & setters } 

    procedure set_Credentials(value: DDN.System.DNICredentials);

  { methods } 

    ///<summary>Maps a URI to an object containing the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">The current version does not use this parameter when resolving URIs. This is provided for future extensibility purposes. For example, this can be mapped to the xlink: role and used as an implementation specific argument in other scenarios.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current version only returns <see cref="T:System.IO.Stream" />
    ///  objects. </param>
    ///<returns>A <see cref="T:System.IO.Stream" />
    ///  object. If the stream is not found, an exception is thrown.</returns>
    function GetEntity(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNObject;
    ///<summary>When overridden in a derived class, resolves the absolute URI from the base and relative URIs.</summary>
    ///  <param name="baseUri">The base URI used to resolve the relative URI.</param>
    ///  <param name="relativeUri">The URI to resolve. The URI can be absolute or relative. If absolute, this value effectively replaces the <paramref name="baseUri" />
    ///  value. If relative, it combines with the <paramref name="baseUri" />
    ///  to make an absolute URI.</param>
    ///<returns>The absolute URI or <see langword="null" />
    ///  if the relative URI cannot be resolved.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="relativeUri" />
    ///  is <see langword="null" />
    ///  .</exception>
    function ResolveUri(baseUri: DDN.System.DNUri; relativeUri: string): DDN.System.DNUri;
    ///<summary>Enables the resolver to return types other than <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="absoluteUri">The URI.</param>
    ///  <param name="type">The type to return.</param>
    ///<returns><see langword="true" />
    ///  if the <paramref name="type" />
    ///  is supported; otherwise, <see langword="false" />
    ///  .</returns>
    function SupportsType(absoluteUri: DDN.System.DNUri; &type: DDN.mscorlib.DNType): Boolean;
    ///<summary>Asynchronously maps a URI to an object that contains the actual resource.</summary>
    ///  <param name="absoluteUri">The URI returned from <see cref="M:System.Xml.XmlResolver.ResolveUri(System.Uri,System.String)" />
    ///  .</param>
    ///  <param name="role">Currently not used.</param>
    ///  <param name="ofObjectToReturn">The type of object to return. The current version only returns <see cref="T:System.IO.Stream" />
    ///  objects.</param>
    ///<returns>A stream object or <see langword="null" />
    ///  if a type other than stream is specified.</returns>
    function GetEntityAsync(absoluteUri: DDN.System.DNUri; role: string; ofObjectToReturn: DDN.mscorlib.DNType): DDN.mscorlib.DNTask<DDN.mscorlib.DNObject>;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, sets the credentials used to authenticate web requests.</summary>
    ///<returns>The credentials to be used to authenticate web requests. If this property is not set, the value defaults to <see langword="null" />
    ///  ; that is, the <see langword="XmlResolver" />
    ///  has no user credentials.</returns>
    property Credentials: DDN.System.DNICredentials write set_Credentials;
  end;

  TDNXmlXapResolver = class(TDNGenericImport<DNXmlXapResolverClass, DNXmlXapResolver>) end;

  //-------------namespace: System.Xml----------------
  DNXmlWriterClass = interface(DNObjectClass)
  ['{387BD4BD-B278-52F4-B752-3F6A5A361BA4}']
  { static methods } 

    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the specified filename.</summary>
    ///  <param name="outputFileName">The file to which you want to write. The <see cref="T:System.Xml.XmlWriter" />
    ///  creates a file at the specified path and writes to it in XML 1.0 text syntax. The <paramref name="outputFileName" />
    ///  must be a file system path.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="url" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(outputFileName: string): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the filename and <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object.</summary>
    ///  <param name="outputFileName">The file to which you want to write. The <see cref="T:System.Xml.XmlWriter" />
    ///  creates a file at the specified path and writes to it in XML 1.0 text syntax. The <paramref name="outputFileName" />
    ///  must be a file system path.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to configure the new <see cref="T:System.Xml.XmlWriter" />
    ///  instance. If this is <see langword="null" />
    ///  , a <see cref="T:System.Xml.XmlWriterSettings" />
    ///  with default settings is used.If the <see cref="T:System.Xml.XmlWriter" />
    ///  is being used with the <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" />
    ///  method, you should use the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property to obtain an <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object with the correct settings. This ensures that the created <see cref="T:System.Xml.XmlWriter" />
    ///  object has the correct output settings.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="url" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(outputFileName: string; settings: DNXmlWriterSettings): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the specified stream.</summary>
    ///  <param name="output">The stream to which you want to write. The <see cref="T:System.Xml.XmlWriter" />
    ///  writes XML 1.0 text syntax and appends it to the specified stream.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stream" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DDN.mscorlib.DNStream): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the stream and <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object.</summary>
    ///  <param name="output">The stream to which you want to write. The <see cref="T:System.Xml.XmlWriter" />
    ///  writes XML 1.0 text syntax and appends it to the specified stream.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to configure the new <see cref="T:System.Xml.XmlWriter" />
    ///  instance. If this is <see langword="null" />
    ///  , a <see cref="T:System.Xml.XmlWriterSettings" />
    ///  with default settings is used.If the <see cref="T:System.Xml.XmlWriter" />
    ///  is being used with the <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" />
    ///  method, you should use the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property to obtain an <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object with the correct settings. This ensures that the created <see cref="T:System.Xml.XmlWriter" />
    ///  object has the correct output settings.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stream" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DDN.mscorlib.DNStream; settings: DNXmlWriterSettings): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="output">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to write. The <see cref="T:System.Xml.XmlWriter" />
    ///  writes XML 1.0 text syntax and appends it to the specified <see cref="T:System.IO.TextWriter" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="text" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DDN.mscorlib.DNTextWriter): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the <see cref="T:System.IO.TextWriter" />
    ///  and <see cref="T:System.Xml.XmlWriterSettings" />
    ///  objects.</summary>
    ///  <param name="output">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to write. The <see cref="T:System.Xml.XmlWriter" />
    ///  writes XML 1.0 text syntax and appends it to the specified <see cref="T:System.IO.TextWriter" />
    ///  .</param>
    ///  <param name="settings">The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to configure the new <see cref="T:System.Xml.XmlWriter" />
    ///  instance. If this is <see langword="null" />
    ///  , a <see cref="T:System.Xml.XmlWriterSettings" />
    ///  with default settings is used.If the <see cref="T:System.Xml.XmlWriter" />
    ///  is being used with the <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" />
    ///  method, you should use the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property to obtain an <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object with the correct settings. This ensures that the created <see cref="T:System.Xml.XmlWriter" />
    ///  object has the correct output settings.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="text" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DDN.mscorlib.DNTextWriter; settings: DNXmlWriterSettings): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the specified <see cref="T:System.Text.StringBuilder" />
    ///  .</summary>
    ///  <param name="output">The <see cref="T:System.Text.StringBuilder" />
    ///  to which to write to. Content written by the <see cref="T:System.Xml.XmlWriter" />
    ///  is appended to the <see cref="T:System.Text.StringBuilder" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="builder" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DDN.mscorlib.DNStringBuilder): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the <see cref="T:System.Text.StringBuilder" />
    ///  and <see cref="T:System.Xml.XmlWriterSettings" />
    ///  objects.</summary>
    ///  <param name="output">The <see cref="T:System.Text.StringBuilder" />
    ///  to which to write to. Content written by the <see cref="T:System.Xml.XmlWriter" />
    ///  is appended to the <see cref="T:System.Text.StringBuilder" />
    ///  .</param>
    ///  <param name="settings">The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to configure the new <see cref="T:System.Xml.XmlWriter" />
    ///  instance. If this is <see langword="null" />
    ///  , a <see cref="T:System.Xml.XmlWriterSettings" />
    ///  with default settings is used.If the <see cref="T:System.Xml.XmlWriter" />
    ///  is being used with the <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" />
    ///  method, you should use the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property to obtain an <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object with the correct settings. This ensures that the created <see cref="T:System.Xml.XmlWriter" />
    ///  object has the correct output settings.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="builder" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DDN.mscorlib.DNStringBuilder; settings: DNXmlWriterSettings): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  object.</summary>
    ///  <param name="output">The <see cref="T:System.Xml.XmlWriter" />
    ///  object that you want to use as the underlying writer.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object that is wrapped around the specified <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="writer" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DNXmlWriter): DNXmlWriter; overload;
    ///<summary>Creates a new <see cref="T:System.Xml.XmlWriter" />
    ///  instance using the specified <see cref="T:System.Xml.XmlWriter" />
    ///  and <see cref="T:System.Xml.XmlWriterSettings" />
    ///  objects.</summary>
    ///  <param name="output">The <see cref="T:System.Xml.XmlWriter" />
    ///  object that you want to use as the underlying writer.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to configure the new <see cref="T:System.Xml.XmlWriter" />
    ///  instance. If this is <see langword="null" />
    ///  , a <see cref="T:System.Xml.XmlWriterSettings" />
    ///  with default settings is used.If the <see cref="T:System.Xml.XmlWriter" />
    ///  is being used with the <see cref="M:System.Xml.Xsl.XslCompiledTransform.Transform(System.String,System.Xml.XmlWriter)" />
    ///  method, you should use the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property to obtain an <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object with the correct settings. This ensures that the created <see cref="T:System.Xml.XmlWriter" />
    ///  object has the correct output settings.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object that is wrapped around the specified <see cref="T:System.Xml.XmlWriter" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="writer" />
    ///  value is <see langword="null" />
    ///  .</exception>
    {class} function Create(output: DNXmlWriter; settings: DNXmlWriterSettings): DNXmlWriter; overload;

  end;

  ///<summary>Represents a writer that provides a fast, non-cached, forward-only way to generate streams or files that contain XML data.</summary>
  [DNTypeName('System.Xml.XmlWriter')]
  DNXmlWriter = interface(DDN.mscorlib.DNIDisposable)
  ['{DEE5DBC9-DE85-3F72-8CA7-9B3A0951D0DB}']
  { getters & setters } 

    function get_Settings: DNXmlWriterSettings;
    function get_WriteState: DNWriteState;
    function get_XmlSpace: DNXmlSpace;
    function get_XmlLang: string;

  { methods } 

    ///<summary>When overridden in a derived class, writes the specified start tag and associates it with the given namespace.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element. If this namespace is already in scope and has an associated prefix, the writer automatically writes that prefix also.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartElement(localName: string; ns: string); overload;
    ///<summary>When overridden in a derived class, writes out a start tag with the specified local name.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartElement(localName: string); overload;
    ///<summary>When overridden in a derived class, writes an attribute with the specified local name, namespace URI, and value.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI to associate with the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The state of writer is not <see langword="WriteState.Element" />
    ///  or writer is closed. </exception><exception cref="T:System.ArgumentException">The <see langword="xml:space" />
    ///  or <see langword="xml:lang" />
    ///  attribute value is invalid. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributeString(localName: string; ns: string; value: string); overload;
    ///<summary>When overridden in a derived class, writes out the attribute with the specified local name and value.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The state of writer is not <see langword="WriteState.Element" />
    ///  or writer is closed. </exception><exception cref="T:System.ArgumentException">The <see langword="xml:space" />
    ///  or <see langword="xml:lang" />
    ///  attribute value is invalid. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributeString(localName: string; value: string); overload;
    ///<summary>When overridden in a derived class, writes out the attribute with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The namespace prefix of the attribute.</param>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The state of writer is not <see langword="WriteState.Element" />
    ///  or writer is closed. </exception><exception cref="T:System.ArgumentException">The <see langword="xml:space" />
    ///  or <see langword="xml:lang" />
    ///  attribute value is invalid. </exception><exception cref="T:System.Xml.XmlException">The <paramref name="localName" />
    ///  or <paramref name="ns" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributeString(prefix: string; localName: string; ns: string; value: string); overload;
    ///<summary>Writes the start of an attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///<exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartAttribute(localName: string; ns: string); overload;
    ///<summary>Writes the start of an attribute with the specified local name.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartAttribute(localName: string); overload;
    ///<summary>When overridden in a derived class, encodes the specified binary bytes as <see langword="BinHex" />
    ///  and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode.</param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write.</param>
    ///  <param name="count">The number of bytes to write.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The writer is closed or in error state.</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero. -or-The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteBinHex(buffer: TArray<Byte>; index: Int32; count: Int32);
    ///<summary>When overridden in a derived class, closes this stream and the underlying stream.</summary>
    ///<exception cref="T:System.InvalidOperationException">A call is made to write more output after <see langword="Close" />
    ///  has been called or the result of this call is an invalid XML document.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Close;
    ///<summary>When overridden in a derived class, writes out the specified name, ensuring it is a valid NmToken according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">The name to write.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="name" />
    ///  is not a valid NmToken; or <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteNmToken(name: string);
    ///<summary>When overridden in a derived class, writes out the specified name, ensuring it is a valid name according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">The name to write.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="name" />
    ///  is not a valid XML name; or <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteName(name: string);
    ///<summary>Writes the object value.</summary>
    ///  <param name="value">The object value to write.
    ///  Note   With the release of the .NET Framework 3.5, this method accepts <see cref="T:System.DateTimeOffset" />
    ///  as a parameter.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The writer is closed or in error state.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNObject); overload;
    ///<summary>Writes a <see cref="T:System.String" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.String" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: string); overload;
    ///<summary>Writes a <see cref="T:System.DateTime" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.DateTime" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNDateTime); overload;
    ///<summary>Writes a <see cref="T:System.DateTimeOffset" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.DateTimeOffset" />
    ///  value to write.</param>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNDateTimeOffset); overload;
    ///<summary>Writes a <see cref="T:System.Double" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Double" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Double); overload;
    ///<summary>Writes a single-precision floating-point number.</summary>
    ///  <param name="value">The single-precision floating-point number to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Single); overload;
    ///<summary>Writes a <see cref="T:System.Decimal" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Decimal" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNDecimal); overload;
    ///<summary>Writes a <see cref="T:System.Int32" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Int32" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Int32); overload;
    ///<summary>Writes a <see cref="T:System.Int64" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Int64" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Int64); overload;
    ///<summary>When overridden in a derived class, writes out all the attributes found at the current position in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  from which to copy the attributes.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="reader" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Xml.XmlException">The reader is not positioned on an <see langword="element" />
    ///  , <see langword="attribute" />
    ///  or <see langword="XmlDeclaration" />
    ///  node. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributes(reader: DNXmlReader; defattr: Boolean);
    ///<summary>Copies everything from the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object to the writer. The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  remains unchanged.</summary>
    ///  <param name="navigator">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to copy from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="navigator" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteNode(navigator: DNXPathNavigator; defattr: Boolean); overload;
    ///<summary>Writes an element with the specified local name and value.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="localName" />
    ///  value is <see langword="null" />
    ///  or an empty string.-or-The parameter values are not valid.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteElementString(localName: string; value: string); overload;
    ///<summary>Writes an element with the specified local name, namespace URI, and value.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="localName" />
    ///  value is <see langword="null" />
    ///  or an empty string.-or-The parameter values are not valid.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteElementString(localName: string; ns: string; value: string); overload;
    ///<summary>Writes an element with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="localName" />
    ///  value is <see langword="null" />
    ///  or an empty string.-or-The parameter values are not valid.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteElementString(prefix: string; localName: string; ns: string; value: string); overload;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlWriter" />
    ///  class.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Dispose;
    ///<summary>Asynchronously writes the XML declaration with the version "1.0".</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteStartDocument" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStartDocumentAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously writes the XML declaration with the version "1.0" and the standalone attribute.</summary>
    ///  <param name="standalone">If <see langword="true" />
    ///  , it writes "standalone=yes"; if <see langword="false" />
    ///  , it writes "standalone=no".</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteStartDocument" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStartDocumentAsync(standalone: Boolean): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously closes any open elements or attributes and puts the writer back in the Start state.</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteEndDocument" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteEndDocumentAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes the DOCTYPE declaration with the specified name and optional attributes.</summary>
    ///  <param name="name">The name of the DOCTYPE. This must be non-empty.</param>
    ///  <param name="pubid">If non-null it also writes PUBLIC "pubid" "sysid" where <paramref name="pubid" />
    ///  and <paramref name="sysid" />
    ///  are replaced with the value of the given arguments.</param>
    ///  <param name="sysid">If <paramref name="pubid" />
    ///  is <see langword="null" />
    ///  and <paramref name="sysid" />
    ///  is non-null it writes SYSTEM "sysid" where <paramref name="sysid" />
    ///  is replaced with the value of this argument.</param>
    ///  <param name="subset">If non-null it writes [subset] where subset is replaced with the value of this argument.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteDocType" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteDocTypeAsync(name: string; pubid: string; sysid: string; subset: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes the specified start tag and associates it with the given namespace and prefix.</summary>
    ///  <param name="prefix">The namespace prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteStartElement" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStartElementAsync(prefix: string; localName: string; ns: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously closes one element and pops the corresponding namespace scope.</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteEndElement" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteEndElementAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously closes one element and pops the corresponding namespace scope.</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteFullEndElement" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteFullEndElementAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out a &lt;![CDATA[...]]&gt; block containing the specified text.</summary>
    ///  <param name="text">The text to place inside the CDATA block.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteCData" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCDataAsync(text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out a comment &lt;!--...--&gt; containing the specified text.</summary>
    ///  <param name="text">Text to place inside the comment.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteComment" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCommentAsync(text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out a processing instruction with a space between the name and text as follows: &lt;?name text?&gt;.</summary>
    ///  <param name="name">The name of the processing instruction.</param>
    ///  <param name="text">The text to include in the processing instruction.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteProcessingInstruction" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteProcessingInstructionAsync(name: string; text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out an entity reference as <see langword="&amp;name;" />
    ///  .</summary>
    ///  <param name="name">The name of the entity reference.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteEntityRef" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteEntityRefAsync(name: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously forces the generation of a character entity for the specified Unicode character value.</summary>
    ///  <param name="ch">The Unicode character for which to generate a character entity.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteCharEntity" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCharEntityAsync(ch: Char): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the given white space.</summary>
    ///  <param name="ws">The string of white space characters.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteWhitespace" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteWhitespaceAsync(ws: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes the given text content.</summary>
    ///  <param name="text">The text to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteString" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStringAsync(text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously generates and writes the surrogate character entity for the surrogate character pair.</summary>
    ///  <param name="lowChar">The low surrogate. This must be a value between 0xDC00 and 0xDFFF.</param>
    ///  <param name="highChar">The high surrogate. This must be a value between 0xD800 and 0xDBFF.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteSurrogateCharEntity" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteSurrogateCharEntityAsync(lowChar: Char; highChar: Char): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes text one buffer at a time.</summary>
    ///  <param name="buffer">Character array containing the text to write.</param>
    ///  <param name="index">The position in the buffer indicating the start of the text to write.</param>
    ///  <param name="count">The number of characters to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteChars" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCharsAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes raw markup manually from a character buffer.</summary>
    ///  <param name="buffer">Character array containing the text to write.</param>
    ///  <param name="index">The position within the buffer indicating the start of the text to write.</param>
    ///  <param name="count">The number of characters to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteRaw" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteRawAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously writes raw markup manually from a string.</summary>
    ///  <param name="data">String containing the text to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteRaw" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteRawAsync(data: string): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously encodes the specified binary bytes as Base64 and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode.</param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write.</param>
    ///  <param name="count">The number of bytes to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteBase64" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously encodes the specified binary bytes as <see langword="BinHex" />
    ///  and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode.</param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write.</param>
    ///  <param name="count">The number of bytes to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteBinHex" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.</summary>
    ///<returns>The task that represents the asynchronous <see langword="Flush" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function FlushAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the specified name, ensuring it is a valid NmToken according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">The name to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteNmToken" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNmTokenAsync(name: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the specified name, ensuring it is a valid name according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">The name to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteName" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNameAsync(name: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the namespace-qualified name. This method looks up the prefix that is in scope for the given namespace.</summary>
    ///  <param name="localName">The local name to write.</param>
    ///  <param name="ns">The namespace URI for the name.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteQualifiedName" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteQualifiedNameAsync(localName: string; ns: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out all the attributes found at the current position in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  from which to copy the attributes.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteAttributes" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteAttributesAsync(reader: DNXmlReader; defattr: Boolean): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously copies everything from the reader to the writer and moves the reader to the start of the next sibling.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  to read from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteNode" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNodeAsync(reader: DNXmlReader; defattr: Boolean): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously copies everything from the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object to the writer. The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  remains unchanged.</summary>
    ///  <param name="navigator">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to copy from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteNode" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNodeAsync(navigator: DNXPathNavigator; defattr: Boolean): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously writes an element with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteElementString" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteElementStringAsync(prefix: string; localName: string; ns: string; value: string): DDN.mscorlib.DNTask;
    ///<summary>When overridden in a derived class, writes the XML declaration with the version "1.0".</summary>
    ///<exception cref="T:System.InvalidOperationException">This is not the first write method called after the constructor.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartDocument; overload;
    ///<summary>When overridden in a derived class, writes the XML declaration with the version "1.0" and the standalone attribute.</summary>
    ///  <param name="standalone">If <see langword="true" />
    ///  , it writes "standalone=yes"; if <see langword="false" />
    ///  , it writes "standalone=no".</param>
    ///<exception cref="T:System.InvalidOperationException">This is not the first write method called after the constructor. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartDocument(standalone: Boolean); overload;
    ///<summary>When overridden in a derived class, closes any open elements or attributes and puts the writer back in the Start state.</summary>
    ///<exception cref="T:System.ArgumentException">The XML document is invalid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteEndDocument;
    ///<summary>When overridden in a derived class, writes the DOCTYPE declaration with the specified name and optional attributes.</summary>
    ///  <param name="name">The name of the DOCTYPE. This must be non-empty.</param>
    ///  <param name="pubid">If non-null it also writes PUBLIC "pubid" "sysid" where <paramref name="pubid" />
    ///  and <paramref name="sysid" />
    ///  are replaced with the value of the given arguments.</param>
    ///  <param name="sysid">If <paramref name="pubid" />
    ///  is <see langword="null" />
    ///  and <paramref name="sysid" />
    ///  is non-null it writes SYSTEM "sysid" where <paramref name="sysid" />
    ///  is replaced with the value of this argument.</param>
    ///  <param name="subset">If non-null it writes [subset] where subset is replaced with the value of this argument.</param>
    ///<exception cref="T:System.InvalidOperationException">This method was called outside the prolog (after the root element). </exception><exception cref="T:System.ArgumentException">The value for <paramref name="name" />
    ///  would result in invalid XML.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteDocType(name: string; pubid: string; sysid: string; subset: string);
    ///<summary>When overridden in a derived class, writes the specified start tag and associates it with the given namespace and prefix.</summary>
    ///  <param name="prefix">The namespace prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartElement(prefix: string; localName: string; ns: string); overload;
    ///<summary>When overridden in a derived class, closes one element and pops the corresponding namespace scope.</summary>
    ///<exception cref="T:System.InvalidOperationException">This results in an invalid XML document.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteEndElement;
    ///<summary>When overridden in a derived class, closes one element and pops the corresponding namespace scope.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteFullEndElement;
    ///<summary>When overridden in a derived class, writes the start of an attribute with the specified prefix, local name, and namespace URI.</summary>
    ///  <param name="prefix">The namespace prefix of the attribute.</param>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI for the attribute.</param>
    ///<exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartAttribute(prefix: string; localName: string; ns: string); overload;
    ///<summary>When overridden in a derived class, closes the previous <see cref="M:System.Xml.XmlWriter.WriteStartAttribute(System.String,System.String)" />
    ///  call.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteEndAttribute;
    ///<summary>When overridden in a derived class, writes out a &lt;![CDATA[...]]&gt; block containing the specified text.</summary>
    ///  <param name="text">The text to place inside the CDATA block.</param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well formed XML document.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteCData(text: string);
    ///<summary>When overridden in a derived class, writes out a comment &lt;!--...--&gt; containing the specified text.</summary>
    ///  <param name="text">Text to place inside the comment.</param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well-formed XML document.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteComment(text: string);
    ///<summary>When overridden in a derived class, writes out a processing instruction with a space between the name and text as follows: &lt;?name text?&gt;.</summary>
    ///  <param name="name">The name of the processing instruction.</param>
    ///  <param name="text">The text to include in the processing instruction.</param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well formed XML document.
    ///  <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .This method is being used to create an XML declaration after <see cref="M:System.Xml.XmlWriter.WriteStartDocument" />
    ///  has already been called. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteProcessingInstruction(name: string; text: string);
    ///<summary>When overridden in a derived class, writes out an entity reference as <see langword="&amp;name;" />
    ///  .</summary>
    ///  <param name="name">The name of the entity reference.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteEntityRef(name: string);
    ///<summary>When overridden in a derived class, forces the generation of a character entity for the specified Unicode character value.</summary>
    ///  <param name="ch">The Unicode character for which to generate a character entity.</param>
    ///<exception cref="T:System.ArgumentException">The character is in the surrogate pair character range, <see langword="0xd800" />
    ///  - <see langword="0xdfff" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteCharEntity(ch: Char);
    ///<summary>When overridden in a derived class, writes out the given white space.</summary>
    ///  <param name="ws">The string of white space characters.</param>
    ///<exception cref="T:System.ArgumentException">The string contains non-white space characters.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteWhitespace(ws: string);
    ///<summary>When overridden in a derived class, writes the given text content.</summary>
    ///  <param name="text">The text to write.</param>
    ///<exception cref="T:System.ArgumentException">The text string contains an invalid surrogate pair.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteString(text: string);
    ///<summary>When overridden in a derived class, generates and writes the surrogate character entity for the surrogate character pair.</summary>
    ///  <param name="lowChar">The low surrogate. This must be a value between 0xDC00 and 0xDFFF.</param>
    ///  <param name="highChar">The high surrogate. This must be a value between 0xD800 and 0xDBFF.</param>
    ///<exception cref="T:System.ArgumentException">An invalid surrogate character pair was passed.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteSurrogateCharEntity(lowChar: Char; highChar: Char);
    ///<summary>When overridden in a derived class, writes text one buffer at a time.</summary>
    ///  <param name="buffer">Character array containing the text to write.</param>
    ///  <param name="index">The position in the buffer indicating the start of the text to write.</param>
    ///  <param name="count">The number of characters to write.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero.-or-The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  ; the call results in surrogate pair characters being split or an invalid surrogate pair being written.</exception><exception cref="T:System.ArgumentException">The <paramref name="buffer" />
    ///  parameter value is not valid.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteChars(buffer: TArray<Char>; index: Int32; count: Int32);
    ///<summary>When overridden in a derived class, writes raw markup manually from a character buffer.</summary>
    ///  <param name="buffer">Character array containing the text to write.</param>
    ///  <param name="index">The position within the buffer indicating the start of the text to write.</param>
    ///  <param name="count">The number of characters to write.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero. -or-The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteRaw(buffer: TArray<Char>; index: Int32; count: Int32); overload;
    ///<summary>When overridden in a derived class, writes raw markup manually from a string.</summary>
    ///  <param name="data">String containing the text to write.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="data" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteRaw(data: string); overload;
    ///<summary>When overridden in a derived class, encodes the specified binary bytes as Base64 and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode.</param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write.</param>
    ///  <param name="count">The number of bytes to write.</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero. -or-The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteBase64(buffer: TArray<Byte>; index: Int32; count: Int32);
    ///<summary>When overridden in a derived class, flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Flush;
    ///<summary>When overridden in a derived class, returns the closest prefix defined in the current namespace scope for the namespace URI.</summary>
    ///  <param name="ns">The namespace URI whose prefix you want to find.</param>
    ///<returns>The matching prefix or <see langword="null" />
    ///  if no matching namespace URI is found in the current scope.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="ns" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    function LookupPrefix(ns: string): string;
    ///<summary>When overridden in a derived class, writes out the namespace-qualified name. This method looks up the prefix that is in scope for the given namespace.</summary>
    ///  <param name="localName">The local name to write.</param>
    ///  <param name="ns">The namespace URI for the name.</param>
    ///<exception cref="T:System.ArgumentException"><paramref name="localName" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .
    ///  <paramref name="localName" />
    ///  is not a valid name. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteQualifiedName(localName: string; ns: string);
    ///<summary>Writes a <see cref="T:System.Boolean" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Boolean" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Boolean); overload;
    ///<summary>When overridden in a derived class, copies everything from the reader to the writer and moves the reader to the start of the next sibling.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  to read from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="reader" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="reader" />
    ///  contains invalid characters.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteNode(reader: DNXmlReader; defattr: Boolean); overload;
    ///<summary>Asynchronously writes out the attribute with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The namespace prefix of the attribute.</param>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteAttributeString" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteAttributeStringAsync(prefix: string; localName: string; ns: string; value: string): DDN.mscorlib.DNTask;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to create this <see cref="T:System.Xml.XmlWriter" />
    ///  instance.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to create this writer instance. If this writer was not created using the <see cref="Overload:System.Xml.XmlWriter.Create" />
    ///  method, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Settings: DNXmlWriterSettings read get_Settings;
    ///<summary>When overridden in a derived class, gets the state of the writer.</summary>
    ///<returns>One of the <see cref="T:System.Xml.WriteState" />
    ///  values.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property WriteState: DNWriteState read get_WriteState;
    ///<summary>When overridden in a derived class, gets an <see cref="T:System.Xml.XmlSpace" />
    ///  representing the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>An <see langword="XmlSpace" />
    ///  representing the current <see langword="xml:space" />
    ///  scope.Value Meaning
    ///<see langword="None" />
    ///  This is the default if no <see langword="xml:space" />
    ///  scope exists.
    ///<see langword="Default" />
    ///  The current scope is <see langword="xml:space" />
    ///  ="default".
    ///<see langword="Preserve" />
    ///  The current scope is <see langword="xml:space" />
    ///  ="preserve".</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property XmlSpace: DNXmlSpace read get_XmlSpace;
    ///<summary>When overridden in a derived class, gets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  scope.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property XmlLang: string read get_XmlLang;
  end;

  TDNXmlWriter = class(TDNGenericImport<DNXmlWriterClass, DNXmlWriter>) end;

  //-------------namespace: System.Xml----------------
  DNXmlTextWriterClass = interface(DNXmlWriterClass)
  ['{1C2628BB-023E-55A7-AA2F-1172CF62087D}']
  { constructors } 

    ///<summary>Creates an instance of the <see langword="XmlTextWriter" />
    ///  class using the specified stream and encoding.</summary>
    ///  <param name="w">The stream to which you want to write. </param>
    ///  <param name="encoding">The encoding to generate. If encoding is <see langword="null" />
    ///  it writes out the stream as UTF-8 and omits the encoding attribute from the <see langword="ProcessingInstruction" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The encoding is not supported or the stream cannot be written to. </exception><exception cref="T:System.ArgumentNullException"><paramref name="w" />
    ///  is <see langword="null" />
    ///  . </exception>
    {class} function init(w: DDN.mscorlib.DNStream; encoding: DDN.mscorlib.DNEncoding): DNXmlTextWriter; overload;
    ///<summary>Creates an instance of the <see cref="T:System.Xml.XmlTextWriter" />
    ///  class using the specified file.</summary>
    ///  <param name="filename">The filename to write to. If the file exists, it truncates it and overwrites it with the new content. </param>
    ///  <param name="encoding">The encoding to generate. If encoding is <see langword="null" />
    ///  it writes the file out as UTF-8, and omits the encoding attribute from the <see langword="ProcessingInstruction" />
    ///  . </param>
    ///<exception cref="T:System.ArgumentException">The encoding is not supported; the filename is empty, contains only white space, or contains one or more invalid characters. </exception><exception cref="T:System.UnauthorizedAccessException">Access is denied. </exception><exception cref="T:System.ArgumentNullException">The filename is <see langword="null" />
    ///  . </exception><exception cref="T:System.IO.DirectoryNotFoundException">The directory to write to is not found. </exception><exception cref="T:System.IO.IOException">The filename includes an incorrect or invalid syntax for file name, directory name, or volume label syntax. </exception><exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
    {class} function init(filename: string; encoding: DDN.mscorlib.DNEncoding): DNXmlTextWriter; overload;
    ///<summary>Creates an instance of the <see langword="XmlTextWriter" />
    ///  class using the specified <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="w">The <see langword="TextWriter" />
    ///  to write to. It is assumed that the <see langword="TextWriter" />
    ///  is already set to the correct encoding. </param>
    {class} function init(w: DDN.mscorlib.DNTextWriter): DNXmlTextWriter; overload;

  end;

  ///<summary>Represents a writer that provides a fast, non-cached, forward-only way of generating streams or files containing XML data that conforms to the W3C Extensible Markup Language (XML) 1.0 and the Namespaces in XML recommendations. Starting with the .NET Framework 2.0, we recommend that you use the <see cref="T:System.Xml.XmlWriter" />
  ///  class instead.</summary>
  [DNTypeName('System.Xml.XmlTextWriter')]
  DNXmlTextWriter = interface(DNXmlWriter)
  ['{CA18874F-214A-3FE7-BF32-7C2EE1E49E0E}']
  { getters & setters } 

    function get_BaseStream: DDN.mscorlib.DNStream;
    function get_Namespaces: Boolean;
    procedure set_Namespaces(value: Boolean);
    function get_Formatting: DNFormatting;
    procedure set_Formatting(value: DNFormatting);
    function get_Indentation: Int32;
    procedure set_Indentation(value: Int32);
    function get_IndentChar: Char;
    procedure set_IndentChar(value: Char);
    function get_QuoteChar: Char;
    procedure set_QuoteChar(value: Char);
    function get_WriteState: DNWriteState;
    function get_XmlSpace: DNXmlSpace;
    function get_XmlLang: string;
    function get_Settings: DNXmlWriterSettings;

  { methods } 

    ///<summary>Writes the start of an attribute.</summary>
    ///  <param name="prefix"><see langword="Namespace" />
    ///  prefix of the attribute. </param>
    ///  <param name="localName"><see langword="LocalName" />
    ///  of the attribute. </param>
    ///  <param name="ns"><see langword="NamespaceURI" />
    ///  of the attribute </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="localName" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  . </exception>
    procedure WriteStartAttribute(prefix: string; localName: string; ns: string); overload;
    ///<summary>Writes out a &lt;![CDATA[...]]&gt; block containing the specified text.</summary>
    ///  <param name="text">Text to place inside the CDATA block. </param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well formed XML document. </exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XmlTextWriter.WriteState" />
    ///  is <see langword="Closed" />
    ///  . </exception>
    procedure WriteCData(text: string);
    ///<summary>Writes out a comment &lt;!--...--&gt; containing the specified text.</summary>
    ///  <param name="text">Text to place inside the comment. </param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well formed XML document </exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XmlTextWriter.WriteState" />
    ///  is <see langword="Closed" />
    ///  . </exception>
    procedure WriteComment(text: string);
    ///<summary>Writes out a processing instruction with a space between the name and text as follows: &lt;?name text?&gt;.</summary>
    ///  <param name="name">Name of the processing instruction. </param>
    ///  <param name="text">Text to include in the processing instruction. </param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well formed XML document.
    ///  <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .This method is being used to create an XML declaration after <see cref="M:System.Xml.XmlTextWriter.WriteStartDocument" />
    ///  has already been called. </exception>
    procedure WriteProcessingInstruction(name: string; text: string);
    ///<summary>Writes out the namespace-qualified name. This method looks up the prefix that is in scope for the given namespace.</summary>
    ///  <param name="localName">The local name to write. </param>
    ///  <param name="ns">The namespace URI to associate with the name. </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="localName" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  .
    ///  <paramref name="localName" />
    ///  is not a valid name according to the W3C Namespaces spec. </exception>
    procedure WriteQualifiedName(localName: string; ns: string);
    ///<summary>Writes the XML declaration with the version "1.0".</summary>
    ///<exception cref="T:System.InvalidOperationException">This is not the first write method called after the constructor. </exception>
    procedure WriteStartDocument; overload;
    ///<summary>Writes the XML declaration with the version "1.0" and the standalone attribute.</summary>
    ///  <param name="standalone">If <see langword="true" />
    ///  , it writes "standalone=yes"; if <see langword="false" />
    ///  , it writes "standalone=no". </param>
    ///<exception cref="T:System.InvalidOperationException">This is not the first write method called after the constructor. </exception>
    procedure WriteStartDocument(standalone: Boolean); overload;
    ///<summary>Closes any open elements or attributes and puts the writer back in the Start state.</summary>
    ///<exception cref="T:System.ArgumentException">The XML document is invalid. </exception>
    procedure WriteEndDocument;
    ///<summary>Writes the specified start tag and associates it with the given namespace and prefix.</summary>
    ///  <param name="prefix">The namespace prefix of the element. </param>
    ///  <param name="localName">The local name of the element. </param>
    ///  <param name="ns">The namespace URI to associate with the element. If this namespace is already in scope and has an associated prefix then the writer automatically writes that prefix also. </param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed. </exception>
    procedure WriteStartElement(prefix: string; localName: string; ns: string); overload;
    ///<summary>Closes one element and pops the corresponding namespace scope.</summary>
    procedure WriteEndElement;
    ///<summary>Closes one element and pops the corresponding namespace scope.</summary>
    procedure WriteFullEndElement;
    ///<summary>Closes the previous <see cref="M:System.Xml.XmlTextWriter.WriteStartAttribute(System.String,System.String,System.String)" />
    ///  call.</summary>
    procedure WriteEndAttribute;
    ///<summary>Writes out an entity reference as <see langword="&amp;name;" />
    ///  .</summary>
    ///  <param name="name">Name of the entity reference. </param>
    ///<exception cref="T:System.ArgumentException">The text would result in a non-well formed XML document or <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  . </exception>
    procedure WriteEntityRef(name: string);
    ///<summary>Forces the generation of a character entity for the specified Unicode character value.</summary>
    ///  <param name="ch">Unicode character for which to generate a character entity. </param>
    ///<exception cref="T:System.ArgumentException">The character is in the surrogate pair character range, <see langword="0xd800" />
    ///  - <see langword="0xdfff" />
    ///  ; or the text would result in a non-well formed XML document. </exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XmlTextWriter.WriteState" />
    ///  is <see langword="Closed" />
    ///  . </exception>
    procedure WriteCharEntity(ch: Char);
    ///<summary>Writes out the given white space.</summary>
    ///  <param name="ws">The string of white space characters. </param>
    ///<exception cref="T:System.ArgumentException">The string contains non-white space characters. </exception>
    procedure WriteWhitespace(ws: string);
    ///<summary>Writes the given text content.</summary>
    ///  <param name="text">Text to write. </param>
    ///<exception cref="T:System.ArgumentException">The text string contains an invalid surrogate pair. </exception>
    procedure WriteString(text: string);
    ///<summary>Generates and writes the surrogate character entity for the surrogate character pair.</summary>
    ///  <param name="lowChar">The low surrogate. This must be a value between <see langword="0xDC00" />
    ///  and <see langword="0xDFFF" />
    ///  . </param>
    ///  <param name="highChar">The high surrogate. This must be a value between <see langword="0xD800" />
    ///  and <see langword="0xDBFF" />
    ///  . </param>
    ///<exception cref="T:System.Exception">An invalid surrogate character pair was passed. </exception>
    procedure WriteSurrogateCharEntity(lowChar: Char; highChar: Char);
    ///<summary>Writes text one buffer at a time.</summary>
    ///  <param name="buffer">Character array containing the text to write. </param>
    ///  <param name="index">The position in the buffer indicating the start of the text to write. </param>
    ///  <param name="count">The number of characters to write. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero. -or-The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  ; the call results in surrogate pair characters being split or an invalid surrogate pair being written.</exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XmlTextWriter.WriteState" />
    ///  is Closed. </exception>
    procedure WriteChars(buffer: TArray<Char>; index: Int32; count: Int32);
    ///<summary>Writes raw markup manually from a character buffer.</summary>
    ///  <param name="buffer">Character array containing the text to write. </param>
    ///  <param name="index">The position within the buffer indicating the start of the text to write. </param>
    ///  <param name="count">The number of characters to write. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero.-or-The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  . </exception>
    procedure WriteRaw(buffer: TArray<Char>; index: Int32; count: Int32); overload;
    ///<summary>Writes raw markup manually from a string.</summary>
    ///  <param name="data">String containing the text to write. </param>
    procedure WriteRaw(data: string); overload;
    ///<summary>Encodes the specified binary bytes as binhex and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode. </param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write. </param>
    ///  <param name="count">The number of bytes to write. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero. </exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XmlTextWriter.WriteState" />
    ///  is Closed. </exception>
    procedure WriteBinHex(buffer: TArray<Byte>; index: Int32; count: Int32);
    ///<summary>Closes this stream and the underlying stream.</summary>
    procedure Close;
    ///<summary>Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.</summary>
    procedure Flush;
    ///<summary>Writes out the specified name, ensuring it is a valid name according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">Name to write. </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="name" />
    ///  is not a valid XML name; or <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  . </exception>
    procedure WriteName(name: string);
    ///<summary>Returns the closest prefix defined in the current namespace scope for the namespace URI.</summary>
    ///  <param name="ns">Namespace URI whose prefix you want to find. </param>
    ///<returns>The matching prefix. Or <see langword="null" />
    ///  if no matching namespace URI is found in the current scope.</returns>
    ///<exception cref="T:System.ArgumentException"><paramref name="ns" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  . </exception>
    function LookupPrefix(ns: string): string;
    ///<summary>Writes the DOCTYPE declaration with the specified name and optional attributes.</summary>
    ///  <param name="name">The name of the DOCTYPE. This must be non-empty. </param>
    ///  <param name="pubid">If non-null it also writes PUBLIC "pubid" "sysid" where <paramref name="pubid" />
    ///  and <paramref name="sysid" />
    ///  are replaced with the value of the given arguments. </param>
    ///  <param name="sysid">If <paramref name="pubid" />
    ///  is null and <paramref name="sysid" />
    ///  is non-null it writes SYSTEM "sysid" where <paramref name="sysid" />
    ///  is replaced with the value of this argument. </param>
    ///  <param name="subset">If non-null it writes [subset] where subset is replaced with the value of this argument. </param>
    ///<exception cref="T:System.InvalidOperationException">This method was called outside the prolog (after the root element). </exception><exception cref="T:System.ArgumentException"><paramref name="name" />
    ///  is <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  -or- the value for <paramref name="name" />
    ///  would result in invalid XML. </exception>
    procedure WriteDocType(name: string; pubid: string; sysid: string; subset: string);
    ///<summary>Encodes the specified binary bytes as base64 and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode. </param>
    ///  <param name="index">The position within the buffer indicating the start of the bytes to write. </param>
    ///  <param name="count">The number of bytes to write. </param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="buffer" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.ArgumentException">The buffer length minus <paramref name="index" />
    ///  is less than <paramref name="count" />
    ///  . </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />
    ///  or <paramref name="count" />
    ///  is less than zero. </exception><exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XmlTextWriter.WriteState" />
    ///  is <see langword="Closed" />
    ///  . </exception>
    procedure WriteBase64(buffer: TArray<Byte>; index: Int32; count: Int32);
    ///<summary>Writes out the specified name, ensuring it is a valid <see langword="NmToken" />
    ///  according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">Name to write. </param>
    ///<exception cref="T:System.ArgumentException"><paramref name="name" />
    ///  is not a valid <see langword="NmToken" />
    ///  ; or <paramref name="name" />
    ///  is either <see langword="null" />
    ///  or <see langword="String.Empty" />
    ///  . </exception>
    procedure WriteNmToken(name: string);
    ///<summary>When overridden in a derived class, writes the specified start tag and associates it with the given namespace.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element. If this namespace is already in scope and has an associated prefix, the writer automatically writes that prefix also.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartElement(localName: string; ns: string); overload;
    ///<summary>When overridden in a derived class, writes out a start tag with the specified local name.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartElement(localName: string); overload;
    ///<summary>When overridden in a derived class, writes an attribute with the specified local name, namespace URI, and value.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI to associate with the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The state of writer is not <see langword="WriteState.Element" />
    ///  or writer is closed. </exception><exception cref="T:System.ArgumentException">The <see langword="xml:space" />
    ///  or <see langword="xml:lang" />
    ///  attribute value is invalid. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributeString(localName: string; ns: string; value: string); overload;
    ///<summary>When overridden in a derived class, writes out the attribute with the specified local name and value.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The state of writer is not <see langword="WriteState.Element" />
    ///  or writer is closed. </exception><exception cref="T:System.ArgumentException">The <see langword="xml:space" />
    ///  or <see langword="xml:lang" />
    ///  attribute value is invalid. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributeString(localName: string; value: string); overload;
    ///<summary>When overridden in a derived class, writes out the attribute with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The namespace prefix of the attribute.</param>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The state of writer is not <see langword="WriteState.Element" />
    ///  or writer is closed. </exception><exception cref="T:System.ArgumentException">The <see langword="xml:space" />
    ///  or <see langword="xml:lang" />
    ///  attribute value is invalid. </exception><exception cref="T:System.Xml.XmlException">The <paramref name="localName" />
    ///  or <paramref name="ns" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributeString(prefix: string; localName: string; ns: string; value: string); overload;
    ///<summary>Writes the start of an attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///<exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartAttribute(localName: string; ns: string); overload;
    ///<summary>Writes the start of an attribute with the specified local name.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///<exception cref="T:System.InvalidOperationException">The writer is closed.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteStartAttribute(localName: string); overload;
    ///<summary>Writes the object value.</summary>
    ///  <param name="value">The object value to write.
    ///  Note   With the release of the .NET Framework 3.5, this method accepts <see cref="T:System.DateTimeOffset" />
    ///  as a parameter.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.ArgumentNullException">The <paramref name="value" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The writer is closed or in error state.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNObject); overload;
    ///<summary>Writes a <see cref="T:System.String" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.String" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: string); overload;
    ///<summary>Writes a <see cref="T:System.DateTime" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.DateTime" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNDateTime); overload;
    ///<summary>Writes a <see cref="T:System.DateTimeOffset" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.DateTimeOffset" />
    ///  value to write.</param>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNDateTimeOffset); overload;
    ///<summary>Writes a <see cref="T:System.Double" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Double" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Double); overload;
    ///<summary>Writes a single-precision floating-point number.</summary>
    ///  <param name="value">The single-precision floating-point number to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Single); overload;
    ///<summary>Writes a <see cref="T:System.Decimal" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Decimal" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: DDN.mscorlib.DNDecimal); overload;
    ///<summary>Writes a <see cref="T:System.Int32" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Int32" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Int32); overload;
    ///<summary>Writes a <see cref="T:System.Int64" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Int64" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Int64); overload;
    ///<summary>When overridden in a derived class, writes out all the attributes found at the current position in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  from which to copy the attributes.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="reader" />
    ///  is <see langword="null" />
    ///  . </exception><exception cref="T:System.Xml.XmlException">The reader is not positioned on an <see langword="element" />
    ///  , <see langword="attribute" />
    ///  or <see langword="XmlDeclaration" />
    ///  node. </exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteAttributes(reader: DNXmlReader; defattr: Boolean);
    ///<summary>Copies everything from the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object to the writer. The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  remains unchanged.</summary>
    ///  <param name="navigator">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to copy from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="navigator" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteNode(navigator: DNXPathNavigator; defattr: Boolean); overload;
    ///<summary>Writes an element with the specified local name and value.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="localName" />
    ///  value is <see langword="null" />
    ///  or an empty string.-or-The parameter values are not valid.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteElementString(localName: string; value: string); overload;
    ///<summary>Writes an element with the specified local name, namespace URI, and value.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="localName" />
    ///  value is <see langword="null" />
    ///  or an empty string.-or-The parameter values are not valid.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteElementString(localName: string; ns: string; value: string); overload;
    ///<summary>Writes an element with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="localName" />
    ///  value is <see langword="null" />
    ///  or an empty string.-or-The parameter values are not valid.</exception><exception cref="T:System.Text.EncoderFallbackException">There is a character in the buffer that is a valid XML character but is not valid for the output encoding. For example, if the output encoding is ASCII, you should only use characters from the range of 0 to 127 for element and attribute names. The invalid character might be in the argument of this method or in an argument of previous methods that were writing to the buffer. Such characters are escaped by character entity references when possible (for example, in text nodes or attribute values). However, the character entity reference is not allowed in element and attribute names, comments, processing instructions, or CDATA sections.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteElementString(prefix: string; localName: string; ns: string; value: string); overload;
    ///<summary>Releases all resources used by the current instance of the <see cref="T:System.Xml.XmlWriter" />
    ///  class.</summary>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure Dispose;
    ///<summary>Asynchronously writes the XML declaration with the version "1.0".</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteStartDocument" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStartDocumentAsync: DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously writes the XML declaration with the version "1.0" and the standalone attribute.</summary>
    ///  <param name="standalone">If <see langword="true" />
    ///  , it writes "standalone=yes"; if <see langword="false" />
    ///  , it writes "standalone=no".</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteStartDocument" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStartDocumentAsync(standalone: Boolean): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously closes any open elements or attributes and puts the writer back in the Start state.</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteEndDocument" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteEndDocumentAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes the DOCTYPE declaration with the specified name and optional attributes.</summary>
    ///  <param name="name">The name of the DOCTYPE. This must be non-empty.</param>
    ///  <param name="pubid">If non-null it also writes PUBLIC "pubid" "sysid" where <paramref name="pubid" />
    ///  and <paramref name="sysid" />
    ///  are replaced with the value of the given arguments.</param>
    ///  <param name="sysid">If <paramref name="pubid" />
    ///  is <see langword="null" />
    ///  and <paramref name="sysid" />
    ///  is non-null it writes SYSTEM "sysid" where <paramref name="sysid" />
    ///  is replaced with the value of this argument.</param>
    ///  <param name="subset">If non-null it writes [subset] where subset is replaced with the value of this argument.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteDocType" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteDocTypeAsync(name: string; pubid: string; sysid: string; subset: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes the specified start tag and associates it with the given namespace and prefix.</summary>
    ///  <param name="prefix">The namespace prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI to associate with the element.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteStartElement" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStartElementAsync(prefix: string; localName: string; ns: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously closes one element and pops the corresponding namespace scope.</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteEndElement" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteEndElementAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously closes one element and pops the corresponding namespace scope.</summary>
    ///<returns>The task that represents the asynchronous <see langword="WriteFullEndElement" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteFullEndElementAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out a &lt;![CDATA[...]]&gt; block containing the specified text.</summary>
    ///  <param name="text">The text to place inside the CDATA block.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteCData" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCDataAsync(text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out a comment &lt;!--...--&gt; containing the specified text.</summary>
    ///  <param name="text">Text to place inside the comment.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteComment" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCommentAsync(text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out a processing instruction with a space between the name and text as follows: &lt;?name text?&gt;.</summary>
    ///  <param name="name">The name of the processing instruction.</param>
    ///  <param name="text">The text to include in the processing instruction.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteProcessingInstruction" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteProcessingInstructionAsync(name: string; text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out an entity reference as <see langword="&amp;name;" />
    ///  .</summary>
    ///  <param name="name">The name of the entity reference.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteEntityRef" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteEntityRefAsync(name: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously forces the generation of a character entity for the specified Unicode character value.</summary>
    ///  <param name="ch">The Unicode character for which to generate a character entity.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteCharEntity" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCharEntityAsync(ch: Char): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the given white space.</summary>
    ///  <param name="ws">The string of white space characters.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteWhitespace" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteWhitespaceAsync(ws: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes the given text content.</summary>
    ///  <param name="text">The text to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteString" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteStringAsync(text: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously generates and writes the surrogate character entity for the surrogate character pair.</summary>
    ///  <param name="lowChar">The low surrogate. This must be a value between 0xDC00 and 0xDFFF.</param>
    ///  <param name="highChar">The high surrogate. This must be a value between 0xD800 and 0xDBFF.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteSurrogateCharEntity" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteSurrogateCharEntityAsync(lowChar: Char; highChar: Char): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes text one buffer at a time.</summary>
    ///  <param name="buffer">Character array containing the text to write.</param>
    ///  <param name="index">The position in the buffer indicating the start of the text to write.</param>
    ///  <param name="count">The number of characters to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteChars" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteCharsAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes raw markup manually from a character buffer.</summary>
    ///  <param name="buffer">Character array containing the text to write.</param>
    ///  <param name="index">The position within the buffer indicating the start of the text to write.</param>
    ///  <param name="count">The number of characters to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteRaw" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteRawAsync(buffer: TArray<Char>; index: Int32; count: Int32): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously writes raw markup manually from a string.</summary>
    ///  <param name="data">String containing the text to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteRaw" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteRawAsync(data: string): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously encodes the specified binary bytes as Base64 and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode.</param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write.</param>
    ///  <param name="count">The number of bytes to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteBase64" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteBase64Async(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously encodes the specified binary bytes as <see langword="BinHex" />
    ///  and writes out the resulting text.</summary>
    ///  <param name="buffer">Byte array to encode.</param>
    ///  <param name="index">The position in the buffer indicating the start of the bytes to write.</param>
    ///  <param name="count">The number of bytes to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteBinHex" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteBinHexAsync(buffer: TArray<Byte>; index: Int32; count: Int32): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.</summary>
    ///<returns>The task that represents the asynchronous <see langword="Flush" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function FlushAsync: DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the specified name, ensuring it is a valid NmToken according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">The name to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteNmToken" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNmTokenAsync(name: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the specified name, ensuring it is a valid name according to the W3C XML 1.0 recommendation (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name).</summary>
    ///  <param name="name">The name to write.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteName" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNameAsync(name: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out the namespace-qualified name. This method looks up the prefix that is in scope for the given namespace.</summary>
    ///  <param name="localName">The local name to write.</param>
    ///  <param name="ns">The namespace URI for the name.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteQualifiedName" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteQualifiedNameAsync(localName: string; ns: string): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously writes out all the attributes found at the current position in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="reader">The <see langword="XmlReader" />
    ///  from which to copy the attributes.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteAttributes" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteAttributesAsync(reader: DNXmlReader; defattr: Boolean): DDN.mscorlib.DNTask;
    ///<summary>Asynchronously copies everything from the reader to the writer and moves the reader to the start of the next sibling.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  to read from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteNode" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNodeAsync(reader: DNXmlReader; defattr: Boolean): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously copies everything from the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object to the writer. The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  remains unchanged.</summary>
    ///  <param name="navigator">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to copy from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteNode" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteNodeAsync(navigator: DNXPathNavigator; defattr: Boolean): DDN.mscorlib.DNTask; overload;
    ///<summary>Asynchronously writes an element with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The prefix of the element.</param>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="ns">The namespace URI of the element.</param>
    ///  <param name="value">The value of the element.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteElementString" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteElementStringAsync(prefix: string; localName: string; ns: string; value: string): DDN.mscorlib.DNTask;
    ///<summary>Writes a <see cref="T:System.Boolean" />
    ///  value.</summary>
    ///  <param name="value">The <see cref="T:System.Boolean" />
    ///  value to write.</param>
    ///<exception cref="T:System.ArgumentException">An invalid value was specified.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteValue(value: Boolean); overload;
    ///<summary>When overridden in a derived class, copies everything from the reader to the writer and moves the reader to the start of the next sibling.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  to read from.</param>
    ///  <param name="defattr"><see langword="true" />
    ///  to copy the default attributes from the <see langword="XmlReader" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<exception cref="T:System.ArgumentNullException"><paramref name="reader" />
    ///  is <see langword="null" />
    ///  .</exception><exception cref="T:System.ArgumentException"><paramref name="reader" />
    ///  contains invalid characters.</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    procedure WriteNode(reader: DNXmlReader; defattr: Boolean); overload;
    ///<summary>Asynchronously writes out the attribute with the specified prefix, local name, namespace URI, and value.</summary>
    ///  <param name="prefix">The namespace prefix of the attribute.</param>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="ns">The namespace URI of the attribute.</param>
    ///  <param name="value">The value of the attribute.</param>
    ///<returns>The task that represents the asynchronous <see langword="WriteAttributeString" />
    ///  operation.</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception><exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  asynchronous method was called without setting the <see cref="P:System.Xml.XmlWriterSettings.Async" />
    ///  flag to <see langword="true" />
    ///  . In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “Set XmlWriterSettings.Async to true if you want to use Async Methods.”</exception>
    function WriteAttributeStringAsync(prefix: string; localName: string; ns: string; value: string): DDN.mscorlib.DNTask;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets the underlying stream object.</summary>
    ///<returns>The stream to which the <see langword="XmlTextWriter" />
    ///  is writing or <see langword="null" />
    ///  if the <see langword="XmlTextWriter" />
    ///  was constructed using a <see cref="T:System.IO.TextWriter" />
    ///  that does not inherit from the <see cref="T:System.IO.StreamWriter" />
    ///  class.</returns>
    property BaseStream: DDN.mscorlib.DNStream read get_BaseStream;
    ///<summary>Gets or sets a value indicating whether to do namespace support.</summary>
    ///<returns><see langword="true" />
    ///  to support namespaces; otherwise, <see langword="false" />
    ///  .The default is <see langword="true" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">You can only change this property when in the <see langword="WriteState.Start" />
    ///  state. </exception>
    property Namespaces: Boolean read get_Namespaces write set_Namespaces;
    ///<summary>Indicates how the output is formatted.</summary>
    ///<returns>One of the <see cref="T:System.Xml.Formatting" />
    ///  values. The default is <see langword="Formatting.None" />
    ///  (no special formatting).</returns>
    property Formatting: DNFormatting read get_Formatting write set_Formatting;
    ///<summary>Gets or sets how many IndentChars to write for each level in the hierarchy when <see cref="P:System.Xml.XmlTextWriter.Formatting" />
    ///  is set to <see langword="Formatting.Indented" />
    ///  .</summary>
    ///<returns>Number of <see langword="IndentChars" />
    ///  for each level. The default is 2.</returns>
    ///<exception cref="T:System.ArgumentException">Setting this property to a negative value. </exception>
    property Indentation: Int32 read get_Indentation write set_Indentation;
    ///<summary>Gets or sets which character to use for indenting when <see cref="P:System.Xml.XmlTextWriter.Formatting" />
    ///  is set to <see langword="Formatting.Indented" />
    ///  .</summary>
    ///<returns>The character to use for indenting. The default is space.The <see langword="XmlTextWriter" />
    ///  allows you to set this property to any character. To ensure valid XML, you must specify a valid white space character, 0x9, 0x10, 0x13 or 0x20.</returns>
    property IndentChar: Char read get_IndentChar write set_IndentChar;
    ///<summary>Gets or sets which character to use to quote attribute values.</summary>
    ///<returns>The character to use to quote attribute values. This must be a single quote (&amp;#39;) or a double quote (&amp;#34;). The default is a double quote.</returns>
    ///<exception cref="T:System.ArgumentException">Setting this property to something other than either a single or double quote. </exception>
    property QuoteChar: Char read get_QuoteChar write set_QuoteChar;
    ///<summary>Gets the state of the writer.</summary>
    ///<returns>One of the <see cref="T:System.Xml.WriteState" />
    ///  values.</returns>
    property WriteState: DNWriteState read get_WriteState;
    ///<summary>Gets an <see cref="T:System.Xml.XmlSpace" />
    ///  representing the current <see langword="xml:space" />
    ///  scope.</summary>
    ///<returns>An <see langword="XmlSpace" />
    ///  representing the current <see langword="xml:space" />
    ///  scope.Value Meaning None This is the default if no <see langword="xml:space" />
    ///  scope exists. Default The current scope is <see langword="xml:space" />
    ///  ="default". Preserve The current scope is <see langword="xml:space" />
    ///  ="preserve". </returns>
    property XmlSpace: DNXmlSpace read get_XmlSpace;
    ///<summary>Gets the current <see langword="xml:lang" />
    ///  scope.</summary>
    ///<returns>The current <see langword="xml:lang" />
    ///  or <see langword="null" />
    ///  if there is no <see langword="xml:lang" />
    ///  in the current scope.</returns>
    property XmlLang: string read get_XmlLang;
    ///<summary>Gets the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to create this <see cref="T:System.Xml.XmlWriter" />
    ///  instance.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object used to create this writer instance. If this writer was not created using the <see cref="Overload:System.Xml.XmlWriter.Create" />
    ///  method, this property returns <see langword="null" />
    ///  .</returns>
    ///<exception cref="T:System.InvalidOperationException">An <see cref="T:System.Xml.XmlWriter" />
    ///  method was called before a previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" />
    ///  is thrown with the message “An asynchronous operation is already in progress.”</exception>
    property Settings: DNXmlWriterSettings read get_Settings;
  end;

  TDNXmlTextWriter = class(TDNGenericImport<DNXmlTextWriterClass, DNXmlTextWriter>) end;

  //-------------namespace: System.Xml----------------
  DNXmlWriterSettingsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{8666F90C-F5C9-5F87-910D-1BD914FBFB3C}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  class.</summary>
    {class} function init: DNXmlWriterSettings;

  end;

  ///<summary>Specifies a set of features to support on the <see cref="T:System.Xml.XmlWriter" />
  ///  object created by the <see cref="Overload:System.Xml.XmlWriter.Create" />
  ///  method.</summary>
  [DNTypeName('System.Xml.XmlWriterSettings')]
  DNXmlWriterSettings = interface(DDN.mscorlib.DNObject)
  ['{FF4A400D-DA06-355E-86B7-9B296810A674}']
  { getters & setters } 

    function get_Async: Boolean;
    procedure set_Async(value: Boolean);
    function get_Encoding: DDN.mscorlib.DNEncoding;
    procedure set_Encoding(value: DDN.mscorlib.DNEncoding);
    function get_OmitXmlDeclaration: Boolean;
    procedure set_OmitXmlDeclaration(value: Boolean);
    function get_NewLineHandling: DNNewLineHandling;
    procedure set_NewLineHandling(value: DNNewLineHandling);
    function get_NewLineChars: string;
    procedure set_NewLineChars(value: string);
    function get_Indent: Boolean;
    procedure set_Indent(value: Boolean);
    function get_IndentChars: string;
    procedure set_IndentChars(value: string);
    function get_NewLineOnAttributes: Boolean;
    procedure set_NewLineOnAttributes(value: Boolean);
    function get_CloseOutput: Boolean;
    procedure set_CloseOutput(value: Boolean);
    function get_ConformanceLevel: DNConformanceLevel;
    procedure set_ConformanceLevel(value: DNConformanceLevel);
    function get_CheckCharacters: Boolean;
    procedure set_CheckCharacters(value: Boolean);
    function get_NamespaceHandling: DNNamespaceHandling;
    procedure set_NamespaceHandling(value: DNNamespaceHandling);
    function get_WriteEndDocumentOnClose: Boolean;
    procedure set_WriteEndDocumentOnClose(value: Boolean);
    function get_OutputMethod: DNXmlOutputMethod;
    function get_DoNotEscapeUriAttributes: Boolean;
    procedure set_DoNotEscapeUriAttributes(value: Boolean);

  { methods } 

    ///<summary>Creates a copy of the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  instance.</summary>
    ///<returns>The cloned <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object.</returns>
    function Clone: DNXmlWriterSettings;
    ///<summary>Resets the members of the settings class to their default values.</summary>
    procedure Reset;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value that indicates whether asynchronous <see cref="T:System.Xml.XmlWriter" />
    ///  methods can be used on a particular <see cref="T:System.Xml.XmlWriter" />
    ///  instance.</summary>
    ///<returns><see langword="true" />
    ///  if asynchronous methods can be used; otherwise, <see langword="false" />
    ///  .</returns>
    property Async: Boolean read get_Async write set_Async;
    ///<summary>Gets or sets the type of text encoding to use.</summary>
    ///<returns>The text encoding to use. The default is <see langword="Encoding.UTF8" />
    ///  .</returns>
    property Encoding: DDN.mscorlib.DNEncoding read get_Encoding write set_Encoding;
    ///<summary>Gets or sets a value indicating whether to omit an XML declaration.</summary>
    ///<returns><see langword="true" />
    ///  to omit the XML declaration; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  , an XML declaration is written.</returns>
    property OmitXmlDeclaration: Boolean read get_OmitXmlDeclaration write set_OmitXmlDeclaration;
    ///<summary>Gets or sets a value indicating whether to normalize line breaks in the output.</summary>
    ///<returns>One of the <see cref="T:System.Xml.NewLineHandling" />
    ///  values. The default is <see cref="F:System.Xml.NewLineHandling.Replace" />
    ///  .</returns>
    property NewLineHandling: DNNewLineHandling read get_NewLineHandling write set_NewLineHandling;
    ///<summary>Gets or sets the character string to use for line breaks.</summary>
    ///<returns>The character string to use for line breaks. This can be set to any string value. However, to ensure valid XML, you should specify only valid white space characters, such as space characters, tabs, carriage returns, or line feeds. The default is \r\n (carriage return, new line).</returns>
    ///<exception cref="T:System.ArgumentNullException">The value assigned to the <see cref="P:System.Xml.XmlWriterSettings.NewLineChars" />
    ///  is <see langword="null" />
    ///  .</exception>
    property NewLineChars: string read get_NewLineChars write set_NewLineChars;
    ///<summary>Gets or sets a value indicating whether to indent elements.</summary>
    ///<returns><see langword="true" />
    ///  to write individual elements on new lines and indent; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property Indent: Boolean read get_Indent write set_Indent;
    ///<summary>Gets or sets the character string to use when indenting. This setting is used when the <see cref="P:System.Xml.XmlWriterSettings.Indent" />
    ///  property is set to <see langword="true" />
    ///  .</summary>
    ///<returns>The character string to use when indenting. This can be set to any string value. However, to ensure valid XML, you should specify only valid white space characters, such as space characters, tabs, carriage returns, or line feeds. The default is two spaces.</returns>
    ///<exception cref="T:System.ArgumentNullException">The value assigned to the <see cref="P:System.Xml.XmlWriterSettings.IndentChars" />
    ///  is <see langword="null" />
    ///  .</exception>
    property IndentChars: string read get_IndentChars write set_IndentChars;
    ///<summary>Gets or sets a value indicating whether to write attributes on a new line.</summary>
    ///<returns><see langword="true" />
    ///  to write attributes on individual lines; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .This setting has no effect when the <see cref="P:System.Xml.XmlWriterSettings.Indent" />
    ///  property value is <see langword="false" />
    ///  .When <see cref="P:System.Xml.XmlWriterSettings.NewLineOnAttributes" />
    ///  is set to <see langword="true" />
    ///  , each attribute is pre-pended with a new line and one extra level of indentation.</returns>
    property NewLineOnAttributes: Boolean read get_NewLineOnAttributes write set_NewLineOnAttributes;
    ///<summary>Gets or sets a value indicating whether the <see cref="T:System.Xml.XmlWriter" />
    ///  should also close the underlying stream or <see cref="T:System.IO.TextWriter" />
    ///  when the <see cref="M:System.Xml.XmlWriter.Close" />
    ///  method is called.</summary>
    ///<returns><see langword="true" />
    ///  to also close the underlying stream or <see cref="T:System.IO.TextWriter" />
    ///  ; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property CloseOutput: Boolean read get_CloseOutput write set_CloseOutput;
    ///<summary>Gets or sets the level of conformance that the XML writer checks the XML output for.</summary>
    ///<returns>One of the enumeration values that specifies the level of conformance (document, fragment, or automatic detection). The default is <see cref="F:System.Xml.ConformanceLevel.Document" />
    ///  .</returns>
    property ConformanceLevel: DNConformanceLevel read get_ConformanceLevel write set_ConformanceLevel;
    ///<summary>Gets or sets a value that indicates whether the XML writer should check to ensure that all characters in the document conform to the "2.2 Characters" section of the W3C XML 1.0 Recommendation.</summary>
    ///<returns><see langword="true" />
    ///  to do character checking; otherwise, <see langword="false" />
    ///  . The default is <see langword="true" />
    ///  .</returns>
    property CheckCharacters: Boolean read get_CheckCharacters write set_CheckCharacters;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.XmlWriter" />
    ///  should remove duplicate namespace declarations when writing XML content. The default behavior is for the writer to output all namespace declarations that are present in the writer's namespace resolver.</summary>
    ///<returns>The <see cref="T:System.Xml.NamespaceHandling" />
    ///  enumeration used to specify whether to remove duplicate namespace declarations in the <see cref="T:System.Xml.XmlWriter" />
    ///  .</returns>
    property NamespaceHandling: DNNamespaceHandling read get_NamespaceHandling write set_NamespaceHandling;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.XmlWriter" />
    ///  will add closing tags to all unclosed element tags when the <see cref="M:System.Xml.XmlWriter.Close" />
    ///  method is called.</summary>
    ///<returns><see langword="true" />
    ///  if all unclosed element tags will be closed out; otherwise, <see langword="false" />
    ///  . The default value is <see langword="true" />
    ///  . </returns>
    property WriteEndDocumentOnClose: Boolean read get_WriteEndDocumentOnClose write set_WriteEndDocumentOnClose;
    ///<summary>Gets the method used to serialize the <see cref="T:System.Xml.XmlWriter" />
    ///  output.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XmlOutputMethod" />
    ///  values. The default is <see cref="F:System.Xml.XmlOutputMethod.Xml" />
    ///  .</returns>
    property OutputMethod: DNXmlOutputMethod read get_OutputMethod;
    ///<summary>Gets or sets a value that indicates whether the <see cref="T:System.Xml.XmlWriter" />
    ///  does not escape URI attributes.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XmlWriter" />
    ///  do not escape URI attributes; otherwise, <see langword="false" />
    ///  .</returns>
    property DoNotEscapeUriAttributes: Boolean read get_DoNotEscapeUriAttributes write set_DoNotEscapeUriAttributes;
  end;

  TDNXmlWriterSettings = class(TDNGenericImport<DNXmlWriterSettingsClass, DNXmlWriterSettings>) end;

  //-------------namespace: System.Xml.XPath----------------
  DNXPathDocumentClass = interface(DNObjectClass)
  ['{8C1F535F-E646-5B7F-A23D-656BCDCACC7F}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  class from the XML data that is contained in the specified <see cref="T:System.Xml.XmlReader" />
    ///  object.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  object that contains the XML data. </param>
    ///<exception cref="T:System.Xml.XmlException">An error was encountered in the XML data. The <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  remains empty. </exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(reader: DNXmlReader): DNXPathDocument; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  class from the XML data that is contained in the specified <see cref="T:System.Xml.XmlReader" />
    ///  object with the specified white space handling.</summary>
    ///  <param name="reader">The <see cref="T:System.Xml.XmlReader" />
    ///  object that contains the XML data.</param>
    ///  <param name="space">An <see cref="T:System.Xml.XmlSpace" />
    ///  object.</param>
    ///<exception cref="T:System.Xml.XmlException">An error was encountered in the XML data. The <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  remains empty. </exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object parameter or <see cref="T:System.Xml.XmlSpace" />
    ///  object parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(reader: DNXmlReader; space: DNXmlSpace): DNXPathDocument; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  class from the XML data that is contained in the specified <see cref="T:System.IO.TextReader" />
    ///  object.</summary>
    ///  <param name="textReader">The <see cref="T:System.IO.TextReader" />
    ///  object that contains the XML data.</param>
    ///<exception cref="T:System.Xml.XmlException">An error was encountered in the XML data. The <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  remains empty. </exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.IO.TextReader" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(textReader: DDN.mscorlib.DNTextReader): DNXPathDocument; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  class from the XML data in the specified <see cref="T:System.IO.Stream" />
    ///  object.</summary>
    ///  <param name="stream">The <see cref="T:System.IO.Stream" />
    ///  object that contains the XML data.</param>
    ///<exception cref="T:System.Xml.XmlException">An error was encountered in the XML data. The <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  remains empty. </exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.IO.Stream" />
    ///  object passed as a parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(stream: DDN.mscorlib.DNStream): DNXPathDocument; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  class from the XML data in the specified file.</summary>
    ///  <param name="uri">The path of the file that contains the XML data.</param>
    ///<exception cref="T:System.Xml.XmlException">An error was encountered in the XML data. The <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  remains empty. </exception><exception cref="T:System.ArgumentNullException">The file path parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(uri: string): DNXPathDocument; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  class from the XML data in the file specified with the white space handling specified.</summary>
    ///  <param name="uri">The path of the file that contains the XML data.</param>
    ///  <param name="space">An <see cref="T:System.Xml.XmlSpace" />
    ///  object.</param>
    ///<exception cref="T:System.Xml.XmlException">An error was encountered in the XML data. The <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  remains empty. </exception><exception cref="T:System.ArgumentNullException">The file path parameter or <see cref="T:System.Xml.XmlSpace" />
    ///  object parameter is <see langword="null" />
    ///  .</exception>
    {class} function init(uri: string; space: DNXmlSpace): DNXPathDocument; overload;

  end;

  ///<summary>Provides a fast, read-only, in-memory representation of an XML document by using the XPath data model.</summary>
  [DNTypeName('System.Xml.XPath.XPathDocument')]
  DNXPathDocument = interface(DNIXPathNavigable)
  ['{B6446D0E-E67F-3271-B8DA-BF8BBBA19466}']
  { methods } 

    ///<summary>Initializes a read-only <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object for navigating through nodes in this <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  .</summary>
    ///<returns>A read-only <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object.</returns>
    function CreateNavigator: DNXPathNavigator;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXPathDocument = class(TDNGenericImport<DNXPathDocumentClass, DNXPathDocument>) end;

  //-------------namespace: System.Xml.XPath----------------
  DNXPathExpressionClass = interface(DDN.mscorlib.DNObjectClass)
  ['{F66C6659-D159-5BE6-A5CE-CAA051FE3D65}']
  { static methods } 

    ///<summary>Compiles the XPath expression specified and returns an <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object representing the XPath expression.</summary>
    ///  <param name="xpath">An XPath expression.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression parameter is not a valid XPath expression.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    {class} function Compile(xpath: string): DNXPathExpression; overload;
    ///<summary>Compiles the specified XPath expression, with the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified for namespace resolution, and returns an <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object that represents the XPath expression.</summary>
    ///  <param name="xpath">An XPath expression.</param>
    ///  <param name="nsResolver">An object that implements the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  interface for namespace resolution.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object.</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression parameter is not a valid XPath expression.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    {class} function Compile(xpath: string; nsResolver: DNIXmlNamespaceResolver): DNXPathExpression; overload;

  end;

  ///<summary>Provides a typed class that represents a compiled XPath expression.</summary>
  [DNTypeName('System.Xml.XPath.XPathExpression')]
  DNXPathExpression = interface(DDN.mscorlib.DNObject)
  ['{B2D5CCCE-B400-3DC6-B310-EB894C049E94}']
  { getters & setters } 

    function get_Expression: string;
    function get_ReturnType: DNXPathResultType;

  { methods } 

    ///<summary>When overridden in a derived class, sorts the nodes selected by the XPath expression according to the specified <see cref="T:System.Collections.IComparer" />
    ///  object.</summary>
    ///  <param name="expr">An object representing the sort key. This can be the <see langword="string" />
    ///  value of the node or an <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object with a compiled XPath expression.</param>
    ///  <param name="comparer">An <see cref="T:System.Collections.IComparer" />
    ///  object that provides the specific data type comparisons for comparing two objects for equivalence. </param>
    ///<exception cref="T:System.Xml.XPath.XPathException">The <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  or sort key includes a prefix and either an <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  is not provided, or the prefix cannot be found in the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  .</exception>
    procedure AddSort(expr: DDN.mscorlib.DNObject; comparer: DDN.mscorlib.DNIComparer); overload;
    ///<summary>When overridden in a derived class, sorts the nodes selected by the XPath expression according to the supplied parameters.</summary>
    ///  <param name="expr">An object representing the sort key. This can be the <see langword="string" />
    ///  value of the node or an <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object with a compiled XPath expression. </param>
    ///  <param name="order">An <see cref="T:System.Xml.XPath.XmlSortOrder" />
    ///  value indicating the sort order. </param>
    ///  <param name="caseOrder">An <see cref="T:System.Xml.XPath.XmlCaseOrder" />
    ///  value indicating how to sort uppercase and lowercase letters.</param>
    ///  <param name="lang">The language to use for comparison. Uses the <see cref="T:System.Globalization.CultureInfo" />
    ///  class that can be passed to the <see cref="Overload:System.String.Compare" />
    ///  method for the language types, for example, "us-en" for U.S. English. If an empty string is specified, the system environment is used to determine the <see cref="T:System.Globalization.CultureInfo" />
    ///  . </param>
    ///  <param name="dataType">An <see cref="T:System.Xml.XPath.XmlDataType" />
    ///  value indicating the sort order for the data type. </param>
    ///<exception cref="T:System.Xml.XPath.XPathException">The <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  or sort key includes a prefix and either an <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  is not provided, or the prefix cannot be found in the supplied <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  . </exception>
    procedure AddSort(expr: DDN.mscorlib.DNObject; order: DNXmlSortOrder; caseOrder: DNXmlCaseOrder; lang: string; dataType: DNXmlDataType); overload;
    ///<summary>When overridden in a derived class, returns a clone of this <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object.</returns>
    function Clone: DNXPathExpression;
    ///<summary>When overridden in a derived class, specifies the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  object to use for namespace resolution.</summary>
    ///  <param name="nsManager">An <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  object to use for namespace resolution. </param>
    ///<exception cref="T:System.Xml.XPath.XPathException">The <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  object parameter is not derived from the <see cref="T:System.Xml.XmlNamespaceManager" />
    ///  class. </exception>
    procedure SetContext(nsManager: DNXmlNamespaceManager); overload;
    ///<summary>When overridden in a derived class, specifies the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object to use for namespace resolution.</summary>
    ///  <param name="nsResolver">An object that implements the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  interface to use for namespace resolution.</param>
    ///<exception cref="T:System.Xml.XPath.XPathException">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object parameter is not derived from <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  . </exception>
    procedure SetContext(nsResolver: DNIXmlNamespaceResolver); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, gets a <see langword="string" />
    ///  representation of the <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  .</summary>
    ///<returns>A <see langword="string" />
    ///  representation of the <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  .</returns>
    property Expression: string read get_Expression;
    ///<summary>When overridden in a derived class, gets the result type of the XPath expression.</summary>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathResultType" />
    ///  value representing the result type of the XPath expression.</returns>
    property ReturnType: DNXPathResultType read get_ReturnType;
  end;

  TDNXPathExpression = class(TDNGenericImport<DNXPathExpressionClass, DNXPathExpression>) end;

  //-------------namespace: System.Xml.XPath----------------
  DNXPathItemClass = interface(DDN.mscorlib.DNObjectClass)
  ['{690D9F07-5437-59CB-A7C4-9C8A860A77A8}']
  end;

  ///<summary>Represents an item in the XQuery 1.0 and XPath 2.0 Data Model.</summary>
  [DNTypeName('System.Xml.XPath.XPathItem')]
  DNXPathItem = interface(DDN.mscorlib.DNObject)
  ['{A44B4227-A179-337E-8392-7DCF1267E90E}']
  { getters & setters } 

    function get_IsNode: Boolean;
    function get_XmlType: DNXmlSchemaType;
    function get_Value: string;
    function get_TypedValue: DDN.mscorlib.DNObject;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_ValueAsBoolean: Boolean;
    function get_ValueAsDateTime: DDN.mscorlib.DNDateTime;
    function get_ValueAsDouble: Double;
    function get_ValueAsInt: Int32;
    function get_ValueAsLong: Int64;

  { methods } 

    ///<summary>Returns the item's value as the specified type.</summary>
    ///  <param name="returnType">The type to return the item value as.</param>
    ///<returns>The value of the item as the type requested.</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    function ValueAs(returnType: DDN.mscorlib.DNType): DDN.mscorlib.DNObject; overload;
    ///<summary>When overridden in a derived class, returns the item's value as the type specified using the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified to resolve namespace prefixes.</summary>
    ///  <param name="returnType">The type to return the item's value as.</param>
    ///  <param name="nsResolver">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used to resolve namespace prefixes.</param>
    ///<returns>The value of the item as the type requested.</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    function ValueAs(returnType: DDN.mscorlib.DNType; nsResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, gets a value indicating whether the item represents an XPath node or an atomic value.</summary>
    ///<returns><see langword="true" />
    ///  if the item represents an XPath node; <see langword="false" />
    ///  if the item represents an atomic value.</returns>
    property IsNode: Boolean read get_IsNode;
    ///<summary>When overridden in a derived class, gets the <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  for the item.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  for the item.</returns>
    property XmlType: DNXmlSchemaType read get_XmlType;
    ///<summary>When overridden in a derived class, gets the <see langword="string" />
    ///  value of the item.</summary>
    ///<returns>The <see langword="string" />
    ///  value of the item.</returns>
    property Value: string read get_Value;
    ///<summary>When overridden in a derived class, gets the current item as a boxed object of the most appropriate .NET Framework 2.0 type according to its schema type.</summary>
    ///<returns>The current item as a boxed object of the most appropriate .NET Framework type.</returns>
    property TypedValue: DDN.mscorlib.DNObject read get_TypedValue;
    ///<summary>When overridden in a derived class, gets the .NET Framework 2.0 type of the item.</summary>
    ///<returns>The .NET Framework type of the item. The default value is <see cref="T:System.String" />
    ///  .</returns>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    ///<summary>When overridden in a derived class, gets the item's value as a <see cref="T:System.Boolean" />
    ///  .</summary>
    ///<returns>The item's value as a <see cref="T:System.Boolean" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the <see cref="T:System.Boolean" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Boolean" />
    ///  is not valid.</exception>
    property ValueAsBoolean: Boolean read get_ValueAsBoolean;
    ///<summary>When overridden in a derived class, gets the item's value as a <see cref="T:System.DateTime" />
    ///  .</summary>
    ///<returns>The item's value as a <see cref="T:System.DateTime" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the <see cref="T:System.DateTime" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.DateTime" />
    ///  is not valid.</exception>
    property ValueAsDateTime: DDN.mscorlib.DNDateTime read get_ValueAsDateTime;
    ///<summary>When overridden in a derived class, gets the item's value as a <see cref="T:System.Double" />
    ///  .</summary>
    ///<returns>The item's value as a <see cref="T:System.Double" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the <see cref="T:System.Double" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Double" />
    ///  is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    property ValueAsDouble: Double read get_ValueAsDouble;
    ///<summary>When overridden in a derived class, gets the item's value as an <see cref="T:System.Int32" />
    ///  .</summary>
    ///<returns>The item's value as an <see cref="T:System.Int32" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the <see cref="T:System.Int32" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Int32" />
    ///  is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    property ValueAsInt: Int32 read get_ValueAsInt;
    ///<summary>When overridden in a derived class, gets the item's value as an <see cref="T:System.Int64" />
    ///  .</summary>
    ///<returns>The item's value as an <see cref="T:System.Int64" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the <see cref="T:System.Int64" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Int64" />
    ///  is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    property ValueAsLong: Int64 read get_ValueAsLong;
  end;

  TDNXPathItem = class(TDNGenericImport<DNXPathItemClass, DNXPathItem>) end;

  //-------------namespace: System.Xml.Schema----------------
  DNXmlAtomicValueClass = interface(DNXPathItemClass)
  ['{5C156F4B-59C5-5CBC-BC46-1F5637A16EBE}']
  end;

  ///<summary>Represents the typed value of a validated XML element or attribute. The <see cref="T:System.Xml.Schema.XmlAtomicValue" />
  ///  class cannot be inherited.</summary>
  [DNTypeName('System.Xml.Schema.XmlAtomicValue')]
  DNXmlAtomicValue = interface(DNXPathItem)
  ['{18D064C4-771A-3DB5-9B38-A0D84B778768}']
  { getters & setters } 

    function get_IsNode: Boolean;
    function get_XmlType: DNXmlSchemaType;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_TypedValue: DDN.mscorlib.DNObject;
    function get_ValueAsBoolean: Boolean;
    function get_ValueAsDateTime: DDN.mscorlib.DNDateTime;
    function get_ValueAsDouble: Double;
    function get_ValueAsInt: Int32;
    function get_ValueAsLong: Int64;
    function get_Value: string;

  { methods } 

    ///<summary>Returns a copy of this <see cref="T:System.Xml.Schema.XmlAtomicValue" />
    ///  object.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlAtomicValue" />
    ///  object copy of this <see cref="T:System.Xml.Schema.XmlAtomicValue" />
    ///  object.</returns>
    function Clone: DNXmlAtomicValue;
    ///<summary>Returns the validated XML element or attribute's value as the type specified using the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified to resolve namespace prefixes.</summary>
    ///  <param name="type">The type to return the validated XML element or attribute's value as.</param>
    ///  <param name="nsResolver">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used to resolve namespace prefixes.</param>
    ///<returns>The value of the validated XML element or attribute as the type requested.</returns>
    ///<exception cref="T:System.FormatException">The validated XML element or attribute's value is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    function ValueAs(&type: DDN.mscorlib.DNType; nsResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>Gets the <see langword="string" />
    ///  value of the validated XML element or attribute.</summary>
    ///<returns>The <see langword="string" />
    ///  value of the validated XML element or attribute.</returns>
    function ToString: string;
    ///<summary>Returns the item's value as the specified type.</summary>
    ///  <param name="returnType">The type to return the item value as.</param>
    ///<returns>The value of the item as the type requested.</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    function ValueAs(returnType: DDN.mscorlib.DNType): DDN.mscorlib.DNObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a value indicating whether the validated XML element or attribute is an XPath node or an atomic value.</summary>
    ///<returns><see langword="true" />
    ///  if the validated XML element or attribute is an XPath node; <see langword="false" />
    ///  if the validated XML element or attribute is an atomic value.</returns>
    property IsNode: Boolean read get_IsNode;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  for the validated XML element or attribute.</summary>
    ///<returns>The <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  for the validated XML element or attribute.</returns>
    property XmlType: DNXmlSchemaType read get_XmlType;
    ///<summary>Gets the Microsoft .NET Framework type of the validated XML element or attribute.</summary>
    ///<returns>The .NET Framework type of the validated XML element or attribute. The default value is <see cref="T:System.String" />
    ///  .</returns>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    ///<summary>Gets the current validated XML element or attribute as a boxed object of the most appropriate Microsoft .NET Framework type according to its schema type.</summary>
    ///<returns>The current validated XML element or attribute as a boxed object of the most appropriate .NET Framework type.</returns>
    property TypedValue: DDN.mscorlib.DNObject read get_TypedValue;
    ///<summary>Gets the validated XML element or attribute's value as a <see cref="T:System.Boolean" />
    ///  .</summary>
    ///<returns>The validated XML element or attribute's value as a <see cref="T:System.Boolean" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The validated XML element or attribute's value is not in the correct format for the <see cref="T:System.Boolean" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Boolean" />
    ///  is not valid.</exception>
    property ValueAsBoolean: Boolean read get_ValueAsBoolean;
    ///<summary>Gets the validated XML element or attribute's value as a <see cref="T:System.DateTime" />
    ///  .</summary>
    ///<returns>The validated XML element or attribute's value as a <see cref="T:System.DateTime" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The validated XML element or attribute's value is not in the correct format for the <see cref="T:System.DateTime" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.DateTime" />
    ///  is not valid.</exception>
    property ValueAsDateTime: DDN.mscorlib.DNDateTime read get_ValueAsDateTime;
    ///<summary>Gets the validated XML element or attribute's value as a <see cref="T:System.Double" />
    ///  .</summary>
    ///<returns>The validated XML element or attribute's value as a <see cref="T:System.Double" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The validated XML element or attribute's value is not in the correct format for the <see cref="T:System.Double" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Double" />
    ///  is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    property ValueAsDouble: Double read get_ValueAsDouble;
    ///<summary>Gets the validated XML element or attribute's value as an <see cref="T:System.Int32" />
    ///  .</summary>
    ///<returns>The validated XML element or attribute's value as an <see cref="T:System.Int32" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The validated XML element or attribute's value is not in the correct format for the <see cref="T:System.Int32" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Int32" />
    ///  is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    property ValueAsInt: Int32 read get_ValueAsInt;
    ///<summary>Gets the validated XML element or attribute's value as an <see cref="T:System.Int64" />
    ///  .</summary>
    ///<returns>The validated XML element or attribute's value as an <see cref="T:System.Int64" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The validated XML element or attribute's value is not in the correct format for the <see cref="T:System.Int64" />
    ///  type.</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Int64" />
    ///  is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    property ValueAsLong: Int64 read get_ValueAsLong;
    ///<summary>Gets the <see langword="string" />
    ///  value of the validated XML element or attribute.</summary>
    ///<returns>The <see langword="string" />
    ///  value of the validated XML element or attribute.</returns>
    property Value: string read get_Value;
  end;

  TDNXmlAtomicValue = class(TDNGenericImport<DNXmlAtomicValueClass, DNXmlAtomicValue>) end;

  //-------------namespace: System.Xml.XPath----------------
  DNXPathNavigatorClass = interface(DNXPathItemClass)
  ['{ED2BA7FB-0878-504B-988D-16D04F1775E3}']
  { static getter & setter } 

    {class} function get_NavigatorComparer: DDN.mscorlib.DNIEqualityComparer;

  { static propertys } 

    ///<summary>Gets an <see cref="T:System.Collections.IEqualityComparer" />
    ///  used for equality comparison of <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  objects.</summary>
    ///<returns>An <see cref="T:System.Collections.IEqualityComparer" />
    ///  used for equality comparison of <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  objects.</returns>
    {class} property NavigatorComparer: DDN.mscorlib.DNIEqualityComparer read get_NavigatorComparer;
  end;

  ///<summary>Provides a cursor model for navigating and editing XML data.</summary>
  [DNTypeName('System.Xml.XPath.XPathNavigator')]
  DNXPathNavigator = interface(DNXPathItem)
  ['{BE86B874-6C3C-3FC2-A6B3-4DA73CA20540}']
  { getters & setters } 

    function get_IsNode: Boolean;
    function get_XmlType: DNXmlSchemaType;
    function get_TypedValue: DDN.mscorlib.DNObject;
    function get_ValueType: DDN.mscorlib.DNType;
    function get_ValueAsBoolean: Boolean;
    function get_ValueAsDateTime: DDN.mscorlib.DNDateTime;
    function get_ValueAsDouble: Double;
    function get_ValueAsInt: Int32;
    function get_ValueAsLong: Int64;
    function get_NameTable: DNXmlNameTable;
    function get_NodeType: DNXPathNodeType;
    function get_LocalName: string;
    function get_Name: string;
    function get_NamespaceURI: string;
    function get_Prefix: string;
    function get_BaseURI: string;
    function get_IsEmptyElement: Boolean;
    function get_XmlLang: string;
    function get_UnderlyingObject: DDN.mscorlib.DNObject;
    function get_HasAttributes: Boolean;
    function get_HasChildren: Boolean;
    function get_SchemaInfo: DNIXmlSchemaInfo;
    function get_CanEdit: Boolean;
    function get_OuterXml: string;
    procedure set_OuterXml(value: string);
    function get_InnerXml: string;
    procedure set_InnerXml(value: string);
    function get_Value: string;

  { methods } 

    ///<summary>Gets the text value of the current node.</summary>
    ///<returns>A <see langword="string" />
    ///  that contains the text value of the current node.</returns>
    function ToString: string;
    ///<summary>Sets the value of the current node.</summary>
    ///  <param name="value">The new value of the node.</param>
    ///<exception cref="T:System.ArgumentNullException">The value parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on the root node, a namespace node, or the specified value is invalid.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure SetValue(value: string);
    ///<summary>Sets the typed value of the current node.</summary>
    ///  <param name="typedValue">The new typed value of the node.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support the type of the object specified.</exception><exception cref="T:System.ArgumentNullException">The value specified cannot be <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element or attribute node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure SetTypedValue(typedValue: DDN.mscorlib.DNObject);
    ///<summary>Gets the current node's value as the <see cref="T:System.Type" />
    ///  specified, using the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified to resolve namespace prefixes.</summary>
    ///  <param name="returnType">The <see cref="T:System.Type" />
    ///  to return the current node's value as.</param>
    ///  <param name="nsResolver">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used to resolve namespace prefixes.</param>
    ///<returns>The value of the current node as the <see cref="T:System.Type" />
    ///  requested.</returns>
    ///<exception cref="T:System.FormatException">The current node's value is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception>
    function ValueAs(returnType: DDN.mscorlib.DNType; nsResolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>Returns a copy of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  copy of this <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</returns>
    function CreateNavigator: DNXPathNavigator;
    ///<summary>Returns an <see cref="T:System.Xml.XmlReader" />
    ///  object that contains the current node and its child nodes.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  object that contains the current node and its child nodes.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node or the root node.</exception>
    function ReadSubtree: DNXmlReader;
    ///<summary>Streams the current node and its child nodes to the <see cref="T:System.Xml.XmlWriter" />
    ///  object specified.</summary>
    ///  <param name="writer">The <see cref="T:System.Xml.XmlWriter" />
    ///  object to stream to.</param>
    procedure WriteSubtree(writer: DNXmlWriter);
    ///<summary>Gets the value of the attribute with the specified local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute. <paramref name="localName" />
    ///  is case-sensitive.</param>
    ///  <param name="namespaceURI">The namespace URI of the attribute.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the value of the specified attribute; <see cref="F:System.String.Empty" />
    ///  if a matching attribute is not found, or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node.</returns>
    function GetAttribute(localName: string; namespaceURI: string): string;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the attribute with the matching local name and namespace URI.</summary>
    ///  <param name="localName">The local name of the attribute.</param>
    ///  <param name="namespaceURI">The namespace URI of the attribute; <see langword="null" />
    ///  for an empty namespace.</param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the attribute; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToAttribute(localName: string; namespaceURI: string): Boolean;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the namespace node with the specified namespace prefix.</summary>
    ///  <param name="name">The namespace prefix of the namespace node.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the specified namespace; <see langword="false" />
    ///  if a matching namespace node was not found, or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node. If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNamespace(name: string): Boolean;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to first namespace node of the current node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the first namespace node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToFirstNamespace: Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the next namespace node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the next namespace node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNextNamespace: Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the first sibling node of the current node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the first sibling node of the current node; <see langword="false" />
    ///  if there is no first sibling, or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is currently positioned on an attribute node. If the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is already positioned on the first sibling, <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  will return <see langword="true" />
    ///  and will not move its position.If <see cref="M:System.Xml.XPath.XPathNavigator.MoveToFirst" />
    ///  returns <see langword="false" />
    ///  because there is no first sibling, or if <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is currently positioned on an attribute, the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToFirst: Boolean;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the root node that the current node belongs to.</summary>
    procedure MoveToRoot;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the child node with the local name and namespace URI specified.</summary>
    ///  <param name="localName">The local name of the child node to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the child node to move to.</param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the child node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToChild(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the child node of the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  specified.</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the child node to move to.</param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the child node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToChild(&type: DNXPathNodeType): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the element with the local name and namespace URI specified in document order.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  moved successfully; otherwise <see langword="false" />
    ///  .</returns>
    function MoveToFollowing(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the element with the local name and namespace URI specified, to the boundary specified, in document order.</summary>
    ///  <param name="localName">The local name of the element.</param>
    ///  <param name="namespaceURI">The namespace URI of the element.</param>
    ///  <param name="end">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the element boundary which the current <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  will not move past while searching for the following element.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  moved successfully; otherwise <see langword="false" />
    ///  .</returns>
    function MoveToFollowing(localName: string; namespaceURI: string; &end: DNXPathNavigator): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the following element of the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  specified in document order.</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the element. The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  cannot be <see cref="F:System.Xml.XPath.XPathNodeType.Attribute" />
    ///  or <see cref="F:System.Xml.XPath.XPathNodeType.Namespace" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  moved successfully; otherwise <see langword="false" />
    ///  .</returns>
    function MoveToFollowing(&type: DNXPathNodeType): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the following element of the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  specified, to the boundary specified, in document order.</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the element. The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  cannot be <see cref="F:System.Xml.XPath.XPathNodeType.Attribute" />
    ///  or <see cref="F:System.Xml.XPath.XPathNodeType.Namespace" />
    ///  .</param>
    ///  <param name="end">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the element boundary which the current <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  will not move past while searching for the following element.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  moved successfully; otherwise <see langword="false" />
    ///  .</returns>
    function MoveToFollowing(&type: DNXPathNodeType; &end: DNXPathNavigator): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the next sibling node with the local name and namespace URI specified.</summary>
    ///  <param name="localName">The local name of the next sibling node to move to.</param>
    ///  <param name="namespaceURI">The namespace URI of the next sibling node to move to.</param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the next sibling node; <see langword="false" />
    ///  if there are no more siblings, or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is currently positioned on an attribute node. If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNext(localName: string; namespaceURI: string): Boolean; overload;
    ///<summary>Moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the next sibling node of the current node that matches the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  specified.</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the sibling node to move to.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the next sibling node; otherwise, <see langword="false" />
    ///  if there are no more siblings or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is currently positioned on an attribute node. If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNext(&type: DNXPathNodeType): Boolean; overload;
    ///<summary>Determines whether the specified <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is a descendant of the current <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///  <param name="nav">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to compare to this <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the specified <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is a descendant of the current <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    function IsDescendant(nav: DNXPathNavigator): Boolean;
    ///<summary>Compiles a string representing an XPath expression and returns an <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object.</summary>
    ///  <param name="xpath">A string representing an XPath expression.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object representing the XPath expression.</returns>
    ///<exception cref="T:System.ArgumentException">The <paramref name="xpath" />
    ///  parameter contains an XPath expression that is not valid.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Compile(xpath: string): DNXPathExpression;
    ///<summary>Selects a single node in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified XPath query.</summary>
    ///  <param name="xpath">A <see cref="T:System.String" />
    ///  representing an XPath expression.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object that contains the first matching node for the XPath query specified; otherwise, <see langword="null" />
    ///  if there are no query results.</returns>
    ///<exception cref="T:System.ArgumentException">An error was encountered in the XPath query or the return type of the XPath expression is not a node.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath query is not valid.</exception>
    function SelectSingleNode(xpath: string): DNXPathNavigator; overload;
    ///<summary>Selects a single node in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object using the specified XPath query with the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified to resolve namespace prefixes.</summary>
    ///  <param name="xpath">A <see cref="T:System.String" />
    ///  representing an XPath expression.</param>
    ///  <param name="resolver">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used to resolve namespace prefixes in the XPath query.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object that contains the first matching node for the XPath query specified; otherwise <see langword="null" />
    ///  if there are no query results.</returns>
    ///<exception cref="T:System.ArgumentException">An error was encountered in the XPath query or the return type of the XPath expression is not a node.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath query is not valid.</exception>
    function SelectSingleNode(xpath: string; resolver: DNIXmlNamespaceResolver): DNXPathNavigator; overload;
    ///<summary>Selects a single node in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object.</summary>
    ///  <param name="expression">An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object containing the compiled XPath query.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object that contains the first matching node for the XPath query specified; otherwise <see langword="null" />
    ///  if there are no query results.</returns>
    ///<exception cref="T:System.ArgumentException">An error was encountered in the XPath query or the return type of the XPath expression is not a node.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath query is not valid.</exception>
    function SelectSingleNode(expression: DNXPathExpression): DNXPathNavigator; overload;
    ///<summary>Selects a node set, using the specified XPath expression.</summary>
    ///  <param name="xpath">A <see cref="T:System.String" />
    ///  representing an XPath expression.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  pointing to the selected node set.</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression contains an error or its return type is not a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Select(xpath: string): DNXPathNodeIterator; overload;
    ///<summary>Selects a node set using the specified XPath expression with the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified to resolve namespace prefixes.</summary>
    ///  <param name="xpath">A <see cref="T:System.String" />
    ///  representing an XPath expression.</param>
    ///  <param name="resolver">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used to resolve namespace prefixes.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that points to the selected node set.</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression contains an error or its return type is not a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Select(xpath: string; resolver: DNIXmlNamespaceResolver): DNXPathNodeIterator; overload;
    ///<summary>Selects a node set using the specified <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  .</summary>
    ///  <param name="expr">An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object containing the compiled XPath query.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that points to the selected node set.</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression contains an error or its return type is not a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Select(expr: DNXPathExpression): DNXPathNodeIterator; overload;
    ///<summary>Evaluates the specified XPath expression and returns the typed result.</summary>
    ///  <param name="xpath">A string representing an XPath expression that can be evaluated.</param>
    ///<returns>The result of the expression (Boolean, number, string, or node set). This maps to <see cref="T:System.Boolean" />
    ///  , <see cref="T:System.Double" />
    ///  , <see cref="T:System.String" />
    ///  , or <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  objects respectively.</returns>
    ///<exception cref="T:System.ArgumentException">The return type of the XPath expression is a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Evaluate(xpath: string): DDN.mscorlib.DNObject; overload;
    ///<summary>Evaluates the specified XPath expression and returns the typed result, using the <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object specified to resolve namespace prefixes in the XPath expression.</summary>
    ///  <param name="xpath">A string representing an XPath expression that can be evaluated.</param>
    ///  <param name="resolver">The <see cref="T:System.Xml.IXmlNamespaceResolver" />
    ///  object used to resolve namespace prefixes in the XPath expression.</param>
    ///<returns>The result of the expression (Boolean, number, string, or node set). This maps to <see cref="T:System.Boolean" />
    ///  , <see cref="T:System.Double" />
    ///  , <see cref="T:System.String" />
    ///  , or <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  objects respectively.</returns>
    ///<exception cref="T:System.ArgumentException">The return type of the XPath expression is a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Evaluate(xpath: string; resolver: DNIXmlNamespaceResolver): DDN.mscorlib.DNObject; overload;
    ///<summary>Evaluates the <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  and returns the typed result.</summary>
    ///  <param name="expr">An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  that can be evaluated.</param>
    ///<returns>The result of the expression (Boolean, number, string, or node set). This maps to <see cref="T:System.Boolean" />
    ///  , <see cref="T:System.Double" />
    ///  , <see cref="T:System.String" />
    ///  , or <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  objects respectively.</returns>
    ///<exception cref="T:System.ArgumentException">The return type of the XPath expression is a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Evaluate(expr: DNXPathExpression): DDN.mscorlib.DNObject; overload;
    ///<summary>Uses the supplied context to evaluate the <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  , and returns the typed result.</summary>
    ///  <param name="expr">An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  that can be evaluated.</param>
    ///  <param name="context">An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that points to the selected node set that the evaluation is to be performed on.</param>
    ///<returns>The result of the expression (Boolean, number, string, or node set). This maps to <see cref="T:System.Boolean" />
    ///  , <see cref="T:System.Double" />
    ///  , <see cref="T:System.String" />
    ///  , or <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  objects respectively.</returns>
    ///<exception cref="T:System.ArgumentException">The return type of the XPath expression is a node set.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Evaluate(expr: DNXPathExpression; context: DNXPathNodeIterator): DDN.mscorlib.DNObject; overload;
    ///<summary>Determines whether the current node matches the specified <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  .</summary>
    ///  <param name="expr">An <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  object containing the compiled XPath expression.</param>
    ///<returns><see langword="true" />
    ///  if the current node matches the <see cref="T:System.Xml.XPath.XPathExpression" />
    ///  ; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression cannot be evaluated.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Matches(expr: DNXPathExpression): Boolean; overload;
    ///<summary>Determines whether the current node matches the specified XPath expression.</summary>
    ///  <param name="xpath">The XPath expression.</param>
    ///<returns><see langword="true" />
    ///  if the current node matches the specified XPath expression; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.ArgumentException">The XPath expression cannot be evaluated.</exception><exception cref="T:System.Xml.XPath.XPathException">The XPath expression is not valid.</exception>
    function Matches(xpath: string): Boolean; overload;
    ///<summary>Selects all the child nodes of the current node that have the matching <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  .</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the child nodes.</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that contains the selected nodes.</returns>
    function SelectChildren(&type: DNXPathNodeType): DNXPathNodeIterator; overload;
    ///<summary>Selects all the child nodes of the current node that have the local name and namespace URI specified.</summary>
    ///  <param name="name">The local name of the child nodes. </param>
    ///  <param name="namespaceURI">The namespace URI of the child nodes. </param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that contains the selected nodes.</returns>
    ///<exception cref="T:System.ArgumentNullException"><see langword="null" />
    ///  cannot be passed as a parameter.</exception>
    function SelectChildren(name: string; namespaceURI: string): DNXPathNodeIterator; overload;
    ///<summary>Selects all the ancestor nodes of the current node that have a matching <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  .</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the ancestor nodes.</param>
    ///  <param name="matchSelf">To include the context node in the selection, <see langword="true" />
    ///  ; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that contains the selected nodes. The returned nodes are in reverse document order.</returns>
    function SelectAncestors(&type: DNXPathNodeType; matchSelf: Boolean): DNXPathNodeIterator; overload;
    ///<summary>Selects all the ancestor nodes of the current node that have the specified local name and namespace URI.</summary>
    ///  <param name="name">The local name of the ancestor nodes.</param>
    ///  <param name="namespaceURI">The namespace URI of the ancestor nodes.</param>
    ///  <param name="matchSelf">To include the context node in the selection, <see langword="true" />
    ///  ; otherwise, <see langword="false" />
    ///  . </param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that contains the selected nodes. The returned nodes are in reverse document order.</returns>
    ///<exception cref="T:System.ArgumentNullException"><see langword="null" />
    ///  cannot be passed as a parameter.</exception>
    function SelectAncestors(name: string; namespaceURI: string; matchSelf: Boolean): DNXPathNodeIterator; overload;
    ///<summary>Selects all the descendant nodes of the current node that have a matching <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  .</summary>
    ///  <param name="type">The <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the descendant nodes.</param>
    ///  <param name="matchSelf"><see langword="true" />
    ///  to include the context node in the selection; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that contains the selected nodes.</returns>
    function SelectDescendants(&type: DNXPathNodeType; matchSelf: Boolean): DNXPathNodeIterator; overload;
    ///<summary>Selects all the descendant nodes of the current node with the local name and namespace URI specified.</summary>
    ///  <param name="name">The local name of the descendant nodes. </param>
    ///  <param name="namespaceURI">The namespace URI of the descendant nodes. </param>
    ///  <param name="matchSelf"><see langword="true" />
    ///  to include the context node in the selection; otherwise, <see langword="false" />
    ///  .</param>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  that contains the selected nodes.</returns>
    ///<exception cref="T:System.ArgumentNullException"><see langword="null" />
    ///  cannot be passed as a parameter.</exception>
    function SelectDescendants(name: string; namespaceURI: string; matchSelf: Boolean): DNXPathNodeIterator; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create a new child node at the beginning of the list of child nodes of the current node.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create a new child node at the beginning of the list of child nodes of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on does not allow a new child node to be prepended.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    function PrependChild: DNXmlWriter; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create one or more new child nodes at the end of the list of child nodes of the current node. </summary>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create new child nodes at the end of the list of child nodes of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on is not the root node or an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    function AppendChild: DNXmlWriter; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create a new sibling node after the currently selected node.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create a new sibling node after the currently selected node.</returns>
    ///<exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted after the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    function InsertAfter: DNXmlWriter; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create a new sibling node before the currently selected node.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create a new sibling node before the currently selected node.</returns>
    ///<exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted before the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    function InsertBefore: DNXmlWriter; overload;
    ///<summary>Returns an <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create new attributes on the current element.</summary>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object used to create new attributes on the current element.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    function CreateAttributes: DNXmlWriter;
    ///<summary>Replaces a range of sibling nodes from the current node to the node specified.</summary>
    ///  <param name="lastSiblingToReplace">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  positioned on the last sibling node in the range to replace.</param>
    ///<returns>An <see cref="T:System.Xml.XmlWriter" />
    ///  object used to specify the replacement range.</returns>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  specified is <see langword="null" />
    ///  .</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.InvalidOperationException">The last node to replace specified is not a valid sibling node of the current node.</exception>
    function ReplaceRange(lastSiblingToReplace: DNXPathNavigator): DNXmlWriter;
    ///<summary>Replaces the current node with the content of the string specified.</summary>
    ///  <param name="newNode">The XML data string for the new node.</param>
    ///<exception cref="T:System.ArgumentNullException">The XML string parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element, text, processing instruction, or comment node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML string parameter is not well-formed.</exception>
    procedure ReplaceSelf(newNode: string); overload;
    ///<summary>Replaces the current node with the contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object specified.</summary>
    ///  <param name="newNode">An <see cref="T:System.Xml.XmlReader" />
    ///  object positioned on the XML data for the new node.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is in an error state or closed.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element, text, processing instruction, or comment node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is not well-formed.</exception>
    procedure ReplaceSelf(newNode: DNXmlReader); overload;
    ///<summary>Replaces the current node with the contents of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object specified.</summary>
    ///  <param name="newNode">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the new node.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element, text, processing instruction, or comment node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML contents of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object parameter is not well-formed.</exception>
    procedure ReplaceSelf(newNode: DNXPathNavigator); overload;
    ///<summary>Creates a new child node at the end of the list of child nodes of the current node using the XML data string specified.</summary>
    ///  <param name="newChild">The XML data string for the new child node.</param>
    ///<exception cref="T:System.ArgumentNullException">The XML data string parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on is not the root node or an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML data string parameter is not well-formed.</exception>
    procedure AppendChild(newChild: string); overload;
    ///<summary>Creates a new child node at the end of the list of child nodes of the current node using the XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object specified.</summary>
    ///  <param name="newChild">An <see cref="T:System.Xml.XmlReader" />
    ///  object positioned on the XML data for the new child node.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is in an error state or closed.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on is not the root node or an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is not well-formed.</exception>
    procedure AppendChild(newChild: DNXmlReader); overload;
    ///<summary>Creates a new child node at the end of the list of child nodes of the current node using the nodes in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  specified.</summary>
    ///  <param name="newChild">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the node to add as the new child node.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on is not the root node or an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure AppendChild(newChild: DNXPathNavigator); overload;
    ///<summary>Creates a new child node at the beginning of the list of child nodes of the current node using the XML string specified.</summary>
    ///  <param name="newChild">The XML data string for the new child node.</param>
    ///<exception cref="T:System.ArgumentNullException">The XML string parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on does not allow a new child node to be prepended.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML string parameter is not well-formed.</exception>
    procedure PrependChild(newChild: string); overload;
    ///<summary>Creates a new child node at the beginning of the list of child nodes of the current node using the XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object specified.</summary>
    ///  <param name="newChild">An <see cref="T:System.Xml.XmlReader" />
    ///  object positioned on the XML data for the new child node.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is in an error state or closed.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on does not allow a new child node to be prepended.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is not well-formed.</exception>
    procedure PrependChild(newChild: DNXmlReader); overload;
    ///<summary>Creates a new child node at the beginning of the list of child nodes of the current node using the nodes in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object specified.</summary>
    ///  <param name="newChild">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the node to add as the new child node.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on does not allow a new child node to be prepended.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure PrependChild(newChild: DNXPathNavigator); overload;
    ///<summary>Creates a new sibling node before the currently selected node using the XML string specified.</summary>
    ///  <param name="newSibling">The XML data string for the new sibling node.</param>
    ///<exception cref="T:System.ArgumentNullException">The XML string parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted before the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML string parameter is not well-formed.</exception>
    procedure InsertBefore(newSibling: string); overload;
    ///<summary>Creates a new sibling node before the currently selected node using the XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object specified.</summary>
    ///  <param name="newSibling">An <see cref="T:System.Xml.XmlReader" />
    ///  object positioned on the XML data for the new sibling node.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is in an error state or closed.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted before the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is not well-formed.</exception>
    procedure InsertBefore(newSibling: DNXmlReader); overload;
    ///<summary>Creates a new sibling node before the currently selected node using the nodes in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  specified.</summary>
    ///  <param name="newSibling">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the node to add as the new sibling node.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted before the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure InsertBefore(newSibling: DNXPathNavigator); overload;
    ///<summary>Creates a new sibling node after the currently selected node using the XML string specified.</summary>
    ///  <param name="newSibling">The XML data string for the new sibling node.</param>
    ///<exception cref="T:System.ArgumentNullException">The XML string parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted after the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML string parameter is not well-formed.</exception>
    procedure InsertAfter(newSibling: string); overload;
    ///<summary>Creates a new sibling node after the currently selected node using the XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object specified.</summary>
    ///  <param name="newSibling">An <see cref="T:System.Xml.XmlReader" />
    ///  object positioned on the XML data for the new sibling node.</param>
    ///<exception cref="T:System.ArgumentException">The <see cref="T:System.Xml.XmlReader" />
    ///  object is in an error state or closed.</exception><exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted after the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.Xml.XmlException">The XML contents of the <see cref="T:System.Xml.XmlReader" />
    ///  object parameter is not well-formed.</exception>
    procedure InsertAfter(newSibling: DNXmlReader); overload;
    ///<summary>Creates a new sibling node after the currently selected node using the nodes in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object specified.</summary>
    ///  <param name="newSibling">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the node to add as the new sibling node.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object parameter is <see langword="null" />
    ///  .</exception><exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted after the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure InsertAfter(newSibling: DNXPathNavigator); overload;
    ///<summary>Deletes a range of sibling nodes from the current node to the node specified.</summary>
    ///  <param name="lastSiblingToDelete">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  positioned on the last sibling node in the range to delete.</param>
    ///<exception cref="T:System.ArgumentNullException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  specified is <see langword="null" />
    ///  .</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception><exception cref="T:System.InvalidOperationException">The last node to delete specified is not a valid sibling node of the current node.</exception>
    procedure DeleteRange(lastSiblingToDelete: DNXPathNavigator);
    ///<summary>Deletes the current node and its child nodes.</summary>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on a node that cannot be deleted such as the root node or a namespace node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure DeleteSelf;
    ///<summary>Creates a new child element at the beginning of the list of child nodes of the current node using the namespace prefix, local name, and namespace URI specified with the value specified.</summary>
    ///  <param name="prefix">The namespace prefix of the new child element (if any).</param>
    ///  <param name="localName">The local name of the new child element (if any).</param>
    ///  <param name="namespaceURI">The namespace URI of the new child element (if any). <see cref="F:System.String.Empty" />
    ///  and <see langword="null" />
    ///  are equivalent.</param>
    ///  <param name="value">The value of the new child element. If <see cref="F:System.String.Empty" />
    ///  or <see langword="null" />
    ///  are passed, an empty element is created.</param>
    ///<exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on does not allow a new child node to be prepended.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure PrependChildElement(prefix: string; localName: string; namespaceURI: string; value: string);
    ///<summary>Creates a new child element node at the end of the list of child nodes of the current node using the namespace prefix, local name and namespace URI specified with the value specified.</summary>
    ///  <param name="prefix">The namespace prefix of the new child element node (if any).</param>
    ///  <param name="localName">The local name of the new child element node (if any).</param>
    ///  <param name="namespaceURI">The namespace URI of the new child element node (if any). <see cref="F:System.String.Empty" />
    ///  and <see langword="null" />
    ///  are equivalent.</param>
    ///  <param name="value">The value of the new child element node. If <see cref="F:System.String.Empty" />
    ///  or <see langword="null" />
    ///  are passed, an empty element is created.</param>
    ///<exception cref="T:System.InvalidOperationException">The current node the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on is not the root node or an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure AppendChildElement(prefix: string; localName: string; namespaceURI: string; value: string);
    ///<summary>Creates a new sibling element before the current node using the namespace prefix, local name, and namespace URI specified, with the value specified.</summary>
    ///  <param name="prefix">The namespace prefix of the new child element (if any).</param>
    ///  <param name="localName">The local name of the new child element (if any).</param>
    ///  <param name="namespaceURI">The namespace URI of the new child element (if any). <see cref="F:System.String.Empty" />
    ///  and <see langword="null" />
    ///  are equivalent.</param>
    ///  <param name="value">The value of the new child element. If <see cref="F:System.String.Empty" />
    ///  or <see langword="null" />
    ///  are passed, an empty element is created.</param>
    ///<exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted before the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure InsertElementBefore(prefix: string; localName: string; namespaceURI: string; value: string);
    ///<summary>Creates a new sibling element after the current node using the namespace prefix, local name and namespace URI specified, with the value specified.</summary>
    ///  <param name="prefix">The namespace prefix of the new child element (if any).</param>
    ///  <param name="localName">The local name of the new child element (if any).</param>
    ///  <param name="namespaceURI">The namespace URI of the new child element (if any). <see cref="F:System.String.Empty" />
    ///  and <see langword="null" />
    ///  are equivalent.</param>
    ///  <param name="value">The value of the new child element. If <see cref="F:System.String.Empty" />
    ///  or <see langword="null" />
    ///  are passed, an empty element is created.</param>
    ///<exception cref="T:System.InvalidOperationException">The position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not allow a new sibling node to be inserted after the current node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure InsertElementAfter(prefix: string; localName: string; namespaceURI: string; value: string);
    ///<summary>Creates an attribute node on the current element node using the namespace prefix, local name and namespace URI specified with the value specified.</summary>
    ///  <param name="prefix">The namespace prefix of the new attribute node (if any).</param>
    ///  <param name="localName">The local name of the new attribute node which cannot <see cref="F:System.String.Empty" />
    ///  or <see langword="null" />
    ///  .</param>
    ///  <param name="namespaceURI">The namespace URI for the new attribute node (if any).</param>
    ///  <param name="value">The value of the new attribute node. If <see cref="F:System.String.Empty" />
    ///  or <see langword="null" />
    ///  are passed, an empty attribute node is created.</param>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node.</exception><exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  does not support editing.</exception>
    procedure CreateAttribute(prefix: string; localName: string; namespaceURI: string; value: string);
    ///<summary>Gets the namespace URI for the specified prefix.</summary>
    ///  <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass <see cref="F:System.String.Empty" />
    ///  .</param>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the namespace URI assigned to the namespace prefix specified; <see langword="null" />
    ///  if no namespace URI is assigned to the prefix specified. The <see cref="T:System.String" />
    ///  returned is atomized.</returns>
    function LookupNamespace(prefix: string): string;
    ///<summary>Gets the prefix declared for the specified namespace URI.</summary>
    ///  <param name="namespaceURI">The namespace URI to resolve for the prefix.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the namespace prefix assigned to the namespace URI specified; otherwise, <see cref="F:System.String.Empty" />
    ///  if no prefix is assigned to the namespace URI specified. The <see cref="T:System.String" />
    ///  returned is atomized.</returns>
    function LookupPrefix(namespaceURI: string): string;
    ///<summary>Returns the in-scope namespaces of the current node.</summary>
    ///  <param name="scope">An <see cref="T:System.Xml.XmlNamespaceScope" />
    ///  value specifying the namespaces to return.</param>
    ///<returns>An <see cref="T:System.Collections.Generic.IDictionary`2" />
    ///  collection of namespace names keyed by prefix.</returns>
    function GetNamespacesInScope(scope: DNXmlNamespaceScope): DDN.mscorlib.DNIDictionary<string, string>;
    ///<summary>When overridden in a derived class, creates a new <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  positioned at the same node as this <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///<returns>A new <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  positioned at the same node as this <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</returns>
    function Clone: DNXPathNavigator;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the first attribute of the current node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the first attribute of the current node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToFirstAttribute: Boolean;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the next attribute.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the next attribute; <see langword="false" />
    ///  if there are no more attributes. If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNextAttribute: Boolean;
    ///<summary>Returns the value of the namespace node corresponding to the specified local name.</summary>
    ///  <param name="name">The local name of the namespace node.</param>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the value of the namespace node; <see cref="F:System.String.Empty" />
    ///  if a matching namespace node is not found, or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node.</returns>
    function GetNamespace(name: string): string;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the first namespace node that matches the <see cref="T:System.Xml.XPath.XPathNamespaceScope" />
    ///  specified.</summary>
    ///  <param name="namespaceScope">An <see cref="T:System.Xml.XPath.XPathNamespaceScope" />
    ///  value describing the namespace scope. </param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the first namespace node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToFirstNamespace(namespaceScope: DNXPathNamespaceScope): Boolean; overload;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the next namespace node matching the <see cref="T:System.Xml.XPath.XPathNamespaceScope" />
    ///  specified.</summary>
    ///  <param name="namespaceScope">An <see cref="T:System.Xml.XPath.XPathNamespaceScope" />
    ///  value describing the namespace scope. </param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the next namespace node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNextNamespace(namespaceScope: DNXPathNamespaceScope): Boolean; overload;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the next sibling node of the current node.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the next sibling node; otherwise, <see langword="false" />
    ///  if there are no more siblings or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is currently positioned on an attribute node. If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToNext: Boolean; overload;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the previous sibling node of the current node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the previous sibling node; otherwise, <see langword="false" />
    ///  if there is no previous sibling node or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is currently positioned on an attribute node. If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToPrevious: Boolean;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the first child node of the current node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the first child node of the current node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToFirstChild: Boolean;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the parent node of the current node.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the parent node of the current node; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveToParent: Boolean;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to the same position as the specified <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///  <param name="other">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  positioned on the node that you want to move to. </param>
    ///<returns>Returns <see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving to the same position as the specified <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  ; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is unchanged.</returns>
    function MoveTo(other: DNXPathNavigator): Boolean;
    ///<summary>When overridden in a derived class, moves to the node that has an attribute of type ID whose value matches the specified <see cref="T:System.String" />
    ///  .</summary>
    ///  <param name="id">A <see cref="T:System.String" />
    ///  representing the ID value of the node to which you want to move.</param>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is successful moving; otherwise, <see langword="false" />
    ///  . If <see langword="false" />
    ///  , the position of the navigator is unchanged.</returns>
    function MoveToId(id: string): Boolean;
    ///<summary>When overridden in a derived class, determines whether the current <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is at the same position as the specified <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///  <param name="other">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to compare to this <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</param>
    ///<returns><see langword="true" />
    ///  if the two <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  objects have the same position; otherwise, <see langword="false" />
    ///  .</returns>
    function IsSamePosition(other: DNXPathNavigator): Boolean;
    ///<summary>Compares the position of the current <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  with the position of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  specified.</summary>
    ///  <param name="nav">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  to compare against.</param>
    ///<returns>An <see cref="T:System.Xml.XmlNodeOrder" />
    ///  value representing the comparative position of the two <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  objects.</returns>
    function ComparePosition(nav: DNXPathNavigator): DNXmlNodeOrder;
    ///<summary>Verifies that the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  conforms to the XML Schema definition language (XSD) schema provided.</summary>
    ///  <param name="schemas">The <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  containing the schemas used to validate the XML data contained in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</param>
    ///  <param name="validationEventHandler">The <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  that receives information about schema validation warnings and errors.</param>
    ///<returns><see langword="true" />
    ///  if no schema validation errors occurred; otherwise, <see langword="false" />
    ///  .</returns>
    ///<exception cref="T:System.Xml.Schema.XmlSchemaValidationException">A schema validation error occurred, and no <see cref="T:System.Xml.Schema.ValidationEventHandler" />
    ///  was specified to handle validation errors.</exception><exception cref="T:System.InvalidOperationException">The <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is positioned on a node that is not an element, attribute, or the root node or there is not type information to perform validation.</exception><exception cref="T:System.ArgumentException">The <see cref="M:System.Xml.XPath.XPathNavigator.CheckValidity(System.Xml.Schema.XmlSchemaSet,System.Xml.Schema.ValidationEventHandler)" />
    ///  method was called with an <see cref="T:System.Xml.Schema.XmlSchemaSet" />
    ///  parameter when the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  was not positioned on the root node of the XML data.</exception>
    function CheckValidity(schemas: DNXmlSchemaSet; validationEventHandler: DNValidationEventHandler): Boolean;
    ///<summary>Returns the item's value as the specified type.</summary>
    ///  <param name="returnType">The type to return the item value as.</param>
    ///<returns>The value of the item as the type requested.</returns>
    ///<exception cref="T:System.FormatException">The item's value is not in the correct format for the target type.</exception><exception cref="T:System.InvalidCastException">The attempted cast is not valid.</exception><exception cref="T:System.OverflowException">The attempted cast resulted in an overflow.</exception>
    function ValueAs(returnType: DDN.mscorlib.DNType): DDN.mscorlib.DNObject; overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;

  { propertys } 

    ///<summary>Gets a value indicating if the current node represents an XPath node.</summary>
    ///<returns>Always returns <see langword="true" />
    ///  .</returns>
    property IsNode: Boolean read get_IsNode;
    ///<summary>Gets the <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  information for the current node.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.XmlSchemaType" />
    ///  object; default is <see langword="null" />
    ///  .</returns>
    property XmlType: DNXmlSchemaType read get_XmlType;
    ///<summary>Gets the current node as a boxed object of the most appropriate .NET Framework type.</summary>
    ///<returns>The current node as a boxed object of the most appropriate .NET Framework type.</returns>
    property TypedValue: DDN.mscorlib.DNObject read get_TypedValue;
    ///<summary>Gets the .NET Framework <see cref="T:System.Type" />
    ///  of the current node.</summary>
    ///<returns>The .NET Framework <see cref="T:System.Type" />
    ///  of the current node. The default value is <see cref="T:System.String" />
    ///  .</returns>
    property ValueType: DDN.mscorlib.DNType read get_ValueType;
    ///<summary>Gets the current node's value as a <see cref="T:System.Boolean" />
    ///  .</summary>
    ///<returns>The current node's value as a <see cref="T:System.Boolean" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The current node's string value cannot be converted to a <see cref="T:System.Boolean" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Boolean" />
    ///  is not valid.</exception>
    property ValueAsBoolean: Boolean read get_ValueAsBoolean;
    ///<summary>Gets the current node's value as a <see cref="T:System.DateTime" />
    ///  .</summary>
    ///<returns>The current node's value as a <see cref="T:System.DateTime" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The current node's string value cannot be converted to a <see cref="T:System.DateTime" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.DateTime" />
    ///  is not valid.</exception>
    property ValueAsDateTime: DDN.mscorlib.DNDateTime read get_ValueAsDateTime;
    ///<summary>Gets the current node's value as a <see cref="T:System.Double" />
    ///  .</summary>
    ///<returns>The current node's value as a <see cref="T:System.Double" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The current node's string value cannot be converted to a <see cref="T:System.Double" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Double" />
    ///  is not valid.</exception>
    property ValueAsDouble: Double read get_ValueAsDouble;
    ///<summary>Gets the current node's value as an <see cref="T:System.Int32" />
    ///  .</summary>
    ///<returns>The current node's value as an <see cref="T:System.Int32" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The current node's string value cannot be converted to a <see cref="T:System.Int32" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Int32" />
    ///  is not valid.</exception>
    property ValueAsInt: Int32 read get_ValueAsInt;
    ///<summary>Gets the current node's value as an <see cref="T:System.Int64" />
    ///  .</summary>
    ///<returns>The current node's value as an <see cref="T:System.Int64" />
    ///  .</returns>
    ///<exception cref="T:System.FormatException">The current node's string value cannot be converted to a <see cref="T:System.Int64" />
    ///  .</exception><exception cref="T:System.InvalidCastException">The attempted cast to <see cref="T:System.Int64" />
    ///  is not valid.</exception>
    property ValueAsLong: Int64 read get_ValueAsLong;
    ///<summary>When overridden in a derived class, gets the <see cref="T:System.Xml.XmlNameTable" />
    ///  of the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///<returns>An <see cref="T:System.Xml.XmlNameTable" />
    ///  object enabling you to get the atomized version of a <see cref="T:System.String" />
    ///  within the XML document.</returns>
    property NameTable: DNXmlNameTable read get_NameTable;
    ///<summary>When overridden in a derived class, gets the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  of the current node.</summary>
    ///<returns>One of the <see cref="T:System.Xml.XPath.XPathNodeType" />
    ///  values representing the current node.</returns>
    property NodeType: DNXPathNodeType read get_NodeType;
    ///<summary>When overridden in a derived class, gets the <see cref="P:System.Xml.XPath.XPathNavigator.Name" />
    ///  of the current node without any namespace prefix.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the local name of the current node, or <see cref="F:System.String.Empty" />
    ///  if the current node does not have a name (for example, text or comment nodes).</returns>
    property LocalName: string read get_LocalName;
    ///<summary>When overridden in a derived class, gets the qualified name of the current node.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the qualified <see cref="P:System.Xml.XPath.XPathNavigator.Name" />
    ///  of the current node, or <see cref="F:System.String.Empty" />
    ///  if the current node does not have a name (for example, text or comment nodes).</returns>
    property Name: string read get_Name;
    ///<summary>When overridden in a derived class, gets the namespace URI of the current node.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the namespace URI of the current node, or <see cref="F:System.String.Empty" />
    ///  if the current node has no namespace URI.</returns>
    property NamespaceURI: string read get_NamespaceURI;
    ///<summary>When overridden in a derived class, gets the namespace prefix associated with the current node.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the namespace prefix associated with the current node.</returns>
    property Prefix: string read get_Prefix;
    ///<summary>When overridden in a derived class, gets the base URI for the current node.</summary>
    ///<returns>The location from which the node was loaded, or <see cref="F:System.String.Empty" />
    ///  if there is no value.</returns>
    property BaseURI: string read get_BaseURI;
    ///<summary>When overridden in a derived class, gets a value indicating whether the current node is an empty element without an end element tag.</summary>
    ///<returns><see langword="true" />
    ///  if the current node is an empty element; otherwise, <see langword="false" />
    ///  .</returns>
    property IsEmptyElement: Boolean read get_IsEmptyElement;
    ///<summary>Gets the xml:lang scope for the current node.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the value of the xml:lang scope, or <see cref="F:System.String.Empty" />
    ///  if the current node has no xml:lang scope value to return.</returns>
    property XmlLang: string read get_XmlLang;
    ///<summary>Used by <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  implementations which provide a "virtualized" XML view over a store, to provide access to underlying objects.</summary>
    ///<returns>The default is <see langword="null" />
    ///  .</returns>
    property UnderlyingObject: DDN.mscorlib.DNObject read get_UnderlyingObject;
    ///<summary>Gets a value indicating whether the current node has any attributes.</summary>
    ///<returns>Returns <see langword="true" />
    ///  if the current node has attributes; returns <see langword="false" />
    ///  if the current node has no attributes, or if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  is not positioned on an element node.</returns>
    property HasAttributes: Boolean read get_HasAttributes;
    ///<summary>Gets a value indicating whether the current node has any child nodes.</summary>
    ///<returns><see langword="true" />
    ///  if the current node has any child nodes; otherwise, <see langword="false" />
    ///  .</returns>
    property HasChildren: Boolean read get_HasChildren;
    ///<summary>Gets the schema information that has been assigned to the current node as a result of schema validation.</summary>
    ///<returns>An <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />
    ///  object that contains the schema information for the current node.</returns>
    property SchemaInfo: DNIXmlSchemaInfo read get_SchemaInfo;
    ///<summary>Gets a value indicating whether the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  can edit the underlying XML data.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  can edit the underlying XML data; otherwise <see langword="false" />
    ///  .</returns>
    property CanEdit: Boolean read get_CanEdit;
    ///<summary>Gets or sets the markup representing the opening and closing tags of the current node and its child nodes.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the markup representing the opening and closing tags of the current node and its child nodes.</returns>
    property OuterXml: string read get_OuterXml write set_OuterXml;
    ///<summary>Gets or sets the markup representing the child nodes of the current node.</summary>
    ///<returns>A <see cref="T:System.String" />
    ///  that contains the markup of the child nodes of the current node.</returns>
    ///<exception cref="T:System.InvalidOperationException">The <see cref="P:System.Xml.XPath.XPathNavigator.InnerXml" />
    ///  property cannot be set.</exception>
    property InnerXml: string read get_InnerXml write set_InnerXml;
    ///<summary>When overridden in a derived class, gets the <see langword="string" />
    ///  value of the item.</summary>
    ///<returns>The <see langword="string" />
    ///  value of the item.</returns>
    property Value: string read get_Value;
  end;

  TDNXPathNavigator = class(TDNGenericImport<DNXPathNavigatorClass, DNXPathNavigator>) end;

  //-------------namespace: System.Xml.XPath----------------
  DNXPathNodeIteratorClass = interface(DNObjectClass)
  ['{D5B45F05-6AFE-58F0-9E23-31308022884E}']
  end;

  ///<summary>Provides an iterator over a selected set of nodes.</summary>
  [DNTypeName('System.Xml.XPath.XPathNodeIterator')]
  DNXPathNodeIterator = interface(DDN.mscorlib.DNICloneable)
  ['{181EDCFA-EB65-387B-9544-B953DD6A55D0}']
  { getters & setters } 

    function get_Current: DNXPathNavigator;
    function get_CurrentPosition: Int32;
    function get_Count: Int32;

  { methods } 

    ///<summary>Returns an <see cref="T:System.Collections.IEnumerator" />
    ///  object to iterate through the selected node set.</summary>
    ///<returns>An <see cref="T:System.Collections.IEnumerator" />
    ///  object to iterate through the selected node set.</returns>
    function GetEnumerator: DDN.mscorlib.DNIEnumerator;
    ///<summary>When overridden in a derived class, returns a clone of this <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  object.</summary>
    ///<returns>A new <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  object clone of this <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  object.</returns>
    function Clone: DNXPathNodeIterator;
    ///<summary>When overridden in a derived class, moves the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object returned by the <see cref="P:System.Xml.XPath.XPathNodeIterator.Current" />
    ///  property to the next node in the selected node set.</summary>
    ///<returns><see langword="true" />
    ///  if the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object moved to the next node; <see langword="false" />
    ///  if there are no more selected nodes.</returns>
    function MoveNext: Boolean;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>When overridden in a derived class, gets the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object for this <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  , positioned on the current context node.</summary>
    ///<returns>An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object positioned on the context node from which the node set was selected. The <see cref="M:System.Xml.XPath.XPathNodeIterator.MoveNext" />
    ///  method must be called to move the <see cref="T:System.Xml.XPath.XPathNodeIterator" />
    ///  to the first node in the selected set.</returns>
    property Current: DNXPathNavigator read get_Current;
    ///<summary>When overridden in a derived class, gets the index of the current position in the selected set of nodes.</summary>
    ///<returns>The index of the current position.</returns>
    property CurrentPosition: Int32 read get_CurrentPosition;
    ///<summary>Gets the index of the last node in the selected set of nodes.</summary>
    ///<returns>The index of the last node in the selected set of nodes, or 0 if there are no selected nodes.</returns>
    property Count: Int32 read get_Count;
  end;

  TDNXPathNodeIterator = class(TDNGenericImport<DNXPathNodeIteratorClass, DNXPathNodeIterator>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXslCompiledTransformClass = interface(DDN.mscorlib.DNObjectClass)
  ['{3595CC68-E00B-51D8-94EE-1BD2B8168423}']
  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XslCompiledTransform" />
    ///  class. </summary>
    {class} function init: DNXslCompiledTransform; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XslCompiledTransform" />
    ///  class with the specified debug setting. </summary>
    ///  <param name="enableDebug"><see langword="true" />
    ///  to generate debug information; otherwise <see langword="false" />
    ///  . Setting this to <see langword="true" />
    ///  enables you to debug the style sheet with the Microsoft Visual Studio Debugger.</param>
    {class} function init(enableDebug: Boolean): DNXslCompiledTransform; overload;

  { static methods } 

    ///<summary>Compiles an XSLT style sheet to a specified type.</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XmlReader" />
    ///  positioned at the beginning of the style sheet to be compiled.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  to be applied to the style sheet. If this is <see langword="null" />
    ///  , the <see cref="P:System.Xml.Xsl.XsltSettings.Default" />
    ///  will be applied.</param>
    ///  <param name="stylesheetResolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  use to resolve style sheet modules referenced in <see langword="xsl:import" />
    ///  and <see langword="xsl:include" />
    ///  elements. If this is <see langword="null" />
    ///  , external resources will not be resolved.</param>
    ///  <param name="debug">Setting this to <see langword="true" />
    ///  enables debugging the style sheet with a debugger.</param>
    ///  <param name="typeBuilder">The <see cref="T:System.Reflection.Emit.TypeBuilder" />
    ///  used for the style sheet compilation. The provided TypeBuilder is used to generate the resulting type.</param>
    ///  <param name="scriptAssemblyPath">The base path for the assemblies generated for <see langword="msxsl:script" />
    ///  elements. If only one script assembly is generated, this parameter specifies the path for that assembly. In case of multiple script assemblies, a distinctive suffix will be appended to the file name to ensure uniqueness of assembly names.</param>
    ///<returns>A <see cref="T:System.CodeDom.Compiler.CompilerErrorCollection" />
    ///  object containing compiler errors and warnings that indicate the results of the compilation.</returns>
    {class} function CompileToType(stylesheet: DNXmlReader; settings: DNXsltSettings; stylesheetResolver: DNXmlResolver; debug: Boolean; typeBuilder: DDN.mscorlib.DNTypeBuilder; scriptAssemblyPath: string): DDN.System.DNCompilerErrorCollection;

  end;

  ///<summary>Transforms XML data using an XSLT style sheet.</summary>
  [DNTypeName('System.Xml.Xsl.XslCompiledTransform')]
  DNXslCompiledTransform = interface(DDN.mscorlib.DNObject)
  ['{EE5E8118-D533-33D7-84AE-F1AB3D9651EB}']
  { getters & setters } 

    function get_OutputSettings: DNXmlWriterSettings;
    function get_TemporaryFiles: DDN.System.DNTempFileCollection;

  { methods } 

    ///<summary>Compiles the XSLT style sheet contained in the <see cref="T:System.Xml.XmlReader" />
    ///  . The <see cref="T:System.Xml.XmlResolver" />
    ///  resolves any XSLT import or include elements and the XSLT settings determine the permissions for the style sheet.</summary>
    ///  <param name="stylesheet">The <see cref="T:System.Xml.XmlReader" />
    ///  containing the style sheet.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  to apply to the style sheet. If this is <see langword="null" />
    ///  , the <see cref="P:System.Xml.Xsl.XsltSettings.Default" />
    ///  setting is applied.</param>
    ///  <param name="stylesheetResolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve any style sheets referenced in XSLT import and include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stylesheet" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">The style sheet contains an error.</exception>
    procedure Load(stylesheet: DNXmlReader; settings: DNXsltSettings; stylesheetResolver: DNXmlResolver); overload;
    ///<summary>Compiles the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  . The <see cref="T:System.Xml.XmlResolver" />
    ///  resolves any XSLT import or include elements and the XSLT settings determine the permissions for the style sheet.</summary>
    ///  <param name="stylesheet">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the Microsoft .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the style sheet.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  to apply to the style sheet. If this is <see langword="null" />
    ///  , the <see cref="P:System.Xml.Xsl.XsltSettings.Default" />
    ///  setting is applied.</param>
    ///  <param name="stylesheetResolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve any style sheets referenced in XSLT import and include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stylesheet" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">The style sheet contains an error.</exception>
    procedure Load(stylesheet: DNIXPathNavigable; settings: DNXsltSettings; stylesheetResolver: DNXmlResolver); overload;
    ///<summary>Loads and compiles the XSLT style sheet specified by the URI. The <see cref="T:System.Xml.XmlResolver" />
    ///  resolves any XSLT import or include elements and the XSLT settings determine the permissions for the style sheet.</summary>
    ///  <param name="stylesheetUri">The URI of the style sheet.</param>
    ///  <param name="settings">The <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  to apply to the style sheet. If this is <see langword="null" />
    ///  , the <see cref="P:System.Xml.Xsl.XsltSettings.Default" />
    ///  setting is applied.</param>
    ///  <param name="stylesheetResolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the style sheet URI and any style sheets referenced in XSLT import and include elements. </param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stylesheetUri" />
    ///  or <paramref name="stylesheetResolver" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">The style sheet contains an error.</exception><exception cref="T:System.IO.FileNotFoundException">The style sheet cannot be found.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="stylesheetUri" />
    ///  value includes a filename or directory that cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="stylesheetUri" />
    ///  value cannot be resolved.-or-An error occurred while processing the request.</exception><exception cref="T:System.UriFormatException"><paramref name="stylesheetUri" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the style sheet.</exception>
    procedure Load(stylesheetUri: string; settings: DNXsltSettings; stylesheetResolver: DNXmlResolver); overload;
    ///<summary>Compiles the style sheet contained in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XmlReader" />
    ///  containing the style sheet.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stylesheet" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">The style sheet contains an error.</exception>
    procedure Load(stylesheet: DNXmlReader); overload;
    ///<summary>Compiles the style sheet contained in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object.</summary>
    ///  <param name="stylesheet">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the Microsoft .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the style sheet.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stylesheet" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">The style sheet contains an error.</exception>
    procedure Load(stylesheet: DNIXPathNavigable); overload;
    ///<summary>Loads and compiles the style sheet located at the specified URI.</summary>
    ///  <param name="stylesheetUri">The URI of the style sheet.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="stylesheetUri" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">The style sheet contains an error.</exception><exception cref="T:System.IO.FileNotFoundException">The style sheet cannot be found.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="stylesheetUri" />
    ///  value includes a filename or directory that cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="stylesheetUri" />
    ///  value cannot be resolved.-or-An error occurred while processing the request.</exception><exception cref="T:System.UriFormatException"><paramref name="stylesheetUri" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the style sheet.</exception>
    procedure Load(stylesheetUri: string); overload;
    ///<summary>Loads the compiled style sheet that was created using the XSLT Compiler (xsltc.exe).</summary>
    ///  <param name="compiledStylesheet">The name of the class that contains the compiled style sheet. This is usually the name of the style sheet. Unless otherwise specified, the xsltc.exe tool uses the name of the style sheet for the class and assembly names.</param>
    procedure Load(compiledStylesheet: DDN.mscorlib.DNType); overload;
    ///<summary>Loads a method from a style sheet compiled using the <see langword="XSLTC.exe" />
    ///  utility.</summary>
    ///  <param name="executeMethod">A <see cref="T:System.Reflection.MethodInfo" />
    ///  object representing the compiler-generated <paramref name="execute" />
    ///  method of the compiled style sheet.</param>
    ///  <param name="queryData">A byte array of serialized data structures in the <paramref name="staticData" />
    ///  field of the compiled style sheet as generated by the <see cref="M:System.Xml.Xsl.XslCompiledTransform.CompileToType(System.Xml.XmlReader,System.Xml.Xsl.XsltSettings,System.Xml.XmlResolver,System.Boolean,System.Reflection.Emit.TypeBuilder,System.String)" />
    ///  method.</param>
    ///  <param name="earlyBoundTypes">An array of types stored in the compiler-generated <paramref name="ebTypes" />
    ///  field of the compiled style sheet.</param>
    procedure Load(executeMethod: DDN.mscorlib.DNMethodInfo; queryData: TArray<Byte>; earlyBoundTypes: TArray<DDN.mscorlib.DNType>); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the Microsoft .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed.</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNIXPathNavigable; results: DNXmlWriter); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the Microsoft .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNIXPathNavigable; arguments: DNXsltArgumentList; results: DNXmlWriter); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object and outputs the results to an <see cref="T:System.IO.TextWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the Microsoft .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNIXPathNavigable; arguments: DNXsltArgumentList; results: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object and outputs the results to a stream. The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional runtime arguments.</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the Microsoft .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The stream to which you want to output.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNIXPathNavigable; arguments: DNXsltArgumentList; results: DDN.mscorlib.DNStream); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XmlReader" />
    ///  object and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="input">The <see cref="T:System.Xml.XmlReader" />
    ///  containing the input document.</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNXmlReader; results: DNXmlWriter); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XmlReader" />
    ///  object and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XmlReader" />
    ///  containing the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNXmlReader; arguments: DNXsltArgumentList; results: DNXmlWriter); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XmlReader" />
    ///  object and outputs the results to a <see cref="T:System.IO.TextWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XmlReader" />
    ///  containing the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNXmlReader; arguments: DNXsltArgumentList; results: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XmlReader" />
    ///  object and outputs the results to a stream. The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XmlReader" />
    ///  containing the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The stream to which you want to output.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNXmlReader; arguments: DNXsltArgumentList; results: DDN.mscorlib.DNStream); overload;
    ///<summary>Executes the transform using the input document specified by the URI and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="inputUri">The URI of the input document.</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="inputUri" />
    ///  value includes a filename or directory cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="inputUri" />
    ///  value cannot be resolved.-or-An error occurred while processing the request.</exception><exception cref="T:System.UriFormatException"><paramref name="inputUri" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the input document.</exception>
    procedure Transform(inputUri: string; results: DNXmlWriter); overload;
    ///<summary>Executes the transform using the input document specified by the URI and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="inputUri">The URI of the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="inputtUri" />
    ///  value includes a filename or directory cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="inputUri" />
    ///  value cannot be resolved.-or-An error occurred while processing the request.</exception><exception cref="T:System.UriFormatException"><paramref name="inputUri" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the input document.</exception>
    procedure Transform(inputUri: string; arguments: DNXsltArgumentList; results: DNXmlWriter); overload;
    ///<summary>Executes the transform using the input document specified by the URI and outputs the results to a <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="inputUri">The URI of the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="inputUri" />
    ///  value includes a filename or directory cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="inputUri" />
    ///  value cannot be resolved.-or-An error occurred while processing the request</exception><exception cref="T:System.UriFormatException"><paramref name="inputUri" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the input document.</exception>
    procedure Transform(inputUri: string; arguments: DNXsltArgumentList; results: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Executes the transform using the input document specified by the URI and outputs the results to stream. The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments.</summary>
    ///  <param name="inputUri">The URI of the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The stream to which you want to output.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="inputUri" />
    ///  value includes a filename or directory cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="inputUri" />
    ///  value cannot be resolved.-or-An error occurred while processing the request</exception><exception cref="T:System.UriFormatException"><paramref name="inputUri" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the input document.</exception>
    procedure Transform(inputUri: string; arguments: DNXsltArgumentList; results: DDN.mscorlib.DNStream); overload;
    ///<summary>Executes the transform using the input document specified by the URI and outputs the results to a file.</summary>
    ///  <param name="inputUri">The URI of the input document.</param>
    ///  <param name="resultsFile">The URI of the output file.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="inputUri" />
    ///  or <paramref name="resultsFile" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception><exception cref="T:System.IO.FileNotFoundException">The input document cannot be found.</exception><exception cref="T:System.IO.DirectoryNotFoundException">The <paramref name="inputUri" />
    ///  or <paramref name="resultsFile" />
    ///  value includes a filename or directory cannot be found.</exception><exception cref="T:System.Net.WebException">The <paramref name="inputUri" />
    ///  or <paramref name="resultsFile" />
    ///  value cannot be resolved.-or-An error occurred while processing the request</exception><exception cref="T:System.UriFormatException"><paramref name="inputUri" />
    ///  or <paramref name="resultsFile" />
    ///  is not a valid URI.</exception><exception cref="T:System.Xml.XmlException">There was a parsing error loading the input document.</exception>
    procedure Transform(inputUri: string; resultsFile: string); overload;
    ///<summary>Executes the transform using the input document specified by the <see cref="T:System.Xml.XmlReader" />
    ///  object and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments and the XmlResolver resolves the XSLT document() function.</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XmlReader" />
    ///  containing the input document.</param>
    ///  <param name="arguments">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transform. This value can be <see langword="null" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an xsl:output element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///  <param name="documentResolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.</param>
    ///<exception cref="T:System.ArgumentNullException">The <paramref name="input" />
    ///  or <paramref name="results" />
    ///  value is <see langword="null" />
    ///  .</exception><exception cref="T:System.Xml.Xsl.XsltException">There was an error executing the XSLT transform.</exception>
    procedure Transform(input: DNXmlReader; arguments: DNXsltArgumentList; results: DNXmlWriter; documentResolver: DNXmlResolver); overload;
    ///<summary>Executes the transform by using the input document that is specified by the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object and outputs the results to an <see cref="T:System.Xml.XmlWriter" />
    ///  . The <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  provides additional run-time arguments and the <see cref="T:System.Xml.XmlResolver" />
    ///  resolves the XSLT <see langword="document()" />
    ///  function.</summary>
    ///  <param name="input">The document to transform that is specified by the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  object.</param>
    ///  <param name="arguments">Argument list as <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  .</param>
    ///  <param name="results">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output.If the style sheet contains an <see langword="xsl:output" />
    ///  element, you should create the <see cref="T:System.Xml.XmlWriter" />
    ///  by using the <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object that is returned from the <see cref="P:System.Xml.Xsl.XslCompiledTransform.OutputSettings" />
    ///  property. This ensures that the <see cref="T:System.Xml.XmlWriter" />
    ///  has the correct output settings.</param>
    ///  <param name="documentResolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT <see langword="document()" />
    ///  function. If this is <see langword="null" />
    ///  , the <see langword="document()" />
    ///  function is not resolved.</param>
    procedure Transform(input: DNIXPathNavigable; arguments: DNXsltArgumentList; results: DNXmlWriter; documentResolver: DNXmlResolver); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets an <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object that contains the output information derived from the xsl:output element of the style sheet.</summary>
    ///<returns>A read-only <see cref="T:System.Xml.XmlWriterSettings" />
    ///  object that contains the output information derived from the xsl:output element of the style sheet. This value can be <see langword="null" />
    ///  .</returns>
    property OutputSettings: DNXmlWriterSettings read get_OutputSettings;
    ///<summary>Gets the <see cref="T:System.CodeDom.Compiler.TempFileCollection" />
    ///  that contains the temporary files generated on disk after a successful call to the <see cref="Overload:System.Xml.Xsl.XslCompiledTransform.Load" />
    ///  method. </summary>
    ///<returns>The <see cref="T:System.CodeDom.Compiler.TempFileCollection" />
    ///  that contains the temporary files generated on disk. This value is <see langword="null" />
    ///  if the <see cref="Overload:System.Xml.Xsl.XslCompiledTransform.Load" />
    ///  method has not been successfully called, or if debugging has not been enabled.</returns>
    property TemporaryFiles: DDN.System.DNTempFileCollection read get_TemporaryFiles;
  end;

  TDNXslCompiledTransform = class(TDNGenericImport<DNXslCompiledTransformClass, DNXslCompiledTransform>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXsltArgumentListClass = interface(DDN.mscorlib.DNObjectClass)
  ['{0A43B04C-2118-58C2-AB4B-93CA9511484E}']
  { constructors } 

    ///<summary>Implements a new instance of the <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  .</summary>
    {class} function init: DNXsltArgumentList;

  end;

  ///<summary>Contains a variable number of arguments which are either XSLT parameters or extension objects.</summary>
  [DNTypeName('System.Xml.Xsl.XsltArgumentList')]
  DNXsltArgumentList = interface(DDN.mscorlib.DNObject)
  ['{F8EECF4E-8DCE-3B76-9CB2-AE1C08538E80}']
  { events } 

    procedure add_XsltMessageEncountered(value: DNXsltMessageEncounteredEventHandler);
    procedure remove_XsltMessageEncountered(value: DNXsltMessageEncounteredEventHandler);

  { methods } 

    ///<summary>Gets the parameter associated with the namespace qualified name.</summary>
    ///  <param name="name">The name of the parameter. <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  does not check to ensure the name passed is a valid local name; however, the name cannot be <see langword="null" />
    ///  . </param>
    ///  <param name="namespaceUri">The namespace URI associated with the parameter. </param>
    ///<returns>The parameter object or <see langword="null" />
    ///  if one was not found.</returns>
    function GetParam(name: string; namespaceUri: string): DDN.mscorlib.DNObject;
    ///<summary>Gets the object associated with the given namespace.</summary>
    ///  <param name="namespaceUri">The namespace URI of the object. </param>
    ///<returns>The namespace URI object or <see langword="null" />
    ///  if one was not found.</returns>
    function GetExtensionObject(namespaceUri: string): DDN.mscorlib.DNObject;
    ///<summary>Adds a parameter to the <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  and associates it with the namespace qualified name.</summary>
    ///  <param name="name">The name to associate with the parameter. </param>
    ///  <param name="namespaceUri">The namespace URI to associate with the parameter. To use the default namespace, specify an empty string. </param>
    ///  <param name="parameter">The parameter value or object to add to the list. </param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="namespaceUri" />
    ///  is either <see langword="null" />
    ///  or http://www.w3.org/1999/XSL/Transform.The <paramref name="name" />
    ///  is not a valid name according to the W3C XML specification.The <paramref name="namespaceUri" />
    ///  already has a parameter associated with it. </exception>
    procedure AddParam(name: string; namespaceUri: string; parameter: DDN.mscorlib.DNObject);
    ///<summary>Adds a new object to the <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  and associates it with the namespace URI.</summary>
    ///  <param name="namespaceUri">The namespace URI to associate with the object. To use the default namespace, specify an empty string. </param>
    ///  <param name="extension">The object to add to the list. </param>
    ///<exception cref="T:System.ArgumentException">The <paramref name="namespaceUri" />
    ///  is either <see langword="null" />
    ///  or http://www.w3.org/1999/XSL/Transform The <paramref name="namespaceUri" />
    ///  already has an extension object associated with it. </exception><exception cref="T:System.Security.SecurityException">The caller does not have sufficient permissions to call this method. </exception>
    procedure AddExtensionObject(namespaceUri: string; extension: DDN.mscorlib.DNObject);
    ///<summary>Removes the parameter from the <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  .</summary>
    ///  <param name="name">The name of the parameter to remove. <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  does not check to ensure the name passed is a valid local name; however, the name cannot be <see langword="null" />
    ///  . </param>
    ///  <param name="namespaceUri">The namespace URI of the parameter to remove. </param>
    ///<returns>The parameter object or <see langword="null" />
    ///  if one was not found.</returns>
    function RemoveParam(name: string; namespaceUri: string): DDN.mscorlib.DNObject;
    ///<summary>Removes the object with the namespace URI from the <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  .</summary>
    ///  <param name="namespaceUri">The namespace URI associated with the object to remove. </param>
    ///<returns>The object with the namespace URI or <see langword="null" />
    ///  if one was not found.</returns>
    function RemoveExtensionObject(namespaceUri: string): DDN.mscorlib.DNObject;
    ///<summary>Removes all parameters and extension objects from the <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  .</summary>
    procedure Clear;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  end;

  TDNXsltArgumentList = class(TDNGenericImport<DNXsltArgumentListClass, DNXsltArgumentList>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXslTransformClass = interface(DDN.mscorlib.DNObjectClass)
  ['{97CBD512-0F76-5137-AAA8-2E7AEFC8DCD2}']
  { static getter & setter } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XslTransform" />
    ///  class.</summary>
    {class} function init: DNXslTransform;

  { static propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve external resources when the <see cref="Overload:System.Xml.Xsl.XslTransform.Transform" />
    ///  method is called.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlResolver" />
    ///  to use during transformation. If set to <see langword="null" />
    ///  , the XSLT document() function is not resolved.</returns>
    {class} property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  ///<summary>Transforms XML data using an Extensible Stylesheet Language for Transformations (XSLT) style sheet.</summary>
  [DNTypeName('System.Xml.Xsl.XslTransform')]
  DNXslTransform = interface(DDN.mscorlib.DNObject)
  ['{3B026707-8328-336A-BE86-9EA3E93B088C}']
  { getters & setters } 

    procedure set_XmlResolver(value: DNXmlResolver);

  { methods } 

    ///<summary>Loads the XSLT style sheet specified by a URL.</summary>
    ///  <param name="url">The URL that specifies the XSLT style sheet to load. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The loaded resource is not a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded script, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(url: string); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to an <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  containing the results of the transformation.</returns>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    function Transform(input: DNXPathNavigator; args: DNXsltArgumentList; resolver: DNXmlResolver): DNXmlReader; overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to an <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  containing the results of the transformation.</returns>
    function Transform(input: DNIXPathNavigable; args: DNXsltArgumentList): DNXmlReader; overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XmlReader" />
    ///  object that contains the XSLT style sheet. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to load any style sheets referenced in xsl:import and xsl:include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Load(System.Xml.XmlReader,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The current node does not conform to a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded scripts, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNXmlReader; resolver: DNXmlResolver); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  .</summary>
    ///  <param name="stylesheet">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the XSLT style sheet. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to load any style sheets referenced in xsl:import and xsl:include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Load" />
    ///  method completes. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The loaded resource is not a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded scripts, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNIXPathNavigable; resolver: DNXmlResolver); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object that contains the XSLT style sheet. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to load any style sheets referenced in xsl:import and xsl:include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Load" />
    ///  method completes. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The current node does not conform to a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded scripts, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNXPathNavigator; resolver: DNXmlResolver); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  . This method allows you to limit the permissions of the style sheet by specifying evidence.</summary>
    ///  <param name="stylesheet">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the XSLT style sheet. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to load any style sheets referenced in xsl:import and xsl:include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Load" />
    ///  method completes. </param>
    ///  <param name="evidence">The <see cref="T:System.Security.Policy.Evidence" />
    ///  set on the assembly generated for the script block in the XSLT style sheet.If this is <see langword="null" />
    ///  , script blocks are not processed, the XSLT document() function is not supported, and privileged extension objects are disallowed.The caller must have <see langword="ControlEvidence" />
    ///  permission in order to supply evidence for the script assembly. Semi-trusted callers can set this parameter to <see langword="null" />
    ///  . </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The loaded resource is not a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The referenced style sheet requires functionality that is not allowed by the evidence provided.The caller tries to supply evidence and does not have <see langword="ControlEvidence" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNIXPathNavigable; resolver: DNXmlResolver; evidence: DDN.mscorlib.DNEvidence); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XmlReader" />
    ///  . This method allows you to limit the permissions of the style sheet by specifying evidence.</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XmlReader" />
    ///  object containing the style sheet to load. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to load any style sheets referenced in xsl:import and xsl:include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Load" />
    ///  method completes. </param>
    ///  <param name="evidence">The <see cref="T:System.Security.Policy.Evidence" />
    ///  set on the assembly generated for the script block in the XSLT style sheet.If this is <see langword="null" />
    ///  , script blocks are not processed, the XSLT document() function is not supported, and privileged extension objects are disallowed.The caller must have <see langword="ControlEvidence" />
    ///  permission in order to supply evidence for the script assembly. Semi-trusted callers can set this parameter to <see langword="null" />
    ///  . </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The current node does not conform to a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The referenced style sheet requires functionality that is not allowed by the evidence provided.The caller tries to supply evidence and does not have <see langword="ControlEvidence" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNXmlReader; resolver: DNXmlResolver; evidence: DDN.mscorlib.DNEvidence); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  . This method allows you to limit the permissions of the style sheet by specifying evidence.</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object containing the style sheet to load. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to load any style sheets referenced in xsl:import and xsl:include elements. If this is <see langword="null" />
    ///  , external resources are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Load" />
    ///  method completes. </param>
    ///  <param name="evidence">The <see cref="T:System.Security.Policy.Evidence" />
    ///  set on the assembly generated for the script block in the XSLT style sheet.If this is <see langword="null" />
    ///  , script blocks are not processed, the XSLT document() function is not supported, and privileged extension objects are disallowed.The caller must have <see langword="ControlEvidence" />
    ///  permission in order to supply evidence for the script assembly. Semi-trusted callers can set this parameter to <see langword="null" />
    ///  . </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The current node does not conform to a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The referenced style sheet requires functionality that is not allowed by the evidence provided.The caller tries to supply evidence and does not have <see langword="ControlEvidence" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNXPathNavigator; resolver: DNXmlResolver; evidence: DDN.mscorlib.DNEvidence); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to an <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  containing the results of the transformation.</returns>
    function Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; resolver: DNXmlResolver): DNXmlReader; overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; output: DDN.mscorlib.DNTextWriter; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The stream to which you want to output. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Transform" />
    ///  method completes. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; output: DDN.mscorlib.DNStream; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.IXPathNavigable,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; output: DNXmlWriter; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the input file and outputs the result to an output file.</summary>
    ///  <param name="inputfile">The URL of the source document to be transformed. </param>
    ///  <param name="outputfile">The URL of the output file. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="Overload:System.Xml.Xsl.XslTransform.Transform" />
    ///  method completes. </param>
    procedure Transform(inputfile: string; outputfile: string; resolver: DNXmlResolver); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XmlReader" />
    ///  object that contains the XSLT style sheet. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The current node does not conform to a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded scripts, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNXmlReader); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  .</summary>
    ///  <param name="stylesheet">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the XSLT style sheet. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The loaded resource is not a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded scripts, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNIXPathNavigable); overload;
    ///<summary>Loads the XSLT style sheet contained in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  .</summary>
    ///  <param name="stylesheet">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  object that contains the XSLT style sheet. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The current node does not conform to a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded scripts, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(stylesheet: DNXPathNavigator); overload;
    ///<summary>Loads the XSLT style sheet specified by a URL.</summary>
    ///  <param name="url">The URL that specifies the XSLT style sheet to load. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  to use to load the style sheet and any style sheet(s) referenced in xsl:import and xsl:include elements.If this is <see langword="null" />
    ///  , a default <see cref="T:System.Xml.XmlUrlResolver" />
    ///  with no user credentials is used to open the style sheet. The default <see cref="T:System.Xml.XmlUrlResolver" />
    ///  is not used to resolve any external resources in the style sheet, so xsl:import and xsl:include elements are not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Load(System.String,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.Xml.Xsl.XsltCompileException">The loaded resource is not a valid style sheet. </exception><exception cref="T:System.Security.SecurityException">The style sheet contains embedded script, and the caller does not have <see langword="UnmanagedCode" />
    ///  permission. </exception>
    procedure Load(url: string; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to an <see cref="T:System.Xml.XmlReader" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///<returns>An <see cref="T:System.Xml.XmlReader" />
    ///  containing the results of the transformation.</returns>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    function Transform(input: DNXPathNavigator; args: DNXsltArgumentList): DNXmlReader; overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified args and outputs the result to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.Xml.XmlWriter,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNXPathNavigator; args: DNXsltArgumentList; output: DNXmlWriter; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified args and outputs the result to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNXPathNavigator; args: DNXsltArgumentList; output: DNXmlWriter); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The stream to which you want to output. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.Stream,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNXPathNavigator; args: DNXsltArgumentList; output: DDN.mscorlib.DNStream; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The stream to which you want to output. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNXPathNavigator; args: DNXsltArgumentList; output: DDN.mscorlib.DNStream); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output. </param>
    ///  <param name="resolver">The <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve the XSLT document() function. If this is <see langword="null" />
    ///  , the document() function is not resolved.The <see cref="T:System.Xml.XmlResolver" />
    ///  is not cached after the <see cref="M:System.Xml.Xsl.XslTransform.Transform(System.Xml.XPath.XPathNavigator,System.Xml.Xsl.XsltArgumentList,System.IO.TextWriter,System.Xml.XmlResolver)" />
    ///  method completes. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNXPathNavigator; args: DNXsltArgumentList; output: DDN.mscorlib.DNTextWriter; resolver: DNXmlResolver); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="input">An <see cref="T:System.Xml.XPath.XPathNavigator" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNXPathNavigator; args: DNXsltArgumentList; output: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.TextWriter" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.IO.TextWriter" />
    ///  to which you want to output. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; output: DDN.mscorlib.DNTextWriter); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to a <see cref="T:System.IO.Stream" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The stream to which you want to output. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation.Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; output: DDN.mscorlib.DNStream); overload;
    ///<summary>Transforms the XML data in the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  using the specified <paramref name="args" />
    ///  and outputs the result to an <see cref="T:System.Xml.XmlWriter" />
    ///  .</summary>
    ///  <param name="input">An object implementing the <see cref="T:System.Xml.XPath.IXPathNavigable" />
    ///  interface. In the .NET Framework, this can be either an <see cref="T:System.Xml.XmlNode" />
    ///  (typically an <see cref="T:System.Xml.XmlDocument" />
    ///  ), or an <see cref="T:System.Xml.XPath.XPathDocument" />
    ///  containing the data to be transformed. </param>
    ///  <param name="args">An <see cref="T:System.Xml.Xsl.XsltArgumentList" />
    ///  containing the namespace-qualified arguments used as input to the transformation. </param>
    ///  <param name="output">The <see cref="T:System.Xml.XmlWriter" />
    ///  to which you want to output. </param>
    ///<exception cref="T:System.InvalidOperationException">There was an error processing the XSLT transformation. Note: This is a change in behavior from earlier versions. An <see cref="T:System.Xml.Xsl.XsltException" />
    ///  is thrown if you are using Microsoft .NET Framework version 1.1 or earlier.</exception>
    procedure Transform(input: DNIXPathNavigable; args: DNXsltArgumentList; output: DNXmlWriter); overload;
    ///<summary>Transforms the XML data in the input file and outputs the result to an output file.</summary>
    ///  <param name="inputfile">The URL of the source document to be transformed. </param>
    ///  <param name="outputfile">The URL of the output file. </param>
    procedure Transform(inputfile: string; outputfile: string); overload;
    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Sets the <see cref="T:System.Xml.XmlResolver" />
    ///  used to resolve external resources when the <see cref="Overload:System.Xml.Xsl.XslTransform.Transform" />
    ///  method is called.</summary>
    ///<returns>The <see cref="T:System.Xml.XmlResolver" />
    ///  to use during transformation. If set to <see langword="null" />
    ///  , the XSLT document() function is not resolved.</returns>
    property XmlResolver: DNXmlResolver write set_XmlResolver;
  end;

  TDNXslTransform = class(TDNGenericImport<DNXslTransformClass, DNXslTransform>) end;

  //-------------namespace: System.Xml.Xsl----------------
  DNXsltSettingsClass = interface(DDN.mscorlib.DNObjectClass)
  ['{6642EC2D-6E5E-5FB5-B919-9D63D7F11804}']
  { static getter & setter } 

    {class} function get_Default: DNXsltSettings;
    {class} function get_TrustedXslt: DNXsltSettings;

  { constructors } 

    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  class with default settings.</summary>
    {class} function init: DNXsltSettings; overload;
    ///<summary>Initializes a new instance of the <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  class with the specified settings.</summary>
    ///  <param name="enableDocumentFunction"><see langword="true" />
    ///  to enable support for the XSLT document() function; otherwise, <see langword="false" />
    ///  .</param>
    ///  <param name="enableScript"><see langword="true" />
    ///  to enable support for embedded scripts blocks; otherwise, <see langword="false" />
    ///  .</param>
    {class} function init(enableDocumentFunction: Boolean; enableScript: Boolean): DNXsltSettings; overload;

  { static propertys } 

    ///<summary>Gets an <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  object with default settings. Support for the XSLT document() function and embedded script blocks is disabled.</summary>
    ///<returns>An <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  object with the <see cref="P:System.Xml.Xsl.XsltSettings.EnableDocumentFunction" />
    ///  and <see cref="P:System.Xml.Xsl.XsltSettings.EnableScript" />
    ///  properties set to <see langword="false" />
    ///  .</returns>
    {class} property &Default: DNXsltSettings read get_Default;
    ///<summary>Gets an <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  object that enables support for the XSLT document() function and embedded script blocks.</summary>
    ///<returns>An <see cref="T:System.Xml.Xsl.XsltSettings" />
    ///  object with the <see cref="P:System.Xml.Xsl.XsltSettings.EnableDocumentFunction" />
    ///  and <see cref="P:System.Xml.Xsl.XsltSettings.EnableScript" />
    ///  properties set to <see langword="true" />
    ///  .</returns>
    {class} property TrustedXslt: DNXsltSettings read get_TrustedXslt;
  end;

  ///<summary>Specifies the XSLT features to support during execution of the XSLT style sheet.</summary>
  [DNTypeName('System.Xml.Xsl.XsltSettings')]
  DNXsltSettings = interface(DDN.mscorlib.DNObject)
  ['{84B60F08-1D49-339A-8375-25B1572C81E1}']
  { getters & setters } 

    function get_EnableDocumentFunction: Boolean;
    procedure set_EnableDocumentFunction(value: Boolean);
    function get_EnableScript: Boolean;
    procedure set_EnableScript(value: Boolean);

  { methods } 

    function Equals(obj: DDN.mscorlib.DNObject): Boolean;
    function GetHashCode: Int32;
    function GetType: DDN.mscorlib.DNType;
    function ToString: string;

  { propertys } 

    ///<summary>Gets or sets a value indicating whether to enable support for the XSLT document() function.</summary>
    ///<returns><see langword="true" />
    ///  to support the XSLT document() function; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property EnableDocumentFunction: Boolean read get_EnableDocumentFunction write set_EnableDocumentFunction;
    ///<summary>Gets or sets a value indicating whether to enable support for embedded script blocks.</summary>
    ///<returns><see langword="true" />
    ///  to support script blocks in XSLT style sheets; otherwise, <see langword="false" />
    ///  . The default is <see langword="false" />
    ///  .</returns>
    property EnableScript: Boolean read get_EnableScript write set_EnableScript;
  end;

  TDNXsltSettings = class(TDNGenericImport<DNXsltSettingsClass, DNXsltSettings>) end;


implementation


initialization
  LoadAssemblyModule('System.Xml.dll', True);

finalization

end.
